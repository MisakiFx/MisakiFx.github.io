<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.ico?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon_16.ico?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta name="description" content="Hard working or giving up!!!">
<meta property="og:type" content="website">
<meta property="og:title" content="Misaki`s blog">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="Misaki`s blog">
<meta property="og:description" content="Hard working or giving up!!!">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Misaki`s blog">
<meta name="twitter:description" content="Hard working or giving up!!!">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/"/>





  <title>Misaki`s blog</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

<a href="https://github.com/MisakiFx" class="github-corner" aria-label="View source on GitHub"><svg width="80" height="80" viewBox="0 0 250 250" style="fill:#64CEAA; color:#fff; position: absolute; top: 0; border: 0; left: 0; transform: scale(-1, 1);" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Misaki`s blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">学习是一种态度</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/08/22/【Cpp】第十一章-继承/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="MisakiFx">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/blog-logo.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Misaki`s blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/08/22/【Cpp】第十一章-继承/" itemprop="url">【Cpp】第十一章-继承</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-08-22T17:30:48+08:00">
                2019-08-22
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Cpp/" itemprop="url" rel="index">
                    <span itemprop="name">Cpp</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  7.6k
                </span>
              

              

              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h1><h2 id="什么是继承"><a href="#什么是继承" class="headerlink" title="什么是继承"></a>什么是继承</h2><p>&emsp;&emsp;继承是为了更好的使代码得以复用而产生的，同时呈现了面向对象程序设计中的层次结构，继承会使得我们写好的类可以得到扩展。简单来说继承可以增强我们的代码复用，包括可以复用类的层次结构，同时使程序复用层次和条理。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class Person</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    //如果我们设计一个类考虑到它会被继承那么最好用protected成员取代private成员</span><br><span class="line">    //protected成员在类外部仍然是无法使用的，但是在派生类中它是可见的也就是可以使用的</span><br><span class="line">    Person()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; &quot;im a Person&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    void Print()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; &quot;age = &quot; &lt;&lt; _age &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; &quot;name = &quot; &lt;&lt; _name &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">protected:</span><br><span class="line">    int _age = 20;</span><br><span class="line">    string _name = &quot;Misaki&quot;; </span><br><span class="line">&#125;;</span><br><span class="line">//Programer类，这里让其公有继承Person类</span><br><span class="line">//这时继承产生的新类被称为子类，也叫派生类</span><br><span class="line">//被继承的旧类被称为父类，也叫基类</span><br><span class="line">//继承方式为公有(public)，其会让基类中的public成员成为派生类中的public成员</span><br><span class="line">//基类中的protected成员成为派生类中的protected成员，基类中的private成员在派生类中不可见</span><br><span class="line">//关于继承方式也在下文讲解</span><br><span class="line">class Programer: public Person</span><br><span class="line">&#123;</span><br><span class="line">    //这里我们不再重写几个默认生成的成员函数，他们默认会完成他们应有的功能</span><br><span class="line">    //具体派生类的默认成员函数会在下文讲解</span><br><span class="line">protected:</span><br><span class="line">    int _workyear;</span><br><span class="line">&#125;;</span><br><span class="line">class Teacher: public Person</span><br><span class="line">&#123;</span><br><span class="line">protected:</span><br><span class="line">    int _teachyear;</span><br><span class="line">&#125;;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    Person person;//基类对象</span><br><span class="line">    Programer programer;//派生类对象</span><br><span class="line">    Teacher teacher;//派生类对象</span><br><span class="line">    person.Print();</span><br><span class="line">    programer.Print();</span><br><span class="line">    teacher.Print();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">im a Person</span><br><span class="line">im a Person</span><br><span class="line">im a Person</span><br><span class="line">age = 20</span><br><span class="line">name = Misaki</span><br><span class="line">age = 20</span><br><span class="line">name = Misaki</span><br><span class="line">age = 20</span><br><span class="line">name = Misaki</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;以上这个例子就是简单的利用继承进行了类的扩展扩展出了两个派生类，可以看出派生类中拥有积累的成员函数和成员变量，并且还可以添加新的成员函数和变量。</p>
<h2 id="继承方式"><a href="#继承方式" class="headerlink" title="继承方式"></a>继承方式</h2><h3 id="三种继承方式"><a href="#三种继承方式" class="headerlink" title="三种继承方式"></a>三种继承方式</h3><p>&emsp;&emsp;继承方式一共有三种：<code>public</code>, <code>protected</code>,<code>private</code>，这三种继承方式都可以将基类中的成员继承到派生类中，但是继承方式的不同也决定着在派生类中继承过来的成员的访问权限的不同，具体关于各个继承方式中对访问权限的改变可以参考下图。<br><br><img src="/2019/08/22/【Cpp】第十一章-继承/1.png" alt="继承"><br><br>&emsp;&emsp;这里提到基类中的<code>private</code>成员无论何种继承方式在派生类中都是<strong>不可见</strong>的，所谓不可见指成员依然已经继承了过来并且作为了私有成员，但是在派生类中限制这些成员无论在类外还是类内都是无法访问的。<br>&emsp;&emsp;因此为了让一个成员在派生类中依然可以访问便出现了<code>protected</code>访问权限，所以才说如果一个类为了方便继承最好将其<code>private</code>访问权限用<code>protected</code>来替代，这样即使继承产生派生类也依然可以在派生类中访问该成员。<br>&emsp;&emsp;如果我们在继承时不写出继承方式，则<code>class</code>默认使用<code>private</code>继承，<code>struct</code>默认使用<code>public</code>继承，不过为了可读性最好还是显示的写出继承方式。<br>&emsp;&emsp;最为经常使用的继承方式是<code>public</code>继承，它可以让派生类中各个访问权限下的成员在派生类中还为相应的访问权限，是最为方便便于理解的继承方式，并且其他继承方式的扩展和维护性也并不强，因此除非特殊情况也不建议使用除<code>public</code>外的其他继承方式。</p>
<h2 id="切割"><a href="#切割" class="headerlink" title="切割"></a>切割</h2><p>&emsp;&emsp;在C++中允许将派生类对象隐式类型转换为父类。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">//基类</span><br><span class="line">class Person</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    Person()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; &quot;im a Person&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    void Print()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; &quot;age = &quot; &lt;&lt; _age &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; &quot;name = &quot; &lt;&lt; _name &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">protected:</span><br><span class="line">    int _age = 20;</span><br><span class="line">    string _name = &quot;Misaki&quot;; </span><br><span class="line">&#125;;</span><br><span class="line">//派生类</span><br><span class="line">class Programer: public Person</span><br><span class="line">&#123;</span><br><span class="line">protected:</span><br><span class="line">    int _workyear;</span><br><span class="line">&#125;;</span><br><span class="line">//派生类</span><br><span class="line">class Teacher: public Person</span><br><span class="line">&#123;</span><br><span class="line">protected:</span><br><span class="line">    int _teachyear;</span><br><span class="line">&#125;;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    Person person;</span><br><span class="line">    //Programer programer;</span><br><span class="line">    Teacher teacher;</span><br><span class="line">    //person.Print();</span><br><span class="line">    //programer.Print();</span><br><span class="line">    //teacher.Print();</span><br><span class="line">    //teacher是派生类对象，person是基类对象，这样的隐式类型转换是允许的</span><br><span class="line">    person = teacher;</span><br><span class="line">    //也可以用派生类对象来拷贝构造基类对象</span><br><span class="line">    Person person2 = teacher;</span><br><span class="line">    person.Print();</span><br><span class="line">    person2.Print();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">im a Person</span><br><span class="line">im a Person</span><br><span class="line">age = 20</span><br><span class="line">name = Misaki</span><br><span class="line">age = 20</span><br><span class="line">name = Misaki</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;以上这段代码我们将派生类对象赋值给了基类对象，并且用派生类对象拷贝构造了基类对象，在这其中得以隐式转换最重要的原因就是编译器进行了<strong>切割</strong>处理，即将派生类对象中属于基类的那一部分成员保留，而将属于派生类的成员舍弃，由此才能完成类型转换。<br><br><img src="/2019/08/22/【Cpp】第十一章-继承/2.png" alt="切割"><br><br>&emsp;&emsp;上图过程即为切割的过程，在派生类的对象/指针/引用赋值给父类的对象/指针/引用时都会发生隐式类型转换，过程中都会发生切割。但是<strong>基类对象/指针引用不可以赋值给派生类对象/指针/引用</strong>。当然也有例外，基类指针可以通过强制类型转换也可以赋值给派生类指针，当然只有在基类指针指向了派生类对象时才是安全的。如果基类构成多态也可以用RTTI(运行时类型识别)的<code>dynamic_cast</code>类型识别后进行类型转换，是最为安全的。</p>
<h2 id="继承中的作用域"><a href="#继承中的作用域" class="headerlink" title="继承中的作用域"></a>继承中的作用域</h2><p>&emsp;&emsp;在继承体系中，基类和派生类都有属于自己的作用域，那么如果在派生类中定义了和基类同名的成员编译器会怎样处理呢？</p>
<h3 id="重定义-隐藏"><a href="#重定义-隐藏" class="headerlink" title="重定义/隐藏"></a>重定义/隐藏</h3><p>&emsp;&emsp;派生类和基类有各自独立的作用域，在派生类中如果出现和基类同名成员，则会优先调用派生类的同名成员，即<strong>隐藏</strong>基类成员，这个过程叫做被称为<strong>隐藏</strong>也叫做<strong>重定义</strong>。<br>&emsp;&emsp;但是我们也可以在派生类中加上域限定符显示调用基类的成员。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class Person</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    void Print()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; &quot;Person::Print()&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">protected:</span><br><span class="line">    int _age = 20;</span><br><span class="line">    string _name = &quot;Misaki&quot;; </span><br><span class="line">&#125;;</span><br><span class="line">//派生类</span><br><span class="line">class Teacher: public Person</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    void Print()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; &quot;Teacher::Print()&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    void PrintAge()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; &quot;Teacher::_age:&quot; &lt;&lt; _age &lt;&lt; endl;//重名成员构成隐藏</span><br><span class="line">        cout &lt;&lt; &quot;Person::_age:&quot; &lt;&lt; Person::_age &lt;&lt; endl;//显示调用基类成员</span><br><span class="line">    &#125;</span><br><span class="line">protected:</span><br><span class="line">    int _age = 19;</span><br><span class="line">&#125;;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    Person person;</span><br><span class="line">    person.Print();//Person::Print()</span><br><span class="line">    Teacher teacher;</span><br><span class="line">    teacher.Print();//Teacher::Print()，派生类重名成员构成隐藏</span><br><span class="line">    teacher.PrintAge();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Person::Print()</span><br><span class="line">Teacher::Print()</span><br><span class="line">Teacher::_age:19</span><br><span class="line">Person::_age:20</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;值得注意的是，关于函数，函数重载指的是在相同作用域内函数名相同参数不同构成重载，而<strong>重定义/隐藏是指在基类和派生类的作用域内函数名相同就会构成隐藏</strong>。所以我们最好还是不要在派生类中定义和基类同名的成员，避免隐藏和重定义的发生。</p>
<h2 id="派生类的默认成员函数"><a href="#派生类的默认成员函数" class="headerlink" title="派生类的默认成员函数"></a>派生类的默认成员函数</h2><p>&emsp;&emsp;派生类也有6个默认成员函数，但是着6个默认成员函数既要兼顾到基类也需要兼顾到派生类，因此在写法上与常规的并不相同。</p>
<h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><p>&emsp;&emsp;在派生类的构造函数中我们需要先显示调用基类的构造函数对基类成员进行初始化然后才能对派生类成员进行初始化。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">//基类</span><br><span class="line">class Person</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    //这里构造函数就不选择传参了方便起见我都初始化为定值</span><br><span class="line">    Person()</span><br><span class="line">        :_age(20)</span><br><span class="line">        ,_name(&quot;Misaki&quot;)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; &quot;Person()&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    void Print()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; &quot;age = &quot; &lt;&lt; _age &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; &quot;name = &quot; &lt;&lt; _name &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">protected:</span><br><span class="line">    int _age;</span><br><span class="line">    string _name;</span><br><span class="line">&#125;;</span><br><span class="line">//派生类</span><br><span class="line">class Teacher: public Person</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    //派生类构造函数，先调用基类构造函数，在初始化派生类成员</span><br><span class="line">    //默认生成的构造函数也是这样实现的</span><br><span class="line">    Teacher()</span><br><span class="line">        :Person()</span><br><span class="line">        ,_teachyear(3)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; &quot;Teacher()&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    void Print()</span><br><span class="line">    &#123;</span><br><span class="line">        Person::Print();</span><br><span class="line">        cout &lt;&lt; &quot;teachyear = &quot; &lt;&lt; _teachyear &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    static int _count;</span><br><span class="line">protected:</span><br><span class="line">    int _teachyear;</span><br><span class="line">&#125;;</span><br><span class="line">int Teacher::_count = 2;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    Teacher teacher;</span><br><span class="line">    teacher.Print();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Person()</span><br><span class="line">Teacher()</span><br><span class="line">age = 20</span><br><span class="line">name = Misaki</span><br><span class="line">teachyear = 3</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;从以上代码可以得出<strong>派生类对象初始化会调用派生类构造函数，而在派生类构造函数中会先调用基类的构造函数对基类成员进行初始化然后才会对派生类成员进行初始化</strong>。这样我们就成功的完成了派生类构造函数，并且实现了成员初始化。</p>
<h3 id="拷贝构造函数"><a href="#拷贝构造函数" class="headerlink" title="拷贝构造函数"></a>拷贝构造函数</h3><p>&emsp;&emsp;拷贝构造函数与构造函数类似，我们在派生类的拷贝构造函数中也需要先调用基类拷贝构造函数先拷贝构造基类成员再将派生类成员拷贝构造。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">//基类</span><br><span class="line">class Person</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    //这里构造函数就不选择传参了方便起见我都初始化为定值</span><br><span class="line">    Person()</span><br><span class="line">        :_age(20)</span><br><span class="line">        ,_name(&quot;Misaki&quot;)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; &quot;Person()&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    Person(const Person&amp; person)</span><br><span class="line">        :_age(person._age)</span><br><span class="line">        ,_name(person._name)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; &quot;Person(const Person&amp;)&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    void Print()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; &quot;age = &quot; &lt;&lt; _age &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; &quot;name = &quot; &lt;&lt; _name &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">protected:</span><br><span class="line">    int _age;</span><br><span class="line">    string _name;</span><br><span class="line">&#125;;</span><br><span class="line">//派生类</span><br><span class="line">class Teacher: public Person</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    //派生类构造函数，先调用基类构造函数，在初始化派生类成员</span><br><span class="line">    //默认生成的构造函数也是这样实现的</span><br><span class="line">    Teacher()</span><br><span class="line">        :Person()</span><br><span class="line">        ,_teachyear(3)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; &quot;Teacher()&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    //拷贝构造函数，先调用基类构造函数对基类成拷贝构造，再拷贝构造派生类成员</span><br><span class="line">    //默认生成的拷贝构造也是这样的实现方法</span><br><span class="line">    Teacher(const Teacher&amp; teacher)</span><br><span class="line">        :Person(teacher)//这里利用派生类对象可以隐式转换为基类对象来调用基类拷贝构造</span><br><span class="line">        ,_teachyear(3)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; &quot;Teacher(const Teacher&amp;)&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    void Print()</span><br><span class="line">    &#123;</span><br><span class="line">        Person::Print();</span><br><span class="line">        cout &lt;&lt; &quot;teachyear = &quot; &lt;&lt; _teachyear &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    static int _count;</span><br><span class="line">protected:</span><br><span class="line">    int _teachyear;</span><br><span class="line">&#125;;</span><br><span class="line">int Teacher::_count = 2;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    Teacher teacher1;</span><br><span class="line">    Teacher teacher2 = teacher1;</span><br><span class="line">    teacher2.Print();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Person()</span><br><span class="line">Teacher()</span><br><span class="line">Person(const Person&amp;)</span><br><span class="line">Teacher(const Teacher&amp;)</span><br><span class="line">age = 20</span><br><span class="line">name = Misaki</span><br><span class="line">teachyear = 3</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;从结果可以看出<strong>派生类对象在进行拷贝构造的时候调用了派生类拷贝构造函数，而派生类拷贝构造函数中会先调用基类拷贝构造函数对基类成员进行初始化然后才会对派生类成员进行初始化</strong>。</p>
<h3 id="赋值运算符重载"><a href="#赋值运算符重载" class="headerlink" title="赋值运算符重载"></a>赋值运算符重载</h3><p>&emsp;&emsp;赋值运算符也同样类似，需要先调用基类的赋值运算符重载，然后再进行派生类成员的赋值。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">//基类</span><br><span class="line">class Person</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    //这里构造函数就不选择传参了方便起见我都初始化为定值</span><br><span class="line">    Person()</span><br><span class="line">        :_age(20)</span><br><span class="line">        ,_name(&quot;Misaki&quot;)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; &quot;Person()&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    Person(const Person&amp; person)</span><br><span class="line">        :_age(person._age)</span><br><span class="line">        ,_name(person._name)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; &quot;Person(const Person&amp;)&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    Person&amp; operator=(const Person&amp; person)</span><br><span class="line">    &#123;</span><br><span class="line">        if(&amp;person != this)</span><br><span class="line">        &#123;</span><br><span class="line">            _age = person._age;</span><br><span class="line">            _name = person._name;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; &quot;Person::operator=(const Person&amp;)&quot; &lt;&lt; endl;</span><br><span class="line">        return *this;</span><br><span class="line">    &#125;</span><br><span class="line">    void Print()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; &quot;age = &quot; &lt;&lt; _age &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; &quot;name = &quot; &lt;&lt; _name &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">protected:</span><br><span class="line">    int _age;</span><br><span class="line">    string _name;</span><br><span class="line">&#125;;</span><br><span class="line">//派生类</span><br><span class="line">class Teacher: public Person</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    //派生类构造函数，先调用基类构造函数，在初始化派生类成员</span><br><span class="line">    //默认生成的构造函数也是这样实现的</span><br><span class="line">    Teacher()</span><br><span class="line">        :Person()</span><br><span class="line">        ,_teachyear(3)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; &quot;Teacher()&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    //拷贝构造函数，先调用基类构造函数对基类成拷贝构造，再拷贝构造派生类成员</span><br><span class="line">    //默认生成的拷贝构造也是这样的实现方法</span><br><span class="line">    Teacher(const Teacher&amp; teacher)</span><br><span class="line">        :Person(teacher)//这里利用派生类对象可以隐式转换为基类对象来调用基类拷贝构造</span><br><span class="line">        ,_teachyear(3)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; &quot;Teacher(const Teacher&amp;)&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    //赋值运算符重载，先调用基类的赋值运算符重载对基类成员进行赋值，再赋值派生类成员</span><br><span class="line">    //默认生成的赋值运算符重载也是这样的实现方法</span><br><span class="line">    Teacher&amp; operator=(const Teacher&amp; teacher)</span><br><span class="line">    &#123;</span><br><span class="line">        if(&amp;teacher != this)</span><br><span class="line">        &#123;</span><br><span class="line">            Person::operator=(teacher);//调用基类的赋值运算符重载，并且用隐式类型转换传参</span><br><span class="line">            _teachyear = teacher._teachyear;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; &quot;Teacher::operator=(const Teacher&amp;)&quot; &lt;&lt; endl;</span><br><span class="line">        return *this;</span><br><span class="line">    &#125;</span><br><span class="line">    void Print()</span><br><span class="line">    &#123;</span><br><span class="line">        Person::Print();</span><br><span class="line">        cout &lt;&lt; &quot;teachyear = &quot; &lt;&lt; _teachyear &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    static int _count;</span><br><span class="line">protected:</span><br><span class="line">    int _teachyear;</span><br><span class="line">&#125;;</span><br><span class="line">int Teacher::_count = 2;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    Teacher teacher1;</span><br><span class="line">    Teacher teacher2;</span><br><span class="line">    teacher2 = teacher1;</span><br><span class="line">    teacher2.Print();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Person()</span><br><span class="line">Teacher()</span><br><span class="line">Person()</span><br><span class="line">Teacher()</span><br><span class="line">Person::operator=(const Person&amp;)</span><br><span class="line">Teacher::operator=(const Teacher&amp;)</span><br><span class="line">age = 20</span><br><span class="line">name = Misaki</span><br><span class="line">teachyear = 3</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;从以上代码可以看出<strong>派生类在赋值时会先调用派生类赋值运算符重载，而在派生类赋值运算符重载中会首先调用积累的赋值运算符重载对基类成员进行赋值，然后才会赋值派生类成员</strong>。</p>
<h3 id="析构函数"><a href="#析构函数" class="headerlink" title="析构函数"></a>析构函数</h3><p>&emsp;&emsp;析构函数与其他的默认成员函数有所不同，因为派生类在构造时是先初始化基类成员再初始化派生类成员，因此在析构时是先释放派生类成员再释放基类成员。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">//基类</span><br><span class="line">class Person</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    //这里构造函数就不选择传参了方便起见我都初始化为定值</span><br><span class="line">    Person()</span><br><span class="line">        :_age(20)</span><br><span class="line">        ,_name(&quot;Misaki&quot;)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; &quot;Person()&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    Person(const Person&amp; person)</span><br><span class="line">        :_age(person._age)</span><br><span class="line">        ,_name(person._name)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; &quot;Person(const Person&amp;)&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    Person&amp; operator=(const Person&amp; person)</span><br><span class="line">    &#123;</span><br><span class="line">        if(&amp;person != this)</span><br><span class="line">        &#123;</span><br><span class="line">            _age = person._age;</span><br><span class="line">            _name = person._name;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; &quot;Person::operator=(const Person&amp;)&quot; &lt;&lt; endl;</span><br><span class="line">        return *this;</span><br><span class="line">    &#125;</span><br><span class="line">    ~Person()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; &quot;~Person()&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    void Print()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; &quot;age = &quot; &lt;&lt; _age &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; &quot;name = &quot; &lt;&lt; _name &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">protected:</span><br><span class="line">    int _age;</span><br><span class="line">    string _name;</span><br><span class="line">&#125;;</span><br><span class="line">//派生类</span><br><span class="line">class Teacher: public Person</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    //派生类构造函数，先调用基类构造函数，在初始化派生类成员</span><br><span class="line">    //默认生成的构造函数也是这样实现的</span><br><span class="line">    Teacher()</span><br><span class="line">        :Person()</span><br><span class="line">        ,_teachyear(3)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; &quot;Teacher()&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    //拷贝构造函数，先调用基类构造函数对基类成拷贝构造，再拷贝构造派生类成员</span><br><span class="line">    //默认生成的拷贝构造也是这样的实现方法</span><br><span class="line">    Teacher(const Teacher&amp; teacher)</span><br><span class="line">        :Person(teacher)//这里利用派生类对象可以隐式转换为基类对象来调用基类拷贝构造</span><br><span class="line">        ,_teachyear(3)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; &quot;Teacher(const Teacher&amp;)&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    //赋值运算符重载，先调用基类的赋值运算符重载对基类成员进行赋值，再赋值派生类成员</span><br><span class="line">    //默认生成的赋值运算符重载也是这样的实现方法</span><br><span class="line">    Teacher&amp; operator=(const Teacher&amp; teacher)</span><br><span class="line">    &#123;</span><br><span class="line">        if(&amp;teacher != this)</span><br><span class="line">        &#123;</span><br><span class="line">            Person::operator=(teacher);//调用基类的赋值运算符重载，并且用隐式类型转换传参</span><br><span class="line">            _teachyear = teacher._teachyear;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; &quot;Teacher::operator=(const Teacher&amp;)&quot; &lt;&lt; endl;</span><br><span class="line">        return *this;</span><br><span class="line">    &#125;</span><br><span class="line">    //要注意派生类析构函数不需要显示调用基类的析构函数，在调用派生类析构函数释放派生类成员后</span><br><span class="line">    //会自动调用基类的析构函数，来满足先释放派生类成员再释放基类成员的顺序</span><br><span class="line">    ~Teacher()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; &quot;~Teacher()&quot; &lt;&lt; endl;</span><br><span class="line">        //Person::~Person();这样调用会报错</span><br><span class="line">    &#125;</span><br><span class="line">    void Print()</span><br><span class="line">    &#123;</span><br><span class="line">        Person::Print();</span><br><span class="line">        cout &lt;&lt; &quot;teachyear = &quot; &lt;&lt; _teachyear &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    static int _count;</span><br><span class="line">protected:</span><br><span class="line">    int _teachyear;</span><br><span class="line">&#125;;</span><br><span class="line">int Teacher::_count = 2;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    Teacher teacher;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Person()</span><br><span class="line">Teacher()</span><br><span class="line">~Teacher()</span><br><span class="line">~Person()</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;派生类析构函数执行时会先释放派生类成员再释放基类成员，并且要注意<strong>派生类析构函数会自动调用基类析构函数进行清理，无需手动调用</strong>。从执行结果上也可以看出编译器是先释放派生类成员再释放基类成员。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>&emsp;&emsp;对派生类默认成员函数进行总结。<br>&emsp;&emsp;1、派生类构造函数必须首先调用基类构造函数构造基类成员，之后再构造派生类成员才能成立。<br>&emsp;&emsp;2、派生类拷贝构造函数必须先调用基类拷贝构造函数拷贝构造基类成员，之后再拷贝构造派生类成员才能成立。<br>&emsp;&emsp;3、派生类赋值运算符重载必须先调用基类赋值运算符重载函数对基类成员进行赋值，再对派生类成员进行赋值才能成立。<br>&emsp;&emsp;4、派生类析构函数会在调用后自动调用基类析构函数无需显式调用基类析构函数。<br>&emsp;&emsp;5、派生类对象构造会先构造基类成员再构造派生类成员。<br>&emsp;&emsp;6、派生类对象析构会先释放派生类成员再释放基类成员。</p>
<h2 id="继承与友元"><a href="#继承与友元" class="headerlink" title="继承与友元"></a>继承与友元</h2><p>&emsp;&emsp;在C++类和对象中有介绍<strong>友元</strong>这一概念，即允许在友元类或友元函数中打破类的封装从而使用类的保护和私有成员。那么如果涉及继承，编译器会如何处理呢？<br>&emsp;&emsp;<strong>友元关系不能继承</strong>，即<strong>基类的友元不能访问派生类的私有和保护成员，但其依然可以访问派生类中从基类继承而来的私有和保护成员</strong>。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class Test;</span><br><span class="line">//基类</span><br><span class="line">class Person</span><br><span class="line">&#123;</span><br><span class="line">    friend class Test;</span><br><span class="line">public:</span><br><span class="line">    void Print()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; &quot;age = &quot; &lt;&lt; _age &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; &quot;name = &quot; &lt;&lt; _name &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">protected:</span><br><span class="line">    int _age = 20;</span><br><span class="line">    string _name = &quot;Misaki&quot;;</span><br><span class="line">&#125;;</span><br><span class="line">//派生类</span><br><span class="line">class Teacher: public Person</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    void Print()</span><br><span class="line">    &#123;</span><br><span class="line">        Person::Print();</span><br><span class="line">        cout &lt;&lt; &quot;teachyear = &quot; &lt;&lt; _teachyear &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">protected:</span><br><span class="line">    int _teachyear = 3;</span><br><span class="line">&#125;;</span><br><span class="line">class Test</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    void Print()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; &quot;age = &quot; &lt;&lt; person._age &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; &quot;name = &quot; &lt;&lt; person._name &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    void Print2()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; &quot;age = &quot; &lt;&lt; teacher._age &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; &quot;name = &quot; &lt;&lt; teacher._name &lt;&lt; endl;</span><br><span class="line">        //cout &lt;&lt; &quot;teachyear = &quot; &lt;&lt; teacher._teachyear &lt;&lt; endl;//无法访问</span><br><span class="line">    &#125;</span><br><span class="line">private:</span><br><span class="line">    Person person;</span><br><span class="line">    Teacher teacher;</span><br><span class="line">&#125;;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    Test test;</span><br><span class="line">    test.Print2();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">age = 20</span><br><span class="line">name = Misaki</span><br></pre></td></tr></table></figure></p>
<h2 id="继承和静态成员"><a href="#继承和静态成员" class="headerlink" title="继承和静态成员"></a>继承和静态成员</h2><p>&emsp;&emsp;关于继承和静态成员，我们所要记住的只有一句话，<strong>在整个继承体系中，无论发生多少次继承，静态成员在继承体系中只存在一份</strong>。</p>
<h3 id="静态成员函数"><a href="#静态成员函数" class="headerlink" title="静态成员函数"></a>静态成员函数</h3><p>&emsp;&emsp;关于静态成员函数，这句话将更好理解，在不发生隐藏的情况下我们调用的依然是基类的静态函数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">//基类</span><br><span class="line">class Person</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    static void Print()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; &quot;Person::_count = &quot; &lt;&lt; _count &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">protected:</span><br><span class="line">    int _age = 20;</span><br><span class="line">    string _name = &quot;Misaki&quot;; </span><br><span class="line">    static int _count;</span><br><span class="line">&#125;;</span><br><span class="line">int Person::_count = 1;</span><br><span class="line">//派生类</span><br><span class="line">class Teacher: public Person</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    //static void Print()</span><br><span class="line">    //&#123;</span><br><span class="line">    //    cout &lt;&lt; &quot;Teacher::_count = &quot; &lt;&lt; _count &lt;&lt; endl;</span><br><span class="line">    //&#125;</span><br><span class="line">protected:</span><br><span class="line">    int _age = 19;</span><br><span class="line">&#125;;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    Person::Print();</span><br><span class="line">    Teacher::Print();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Person::_count = 1</span><br><span class="line">Person::_count = 1</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;在发生隐藏的情况下，就会调用派生类的静态函数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">//基类</span><br><span class="line">class Person</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    static void Print()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; &quot;Person::_count = &quot; &lt;&lt; _count &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">protected:</span><br><span class="line">    int _age = 20;</span><br><span class="line">    string _name = &quot;Misaki&quot;; </span><br><span class="line">    static int _count;</span><br><span class="line">&#125;;</span><br><span class="line">int Person::_count = 1;</span><br><span class="line">//派生类</span><br><span class="line">class Teacher: public Person</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    static void Print()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; &quot;Teacher::_count = &quot; &lt;&lt; _count &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">protected:</span><br><span class="line">    int _age = 19;</span><br><span class="line">&#125;;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    Person::Print();</span><br><span class="line">    Teacher::Print();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Person::_count = 1</span><br><span class="line">Teacher::_count = 1</span><br></pre></td></tr></table></figure></p>
<h3 id="静态成员变量"><a href="#静态成员变量" class="headerlink" title="静态成员变量"></a>静态成员变量</h3><p>&emsp;&emsp;关于静态成员变量，我们要理解其在整个继承体系中有且只有一份，我们在基类中将其改变，派生类的也会跟着改变。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">//基类</span><br><span class="line">class Person</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    static void Print()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; &quot;Person::_count = &quot; &lt;&lt; _count &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    static int _count;</span><br><span class="line">protected:</span><br><span class="line">    int _age = 20;</span><br><span class="line">    string _name = &quot;Misaki&quot;; </span><br><span class="line">&#125;;</span><br><span class="line">int Person::_count = 1;</span><br><span class="line">//派生类</span><br><span class="line">class Teacher: public Person</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    static void Print()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; &quot;Teacher::_count = &quot; &lt;&lt; _count &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">protected:</span><br><span class="line">    int _age = 19;</span><br><span class="line">&#125;;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    Person::_count = 3;</span><br><span class="line">    Person::Print();</span><br><span class="line">    Teacher::Print();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Person::_count = 3</span><br><span class="line">Teacher::_count = 3</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;但是如果我们在派生类中定义同名静态成员变量构成隐藏的话，则会产生新的变量，并且隐藏掉基类的同名静态成员，当然我们也可以通过显示调用的方式再去调用它。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">//基类</span><br><span class="line">class Person</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    static void Print()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; &quot;Person::_count = &quot; &lt;&lt; _count &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    static int _count;</span><br><span class="line">protected:</span><br><span class="line">    int _age = 20;</span><br><span class="line">    string _name = &quot;Misaki&quot;; </span><br><span class="line">&#125;;</span><br><span class="line">int Person::_count = 1;</span><br><span class="line">//派生类</span><br><span class="line">class Teacher: public Person</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    static void Print()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; &quot;Teacher::_count = &quot; &lt;&lt; _count &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; &quot;Person::_count = &quot; &lt;&lt; Person::_count &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">protected:</span><br><span class="line">    int _age = 19;</span><br><span class="line">    static int _count;</span><br><span class="line">&#125;;</span><br><span class="line">int Teacher::_count = 5;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    Person::_count = 3;</span><br><span class="line">    Person::Print();</span><br><span class="line">    Teacher::Print();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Person::_count = 3</span><br><span class="line">Teacher::_count = 5</span><br><span class="line">Person::_count = 3</span><br></pre></td></tr></table></figure></p>
<h3 id="继承中隐藏-重定义的权限及生命周期"><a href="#继承中隐藏-重定义的权限及生命周期" class="headerlink" title="继承中隐藏/重定义的权限及生命周期"></a>继承中隐藏/重定义的权限及生命周期</h3><p>&emsp;&emsp;我们知道了静态成员发生隐藏时才会产生新的一份空间进行存储，如果我们将原本在基类中是静态成员的变量在派生类中定义同名成员为非静态的成员编译器会怎么判定呢？<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">//基类</span><br><span class="line">class Person</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    static void Print()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; &quot;Person::_count = &quot; &lt;&lt; _count &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    static int _count;</span><br><span class="line">protected:</span><br><span class="line">    int _age = 20;</span><br><span class="line">    string _name = &quot;Misaki&quot;; </span><br><span class="line">&#125;;</span><br><span class="line">int Person::_count = 1;</span><br><span class="line">//派生类</span><br><span class="line">class Teacher: public Person</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    static void Print()</span><br><span class="line">    &#123;</span><br><span class="line">        //cout &lt;&lt; &quot;Teacher::_count = &quot; &lt;&lt; _count &lt;&lt; endl;//编不过了，因为静态函数中只能调用静态成员，而此时_count隐藏已经不是静态成员</span><br><span class="line">        cout &lt;&lt; &quot;Person::_count = &quot; &lt;&lt; Person::_count &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    int _count = 5;</span><br><span class="line">protected:</span><br><span class="line">    int _age = 19;</span><br><span class="line">&#125;;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    Person::_count = 3;</span><br><span class="line">    Person::Print();</span><br><span class="line">    Teacher::Print();</span><br><span class="line">    Teacher teacher;</span><br><span class="line">    cout &lt;&lt; teacher._count &lt;&lt; endl;//可以访问了</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Person::_count = 3</span><br><span class="line">Person::_count = 3</span><br><span class="line">5</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;由此我们可以判断一点，如果在派生类中发生隐藏和重定义那么在派生类中该<strong>同名成员的生命周期及访问权限将根据在派生类中重定义的情况而决定</strong>，因此在基类中即使是静态的成员如果在派生类中重定义为非静态变量进行使用也是可以的，可见重定义和隐藏是十分恐怖的，因此我们最好是尽量防止在派生类中定义和基类重名的成员，避免发生隐藏和重定义。</p>
<h2 id="菱形继承和虚继承"><a href="#菱形继承和虚继承" class="headerlink" title="菱形继承和虚继承"></a>菱形继承和虚继承</h2><p>&emsp;&emsp;Cpp语法复杂这一特点可以从继承中体现出来，因为其支持多继承，而多继承就有可能会产生<strong>菱形继承</strong>的情况。</p>
<h3 id="菱形继承"><a href="#菱形继承" class="headerlink" title="菱形继承"></a>菱形继承</h3><p>&emsp;&emsp;什么是菱形继承呢？其产生原因就要“归功于”Cpp支持多继承这一特点，多继承就是允许一个类继承于多个基类，当派生类多继承于多个基类时，这些基类也有可能继承于更上层的同一个基类，由此就会产生菱形继承的情况。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class A</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    char _a = &apos;A&apos;;</span><br><span class="line">&#125;;</span><br><span class="line">//B继承于A</span><br><span class="line">class B: public A</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    char _b = &apos;B&apos;;</span><br><span class="line">&#125;;</span><br><span class="line">//C也继承于A</span><br><span class="line">class C: public A</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    char _c = &apos;C&apos;;</span><br><span class="line">&#125;;</span><br><span class="line">//D继承于B,C</span><br><span class="line">class D: public B, public C</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    char _d = &apos;D&apos;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;以上这种结构就会产生菱形继承，我们用画图的方式具现化表示一下。<br><br><img src="/2019/08/22/【Cpp】第十一章-继承/3.png" alt="菱形继承"><br><br>&emsp;&emsp;这种继承体系就是菱形继承，也是非常直观的可以体现出来的。</p>
<h3 id="菱形继承带来的问题"><a href="#菱形继承带来的问题" class="headerlink" title="菱形继承带来的问题"></a>菱形继承带来的问题</h3><p>&emsp;&emsp;菱形继承是Cpp多继承所带来的主要问题之一，一旦发生菱形继承，首当其冲的我们就应该考虑到菱形继承带来的<strong>数据冗余</strong>及<strong>数据二义性</strong>的问题。<br>&emsp;&emsp;还用上面的例子，因为D同时继承了B,C类，而B,C类又都分别继承了A类这就意味着D中存在着两份A类，一份是从B那里继承来的，另一份是从C继承来的，这就造成了数据冗余，并且当我们通过D想要直接访问A类成员时编译器会报错，因为编译器不知道你要访问的时B中的A类成员还是C中的A类成员，我们必须加上域限定符才能访问，这就造成了数据二义性，但是我们通过域限定符姑且可以解决数据二义性的问题，但是数据冗余却无法解决。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class A</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    char _a = &apos;A&apos;;</span><br><span class="line">&#125;;</span><br><span class="line">//B继承于A</span><br><span class="line">class B: public A</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    char _b = &apos;B&apos;;</span><br><span class="line">&#125;;</span><br><span class="line">//C也继承于A</span><br><span class="line">class C: public A</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    char _c = &apos;C&apos;;</span><br><span class="line">&#125;;</span><br><span class="line">//D继承于B,C</span><br><span class="line">class D: public B, public C</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    char _d = &apos;D&apos;;</span><br><span class="line">&#125;;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    D d;</span><br><span class="line">    //cout &lt;&lt; d._a &lt;&lt; endl;//报错</span><br><span class="line">    d.B::_a = &apos;E&apos;;</span><br><span class="line">    d.C::_a = &apos;F&apos;;</span><br><span class="line">    cout &lt;&lt; d.B::_a &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; d.C::_a &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">E</span><br><span class="line">F</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;从以上结果中可以看出d中有着两份A类的成员，因此在我们日常程序设计中应该极力避免菱形继承的产生，因为会浪费空间也会产生不必要的错误。</p>
<h3 id="虚拟继承"><a href="#虚拟继承" class="headerlink" title="虚拟继承"></a>虚拟继承</h3><p>&emsp;&emsp;但是如果在某些场景下一定要产生菱形继承，我们也有办法避免数据冗余及数据二义性的发生，这就要牵扯到<strong>虚拟继承</strong>。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class A</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    char _a = &apos;A&apos;;</span><br><span class="line">&#125;;</span><br><span class="line">//使用虚拟继承使B继承于A</span><br><span class="line">class B: virtual public A</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    char _b = &apos;B&apos;;</span><br><span class="line">&#125;;</span><br><span class="line">//使用虚拟继承使C继承于A</span><br><span class="line">class C: virtual public A</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    char _c = &apos;C&apos;;</span><br><span class="line">&#125;;</span><br><span class="line">//D继承于B,C</span><br><span class="line">class D: public B, public C</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    char _d = &apos;D&apos;;</span><br><span class="line">&#125;;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    //一旦使用虚拟继承那么D类中就只存在一份A的成员变量</span><br><span class="line">    D d;</span><br><span class="line">    //无论用什么作用域进行访问都只能访问到同一份</span><br><span class="line">    d.B::_a = &apos;E&apos;;</span><br><span class="line">    cout &lt;&lt; d._a &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; d.B::_a &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; d.C::_a &lt;&lt; endl;</span><br><span class="line">    d.C::_a = &apos;F&apos;;</span><br><span class="line">    cout &lt;&lt; d._a &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; d.B::_a &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; d.C::_a &lt;&lt; endl;</span><br><span class="line">    //我们甚至还可以这样访问，一旦使用虚拟继承我们可以视d间接继承了A，因此也有了A的作用域</span><br><span class="line">    //这在不使用虚拟继承的情况下是无法完成的</span><br><span class="line">    cout &lt;&lt; d.A::_a &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">E</span><br><span class="line">E</span><br><span class="line">E</span><br><span class="line">F</span><br><span class="line">F</span><br><span class="line">F</span><br><span class="line">F</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;那么虚拟继承是如何做到的这一切呢？在不适用虚拟继承的情况下类D中可以这样表示。<br><br><img src="/2019/08/22/【Cpp】第十一章-继承/4.png" alt="虚拟继承"><br><br>&emsp;&emsp;但是引入虚拟继承后，编译器就会生成一张<strong>虚基表</strong>，这张表中存放着这个类与其虚拟继承的基类之间的地址偏移量，而在这个类中也会多生成一个指针被称为<strong>虚基表指针</strong>指向这张虚基表。因此此时D类中由于所继承的两个基类都是虚拟继承自A类，因此B,C类都会有属于自己的虚基表及指向这张表的虚基表指针，而他们的虚基表中都会存储与同一个A类之间的地址偏移量，因此就可以做到D类中就有唯一的一份A类成员。<br>&emsp;&emsp;使用虚拟继承D中可以如下表示。<br><br><img src="/2019/08/22/【Cpp】第十一章-继承/5.png" alt="虚拟继承"><br><br>&emsp;&emsp;但是要注意虚基表中存放的并不是直接指向类A的指针，而是与A的地址偏移量，由此可以找到A。这样就确保了D中只有唯一的一份A的成员，解决了数据冗余以及数据二义性的问题。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; sizeof(B) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">8</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;我们取一个虚拟继承的类的大小也可以发现其大小变成了8，这是因为多了一个虚基表指针占了4个字节，加上3个字节的补齐成了8。不过这样我们知道了虚基表指针是存储在对象中的，那么虚基表存储在哪里呢？这个根据每个编译器的不同都有不同的处理，vs是存储在寄存器中的。</p>
<h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><p>&emsp;&emsp;在继承这一章，我们透彻的学习了继承的各种知识点，并且还解析了菱形继承以及虚拟继承底层的实现原理，我们不由得产生了一个问题，我什么时候使用继承什么时候使用组合呢？<br>&emsp;&emsp;继承：是一种<strong>is a</strong>的关系。<br>&emsp;&emsp;组合：是一种<strong>has a</strong>的关系。<br>&emsp;&emsp;这一点并不难理解，但是实际开发中，我们尽量优先使用组合，因为组合耦合度低，易于开发和维护，我们可以不用过多的考虑基类的实现，而继承不同。但是有一些情况下确实是继承更为符合情景呢么就是用继承，但要小心多继承。继承的使用也是十分广泛的，比如之后要学习的多态，都多亏于继承的语法，当然如果继承和组合都可以使用的话还是使用组合更好。</p>

          
        
      
    </div>
    
    
    

    

    <div>
    
    </div>

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/08/12/【Cpp】第十章-模板进阶/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="MisakiFx">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/blog-logo.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Misaki`s blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/08/12/【Cpp】第十章-模板进阶/" itemprop="url">【Cpp】第十章-模板进阶</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-08-12T16:35:22+08:00">
                2019-08-12
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Cpp/" itemprop="url" rel="index">
                    <span itemprop="name">Cpp</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  2.9k
                </span>
              

              

              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="模板进阶"><a href="#模板进阶" class="headerlink" title="模板进阶"></a>模板进阶</h1><p>&emsp;&emsp;之前的博客已经介绍过模板的概念，这是Cpp在实现泛型编程中不可缺少的一环，在模板进阶的讨论中会着重于模板的更为高级的使用。</p>
<h2 id="非类型模板参数"><a href="#非类型模板参数" class="headerlink" title="非类型模板参数"></a>非类型模板参数</h2><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>&emsp;&emsp;在模板中我们通常都是定义一个类型模板参数，在进行实例化的时候通过传入类型来实例化模板，但是模板中也可以定义非类型的模板参数。用一个封装的定长顺序表进行举例。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;assert.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">template&lt;class T, size_t L&gt;</span><br><span class="line">class Array</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    Array()</span><br><span class="line">    :_arr(&#123;0&#125;)</span><br><span class="line">    ,_size(0)</span><br><span class="line">    &#123;&#125;</span><br><span class="line">    size_t Size() const</span><br><span class="line">    &#123;</span><br><span class="line">        return _size;</span><br><span class="line">    &#125;</span><br><span class="line">    T&amp; operator[](size_t pos)</span><br><span class="line">    &#123;</span><br><span class="line">        assert(pos &lt; _size);</span><br><span class="line">        return _arr[pos];</span><br><span class="line">    &#125;</span><br><span class="line">    void Push_Back(T data)</span><br><span class="line">    &#123;</span><br><span class="line">        if(_size &lt; L)</span><br><span class="line">        &#123;</span><br><span class="line">            _arr[_size] = data;</span><br><span class="line">            _size++;</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; &quot;Array is full&quot; &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    void Pop_Back()</span><br><span class="line">    &#123;</span><br><span class="line">        if(!Empty())</span><br><span class="line">        &#123;</span><br><span class="line">            _size--;</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; &quot;Array is empty&quot; &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    bool Empty() const</span><br><span class="line">    &#123;</span><br><span class="line">        return _size == 0;</span><br><span class="line">    &#125;</span><br><span class="line">private:</span><br><span class="line">    T _arr[L];</span><br><span class="line">    size_t _size;</span><br><span class="line">&#125;;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    Array&lt;int, 20&gt; arr;</span><br><span class="line">    arr.Push_Back(1);</span><br><span class="line">    arr.Push_Back(2);</span><br><span class="line">    arr.Push_Back(2);</span><br><span class="line">    arr.Push_Back(5);</span><br><span class="line">    arr.Push_Back(7);</span><br><span class="line">    arr.Push_Back(5);</span><br><span class="line">    arr.Pop_Back();</span><br><span class="line">    arr.Pop_Back();</span><br><span class="line">    arr.Pop_Back();</span><br><span class="line">    for(int i = 0; i &lt; arr.Size(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; arr[i] &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><p>&emsp;&emsp;非类型模板参数在使用中有很严格的要求，它必须遵循以下规则，其实这块的要求在网上大部分博客中都说的十分模糊并且在我的实验下发现过于片面和局限，因此我给出我的总结和理解。<br>&emsp;&emsp;1、非类型模板参数可以是整形，指针和引用。<br>&emsp;&emsp;2、再给模板参数传参时要求其必须是一个常量表达式。<br>&emsp;&emsp;3、如果模板参数是一个整形，那么在传参的时候可以传入字面值常量，也可以是全局/局部常量，可以是外部/内部链接（关于链接属性参考其他博客）。<br>&emsp;&emsp;4、如果模板参数是一个指针或者引用，那么传参时要求，如果传入变量，变量必须是全局的，如果是常量常量必须是外部链接属性的，并且不能把动态对象的指针或引用传入。也就是说局部变量和内部链接属性的常量是不可以当作模板参数构造模板的，并且指针和引用还不能是动态对象的。<br>&emsp;&emsp;以上是我个人在环境下多次实验得出的理解和总结，环境是gcc 6.3.0，如果有误区还请指出。</p>
<h2 id="模板的特化"><a href="#模板的特化" class="headerlink" title="模板的特化"></a>模板的特化</h2><p>&emsp;&emsp;模板可以封装不同的类型做相同的操作，然而有这么一种情况，我想要根据不同的类型做出不同于原来模板的操作，这就需要用到模板的特化这个语法。特化就是在原模版的基础上，根据特殊类型进行特殊化的实现方式。</p>
<h3 id="函数模板的特化"><a href="#函数模板的特化" class="headerlink" title="函数模板的特化"></a>函数模板的特化</h3><p>&emsp;&emsp;函数模板特化要求当然要有基本的函数模板，在特化时格式要求<code>template</code>后跟一对尖括号，并且函数名后尖括号内写特化的模板参数。参数及函数体中的模板参数必须全部替换为特化的模板实参，不然会报错。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">//为了验证函数模板与类模板</span><br><span class="line">//先写一个函数模板</span><br><span class="line">template&lt;class T&gt;</span><br><span class="line">T Add(T a, T b)</span><br><span class="line">&#123;</span><br><span class="line">    return a + b;</span><br><span class="line">&#125;</span><br><span class="line">//特化处理</span><br><span class="line">template&lt;&gt;</span><br><span class="line">int Add&lt;int&gt;(int a, int b)</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; &quot;specialization&quot; &lt;&lt; endl;</span><br><span class="line">    return a + b;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; Add(1, 2) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">specialization</span><br><span class="line">3</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;这样的特化写法是最为规范的写法，就像是函数模板的显示实例化一样，当然我们也可以将<code>&lt;int&gt;</code>不要，只要能让模板知道你再特化哪一种情况即可，但是要与模板完全符合，不然是编不过的。<br>&emsp;&emsp;还有一种更为简单的方式，及利用我在模板初阶中提到的<strong>模板匹配规则</strong>。模板匹配是在所有同名函数都不符合调用的情况下才会进行实例化，因此我们可以用类似重载的情况写同名函数来进行处理，在调用时会优先调用非模板函数。这种情况并不能算是模板的特化处理，但是可以用来处理一些模板无法匹配的情况。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">template&lt;class T&gt;</span><br><span class="line">T Add(T&amp; a, T&amp; b)</span><br><span class="line">&#123;</span><br><span class="line">    return a + b;</span><br><span class="line">&#125;</span><br><span class="line">template&lt;&gt;</span><br><span class="line">int Add(int&amp; a, int&amp; b)</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; &quot;specialization&quot; &lt;&lt; endl;</span><br><span class="line">    return a + b;</span><br><span class="line">&#125;</span><br><span class="line">int Add(int a, int b)</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; &quot;overload&quot; &lt;&lt; endl;</span><br><span class="line">    return a + b;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int a = 1;</span><br><span class="line">    int b = 2;</span><br><span class="line">    cout &lt;&lt; Add(a, b) &lt;&lt; endl;//调用重载的Add</span><br><span class="line">    cout &lt;&lt; Add&lt;int&gt;(a, b) &lt;&lt; endl;//调用特化的Add</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">overload</span><br><span class="line">3</span><br><span class="line">specialization</span><br><span class="line">3</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;在这个例子中可以看出根据模板匹配规则确实优先调用了我们重载的函数，我们只有显示实例化才会调用模板。</p>
<h3 id="类模板的特化"><a href="#类模板的特化" class="headerlink" title="类模板的特化"></a>类模板的特化</h3><p>&emsp;&emsp;类模板特化与函数模板类似，但是由于类模板是无法通过其他方式识别模板参数的类型的，因此我们必须通过<code>&lt;&gt;</code>来显示实例化才能进行特化。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">//类模板</span><br><span class="line">template&lt;class T1, class T2&gt;</span><br><span class="line">class Data</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    Data()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; &quot;Data&lt;T1, T2&gt;&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">private:</span><br><span class="line">    T1 _data1;</span><br><span class="line">    T2 _data2;</span><br><span class="line">&#125;;</span><br><span class="line">//特化处理</span><br><span class="line">template&lt;&gt;</span><br><span class="line">class Data&lt;int, char&gt;</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    Data()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; &quot;Data&lt;int, char&gt;&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">private:</span><br><span class="line">    int _data1;</span><br><span class="line">    char _data2;</span><br><span class="line">&#125;;</span><br><span class="line">int main()</span><br><span class="line">&#123;    </span><br><span class="line">    Data&lt;int, int&gt; data1;</span><br><span class="line">    Data&lt;int, char&gt; data2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Data&lt;T1, T2&gt;</span><br><span class="line">Data&lt;int, char&gt;</span><br></pre></td></tr></table></figure></p>
<h3 id="特化的种类"><a href="#特化的种类" class="headerlink" title="特化的种类"></a>特化的种类</h3><h4 id="全特化"><a href="#全特化" class="headerlink" title="全特化"></a>全特化</h4><p>&emsp;&emsp;全特化就是将模板参数全部进行实例特化的情况。这里用类模板举例。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">template&lt;class T1, class T2&gt;</span><br><span class="line">class Data</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    Data()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; &quot;Data&lt;T1, T2&gt;&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">private:</span><br><span class="line">    T1 _data1;</span><br><span class="line">    T2 _data2;</span><br><span class="line">&#125;;</span><br><span class="line">//这样的把所有的模板参数都进行实例特化的就叫全特化</span><br><span class="line">template&lt;&gt;</span><br><span class="line">class Data&lt;int, char&gt;</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    Data()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; &quot;Data&lt;int, char&gt;&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">private:</span><br><span class="line">    int _data1;</span><br><span class="line">    char _data2;</span><br><span class="line">&#125;;</span><br><span class="line">int main()</span><br><span class="line">&#123;    </span><br><span class="line">    Data&lt;int, int&gt; data1;</span><br><span class="line">    Data&lt;int, char&gt; data2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Data&lt;T1, T2&gt;</span><br><span class="line">Data&lt;int, char&gt;</span><br></pre></td></tr></table></figure></p>
<h4 id="偏特化"><a href="#偏特化" class="headerlink" title="偏特化"></a>偏特化</h4><p>&emsp;&emsp;偏特化就是全特化以外的情况，并没有将所有的模板参数全部都实例化为某一特殊情况。偏特化又有两种情况。<br>&emsp;&emsp;<strong>1、部分特化</strong>：部分特化是将模板参数中一部分模板参数进行实例化特化的情况。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">template&lt;class T1, class T2&gt;</span><br><span class="line">class Data</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    Data()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; &quot;Data&lt;T1, T2&gt;&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">private:</span><br><span class="line">    T1 _data1;</span><br><span class="line">    T2 _data2;</span><br><span class="line">&#125;;</span><br><span class="line">//这样的把所有的模板参数都进行实例特化的就叫全特化</span><br><span class="line">template&lt;&gt;</span><br><span class="line">class Data&lt;int, char&gt;</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    Data()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; &quot;Data&lt;int, char&gt;&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">private:</span><br><span class="line">    int _data1;</span><br><span class="line">    char _data2;</span><br><span class="line">&#125;;</span><br><span class="line">//这里就是一个部分特化，只将第一个参数进行实例化的情况</span><br><span class="line">template&lt;class T&gt;</span><br><span class="line">class Data&lt;int, T&gt;</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    Data()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; &quot;Data&lt;int, T&gt;&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    Data&lt;int, int&gt; data1;//这里会调用部分特化</span><br><span class="line">    Data&lt;int, char&gt; data2;//这里调用全特化</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Data&lt;int, T&gt;</span><br><span class="line">Data&lt;int, char&gt;</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;通过这个例子还可以证实如果实例化同时符合全特化和部分特化的特化情况，则会优先调用全特化，之后才会考虑部分特化的情况。<br>&emsp;&emsp;<strong>2、将参数进一步限制的特化</strong>：<br>&emsp;&emsp;这个类型的特化是将参数进行了进一步的限制，我们可以将参数限制为指针类型或者引用，在这种情况下才会调用这种类型的特化<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">template&lt;class T1, class T2&gt;</span><br><span class="line">class Data</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    Data()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; &quot;Data&lt;T1, T2&gt;&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">private:</span><br><span class="line">    T1 _data1;</span><br><span class="line">    T2 _data2;</span><br><span class="line">&#125;;</span><br><span class="line">//这样的把所有的模板参数都进行实例特化的就叫全特化</span><br><span class="line">template&lt;&gt;</span><br><span class="line">class Data&lt;int, char&gt;</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    Data()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; &quot;Data&lt;int, char&gt;&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">private:</span><br><span class="line">    int _data1;</span><br><span class="line">    char _data2;</span><br><span class="line">&#125;;</span><br><span class="line">//这里就是一个部分特化，只将第一个参数进行实例化的情况</span><br><span class="line">template&lt;class T&gt;</span><br><span class="line">class Data&lt;int, T&gt;</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    Data()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; &quot;Data&lt;int, T&gt;&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">//将两个参数类型限制为指针类型，如果两个参数都是指针类型则调用这个特化</span><br><span class="line">template&lt;class T1, class T2&gt;</span><br><span class="line">class Data&lt;T1*, T2*&gt;</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    Data()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; &quot;Data&lt;T1*, T2*&gt;&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    Data&lt;int, int&gt; data1;//这里会调用部分特化</span><br><span class="line">    Data&lt;int, char&gt; data2;//这里调用全特化</span><br><span class="line">    Data&lt;int*, char*&gt; data3;//这里调用类型限制的特化</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="类型萃取"><a href="#类型萃取" class="headerlink" title="类型萃取"></a>类型萃取</h2><p>&emsp;&emsp;类型萃取是通过特化的方式使模板可以识别不同的类型从而使用不同的处理方法。比如说我们要写一个拷贝函数，对于内置类型我们直接调用<code>memcpy()</code>函数拷贝内存，而对于自定义类型我们可能需要使用自定义的其他拷贝方法进行深拷贝，这时候就可以使用类型萃取的方式来区别内置类型和自定义类型达到不同处理方式的结果。<br>&emsp;&emsp;这并不是一种新的语法，更像是一种设计模式，在STL中就有所体现。</p>
<h2 id="模板的分离编译"><a href="#模板的分离编译" class="headerlink" title="模板的分离编译"></a>模板的分离编译</h2><p>&emsp;&emsp;什么是分离编译模式？分离编译模式就是我们通常在写项目是方便项目管理时所使用的将函数和类的声明放进<code>.h</code>文件中而在<code>.cpp</code>文件中写类定义和类成员函数定义的模式。这种方法可行就是应为我们将声明写入<code>.h</code>而在需要使用的地方引入头文件，在链接过程中编译器会根据声明找到具体实现定义的地址完成链接。</p>
<h3 id="模板不支持分离编译"><a href="#模板不支持分离编译" class="headerlink" title="模板不支持分离编译"></a>模板不支持分离编译</h3><p>&emsp;&emsp;但是这里要说的是，无论是函数模板还是类模板在没有实例化之前都是没有具体代码的，那么也就没有具体定义的地址，我们根据声明也就无法链接到定义的地方。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// a.h</span><br><span class="line">template&lt;class T&gt;</span><br><span class="line">T Add(const T&amp; left, const T&amp; right);</span><br><span class="line">// a.cpp</span><br><span class="line">template&lt;class T&gt;</span><br><span class="line">T Add(const T&amp; left, const T&amp; right)</span><br><span class="line">&#123;</span><br><span class="line">    return left + right;</span><br><span class="line">&#125;</span><br><span class="line">// main.cpp</span><br><span class="line">#include&quot;a.h&quot;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    Add(1, 2);</span><br><span class="line">    Add(1.0, 2.0);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;以上这个例子中的代码时编不过的，原因就是模板不支持分离编译，无法连接。</p>
<h3 id="如何解决？"><a href="#如何解决？" class="headerlink" title="如何解决？"></a>如何解决？</h3><p>&emsp;&emsp;解决方法也很简单，最简单的就是将定义和声明都写到头文件中可以了，这样就省去了链接这个步骤，也就不存在错误了。</p>

          
        
      
    </div>
    
    
    

    

    <div>
    
    </div>

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/08/05/【Cpp】第九章-STL-stack类和queue类/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="MisakiFx">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/blog-logo.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Misaki`s blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/08/05/【Cpp】第九章-STL-stack类和queue类/" itemprop="url">【Cpp】第九章-STL_stack类和queue类</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-08-05T18:04:20+08:00">
                2019-08-05
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Cpp/" itemprop="url" rel="index">
                    <span itemprop="name">Cpp</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  3.8k
                </span>
              

              

              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="stack类和queue类"><a href="#stack类和queue类" class="headerlink" title="stack类和queue类"></a>stack类和queue类</h1><p>&emsp;&emsp;<code>stack</code>和<code>queue</code>以及<code>priority_queue</code>(优先级队列)是STL中三大容器适配器，将其称为容器适配器是因为其在底层只是对现有容器进行的了封装而并没有重新实现。因此在容器适配器中都有让传入容器的模板参数。</p>
<h2 id="容器适配器"><a href="#容器适配器" class="headerlink" title="容器适配器"></a>容器适配器</h2><p>&emsp;&emsp;适配器是一种设计模式，在GOF的《设计模式：可复用面向对象软件的基础》中是这样说的：将一个类的接口转换成客户希望的另外一个接口。适配器模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。而容器适配器就是将常见容器的接口进行封装，使之成为我们需要的结构。因此在容器适配的模板参数中我们可以传入我们想要使用的容器作为模板参数进行封装，但是作为适配器的实现容器它们也需要满足一定的要求才可以作为模板参数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//Container就是底层实现的容器的模板参数</span><br><span class="line">template &lt;class T, class Container = deque&lt;T&gt; &gt; class queue;</span><br><span class="line">template &lt;class T, class Container = deque&lt;T&gt; &gt; class stack;</span><br><span class="line">template &lt;class T, class Container = vector&lt;T&gt;,</span><br><span class="line">  class Compare = less&lt;typename Container::value_type&gt; &gt; class priority_queue;</span><br></pre></td></tr></table></figure></p>
<h2 id="stack类"><a href="#stack类" class="headerlink" title="stack类"></a>stack类</h2><p>&emsp;&emsp;<code>stack</code>和我们数据结构中的栈实现了同样的功能，<strong>后进先出</strong>是其最大的特点。它只能从容器的一端进行元素的插入和提取，来满足栈的相关功能。<br>&emsp;&emsp;它底层的容器可以是标准中的容器类也可以是其他的容器类，但是无论如何这些容器类必须满足以下要求。<br>&emsp;&emsp;1、<code>empty()</code>，判空操作。<br>&emsp;&emsp;2、<code>back()</code>，获取尾部元素。<br>&emsp;&emsp;3、<code>push_back()</code>，尾插。<br>&emsp;&emsp;4、<code>pop_back()</code>，尾删。<br>&emsp;&emsp;满足这些要求的容器类才可以被传入，如果没有传入容器的话则默认使用<code>deque</code>。</p>
<h3 id="常用接口"><a href="#常用接口" class="headerlink" title="常用接口"></a>常用接口</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">stack(const container_type &amp;ctnr = container_type()); //构造空的栈</span><br><span class="line">bool empty() const;                                   //检测stack是否为空</span><br><span class="line">size_type size();                                     //const 返回stack中元素的个数</span><br><span class="line">value_type &amp;top();                                    //返回栈顶元素的引用</span><br><span class="line">const value_type &amp;top() const;                        //返回栈顶元素的const引用</span><br><span class="line">void push(const value_type &amp;val);                     //将元素val压入stack中</span><br><span class="line">void pop();                                           //将stack中尾部的元素弹出</span><br><span class="line">template &lt;class... Args&gt;</span><br><span class="line">void emplace(Args &amp;&amp;... args);                        //(C++11) 在stack的栈顶构造元素</span><br><span class="line">void swap(stack &amp;x);                                  //(C++11) 交换两个栈中的元素</span><br></pre></td></tr></table></figure>
<h3 id="栈的应用"><a href="#栈的应用" class="headerlink" title="栈的应用"></a>栈的应用</h3><h4 id="最小栈"><a href="#最小栈" class="headerlink" title="最小栈"></a>最小栈</h4><p>&emsp;&emsp;力扣：<br><a href="https://leetcode-cn.com/problems/min-stack/submissions/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/min-stack/submissions/</a><br>&emsp;&emsp;这道题就是用栈区实现一个可以返回当前栈中最小值的栈，方法有很多种，这里只提供一种方法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">class MinStack &#123;</span><br><span class="line">public:</span><br><span class="line">    /** initialize your data structure here. */</span><br><span class="line">    MinStack()</span><br><span class="line">        :_min(INT_MAX)</span><br><span class="line">    &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    void push(int x) &#123;</span><br><span class="line">        if(x &lt; _min)</span><br><span class="line">        &#123;</span><br><span class="line">            _min = x;</span><br><span class="line">        &#125;</span><br><span class="line">        _elem.push_back(x);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    void pop() &#123;</span><br><span class="line">        if(top() == _min)</span><br><span class="line">        &#123;</span><br><span class="line">            _min = INT_MAX;</span><br><span class="line">            for(int i = 0; i &lt; _elem.size() - 1; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                if(_elem[i] &lt; _min)</span><br><span class="line">                &#123;</span><br><span class="line">                    _min = _elem[i];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        _elem.pop_back();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    int top() &#123;</span><br><span class="line">        return _elem[_elem.size() - 1];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    int getMin() &#123;</span><br><span class="line">        return _min;</span><br><span class="line">    &#125;</span><br><span class="line">private:</span><br><span class="line">    std::vector&lt;int&gt; _elem;</span><br><span class="line">    int _min;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Your MinStack object will be instantiated and called as such:</span><br><span class="line"> * MinStack* obj = new MinStack();</span><br><span class="line"> * obj-&gt;push(x);</span><br><span class="line"> * obj-&gt;pop();</span><br><span class="line"> * int param_3 = obj-&gt;top();</span><br><span class="line"> * int param_4 = obj-&gt;getMin();</span><br><span class="line"> */</span><br></pre></td></tr></table></figure></p>
<h4 id="栈的压入、弹出序列"><a href="#栈的压入、弹出序列" class="headerlink" title="栈的压入、弹出序列"></a>栈的压入、弹出序列</h4><p>&emsp;&emsp;牛客网：<br><a href="https://www.nowcoder.com/practice/d77d11405cc7470d82554cb392585106?tpId=13&amp;&amp;tqId=11174&amp;rp=1&amp;ru=/activity/oj&amp;qru=/ta/coding-interviews/question-ranking" target="_blank" rel="noopener">https://www.nowcoder.com/practice/d77d11405cc7470d82554cb392585106?tpId=13&amp;&amp;tqId=11174&amp;rp=1&amp;ru=/activity/oj&amp;qru=/ta/coding-interviews/question-ranking</a><br>&emsp;&emsp;这道题用到了栈的弹出序列是否匹配压入序列的算法，大致思路是用一个栈进行模拟，并且设立用于分别遍历弹出和压入序列的下标，只要栈顶元素不等于当前遍历到的弹出序列的元素，就将压入序列当前元素压入栈，并且遍历压入序列的下一个元素，如果相等，则将栈顶元素弹出，并且遍历弹出序列的下一个元素。如果当弹出序列还没有遍历完毕而压入序列也始终找不到下一个可以和弹出序列进行匹配的元素则不匹配，返回false，如果弹出序列遍历完毕，则表示匹配，返回true。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool IsPopOrder(vector&lt;int&gt; pushV,vector&lt;int&gt; popV) &#123;</span><br><span class="line">        int pushIndex = 0;</span><br><span class="line">        int popIndex = 0;</span><br><span class="line">        //用栈进行模拟</span><br><span class="line">        stack&lt;int&gt; s;</span><br><span class="line">        //遍历弹出序列</span><br><span class="line">        while(popIndex &lt; popV.size())</span><br><span class="line">        &#123;</span><br><span class="line">            //栈为空或者栈顶元素不等于当天弹出序列遍历到的元素</span><br><span class="line">            while(s.empty() || s.top() != popV[popIndex])</span><br><span class="line">            &#123;</span><br><span class="line">                //压入序列还有元素则压入</span><br><span class="line">                if(pushIndex &lt; pushV.size())</span><br><span class="line">                &#123;</span><br><span class="line">                    s.push(pushV[pushIndex]);</span><br><span class="line">                    pushIndex++;</span><br><span class="line">                &#125;</span><br><span class="line">                //压入序列全部压入无法完成匹配</span><br><span class="line">                else</span><br><span class="line">                &#123;</span><br><span class="line">                    return false;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            //栈顶元素和弹出序列当前元素相同则往后继续遍历</span><br><span class="line">            s.pop();</span><br><span class="line">            popIndex++;</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h4 id="逆波兰表达式求值"><a href="#逆波兰表达式求值" class="headerlink" title="逆波兰表达式求值"></a>逆波兰表达式求值</h4><p>&emsp;&emsp;力扣：<br><a href="https://leetcode-cn.com/problems/evaluate-reverse-polish-notation/submissions/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/evaluate-reverse-polish-notation/submissions/</a><br>&emsp;&emsp;逆波兰表达式也成为后缀表达式，这里的逆波兰表达式求值由于不涉及括号所以比较简单，我们只需要将遇到的操作数放入栈，遇到操作符则取出栈顶两个元素进行计算，然后将结果再次放入栈最后取出栈中最后一个元素就是答案。不过这里要注意负数的处理，以及从栈中取出的两个操作数哪个是前操作数哪个是后操作数的问题。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int evalRPN(vector&lt;string&gt;&amp; tokens) &#123;</span><br><span class="line">        stack&lt;int&gt; s;</span><br><span class="line">        for(int i = 0; i &lt; tokens.size(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            if(tokens[i][0] &lt;= &apos;9&apos; &amp;&amp; tokens[i][0] &gt;= &apos;0&apos;)</span><br><span class="line">            &#123;</span><br><span class="line">                s.push(atoi(tokens[i].c_str()));</span><br><span class="line">            &#125;</span><br><span class="line">            //要处理负数</span><br><span class="line">            else if(tokens[i][0] == &apos;-&apos; &amp;&amp; tokens[i][1] != &apos;\0&apos;)</span><br><span class="line">            &#123;</span><br><span class="line">                string str = tokens[i].substr(1);</span><br><span class="line">                int temp = -1 * atoi(str.c_str());</span><br><span class="line">                s.push(temp);</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">            &#123;</span><br><span class="line">                int num1 = s.top();</span><br><span class="line">                s.pop();</span><br><span class="line">                int num2 = s.top();</span><br><span class="line">                s.pop();</span><br><span class="line">                switch(tokens[i][0])</span><br><span class="line">                &#123;</span><br><span class="line">                    case &apos;+&apos;:</span><br><span class="line">                        s.push(num2 + num1);</span><br><span class="line">                        break;</span><br><span class="line">                    case &apos;-&apos;:</span><br><span class="line">                        s.push(num2 - num1);</span><br><span class="line">                        break;</span><br><span class="line">                    case &apos;*&apos;:</span><br><span class="line">                        s.push(num2 * num1);</span><br><span class="line">                        break;</span><br><span class="line">                    case &apos;/&apos;:</span><br><span class="line">                        s.push(num2 / num1);</span><br><span class="line">                        break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return s.top();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h2 id="queue类"><a href="#queue类" class="headerlink" title="queue类"></a>queue类</h2><p>&emsp;&emsp;和<code>stack</code>相反，<code>queue</code>有着先进先出的特性，这使得他能够按照顺序完成某一功能。它从容器的一端插入另一端删除，因此它的模板参数中的容器要求有以下功能：<br>&emsp;&emsp;1、<code>empty()</code>，判空<br>&emsp;&emsp;2、<code>size()</code>，长度<br>&emsp;&emsp;3、<code>back()</code>，获取尾部元素<br>&emsp;&emsp;4、<code>front()</code>，获取头部元素<br>&emsp;&emsp;5、<code>push_back()</code>，尾插<br>&emsp;&emsp;6、<code>pop_front()</code>，头删<br>&emsp;&emsp;如果没有传入容器的话则默认使用<code>deque</code>。</p>
<h3 id="常用接口-1"><a href="#常用接口-1" class="headerlink" title="常用接口"></a>常用接口</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">queue(const container_type &amp;ctnr = container_type()); //构造空的队列</span><br><span class="line">bool empty() const;                                   //检测队列是否为空，是返回true，否则返回false</span><br><span class="line">size_type size() const;                               //返回队列中有效元素的个数</span><br><span class="line">value_type &amp;front();                                  //返回队头元素的引用</span><br><span class="line">const value_type &amp;front() const;                      //返回队头元素的const引用</span><br><span class="line">value_type &amp;back();                                   //返回队尾元素的引用</span><br><span class="line">const value_type &amp;back() const;                       //返回队尾元素的cosnt引用</span><br><span class="line">void push(value_type &amp; val);                          //在队尾将元素val入队列</span><br><span class="line">void pop();                                           //将队头元素出队列</span><br><span class="line">template &lt;class... Args&gt;</span><br><span class="line">void emplace(Args &amp;&amp; ... args)(C++ 11);               //在队尾构造元素</span><br><span class="line">void swap(queue &amp; x);                                 //交换两个队列中的元素</span><br></pre></td></tr></table></figure>
<h3 id="队列的应用"><a href="#队列的应用" class="headerlink" title="队列的应用"></a>队列的应用</h3><h4 id="用队列实现栈"><a href="#用队列实现栈" class="headerlink" title="用队列实现栈"></a>用队列实现栈</h4><p>&emsp;&emsp;力扣：<br><a href="https://leetcode-cn.com/problems/implement-stack-using-queues/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/implement-stack-using-queues/</a><br>&emsp;&emsp;利用栈进行层序遍历类似于bfs，即广度优先搜索，我们在进行遍历时需要将每一个结点的儿子都压入栈，只要栈不为空就一直遍历下去。但是这个题要求要区分每一层，则我们需要在遍历每一层前都拿到当前队列中结点的个数，则是这一层要遍历的结点数，我们这一层就只遍历这些结点即可。我们甚至由此可以得出N叉树的层序遍历，都可以用类似的思路。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for a binary tree node.</span><br><span class="line"> * struct TreeNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeNode *left;</span><br><span class="line"> *     TreeNode *right;</span><br><span class="line"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><br><span class="line"> * &#125;;</span><br><span class="line"> */</span><br><span class="line">class Solution &#123;</span><br><span class="line">    public:</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; levelOrder(TreeNode* root) &#123;</span><br><span class="line">        vector&lt;vector&lt;int&gt;&gt; res;</span><br><span class="line">        queue&lt;TreeNode*&gt; q;</span><br><span class="line">        //根结点为空直接返回</span><br><span class="line">        if(root == nullptr)</span><br><span class="line">        &#123;</span><br><span class="line">            return res;</span><br><span class="line">        &#125;</span><br><span class="line">        q.push(root);</span><br><span class="line">        while(!q.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            vector&lt;int&gt; line;</span><br><span class="line">            int size = q.size();</span><br><span class="line">            for(int i = 0; i &lt; size; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                TreeNode* node = q.front();</span><br><span class="line">                if(node-&gt;left != nullptr)</span><br><span class="line">                &#123;</span><br><span class="line">                    q.push(node-&gt;left);</span><br><span class="line">                &#125;</span><br><span class="line">                if(node-&gt;right != nullptr)</span><br><span class="line">                &#123;</span><br><span class="line">                    q.push(node-&gt;right);</span><br><span class="line">                &#125;</span><br><span class="line">                q.pop();</span><br><span class="line">                line.push_back(node-&gt;val);</span><br><span class="line">            &#125;</span><br><span class="line">            res.push_back(line);</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h2 id="priority-queue类"><a href="#priority-queue类" class="headerlink" title="priority_queue类"></a>priority_queue类</h2><p>&emsp;&emsp;<code>priority_queue</code>称为优先级队列，它的出队元素永远是队列中优先级最高的那一个，它的底层是用一个堆来完成的，堆顶就是优先级最高的元素。<br>&emsp;&emsp;优先级队列在每次插入删除元素后都会分别调用算法<code>push_heap()</code>和<code>pop_heap()</code>重新建堆，并且还会和容器中的<code>push_back()</code>和<code>pop_back()</code>结合。同时优先级队列中有一个<code>Compare</code>的模板参数，用于传入一个仿函数，建堆会用这个仿函数按照严格弱序进行建堆。<br>&emsp;&emsp;所谓仿函数则是一个类中重载了<code>operator()</code>使其实例化的对象可以像函数一样进行调用，它的特点是可以使类作为模板参数一部分传入模板内，并且使其实例化出的对象可以当作函数使用。标准中给了两个类提供了仿函数的功能，<code>less</code>和<code>greater</code>。<br>&emsp;&emsp;如果在优先级队列中存放自定义类型的数据，要求自定义类型必须重载<code>operator&lt;</code>或<code>operator&gt;</code>取决于<code>Compare</code>的类型，这两个重载在仿函数中将会进行调用用于判断和比较。<br>&emsp;&emsp;同样的优先级队列中的容器也必须满足一些要求才能完成功能：<br>&emsp;&emsp;1、<code>empty()</code>，判空<br>&emsp;&emsp;2、<code>size()</code>，长度<br>&emsp;&emsp;3、<code>front()</code>，获取头部元素<br>&emsp;&emsp;4、<code>push_back()</code>，尾插<br>&emsp;&emsp;5、<code>pop_back()</code>，尾删<br>&emsp;&emsp;容器还需要支持随机访问迭代器，以便始终在内部保持堆结构。<br>&emsp;&emsp;为什么是这些接口？<code>front()</code>用于在建堆和堆调整后可以获得堆顶元素，即优先级最高的元素，即<code>top()</code>；<code>push()</code>在给堆插入元素时是从容器的尾部插入，因此需要<code>push_back()</code>进行尾插，尾插后再用<code>push_heap()</code>调整堆；<code>pop()</code>在出队时要先调用<code>pop_heap()</code>，这个接口会将堆顶元素与堆的最后一个元素交换位置，并且对堆的除最后一个元素进行调整，这个过程类似于堆排序。之后再调用容器的<code>pop_back()</code>即可将原本堆顶优先级最高的元素出队。</p>
<h3 id="常用接口-2"><a href="#常用接口-2" class="headerlink" title="常用接口"></a>常用接口</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">priority_queue(const Compare &amp;x = Compare(),</span><br><span class="line">                   const Container &amp;y = Container());   //构造一个空的优先级队列</span><br><span class="line">template &lt;class InputIterator&gt;</span><br><span class="line">priority_queue(InputIterator first, InputIterator last,</span><br><span class="line">               const Compare &amp;comp = Compare(),</span><br><span class="line">               const Container &amp;ctnr = Container()); //用[first, last)区间中的元素构造优先级队列</span><br><span class="line">bool empty() const;                                  //检测优先级队列是否为空，是返回true，否则返回false</span><br><span class="line">const value_type &amp;top() const;                       //返回优先级队列中最大(最小元素)，即堆顶元素</span><br><span class="line">void push(const T &amp;x);                               //在优先级队列中插入元素x</span><br><span class="line">void pop();                                          //删除优先级队列中最大(最小)元素，即堆顶元素</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;默认情况下，类模板中<code>Compare</code>的类型为<code>less</code>，实例化出来的对象重载时判断的为是否小于，因此会创建大堆，队列出队返回的值也是队中优先级最高的。</p>
<h3 id="优先级队列的应用"><a href="#优先级队列的应用" class="headerlink" title="优先级队列的应用"></a>优先级队列的应用</h3><p>&emsp;&emsp;优先级队列底层是堆的实现，因此优先级队列擅长于结局堆能够解决的问题，例如TopK问题。</p>
<h4 id="数组中的第K个最大的元素"><a href="#数组中的第K个最大的元素" class="headerlink" title="数组中的第K个最大的元素"></a>数组中的第K个最大的元素</h4><p>&emsp;&emsp;力扣：<br><a href="https://leetcode-cn.com/problems/kth-largest-element-in-an-array/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/kth-largest-element-in-an-array/</a><br>&emsp;&emsp;这道题就利用优先级队列找到第k个大的元素即可，也可以先排序后再找。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int findKthLargest(vector&lt;int&gt;&amp; nums, int k) &#123;</span><br><span class="line">        priority_queue&lt;int&gt; que(nums.begin(), nums.end());</span><br><span class="line">        for(int i = 0; i &lt; k - 1; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            que.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        return que.top();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h4 id="前K个高频元素"><a href="#前K个高频元素" class="headerlink" title="前K个高频元素"></a>前K个高频元素</h4><p>力扣：<br><a href="https://leetcode-cn.com/problems/top-k-frequent-elements/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/top-k-frequent-elements/</a><br>&emsp;&emsp;这道题做起来不难，但是是对优先级队列较为综合的运用，我们要考虑到TOPK问题中找前K大要用小根堆，还要考虑到要将出现次数与元素本身联系起来要在优先级队列中存储<code>pair</code>。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; topKFrequent(vector&lt;int&gt;&amp; nums, int k) &#123;</span><br><span class="line">        map&lt;int, int&gt; m;</span><br><span class="line">        for(int i = 0; i &lt; nums.size(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            m[nums[i]]++;</span><br><span class="line">        &#125;</span><br><span class="line">        //topK问题求前K大一定要用小根堆，维护K个数据</span><br><span class="line">        //用大根堆要放入全部数据费时费空间</span><br><span class="line">        priority_queue&lt;pair&lt;int, int&gt;, vector&lt;pair&lt;int, int&gt;&gt;, greater&lt;pair&lt;int, int&gt;&gt;&gt; que;</span><br><span class="line">        for(auto e : m)</span><br><span class="line">        &#123;</span><br><span class="line">            if(que.size() &gt;= k)</span><br><span class="line">            &#123;</span><br><span class="line">                if(e.second &gt; que.top().first)</span><br><span class="line">                &#123;</span><br><span class="line">                    que.pop();</span><br><span class="line">                    que.push(make_pair(e.second, e.first));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">            &#123;</span><br><span class="line">                que.push(make_pair(e.second, e.first)); </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        vector&lt;int&gt; res(k);</span><br><span class="line">        while(!que.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            res[que.size() - 1] = que.top().second;</span><br><span class="line">            que.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>&emsp;&emsp;依旧是实现常用接口，了解底层原理。</p>
<h3 id="stack类的实现"><a href="#stack类的实现" class="headerlink" title="stack类的实现"></a>stack类的实现</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">#pragma once</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;deque&gt;</span><br><span class="line">template&lt;class T, class Container = std::deque&lt;T&gt;&gt;</span><br><span class="line">class Stack</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    void Push(const T&amp; data)</span><br><span class="line">    &#123;</span><br><span class="line">        _con.push_back(data);</span><br><span class="line">    &#125;</span><br><span class="line">    void Pop()</span><br><span class="line">    &#123;</span><br><span class="line">        _con.pop_back();</span><br><span class="line">    &#125;</span><br><span class="line">    bool Empty()</span><br><span class="line">    &#123;</span><br><span class="line">        return _con.empty();</span><br><span class="line">    &#125;</span><br><span class="line">    size_t Size()</span><br><span class="line">    &#123;</span><br><span class="line">        return _con.size();</span><br><span class="line">    &#125;</span><br><span class="line">    T&amp; Top()</span><br><span class="line">    &#123;</span><br><span class="line">        return _con.back();</span><br><span class="line">    &#125;</span><br><span class="line">    const T&amp; Top() const</span><br><span class="line">    &#123;</span><br><span class="line">        return _con.back();</span><br><span class="line">    &#125;</span><br><span class="line">private:</span><br><span class="line">    Container _con;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="queue的实现"><a href="#queue的实现" class="headerlink" title="queue的实现"></a>queue的实现</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">#pragma once</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;deque&gt;</span><br><span class="line">template&lt;class T, class Container = std::deque&lt;T&gt;&gt;</span><br><span class="line">class Queue</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    void Push(const T&amp; data)</span><br><span class="line">    &#123;</span><br><span class="line">        _con.push_back(data);</span><br><span class="line">    &#125;</span><br><span class="line">    void Pop()</span><br><span class="line">    &#123;</span><br><span class="line">        _con.pop_front();</span><br><span class="line">    &#125;</span><br><span class="line">    size_t Size()</span><br><span class="line">    &#123;</span><br><span class="line">        return _con.size();</span><br><span class="line">    &#125;</span><br><span class="line">    bool Empty()</span><br><span class="line">    &#123;</span><br><span class="line">        return _con.empty();</span><br><span class="line">    &#125;</span><br><span class="line">    T&amp; Back()</span><br><span class="line">    &#123;</span><br><span class="line">        return _con.back();</span><br><span class="line">    &#125;</span><br><span class="line">    const T&amp; Back() const</span><br><span class="line">    &#123;</span><br><span class="line">        return _con.back();</span><br><span class="line">    &#125;</span><br><span class="line">    T&amp; Front()</span><br><span class="line">    &#123;</span><br><span class="line">        return _con.front();</span><br><span class="line">    &#125;</span><br><span class="line">    const T&amp; Front() const</span><br><span class="line">    &#123;</span><br><span class="line">        return _con.front();</span><br><span class="line">    &#125;</span><br><span class="line">private:</span><br><span class="line">    Container _con;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="priority-queue的实现"><a href="#priority-queue的实现" class="headerlink" title="priority_queue的实现"></a>priority_queue的实现</h3><p>&emsp;&emsp;在SGI版本的<code>priority_queue</code>中建堆以及调整堆都是调用的<code>algorithm</code>中的算法函数完成的，但是在模拟实现中我们完全自己实现。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line">#pragma once</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;functional&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">template&lt;class T&gt;</span><br><span class="line">struct Less</span><br><span class="line">&#123;</span><br><span class="line">    bool operator()(const T&amp; obj1, const T&amp; obj2)</span><br><span class="line">    &#123;</span><br><span class="line">        return obj1 &lt; obj2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">template&lt;class T&gt;</span><br><span class="line">struct Greater</span><br><span class="line">&#123;</span><br><span class="line">    bool operator()(const T&amp; obj1, const T&amp; obj2)</span><br><span class="line">    &#123;</span><br><span class="line">        return obj1 &gt; obj2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">template&lt;class T, class Container = std::vector&lt;T&gt;, class Compare = Less&lt;T&gt;&gt;</span><br><span class="line">class Priority_queue</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    //向下调整</span><br><span class="line">    void AdjustDown(size_t parent)</span><br><span class="line">    &#123;</span><br><span class="line">        size_t child = parent * 2 + 1;</span><br><span class="line">        Compare com;</span><br><span class="line">        while(child &lt; _con.size())</span><br><span class="line">        &#123;</span><br><span class="line">            if(child + 1 &lt; _con.size() &amp;&amp; com(_con[child], _con[child + 1]))</span><br><span class="line">            &#123;</span><br><span class="line">                child++;    </span><br><span class="line">            &#125;</span><br><span class="line">            if(com(_con[parent], _con[child]))</span><br><span class="line">            &#123;</span><br><span class="line">                std::swap(_con[parent], _con[child]);</span><br><span class="line">                parent = child;</span><br><span class="line">                child = parent * 2 + 1;    </span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">            &#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    //向上调整</span><br><span class="line">    void AdjustUp(size_t child)</span><br><span class="line">    &#123;</span><br><span class="line">        size_t parent = (child - 1) / 2;</span><br><span class="line">        Compare com;</span><br><span class="line">        while(child &gt; 0)</span><br><span class="line">        &#123;</span><br><span class="line">            if(com(_con[parent], _con[child]))</span><br><span class="line">            &#123;</span><br><span class="line">                std::swap(_con[parent], _con[child]);</span><br><span class="line">                child = parent;</span><br><span class="line">                parent = (child - 1) / 2;</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">            &#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    void Push(const T&amp; data)</span><br><span class="line">    &#123;</span><br><span class="line">        _con.push_back(data);</span><br><span class="line">        //模拟push_heap()的功能</span><br><span class="line">        AdjustUp(_con.size() - 1);</span><br><span class="line">    &#125;</span><br><span class="line">    void Pop()</span><br><span class="line">    &#123;</span><br><span class="line">        //模拟pop_heap()的功能</span><br><span class="line">        std::swap(_con[0], _con[_con.size() - 1]);</span><br><span class="line">        _con.pop_back();</span><br><span class="line">        AdjustDown(0);</span><br><span class="line">    &#125;</span><br><span class="line">    size_t Size()</span><br><span class="line">    &#123;</span><br><span class="line">        return _con.size();</span><br><span class="line">    &#125;</span><br><span class="line">    bool Empty()</span><br><span class="line">    &#123;</span><br><span class="line">        return _con.empty();</span><br><span class="line">    &#125;</span><br><span class="line">    T&amp; Top()</span><br><span class="line">    &#123;</span><br><span class="line">        return _con.front();</span><br><span class="line">    &#125;</span><br><span class="line">    const T&amp; Top() const</span><br><span class="line">    &#123;</span><br><span class="line">        return _con.front();</span><br><span class="line">    &#125;</span><br><span class="line">//private:</span><br><span class="line">    Container _con;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>

          
        
      
    </div>
    
    
    

    

    <div>
    
    </div>

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/07/30/【Cpp】第八章-STL-deque类/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="MisakiFx">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/blog-logo.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Misaki`s blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/07/30/【Cpp】第八章-STL-deque类/" itemprop="url">【Cpp】第八章-STL_deque类</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-07-30T16:39:49+08:00">
                2019-07-30
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Cpp/" itemprop="url" rel="index">
                    <span itemprop="name">Cpp</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  1.4k
                </span>
              

              

              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="deque类"><a href="#deque类" class="headerlink" title="deque类"></a>deque类</h1><h2 id="基础介绍"><a href="#基础介绍" class="headerlink" title="基础介绍"></a>基础介绍</h2><p>&emsp;&emsp;<code>deque</code>是双端队列，它提供了和<code>vector</code>类似的接口但是底层的实现与<code>vector</code>完全不同，<code>vector</code>底层用三个指针指向数组的起点，尾部和总容量的尾部，并且所有元素都是连续的，但是在<code>deque</code>中所有元素并不一定都是在连续的内存空间上的。<code>deque</code>在底层实现上是将一个连续的空间分段进行管理，并将它们的首地址用一个指针数组进行管理，这样特殊的存储结构使得它在头部和尾部增加元素比<code>vector</code>更加高效，但是底层实现更为复杂，存储了很多额外信息。如果抛去在头部和尾部增加元素，在中间任意位置添加元素，它的效率比vector更高，但是比list要低。</p>
<h2 id="常用接口"><a href="#常用接口" class="headerlink" title="常用接口"></a>常用接口</h2><h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">deque();                                                  //构造空的双端队列</span><br><span class="line">deque(size_type n, const value_type &amp;val = value_type()); //用n个值为val的元素构造双端队列</span><br><span class="line">deque(InputIterator first, InputIterator last);           //用[first, last)的区间构造双端队列</span><br><span class="line">deque(const deque &amp;x);                                    //双端队列的拷贝构造函数</span><br></pre></td></tr></table></figure>
<h3 id="迭代器相关"><a href="#迭代器相关" class="headerlink" title="迭代器相关"></a>迭代器相关</h3><p>&emsp;&emsp;由于<code>deque</code>在内存上并不完全是连续的因此想要保持deque的连续性，这个任务就落到了迭代器身上。在底层实现上，<code>deque</code>将一段一段连续的内存称为一个缓冲区(buffer)，并将这些缓冲区的首尾地址存储在一个map中用以映射，map中一个存储缓冲区的地址对应一个结点(node)信息用于标记这个键值对，这样就构建好了基础架构。在迭代器中存储了4个信息，分别是当前结点(cur)，当前缓冲区的头(first)，当前缓冲区的尾(last)以及在map中用以标记当前缓冲区的地址的结点(node)信息。并且在<code>deque</code>内部已经存储好了两个迭代器<code>start</code>和<code>finish</code>用于标记<code>deque</code>的头和尾元素。这样即可完成将一段一段连续的空间在逻辑结构上构成一段连续空间的目的。<br>&emsp;&emsp;当从头遍历<code>deque</code>时，<code>start</code>迭代器中<code>first</code>和<code>last</code>已经从map中找到了第一个结点的缓冲区首尾信息并进行了保存，于是<code>cur</code>就从<code>first</code>开始遍历这个缓冲区，当遍历到<code>last</code>时就重新到map中寻找写一个结点的缓冲区收尾地址并且替换掉原来<code>first</code>和<code>last</code>值，继续遍历，这样即可完成遍历直到最后一个结点也遍历完。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">iterator begin();                       //返回deque起始位置迭代器</span><br><span class="line">iterator end();                         //返回deque最后一个元素下一个位置的迭代器</span><br><span class="line">reverse_iterator rbegin();              //返回deque起始位置的反向迭代器(即end())</span><br><span class="line">reverse_iterator rend();                //返回deque最后一个元素下一个位置的反向迭代器(begin())</span><br><span class="line">const_iterator cbegin() const;          //返回deque起始位置的const迭代器</span><br><span class="line">const_iterator cend() const;            //返回deque最后一个元素下一个位置的const迭代器</span><br><span class="line">const_reverse_iterator crbegin() const; //返回deque起始位置的const反向迭代器(即crend())</span><br><span class="line">const_reverse_iterator crend() const;   //返回deque最后一个元素下一个位置的const反向迭代器(crbegin())</span><br></pre></td></tr></table></figure></p>
<h3 id="容量相关"><a href="#容量相关" class="headerlink" title="容量相关"></a>容量相关</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">size_type size() const;               //返回deque中有效元素个数</span><br><span class="line">bool empty() const;                   //检测deque是否为空，是返回true，否则返回false</span><br><span class="line">void resize(size_type sz, T c = T()); //将deque中的元素改变到sz，多出的空间用c填充</span><br></pre></td></tr></table></figure>
<h3 id="增删改查"><a href="#增删改查" class="headerlink" title="增删改查"></a>增删改查</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">reference operator[](size_type n);                         //返回deque中n位置上元素的引用</span><br><span class="line">const_reference operator[](size_type n) const;             //返回deque中n位置上元素的const 引用</span><br><span class="line">reference front();                                         //返回deque中首元素的引用</span><br><span class="line">const_reference front() const;                             //返回deque中首元素的const引用</span><br><span class="line">reference back();                                          //返回deque中最后一个元素的引用</span><br><span class="line">const_reference back() const;                              //返回deque中最后一个元素的const引用</span><br><span class="line">void push_back(const value_type &amp;val);                     //deque尾部插入元素val</span><br><span class="line">void pop_back();                                           //删除deque尾部元素</span><br><span class="line">void push_front(const value_type &amp;val);                    //deque头部插入元素val</span><br><span class="line">void pop_front();                                          //删除deque头部元素</span><br><span class="line">iterator insert(iterator position, const value_type &amp;val); //在deque的position位置插入值为val的元素</span><br><span class="line">void insert(iterator position, size_type n,</span><br><span class="line">            const value_type &amp;val);                                      //在deque的position位置插入n个值为val的元素</span><br><span class="line">void insert(iterator position, InputIterator first, InputIterator last); //在deque的position位置插入[first, last)区间中的元素</span><br><span class="line">iterator erase(iterator position);                                       //删除deque中position位置的元素，并返回该位置的下一个位置</span><br><span class="line">iterator erase(iterator first, iterator last);                           //删除deque中[first, last)区间中的元素，并返回last位置</span><br><span class="line">void swap(deque &amp; x);                                                    //交换两个deque中的内容</span><br><span class="line">void clear();                                                            //将deque中的元素清空</span><br><span class="line">iterator emplace(const_iterator position, Args &amp;&amp; ... args);             //在deque的position位置构造元素，将元素所需内容通过参数类表传入</span><br><span class="line">void emplace_front(Args &amp;&amp; ... args);                                    //在deque的头部构造元素，元素的参数通过参数列表传入</span><br><span class="line">void emplace_back(Args &amp;&amp; ... args);                                     //在deque的尾部构造元素，元素的参数通过参数列表传入</span><br></pre></td></tr></table></figure>
<h3 id="综合运用"><a href="#综合运用" class="headerlink" title="综合运用"></a>综合运用</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;deque&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    deque&lt;int&gt; deq;</span><br><span class="line">    deq.push_front(1);</span><br><span class="line">    deq.push_back(2);</span><br><span class="line">    deque&lt;int&gt;::iterator it = deq.begin();</span><br><span class="line">    it = deq.insert(it, 0);</span><br><span class="line">    while(it != deq.end())</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; *it &lt;&lt; endl;</span><br><span class="line">        it++;</span><br><span class="line">    &#125;</span><br><span class="line">    it = deq.erase(--it);</span><br><span class="line">    it = deq.begin();</span><br><span class="line">    while(it != deq.end())</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; *it &lt;&lt; endl;</span><br><span class="line">        it++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>&emsp;&emsp;双端队列<code>deque</code>是一个设计并不算成功的容器，如果要随机访问单纯的查询多一点可以用<code>vector</code>而且更加方便，如果需要频繁插入那么<code>list</code>效率又会跟高，因此<code>deque</code>并不常用，其最常用的地方就是在作为适配器<code>stack</code>和<code>queue</code>的底层存储容器。</p>

          
        
      
    </div>
    
    
    

    

    <div>
    
    </div>

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/07/29/【Cpp】第七章-STL-list类/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="MisakiFx">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/blog-logo.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Misaki`s blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/07/29/【Cpp】第七章-STL-list类/" itemprop="url">【Cpp】第七章-STL_list类</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-07-29T23:12:49+08:00">
                2019-07-29
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Cpp/" itemprop="url" rel="index">
                    <span itemprop="name">Cpp</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  2.2k
                </span>
              

              

              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="list类"><a href="#list类" class="headerlink" title="list类"></a>list类</h1><h2 id="基础介绍"><a href="#基础介绍" class="headerlink" title="基础介绍"></a>基础介绍</h2><p>&emsp;&emsp;<code>list类</code>是STL中封装的链表模板类，并且底层实现是以双向链表作为基础进行封装的。在数据结构中，线性存储结构中主要分为顺序表和链表，前者在物理结构上拥有连续的内存空间和地址，在STL中<code>vector</code>和<code>string</code>都是使用了这种结构，其最大的特点就是方便进行随机访问并且尾插和尾删都能达到O1的时间复杂度并且使用方便，而链表作为物理结构上内存空间不连续的数据结构，其最大的特点就是方便在任何位置就行插入删除，<code>list</code>就是建立在此数据结构上封装出的模板类。</p>
<h2 id="常用接口"><a href="#常用接口" class="headerlink" title="常用接口"></a>常用接口</h2><h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">list();                                                  //构造空的list</span><br><span class="line">list(size_type n, const value_type &amp;val = value_type()); //构造的list中包含n个值为val的元素</span><br><span class="line">list(const list &amp;x);                                     //拷贝构造函数</span><br><span class="line">list(InputIterator first, InputIterator last);           //用[first, last)区间中的元素构造list</span><br></pre></td></tr></table></figure>
<h3 id="迭代器相关"><a href="#迭代器相关" class="headerlink" title="迭代器相关"></a>迭代器相关</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">begin();   //返回第一个元素的迭代器</span><br><span class="line">end();     //返回最后一个元素下一个位置的迭代器</span><br><span class="line">rbegin();  //返回第一个元素的reverse_iterator,即end位置</span><br><span class="line">rend();    //返回最后一个元素下一个位置的reverse_iterator,即begin位置</span><br><span class="line">cbegin();  //(C++11) 返回第一个元素的cosnt_iterator</span><br><span class="line">cend();    //(C++11) 返回最后一个元素下一个位置的const_iterator</span><br><span class="line">crbegin(); //(C++11) 即crend()位置</span><br><span class="line">crend();   //(C++11) 即crbegin()位置</span><br></pre></td></tr></table></figure>
<h3 id="容量相关"><a href="#容量相关" class="headerlink" title="容量相关"></a>容量相关</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">bool empty() const;  //检测list是否为空，是返回true，否则返回false</span><br><span class="line">size_t size() const; //返回list中有效节点的个数</span><br></pre></td></tr></table></figure>
<h3 id="增删查改"><a href="#增删查改" class="headerlink" title="增删查改"></a>增删查改</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">reference front();                      //返回list的第一个节点中值的引用</span><br><span class="line">const_reference front() const;          //返回list的第一个节点中值的const引用</span><br><span class="line">reference back();                       //返回list的最后一个节点中值的引用</span><br><span class="line">const_reference back() const;           //返回list的最后一个节点中值的const引用</span><br><span class="line">void push_front(const value_type &amp;val); //在list首元素前插入值为val的元素</span><br><span class="line">void pop_front();                       //删除list中第一个元素</span><br><span class="line">void push_back;                         //(const value_type&amp; val)在list尾部插入值为val的元素</span><br><span class="line">void pop_back();                        //删除list中最后一个元素</span><br><span class="line">template &lt;class... Args&gt;</span><br><span class="line">void emplace_front(Args &amp;&amp; ... args); //（C++11）在list第一个元素前根据参数直接构造元素</span><br><span class="line">template &lt;class... Args&gt;</span><br><span class="line">void emplace_back(Args &amp;&amp; ... args); //（C++11）在list最后一个元素后根据参数直接构造元素</span><br><span class="line">template &lt;class... Args&gt;</span><br><span class="line">iterator emplace(const_iterator position, Args &amp;&amp; ... args);             //（C++11）在链表的任意位置根据参数直接构造元素</span><br><span class="line">iterator insert(iterator position, const value_type &amp;val);               //在list position 位置中插入值为val的元素</span><br><span class="line">void insert(iterator position, size_type n, const value_type &amp;val);      //在list position位置插入n个值为val的元素</span><br><span class="line">void insert(iterator position, InputIterator first, InputIterator last); //在list position位置插入[first, last)区间中元素</span><br><span class="line">iterator erase(iterator position);                                       //删除list position位置的元素</span><br><span class="line">iterator erase(iterator first, iterator last);                           //删除list中[first, last)区间中的元素</span><br><span class="line">void swap(list &amp; x);                                                     //交换两个list中的元素</span><br><span class="line">void resize(size_type n, value_type val = value_type());                 //将list中有效元素个数改变到n个，多出的元素用val填充</span><br><span class="line">void clear();                                                            //清空list中的有效元素</span><br></pre></td></tr></table></figure>
<h2 id="emplace与insert"><a href="#emplace与insert" class="headerlink" title="emplace与insert"></a>emplace与insert</h2><p>&emsp;&emsp;在STL很多接口中我们都发现有一个<code>emplace()</code>的接口也是用来进行插入的，那么它与<code>insert()</code>和<code>push_back()</code>有什么区别呢？以下用<code>vector</code>举个例子，从接口调用上就能看出区别。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    struct Foo </span><br><span class="line">    &#123;</span><br><span class="line">        Foo(int n, double x)</span><br><span class="line">            :_n(n)</span><br><span class="line">            ,_x(x)</span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        int _n;</span><br><span class="line">        double _x;</span><br><span class="line">    &#125;;</span><br><span class="line">    vector&lt;Foo&gt; v;</span><br><span class="line">    v.emplace(v.begin(), 42, 3.1416);     // 没有临时变量产生</span><br><span class="line">    v.insert(v.begin(), Foo(42, 3.1416)); // 需要产生一个临时变量</span><br><span class="line">    v.insert(v.begin(), &#123;42, 3.1416&#125;);    // 需要产生一个临时变量</span><br><span class="line">    for(int i = 0; i &lt; v.size(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; v[i]._n &lt;&lt; &quot; &quot; &lt;&lt; v[i]._x &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">42 3.1416</span><br><span class="line">42 3.1416</span><br><span class="line">42 3.1416</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;在进行内置类型和拥有单参构造函数的类型的插入时我们只传入一个参数往往很难发现区别，但在我们必须传入多个参数才能进行插入时我们就会发现在使用<code>insert()</code>这些接口时我们必须插入与容器中元素类型相同的<strong>元素</strong>才能完成接口调用，这让我们不得不构造一个临时匿名对象，而<code>emplace</code>则不需要，我们只要按照构造一个对象那样给构造元素的参数即可省去了构造匿名对象的过程。而这其中需要用到<code>C++11</code>中的新标准<strong>变参模板</strong>和<strong>完美转发</strong>，因此<code>emplace</code>使用的时候要求编译器支持<code>C++11</code>标准。<br>&emsp;&emsp;<code>emplace</code>不光是调用接口上有所不同，在有的时候也可以提高我们的效率。例如在<code>list</code>中如果利用<code>insert</code>传入一个元素的时候我们就需要先调用元素的构造函数构造元素，然后再调用<code>Node</code>的构造函数以及该元素的拷贝构造函数构造一个拥有该元素值的结点，才能进行插入，而<code>emplace</code>则可以在创建结点时直接利用原本要构造临时元素对象的参数来直接构造结点，并且直接构造结点中的元素对象，<strong>相当于少了一次元素的拷贝构造，并且省去了构造临时对象，效率更高</strong>。</p>
<h2 id="list迭代器失效"><a href="#list迭代器失效" class="headerlink" title="list迭代器失效"></a>list迭代器失效</h2><p>&emsp;&emsp;对于<code>list</code>这种链式结构，在插入后是不会迭代器失效的，因为原先位置的迭代器依旧指向原来的结点，不会因为添加结点导致指向位置的变动。而在删除后迭代器原本指向的结点内存被释放，因此删除后删除结点的迭代器失效，但是其他结点迭代器指向不变因此不会发生迭代器失效。<br>&emsp;&emsp;总结：<strong>list只有在删除节点后才会发生迭代器失效，并且之后删除结点的迭代器失效</strong>。</p>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>&emsp;&emsp;<code>list</code>采用链式结构存储，因此实现起来要稍微麻烦一些，迭代器也需要额外进行封装。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;assert.h&gt;</span><br><span class="line">//定义结点类</span><br><span class="line">template&lt;class T&gt;</span><br><span class="line">struct ListNode</span><br><span class="line">&#123;</span><br><span class="line">    ListNode&lt;T&gt;* _prev;</span><br><span class="line">    ListNode&lt;T&gt;* _next;</span><br><span class="line">    T _data;</span><br><span class="line">    ListNode(const T&amp; data = T())</span><br><span class="line">        :_prev(nullptr)</span><br><span class="line">        ,_next(nullptr)</span><br><span class="line">        ,_data(data)</span><br><span class="line">    &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line">//由于const_iterator与iterator除了在迭代器返回值上不一样外其他要求完全一样</span><br><span class="line">//因此这里要进行实现时可以考虑定义两个类</span><br><span class="line">//但是这里使用一种取巧的方法我们将返回值类型当作模板参数传入模板中</span><br><span class="line">template&lt;class T, class Ref, class Ptr&gt;</span><br><span class="line">struct ListIterator</span><br><span class="line">&#123;</span><br><span class="line">    typedef ListNode&lt;T&gt; Node;</span><br><span class="line">    typedef ListIterator&lt;T, Ref, Ptr&gt; Self;</span><br><span class="line">    //构造函数</span><br><span class="line">    ListIterator(Node* node)</span><br><span class="line">        :_node(node)</span><br><span class="line">    &#123;&#125;</span><br><span class="line">    //operator* 为了让其可以和指针一样使用，返回引用</span><br><span class="line">    Ref operator*()</span><br><span class="line">    &#123;</span><br><span class="line">        return _node-&gt;_data;</span><br><span class="line">    &#125;</span><br><span class="line">    //operator-&gt; 为了让其可以和指针一样使用，返回指针</span><br><span class="line">    //这里实际调用it-&gt;只能取到数据的指针，所以正常来说得写成it-&gt;-&gt;</span><br><span class="line">    //但是经过编译器优化，只用写it-&gt;就可以取到值了</span><br><span class="line">    Ptr operator-&gt;()</span><br><span class="line">    &#123;</span><br><span class="line">        return &amp;(_node-&gt;_data);</span><br><span class="line">    &#125;</span><br><span class="line">    Self operator++()</span><br><span class="line">    &#123;</span><br><span class="line">        _node = _node-&gt;_next;</span><br><span class="line">        return _node;    </span><br><span class="line">    &#125;</span><br><span class="line">    Self operator++(int)</span><br><span class="line">    &#123;</span><br><span class="line">        Self temp(_node);</span><br><span class="line">        _node = _node-&gt;_next;</span><br><span class="line">        return temp;</span><br><span class="line">    &#125; </span><br><span class="line">    Self operator--()</span><br><span class="line">    &#123;</span><br><span class="line">        _node = _node-&gt;_prev;</span><br><span class="line">        return _node;    </span><br><span class="line">    &#125;</span><br><span class="line">    Self operator--(int)</span><br><span class="line">    &#123;</span><br><span class="line">        Self temp(_node);</span><br><span class="line">        _node = _node-&gt;_prev;</span><br><span class="line">        return temp;</span><br><span class="line">    &#125; </span><br><span class="line">    bool operator!=(Self it)</span><br><span class="line">    &#123;</span><br><span class="line">        return _node != it._node;</span><br><span class="line">    &#125;</span><br><span class="line">    Node* _node;</span><br><span class="line">&#125;;</span><br><span class="line">//构建一个带头结点双向循环链表来模拟实现list</span><br><span class="line">template&lt;class T&gt;</span><br><span class="line">class List</span><br><span class="line">&#123;</span><br><span class="line">    typedef ListNode&lt;T&gt; Node;</span><br><span class="line">public:</span><br><span class="line">    typedef ListIterator&lt;T, T&amp;, T*&gt; iterator;</span><br><span class="line">    typedef ListIterator&lt;T, const T&amp;, const T*&gt; const_iterator;</span><br><span class="line">    //构造函数j</span><br><span class="line">    List()</span><br><span class="line">    &#123;</span><br><span class="line">        _head = new Node;</span><br><span class="line">        _head-&gt;_next = _head;</span><br><span class="line">        _head-&gt;_prev = _head;</span><br><span class="line">    &#125;</span><br><span class="line">    //拷贝构造</span><br><span class="line">    List(const List&amp; list)</span><br><span class="line">        :_head(new Node)</span><br><span class="line">    &#123;</span><br><span class="line">        _head-&gt;_next = _head;</span><br><span class="line">        _head-&gt;_prev = _head;</span><br><span class="line">        const_iterator it = list.begin();</span><br><span class="line">        while(it != list.end())</span><br><span class="line">        &#123;</span><br><span class="line">            Push_back(*it);</span><br><span class="line">            it++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    //operator=重载</span><br><span class="line">    List&amp; operator=(const List&amp; list)</span><br><span class="line">    &#123;</span><br><span class="line">        List listTemp = list;</span><br><span class="line">        Swap(listTemp);</span><br><span class="line">    &#125;</span><br><span class="line">    //交换</span><br><span class="line">    void Swap(List&amp; list)</span><br><span class="line">    &#123;</span><br><span class="line">        std::swap(_head, list._head);</span><br><span class="line">    &#125;</span><br><span class="line">    //析构函数</span><br><span class="line">    ~List()</span><br><span class="line">    &#123;</span><br><span class="line">        </span><br><span class="line">        while(_head-&gt;_next != _head)</span><br><span class="line">        &#123;</span><br><span class="line">            Pop_back();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    iterator begin()</span><br><span class="line">    &#123;</span><br><span class="line">        return _head-&gt;_next;</span><br><span class="line">    &#125;</span><br><span class="line">    const_iterator begin() const</span><br><span class="line">    &#123;</span><br><span class="line">        return _head-&gt;_next;</span><br><span class="line">    &#125;</span><br><span class="line">    iterator end()</span><br><span class="line">    &#123;</span><br><span class="line">        return _head;</span><br><span class="line">    &#125;</span><br><span class="line">    const_iterator end() const</span><br><span class="line">    &#123;</span><br><span class="line">        return _head;</span><br><span class="line">    &#125;</span><br><span class="line">    iterator Erase(iterator&amp; it)</span><br><span class="line">    &#123;</span><br><span class="line">        assert(it._node != nullptr);</span><br><span class="line">        Node* pTemp = it._node;</span><br><span class="line">        Node* pNew = pTemp-&gt;_next;</span><br><span class="line">        //it-&gt;_node = pTemp-&gt;_next;</span><br><span class="line">        pTemp-&gt;_prev-&gt;_next = pTemp-&gt;_next;</span><br><span class="line">        pTemp-&gt;_next-&gt;_prev = pTemp-&gt;_prev;</span><br><span class="line">        delete pTemp;</span><br><span class="line">        return pNew;</span><br><span class="line">    &#125;</span><br><span class="line">    //插入</span><br><span class="line">    iterator Insert(iterator&amp; it, const T&amp; data = T())</span><br><span class="line">    &#123;</span><br><span class="line">        assert(it._node != nullptr);</span><br><span class="line">        Node* newNode = new Node(data);</span><br><span class="line">        newNode-&gt;_next = it._node;</span><br><span class="line">        newNode-&gt;_prev = it._node-&gt;_prev;</span><br><span class="line">        it._node-&gt;_prev-&gt;_next = newNode;</span><br><span class="line">        it._node-&gt;_prev  = newNode;</span><br><span class="line">        return newNode;</span><br><span class="line">    &#125;</span><br><span class="line">    //尾插</span><br><span class="line">    void Push_back(const T&amp; data)</span><br><span class="line">    &#123;</span><br><span class="line">        assert(_head != nullptr);</span><br><span class="line">        Node* tail = _head-&gt;_prev;</span><br><span class="line">        Node* newNode = new Node(data);</span><br><span class="line">        newNode-&gt;_next = _head;</span><br><span class="line">        newNode-&gt;_prev = tail;</span><br><span class="line">        tail-&gt;_next = newNode;</span><br><span class="line">        _head-&gt;_prev = newNode;</span><br><span class="line">    &#125;</span><br><span class="line">    //尾删</span><br><span class="line">    void Pop_back()</span><br><span class="line">    &#123;</span><br><span class="line">        assert(_head != nullptr);</span><br><span class="line">        if(_head-&gt;_next == _head)</span><br><span class="line">        &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        Node* tail = _head-&gt;_prev;</span><br><span class="line">        tail-&gt;_prev-&gt;_next = _head;</span><br><span class="line">        _head-&gt;_prev = tail-&gt;_prev;</span><br><span class="line">        delete tail;</span><br><span class="line">    &#125;</span><br><span class="line">private:</span><br><span class="line">    Node* _head;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>

          
        
      
    </div>
    
    
    

    

    <div>
    
    </div>

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/07/27/【算法】第二章-搜索/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="MisakiFx">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/blog-logo.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Misaki`s blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/07/27/【算法】第二章-搜索/" itemprop="url">【算法】第二章-搜索</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-07-27T17:46:48+08:00">
                2019-07-27
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/算法/" itemprop="url" rel="index">
                    <span itemprop="name">算法</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  2.2k
                </span>
              

              

              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="搜索"><a href="#搜索" class="headerlink" title="搜索"></a>搜索</h1><h2 id="深度优先搜索-DFS"><a href="#深度优先搜索-DFS" class="headerlink" title="深度优先搜索(DFS)"></a>深度优先搜索(DFS)</h2><p>&emsp;&emsp;深度优先搜索是使用递归的方式以深度为主逐个探索遍历每种情况，在排列组合，迷宫问题中十分常用。深度优先搜索思想简单，但是由于使用递归，要求我们遍历时探索的必须深度有限。不然有可能会使栈溢出。还要注意有时我们在使用深度优先搜索时情况过多，而大部分是无用解时就需要套入<strong>剪枝</strong>。<br>&emsp;&emsp;模型：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">DFS()</span><br><span class="line">&#123;</span><br><span class="line">    //1.判断边界，如果已经到达搜索的最深，则回退尝试其他可能</span><br><span class="line">    //2.尝试当下的每一种可能</span><br><span class="line">    //3.确定一种可能后，继续下一步</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="例1-员工的重要度"><a href="#例1-员工的重要度" class="headerlink" title="例1 员工的重要度"></a>例1 员工的重要度</h3><p>&emsp;&emsp;力扣：<br><a href="https://leetcode-cn.com/problems/employee-importance/submissions/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/employee-importance/submissions/</a></p>
<h4 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h4><p>&emsp;&emsp;抽象模型。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">DFS(id)</span><br><span class="line">&#123;</span><br><span class="line">    //1.获取当前员工的重要度</span><br><span class="line">    //2.累加每一个下属(for)的重要度,DFS(下属id)</span><br><span class="line">    //3.return累加的重要度</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int DFS(unordered_map&lt;int, Employee*&gt; em, int id)</span><br><span class="line">    &#123;</span><br><span class="line">        int curRet = em[id]-&gt;importance;</span><br><span class="line">        for(auto&amp; e : em[id]-&gt;subordinates)</span><br><span class="line">        &#123;</span><br><span class="line">            curRet += DFS(em, e);</span><br><span class="line">        &#125;</span><br><span class="line">        return curRet;</span><br><span class="line">    &#125;</span><br><span class="line">    int getImportance(vector&lt;Employee*&gt; employees, int id) &#123;</span><br><span class="line">        if(employees.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        unordered_map&lt;int, Employee*&gt; em;</span><br><span class="line">        for(auto&amp; e: employees)</span><br><span class="line">        &#123;</span><br><span class="line">            em[e-&gt;id] = e;</span><br><span class="line">        &#125;</span><br><span class="line">        return DFS(em, id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="例2-图像渲染"><a href="#例2-图像渲染" class="headerlink" title="例2 图像渲染"></a>例2 图像渲染</h3><p>&emsp;&emsp;力扣：<br><a href="https://leetcode-cn.com/problems/flood-fill/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/flood-fill/</a></p>
<h4 id="解析-1"><a href="#解析-1" class="headerlink" title="解析"></a>解析</h4><p>&emsp;&emsp;抽象模型。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">DFS()</span><br><span class="line">&#123;</span><br><span class="line">    //1.nx,ny染色</span><br><span class="line">    //2.处理上，下，左，右4个点</span><br><span class="line">    &#123;</span><br><span class="line">        //以深度优先逐个方向遍历周边4个点</span><br><span class="line">        //新位置颜色符合，且没有越界，且没有染过色</span><br><span class="line">        //符合条件处理新位置</span><br><span class="line">        DFS(新的位置)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">static int nextP[4][2] = &#123;&#123;0, 1&#125;, &#123;1, 0&#125;, &#123;0, -1&#125;, &#123;-1, 0&#125;&#125;;</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    void DFS(vector&lt;vector&lt;int&gt;&gt;&amp; image, int row, int col, int nx, int ny, vector&lt;vector&lt;int&gt;&gt; book, int newColor, int oldColor)</span><br><span class="line">    &#123;</span><br><span class="line">        image[nx][ny] = newColor;</span><br><span class="line">        book[nx][ny] = 1;</span><br><span class="line">        //上下左右遍历</span><br><span class="line">        for(int i = 0; i &lt; 4; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            int newx = nx + nextP[i][0];</span><br><span class="line">            int newy = ny + nextP[i][1];</span><br><span class="line">            if(newx &gt;= row || newx &lt; 0 || newy &gt;= col || newy &lt; 0)</span><br><span class="line">            &#123;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">            if(image[newx][newy] == oldColor &amp;&amp; book[newx][newy] == 0)</span><br><span class="line">            &#123;</span><br><span class="line">                DFS(image, row, col, newx, newy, book, newColor, oldColor);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; floodFill(vector&lt;vector&lt;int&gt;&gt;&amp; image, int sr, int sc, int newColor) &#123;</span><br><span class="line">        if(image.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            return image;</span><br><span class="line">        &#125;</span><br><span class="line">        int row = image.size();</span><br><span class="line">        int col = image[0].size();</span><br><span class="line">        int oldColor = image[sr][sc];</span><br><span class="line">        vector&lt;vector&lt;int&gt;&gt; book(row, vector&lt;int&gt;(col, 0));</span><br><span class="line">        DFS(image, row, col, sr, sc, book, newColor, oldColor);</span><br><span class="line">        return image;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="例3-走迷宫"><a href="#例3-走迷宫" class="headerlink" title="例3 走迷宫"></a>例3 走迷宫</h3><p>&emsp;&emsp;牛客：<br><a href="https://www.nowcoder.com/questionTerminal/6276dbbda7094978b0e9ebb183ba37b9" target="_blank" rel="noopener">https://www.nowcoder.com/questionTerminal/6276dbbda7094978b0e9ebb183ba37b9</a></p>
<h4 id="解析-2"><a href="#解析-2" class="headerlink" title="解析"></a>解析</h4><p>&emsp;&emsp;模型：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">DFS()</span><br><span class="line">&#123;</span><br><span class="line">    //1.当前位置已走，路径长度+1，并且置为墙表示走过了</span><br><span class="line">    //2.走到终点，和最短路径长度比较取最优</span><br><span class="line">    //3.遍历四周，如果不是墙且不越界则遍历</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;但是，这种模型在一张只有极少障碍物的迷宫中要消耗很多的时间，因为我们要让每一个结点都被遍历近10次，这其中会消耗大量时间，并且很多是无用的解。因此我们在其中可以加入动态规划的思想。<br>&emsp;&emsp;模型：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">DFS()</span><br><span class="line">&#123;</span><br><span class="line">    //1.遍历四周，如果不是墙且不越界则进行二次判断</span><br><span class="line">    //2.如果本次路径到达这个位置的路径数要小于以往在表中记录的路径数，则将表中最优解进行修改，否则不再遍历此位置。</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="实现-2"><a href="#实现-2" class="headerlink" title="实现"></a>实现</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">//这类迷宫问题不能纯粹使用深度优先搜索，因为要完全遍历一遍很慢，还要加上动态规划算法（剪枝）</span><br><span class="line">//记录到达每个点上的最少步数，如果大于这个步数则不再走这个点，可以剪掉大量冗余无效的走法</span><br><span class="line">using namespace std;</span><br><span class="line">int res[10][10] = &#123; 0 &#125;;</span><br><span class="line">vector&lt;string&gt; mess(10, string(10, 0));</span><br><span class="line">int nextP[4][2] = &#123;&#123;0, 1&#125;, &#123;1, 0&#125;, &#123;0, -1&#125;, &#123;-1, 0&#125;&#125;;</span><br><span class="line">void dfs(int i, int j)</span><br><span class="line">&#123;</span><br><span class="line">    //继续向四周遍历</span><br><span class="line">    for(int m = 0; m &lt; 4; m++)</span><br><span class="line">    &#123;</span><br><span class="line">        int newi = i + nextP[m][0];</span><br><span class="line">        int newj = j + nextP[m][1];</span><br><span class="line">        if(newi &lt; 10 &amp;&amp; newi &gt;= 0 &amp;&amp; newj &lt; 10 &amp;&amp; newj &gt;= 0 &amp;&amp; mess[newi][newj] != &apos;#&apos;)</span><br><span class="line">        &#123;</span><br><span class="line">            if(res[newi][newj] == 0 || res[newi][newj] &gt; res[i][j] + 1)</span><br><span class="line">            &#123;</span><br><span class="line">                res[newi][newj] = res[i][j] + 1;</span><br><span class="line">                dfs(newi, newj);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    while(cin &gt;&gt; mess[0])</span><br><span class="line">    &#123;</span><br><span class="line">        for(int i = 1; i &lt; 10; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            cin &gt;&gt; mess[i];</span><br><span class="line">        &#125;</span><br><span class="line">        dfs(0, 1);</span><br><span class="line">        cout &lt;&lt; res[9][8] &lt;&lt; endl;</span><br><span class="line">        memset(res, 0, sizeof(res));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="广度优先搜索-BFS"><a href="#广度优先搜索-BFS" class="headerlink" title="广度优先搜索(BFS)"></a>广度优先搜索(BFS)</h2><p>&emsp;&emsp;广度优先搜索是以广度为主逐层往外一次遍历，不同于深度优先逐条解进行排列组合，广度优先搜索只会遍历一次所有结点，并且会最先拿到最优解，因此某些情况下广度优先搜索效率优于深度优先搜索。广度优先搜索在迷宫问题的解上效率会更高，在寻找最优解时会更快，因为其不需要列出所有组合的情况。<br>&emsp;&emsp;广度优先搜索在实现时需要借助队列，每一次将下一层要遍历的结点入队，上一层出队。</p>
<h3 id="例1-员工的重要性"><a href="#例1-员工的重要性" class="headerlink" title="例1 员工的重要性"></a>例1 员工的重要性</h3><p>&emsp;&emsp;力扣：<br><a href="https://leetcode-cn.com/problems/employee-importance/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/employee-importance/</a></p>
<h4 id="解析-3"><a href="#解析-3" class="headerlink" title="解析"></a>解析</h4><p>&emsp;&emsp;将要查找的第一个员工入队，之后每次遍历队中元素将其重要度相加，并且将其下属入队。</p>
<h4 id="实现-3"><a href="#实现-3" class="headerlink" title="实现"></a>实现</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">// Employee info</span><br><span class="line">class Employee &#123;</span><br><span class="line">public:</span><br><span class="line">    // It&apos;s the unique ID of each node.</span><br><span class="line">    // unique id of this employee</span><br><span class="line">    int id;</span><br><span class="line">    // the importance value of this employee</span><br><span class="line">    int importance;</span><br><span class="line">    // the id of direct subordinates</span><br><span class="line">    vector&lt;int&gt; subordinates;</span><br><span class="line">&#125;;</span><br><span class="line">*/</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int getImportance(vector&lt;Employee*&gt; employees, int id) &#123;</span><br><span class="line">        unordered_map&lt;int, Employee*&gt; info;</span><br><span class="line">        for(auto&amp; e : employees)</span><br><span class="line">        &#123;</span><br><span class="line">            info[e-&gt;id] = e;</span><br><span class="line">        &#125;</span><br><span class="line">        queue&lt;int&gt; q;</span><br><span class="line">        //将这个员工入队</span><br><span class="line">        q.push(id);</span><br><span class="line">        int ret = 0;</span><br><span class="line">        //广度优先遍历</span><br><span class="line">        while(!q.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            //依次加上队中所有员工的重要度</span><br><span class="line">            int curId = q.front();</span><br><span class="line">            q.pop();</span><br><span class="line">            ret += info[curId]-&gt;importance;</span><br><span class="line">            //将其下属入队</span><br><span class="line">            for(auto&amp; e : info[curId]-&gt;subordinates)</span><br><span class="line">            &#123;</span><br><span class="line">                q.push(e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="例2-N叉树层序遍历"><a href="#例2-N叉树层序遍历" class="headerlink" title="例2 N叉树层序遍历"></a>例2 N叉树层序遍历</h3><p>&emsp;&emsp;力扣：<br><a href="https://leetcode-cn.com/problems/n-ary-tree-level-order-traversal/submissions/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/n-ary-tree-level-order-traversal/submissions/</a></p>
<h4 id="解析-4"><a href="#解析-4" class="headerlink" title="解析"></a>解析</h4><p>&emsp;&emsp;建立队列，将根节点入队，创造循环遍历队中每个结点将其孩子入队，但这题要注意要分树的每一行进行遍历，先遍历这一行的结点将其放到结果数组中，再以此遍历下一行的结点。</p>
<h4 id="实现-4"><a href="#实现-4" class="headerlink" title="实现"></a>实现</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">// Definition for a Node.</span><br><span class="line">class Node &#123;</span><br><span class="line">public:</span><br><span class="line">    int val;</span><br><span class="line">    vector&lt;Node*&gt; children;</span><br><span class="line"></span><br><span class="line">    Node() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    Node(int _val, vector&lt;Node*&gt; _children) &#123;</span><br><span class="line">        val = _val;</span><br><span class="line">        children = _children;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">*/</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; levelOrder(Node* root) &#123;</span><br><span class="line">        //创造队列</span><br><span class="line">        queue&lt;Node*&gt; q;</span><br><span class="line">        vector&lt;vector&lt;int&gt;&gt; treeVec;</span><br><span class="line">        if(root == nullptr)</span><br><span class="line">        &#123;</span><br><span class="line">            return treeVec;</span><br><span class="line">        &#125;</span><br><span class="line">        //放入根结点</span><br><span class="line">        q.push(root);</span><br><span class="line">        //遍历队中结点</span><br><span class="line">        while(!q.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            //得到这一行的长度</span><br><span class="line">            int sz = q.size();</span><br><span class="line">            vector&lt;int&gt; rowNode;</span><br><span class="line">            //遍历这一行</span><br><span class="line">            while(sz--)</span><br><span class="line">            &#123;</span><br><span class="line">                Node* curNode = q.front();</span><br><span class="line">                q.pop();</span><br><span class="line">                //将这一行结点的值放到rowNode中</span><br><span class="line">                rowNode.push_back(curNode-&gt;val);</span><br><span class="line">                //将这一行中每个结点的孩子入队</span><br><span class="line">                for(auto&amp; chd : curNode-&gt;children)</span><br><span class="line">                &#123;</span><br><span class="line">                    q.push(chd);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            treeVec.push_back(rowNode);</span><br><span class="line">        &#125;</span><br><span class="line">        return treeVec;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="例3-腐烂的橘子"><a href="#例3-腐烂的橘子" class="headerlink" title="例3 腐烂的橘子"></a>例3 腐烂的橘子</h3><p>&emsp;&emsp;力扣：<br><a href="https://leetcode-cn.com/problems/rotting-oranges/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/rotting-oranges/</a></p>
<h4 id="解析-5"><a href="#解析-5" class="headerlink" title="解析"></a>解析</h4><p>&emsp;&emsp;类似于N叉树的遍历。每一分钟腐烂一层，遍历每一层即可，最后搜索结束后判断是否还有新鲜橘子。</p>
<h4 id="实现-5"><a href="#实现-5" class="headerlink" title="实现"></a>实现</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">int nextP[4][2] = &#123;&#123;0, 1&#125;, &#123;1, 0&#125;, &#123;-1, 0&#125;, &#123;0, -1&#125;&#125;;</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int orangesRotting(vector&lt;vector&lt;int&gt;&gt;&amp; grid) &#123;</span><br><span class="line">        queue&lt;pair&lt;int, int&gt;&gt; q;</span><br><span class="line">        int row = grid.size();</span><br><span class="line">        int col = grid[0].size();</span><br><span class="line">        //找出第一批已经坏掉的橘子，入队</span><br><span class="line">        for(int i = 0; i &lt; row; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            for(int j = 0; j &lt; col; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                if(grid[i][j] == 2)</span><br><span class="line">                &#123;</span><br><span class="line">                    q.push(make_pair(i, j));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        //初始状态</span><br><span class="line">        int minRet = 0;</span><br><span class="line">        while(!q.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            //跟N叉树遍历一样，这里遍历一层代表要消耗一分钟</span><br><span class="line">            int flag = 0;</span><br><span class="line">            int sz = q.size();</span><br><span class="line">            //遍历这一层</span><br><span class="line">            while(sz--)</span><br><span class="line">            &#123;</span><br><span class="line">                pair&lt;int, int&gt; curPos = q.front();</span><br><span class="line">                q.pop();</span><br><span class="line">                for(int i = 0; i &lt; 4; i++)</span><br><span class="line">                &#123;</span><br><span class="line">                    int nx = curPos.first + nextP[i][0];</span><br><span class="line">                    int ny = curPos.second + nextP[i][1];</span><br><span class="line">                    if(nx &gt;= row || nx &lt; 0 || ny &gt;= col || ny &lt; 0)</span><br><span class="line">                    &#123;</span><br><span class="line">                        continue;</span><br><span class="line">                    &#125;</span><br><span class="line">                    if(grid[nx][ny] == 1)</span><br><span class="line">                    &#123;</span><br><span class="line">                        flag = 1;</span><br><span class="line">                        grid[nx][ny] = 2;</span><br><span class="line">                        q.push(make_pair(nx, ny));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            if(flag)</span><br><span class="line">            &#123;</span><br><span class="line">                ++minRet;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        for(int i = 0; i &lt; row; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            for(int j = 0; j &lt; col; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                if(grid[i][j] == 1)</span><br><span class="line">                &#123;</span><br><span class="line">                    return -1;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return minRet;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
          
        
      
    </div>
    
    
    

    

    <div>
    
    </div>

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/07/24/【Cpp】第六章-STL-vector类/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="MisakiFx">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/blog-logo.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Misaki`s blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/07/24/【Cpp】第六章-STL-vector类/" itemprop="url">【Cpp】第六章-STL_vector类</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-07-24T22:32:14+08:00">
                2019-07-24
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Cpp/" itemprop="url" rel="index">
                    <span itemprop="name">Cpp</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  1.7k
                </span>
              

              

              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="vector类"><a href="#vector类" class="headerlink" title="vector类"></a>vector类</h1><h2 id="基础介绍"><a href="#基础介绍" class="headerlink" title="基础介绍"></a>基础介绍</h2><p>&emsp;&emsp;vector类是STL中另一大容器，它十分类似于一个顺序表，不过经过封装它已经变成了一个可变长度并且拥有各种功能的顺序表，在其内部我们可以通过利用数组进行实现。vector是很常用的容器，因为它支持随机访问，并且尾插和尾删拥有O1的时间复杂度。但是在中间插入时要更高的时间复杂度，最差情况下需要遍历整个数组才能进行插入。它与string的物理与逻辑结构上十分相似，不过它是一个模板类，我们可以在其中存放任意类型的数据。</p>
<h2 id="常用接口"><a href="#常用接口" class="headerlink" title="常用接口"></a>常用接口</h2><h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">vector();                                                  //无参构造</span><br><span class="line">vector(size_type n, const value_type &amp;val = value_type()); //构造并初始化n个val</span><br><span class="line">vector(const vector &amp;x);                                   //拷贝构造</span><br><span class="line">vector(InputIterator first, InputIterator last);           //使用迭代器进行初始化构造</span><br></pre></td></tr></table></figure>
<h3 id="容量相关"><a href="#容量相关" class="headerlink" title="容量相关"></a>容量相关</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">size();     //获取数据个数</span><br><span class="line">capacity(); //获取容量大小</span><br><span class="line">empty();    //判断是否为空</span><br><span class="line">void resize(size_type n, value_type val = value_type());//改变空间大小，如果大于原有空间用val填充</span><br><span class="line">改变vector的size void reserve(size_type n); //改变vector放入capacity</span><br></pre></td></tr></table></figure>
<h3 id="增删查改"><a href="#增删查改" class="headerlink" title="增删查改"></a>增删查改</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">void push_back(const value_type &amp;val);                     //尾插</span><br><span class="line">void pop_back();                                           //尾删</span><br><span class="line">iterator insert(iterator position, constvalue_type &amp; val); //在position之前插入val</span><br><span class="line">iterator erase(iterator position);                         //删除position位置的数据</span><br><span class="line">void swap(vector &amp; x);                                     //交换两个vector的数据空间</span><br><span class="line">reference operator[](size_type n);                         //像数组一样访问</span><br></pre></td></tr></table></figure>
<h3 id="迭代器相关"><a href="#迭代器相关" class="headerlink" title="迭代器相关"></a>迭代器相关</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">begin();  //获取第一个数据位置的iterator</span><br><span class="line">end();    //获取最后一个数据的下一个位置的iterator</span><br><span class="line">rbegin(); //获取最后一个数据位置的reverse_iterator</span><br><span class="line">rend();   //获取第一个数据前一个位置的reverse_iterator</span><br><span class="line">cbegin(); //获取第一个数据位置的const_iterator</span><br><span class="line">cend();   //获取最后一个数据的下一个位置的const_iterator</span><br></pre></td></tr></table></figure>
<h2 id="迭代器失效问题"><a href="#迭代器失效问题" class="headerlink" title="迭代器失效问题"></a>迭代器失效问题</h2><p>&emsp;&emsp;在容器使用中我们经常会要操作迭代器，很多容器接口中也有提供使用迭代器进行增加删除修改的操作。但是迭代器本身是一个指针，在我们使用接口进行增加或是删除的时候这个迭代器的指向的内容会发生改变甚至是指向非法内存，原因是原来的内存已经被释放，称之为<strong>迭代器失效</strong>，迭代器失效会导致指向内容改变，从而引起bug甚至是内存越界访问导致程序崩溃。</p>
<h3 id="常见场景"><a href="#常见场景" class="headerlink" title="常见场景"></a>常见场景</h3><p>&emsp;&emsp;最为常见的是<code>erase</code>和<code>insert</code>导致的迭代器失效。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int a[] = &#123;1, 2, 3, 4&#125;;</span><br><span class="line">    vector&lt;int&gt; v(a, a + sizeof(a) / sizeof(int));</span><br><span class="line">    vector&lt;int&gt;::iterator it = v.begin();</span><br><span class="line">    while (it != v.end())</span><br><span class="line">    &#123;</span><br><span class="line">        if (*it % 2 == 0)</span><br><span class="line">            v.erase(it);</span><br><span class="line">        ++it;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;以上这段程序就会引起迭代器失效，在删除最后一个元素是甚至导致内存越界访问，程序崩溃。因此可以总结在<strong>利用迭代器删除元素后，删除位置及其之后的所有迭代器都会失效</strong>，原因是，之后的所有元素都会前移，之前的迭代器所指向的内容都会发生改变，甚至是指向非法内存。<br>&emsp;&emsp;同理我们在<code>insert</code>之后由于删除位置及其以后的元素会后移进行变动，因此<strong>插入位置及其之后所有的迭代器也都会失效</strong>，并且如果有扩容发生还可能发生内存越界访问。<br>&emsp;&emsp;对于迭代器失效我们要如何避免呢？我们注意看<code>erase</code>的接口可以发现<code>erase</code>返回的是一个迭代器。说明：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">An iterator pointing to the new location of the element that followed the last element erased by the function call. </span><br><span class="line">This is the container end if the operation erased the last element in the sequence.</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;它的返回值是返回在删除位置之后紧接着它的元素的迭代器，这个迭代器保证是有效的，<code>insert</code>的返回值也是一个迭代器，并且是插入位置插入后的元素的迭代器，因此它们的返回值都是保证有效的，所以我们的代码可以改成以下这样就可以避免迭代器失效。</p>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>&emsp;&emsp;我们模拟实现一个Vector类，并且实现常用接口，让其达到和vector相同的功能。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br></pre></td><td class="code"><pre><span class="line">#pragma once</span><br><span class="line">#include &lt;assert.h&gt;</span><br><span class="line">#include &lt;memory.h&gt;</span><br><span class="line">template &lt;class T&gt;</span><br><span class="line">class Vector</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    typedef T* iterator;</span><br><span class="line">    typedef const T* const_iterator;</span><br><span class="line">    //构造函数</span><br><span class="line">    Vector()</span><br><span class="line">        :_start(nullptr)</span><br><span class="line">        ,_finish(nullptr)</span><br><span class="line">        ,_endOfStorge(nullptr)</span><br><span class="line">    &#123;&#125;        </span><br><span class="line">    Vector(size_t n, T val)</span><br><span class="line">        :_start(nullptr)</span><br><span class="line">        ,_finish(nullptr)</span><br><span class="line">        ,_endOfStorge(nullptr)</span><br><span class="line">    &#123;</span><br><span class="line">        Reserve(n);</span><br><span class="line">        for(int i = 0; i &lt; n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            *_finish = val;</span><br><span class="line">            _finish++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    //拷贝构造</span><br><span class="line">    Vector(const Vector&lt;T&gt;&amp; vec)</span><br><span class="line">        :_start(nullptr)</span><br><span class="line">        ,_finish(nullptr)</span><br><span class="line">        ,_endOfStorge(nullptr)</span><br><span class="line">    &#123;</span><br><span class="line">        Resize(vec.Size());</span><br><span class="line">        memcpy(_start, vec._start, vec.Size() * sizeof(T));</span><br><span class="line">        _finish = _start + vec.Size();</span><br><span class="line">    &#125;</span><br><span class="line">    //operator=重载</span><br><span class="line">    Vector&amp; operator=(Vector&lt;T&gt; vec)</span><br><span class="line">    &#123;</span><br><span class="line">        Swap(vec);</span><br><span class="line">        return *this;</span><br><span class="line">    &#125;</span><br><span class="line">    //交换</span><br><span class="line">    void Swap(Vector&lt;T&gt;&amp; vec)</span><br><span class="line">    &#123;</span><br><span class="line">        std::swap(_start, vec._start);</span><br><span class="line">        std::swap(_finish, vec._finish);</span><br><span class="line">        std::swap(_endOfStorge, vec._endOfStorge);</span><br><span class="line">    &#125;</span><br><span class="line">    //析构函数</span><br><span class="line">    ~Vector()</span><br><span class="line">    &#123;</span><br><span class="line">        delete[] _start;</span><br><span class="line">        _start = nullptr;</span><br><span class="line">        _finish = nullptr;</span><br><span class="line">        _endOfStorge = nullptr;</span><br><span class="line">    &#125;</span><br><span class="line">    //迭代器相关</span><br><span class="line">    iterator begin()</span><br><span class="line">    &#123;</span><br><span class="line">        return _start;</span><br><span class="line">    &#125;</span><br><span class="line">    iterator end()</span><br><span class="line">    &#123;</span><br><span class="line">        return _finish;</span><br><span class="line">    &#125;</span><br><span class="line">    const_iterator begin() const</span><br><span class="line">    &#123;</span><br><span class="line">        return _start;</span><br><span class="line">    &#125;</span><br><span class="line">    const_iterator end() const</span><br><span class="line">    &#123;</span><br><span class="line">        return _finish;</span><br><span class="line">    &#125;</span><br><span class="line">    //插入</span><br><span class="line">    iterator Insert(iterator pos, const T&amp; val)</span><br><span class="line">    &#123;</span><br><span class="line">        assert(pos &gt;= _start &amp;&amp; pos &lt;= _finish);</span><br><span class="line">        //扩容，扩容会导致pos要重新指定位置，因为内存地址变更</span><br><span class="line">        if(_finish == _endOfStorge)</span><br><span class="line">        &#123;</span><br><span class="line">            size_t n = pos - _start;</span><br><span class="line">            size_t size = Capacity() == 0 ? 4 : 2 * Capacity();</span><br><span class="line">            Reserve(size);</span><br><span class="line">            pos = _start + n;</span><br><span class="line">        &#125;</span><br><span class="line">        iterator it = _finish;</span><br><span class="line">        while(it != pos)</span><br><span class="line">        &#123;</span><br><span class="line">            *it = *(it - 1);</span><br><span class="line">            it--;</span><br><span class="line">        &#125;</span><br><span class="line">        *pos = val;</span><br><span class="line">        _finish++;</span><br><span class="line">        return pos;</span><br><span class="line">    &#125;</span><br><span class="line">    //删除</span><br><span class="line">    iterator Erase(iterator pos)</span><br><span class="line">    &#123;</span><br><span class="line">        assert(pos &gt;= _start &amp;&amp; pos &lt;= _finish);</span><br><span class="line">        iterator it = pos + 1;</span><br><span class="line">        while(it != _finish)</span><br><span class="line">        &#123;</span><br><span class="line">            *(it - 1) = *it;</span><br><span class="line">            it++;</span><br><span class="line">        &#125;</span><br><span class="line">        _finish--;</span><br><span class="line">        return pos;</span><br><span class="line">    &#125;</span><br><span class="line">    //尾插</span><br><span class="line">    void Push_back(const T&amp; val)</span><br><span class="line">    &#123;</span><br><span class="line">        //扩容</span><br><span class="line">        if(_endOfStorge == _finish)</span><br><span class="line">        &#123;</span><br><span class="line">            size_t capacity = Capacity() == 0 ? 4 : 2 * Capacity();</span><br><span class="line">            Reserve(capacity);</span><br><span class="line">        &#125;</span><br><span class="line">        *_finish = val;</span><br><span class="line">        _finish++;</span><br><span class="line">    &#125;</span><br><span class="line">    //尾删</span><br><span class="line">    void Pop_back()</span><br><span class="line">    &#123;</span><br><span class="line">        assert(_finish &gt; _start);</span><br><span class="line">        _finish--;</span><br><span class="line">    &#125;</span><br><span class="line">    //operator[]重载</span><br><span class="line">    T&amp; operator[](size_t pos)</span><br><span class="line">    &#123;</span><br><span class="line">        return _start[pos];</span><br><span class="line">    &#125;</span><br><span class="line">    const T&amp; operator[](size_t pos) const</span><br><span class="line">    &#123;</span><br><span class="line">        return _start[pos];</span><br><span class="line">    &#125;</span><br><span class="line">    //长度</span><br><span class="line">    size_t Size() const</span><br><span class="line">    &#123;</span><br><span class="line">        return _finish - _start;</span><br><span class="line">    &#125;</span><br><span class="line">    //容量</span><br><span class="line">    size_t Capacity() const</span><br><span class="line">    &#123;</span><br><span class="line">        return _endOfStorge - _start;</span><br><span class="line">    &#125;</span><br><span class="line">    //重新给容量</span><br><span class="line">    void Reserve(size_t capacity)</span><br><span class="line">    &#123;</span><br><span class="line">        if(capacity &gt; Capacity())</span><br><span class="line">        &#123;</span><br><span class="line">            size_t size = Size();</span><br><span class="line">            //分配新的内存空间</span><br><span class="line">            T* newArr = new T[capacity];</span><br><span class="line">            if(_start)</span><br><span class="line">            &#123;</span><br><span class="line">                memcpy(newArr, _start, size * sizeof(T));</span><br><span class="line">            &#125;</span><br><span class="line">            //销毁原有内存空间</span><br><span class="line">            delete[] _start;</span><br><span class="line">            //注意这里更新三个指针都要进行更新，因为三个指针都还指向原来的内存空间</span><br><span class="line">            _start = newArr;</span><br><span class="line">            _finish = _start + size;</span><br><span class="line">            _endOfStorge = _start + capacity;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    //重新给长度,空白部分val填充</span><br><span class="line">    void Resize(size_t size, T val = T())</span><br><span class="line">    &#123;</span><br><span class="line">        Reserve(size);</span><br><span class="line">        if(Size() &lt; size)</span><br><span class="line">        &#123;</span><br><span class="line">            T* ptr = _finish;</span><br><span class="line">            while(ptr != _start + size)</span><br><span class="line">            &#123;</span><br><span class="line">                *ptr = val;</span><br><span class="line">                ptr++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        _finish = _start + size;</span><br><span class="line">    &#125;</span><br><span class="line">private:</span><br><span class="line">    //vecotor的实现与string有所不同</span><br><span class="line">    //其底层使用三个迭代器（指针）用来标记头部，尾部和总容量尾部</span><br><span class="line">    iterator _start;</span><br><span class="line">    iterator _finish;</span><br><span class="line">    iterator _endOfStorge;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>

          
        
      
    </div>
    
    
    

    

    <div>
    
    </div>

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/07/22/【Cpp】第五章-STL-string类/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="MisakiFx">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/blog-logo.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Misaki`s blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/07/22/【Cpp】第五章-STL-string类/" itemprop="url">【Cpp】第五章-STL_string类</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-07-22T20:51:53+08:00">
                2019-07-22
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Cpp/" itemprop="url" rel="index">
                    <span itemprop="name">Cpp</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  2.9k
                </span>
              

              

              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="string类"><a href="#string类" class="headerlink" title="string类"></a>string类</h1><h2 id="STL"><a href="#STL" class="headerlink" title="STL"></a>STL</h2><p>&emsp;&emsp;<strong>STL</strong>是<code>Standard Template Library</code>的简称，中文名为是<strong>标准模板库</strong>，在Cpp中模板是构成泛型编程的基础，我们利用模板可以极大程度地提高我们的代码复用率，但是如果模板要我们现写也有点过于繁琐，不过好在Cpp中为我们写代码方便为我们制作了一套标准地模板库，供我们直接使用十分方便。</p>
<h3 id="STL的版本"><a href="#STL的版本" class="headerlink" title="STL的版本"></a>STL的版本</h3><p>&emsp;&emsp;STL发展至今也不是一气呵成的，随着发展和进化，STL一共出现了四大版本。</p>
<h4 id="HP版本"><a href="#HP版本" class="headerlink" title="HP版本"></a>HP版本</h4><p>&emsp;&emsp;这个版本是STL的原始版本，由Alexander Stepanov、Meng Lee在惠普实验室完成，是所有STL版本的始祖。并且此版本秉承开源精神，允许任何人免费运用，拷贝，商用，传播，修改这些代码，唯一的条件也只是要求需要像原始版本一样开源使用。</p>
<h4 id="P-J-版本"><a href="#P-J-版本" class="headerlink" title="P.J.版本"></a>P.J.版本</h4><p>&emsp;&emsp;这个版本由P. J. Plauger开发，继承自HP版本，被Windows Visual C++采用，不可公开或修改，可读性较差。</p>
<h4 id="RW版本"><a href="#RW版本" class="headerlink" title="RW版本"></a>RW版本</h4><p>&emsp;&emsp;这个版本由Rouge Wage公司开发，继承自HP版本，被C++ Builder采用，不能公开或修改，可读性一般。</p>
<h4 id="SGI版本"><a href="#SGI版本" class="headerlink" title="SGI版本"></a>SGI版本</h4><p>&emsp;&emsp;这个版本由Silicon Graphics Computer Systems，Inc公司开发，继承自HP版本，被GCC采用，可移植性较好，可公开，修改，贩卖，可读性很高。也是我们学习主要参考的版本。</p>
<h3 id="STL六大组件"><a href="#STL六大组件" class="headerlink" title="STL六大组件"></a>STL六大组件</h3><p>&emsp;&emsp;STL中包含六大组件，他们共同组成STL互相协同工作。</p>
<h4 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h4><p>&emsp;&emsp;<code>string, vector, list, deque, map, set, multimap, multiset</code>。</p>
<h4 id="配接器"><a href="#配接器" class="headerlink" title="配接器"></a>配接器</h4><p>&emsp;&emsp;<code>stack, queue, priority_queue</code></p>
<h4 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h4><p>&emsp;&emsp;<code>find, swap, reverse, sort, merge...</code></p>
<h4 id="空间适配器"><a href="#空间适配器" class="headerlink" title="空间适配器"></a>空间适配器</h4><p>&emsp;&emsp;<code>allocator</code></p>
<h4 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h4><p>&emsp;&emsp;<code>iterator, const_iterator, reverse_iterator, const_reverse_iterator</code></p>
<h4 id="仿函数"><a href="#仿函数" class="headerlink" title="仿函数"></a>仿函数</h4><p>&emsp;&emsp;<code>greater, less...</code><br><br>&emsp;&emsp;STL在日常编程中无论是笔试还是项目都十分常用，必须多用多练，并且自己实现一遍才能熟练掌握。STL(包扩Cpp绝大部分库)学习可分为三个层次：<br><br>&emsp;&emsp;1、熟用STL<br>&emsp;&emsp;2、了解泛型技术d的内涵与STL的学理乃至实作<br>&emsp;&emsp;3、扩充STL<br>&emsp;&emsp;总结就是能用，明理，能扩展。</p>
<h2 id="string类-1"><a href="#string类-1" class="headerlink" title="string类"></a>string类</h2><p>&emsp;&emsp;<code>string</code>类时STL中专门用于字符串处理的容器。在C语言中我们利用字符数组或字符指针来构成字符串，所有字符串使用十分不方便，库中为字符串提供的接口也并不便于使用，于是在Cpp中有了<code>string</code>模板类，这个容器可以帮助我们更加方便的使用字符串，并且帮助我们封装了很多字符串相关的常用接口。</p>
<h3 id="常用接口"><a href="#常用接口" class="headerlink" title="常用接口"></a>常用接口</h3><h4 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h4><p>&emsp;&emsp;<code>string</code>中提供了各种构造函数帮助我们构造字符串。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">string(); //构造空的string类对象，即空字符串</span><br><span class="line">string(const char *s);// 用C-string来构造string类对象</span><br><span class="line">string(size_t n, char c);//string类对象中包含n个字符c</span><br><span class="line">string(const string &amp;s);//拷贝构造函数</span><br><span class="line">string(const string &amp;s, size_t n);//用s中的前n个字符构造新的string类对象 return 0;</span><br></pre></td></tr></table></figure></p>
<h4 id="容量相关接口"><a href="#容量相关接口" class="headerlink" title="容量相关接口"></a>容量相关接口</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">size_t size() const;			  // 返回字符串有效字符长度</span><br><span class="line">size_t length() const;			  // 返回字符串有效字符长度</span><br><span class="line">size_t capacity() const;		  // 返回空间总大小</span><br><span class="line">bool empty() const;				  // 检测字符串释放为空串，是返回true，否则返回false</span><br><span class="line">void clear();					  //清空有效字符</span><br><span class="line">void resize(size_t n, char c);	// 将有效字符的个数该成n个，多出的空间用字符c填充</span><br><span class="line">void resize(size_t n);			  // 将有效字符的个数改成n个，多出的空间用0填充</span><br><span class="line">void reserve(size_t res_arg = 0); // 为字符串预留空间</span><br></pre></td></tr></table></figure>
<h4 id="访问相关接口"><a href="#访问相关接口" class="headerlink" title="访问相关接口"></a>访问相关接口</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">char&amp; operator[] (size_t pos); 	  	    //返回pos位置的字符,非const string类对象调用</span><br><span class="line">const char&amp; operator[] (size_t pos);	//const返回pos位置的字符，const string类对象调用</span><br></pre></td></tr></table></figure>
<h4 id="修改相关接口"><a href="#修改相关接口" class="headerlink" title="修改相关接口"></a>修改相关接口</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">void push_back(char c);							//在字符串后尾插字符c</span><br><span class="line">string&amp; append (const char* s); 				//在字符串后追加一个字符串</span><br><span class="line">string&amp; operator+=(const string&amp; str);			//在字符串后追加字符串str</span><br><span class="line">string&amp; operator+=(const char* s);				//在字符串后追加字符串</span><br><span class="line">string&amp; operator+=(char c);						//在字符串后追加字符c</span><br><span class="line">const char* c_str()const;						//返回C格式字符串</span><br><span class="line">size_t find (char c, size_t pos = 0) const;		//从字符串pos位置开始往后找字符c，返回该字符在字符串中的位置</span><br><span class="line">size_t rfind(char c, size_t pos = npos);		//从字符串pos位置开始往前找字符c，返回该字符在字符串中的位置</span><br><span class="line">string substr(size_t pos = 0, size_t n= npos); 	//const在str中从pos位置开始，截取n个字符，然后将其返回</span><br><span class="line">string&amp; erase (size_t pos = 0, size_t len = npos); //从pos位置起删除串中npos个字符</span><br></pre></td></tr></table></figure>
<h4 id="迭代器相关"><a href="#迭代器相关" class="headerlink" title="迭代器相关"></a>迭代器相关</h4><p>&emsp;&emsp;迭代器十分类似于指针，我们可以将其等同于一个自定义类型的指针，用它我们可以完成容器内的遍历，增加，删除等操作，STL中容器的很多功能也为迭代器设计了很多接口，其中最为常用的还是取到一个容器的迭代器。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">iterator begin();					//取到头部迭代器</span><br><span class="line">const_iterator begin() const;		//取到头部常迭代器</span><br><span class="line">iterator end();						//取到尾部迭代器</span><br><span class="line">const_iterator end() const;			//取到尾部常迭代器</span><br></pre></td></tr></table></figure></p>
<h4 id="其他接口"><a href="#其他接口" class="headerlink" title="其他接口"></a>其他接口</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">string operator+ (const string&amp; lhs, const string&amp; rhs); 	//在lhs串后拼接rhs串</span><br><span class="line">istream&amp; operator&gt;&gt; (istream&amp; is, string&amp; str);				//输入运算符重载</span><br><span class="line">istream&amp; getline (istream&amp; is, string&amp; str);				//获取一行字符串</span><br><span class="line">relational operators 										//大小比较</span><br></pre></td></tr></table></figure>
<h4 id="综合运用"><a href="#综合运用" class="headerlink" title="综合运用"></a>综合运用</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	string str = &quot;123456&quot;;//单参构造的隐式类型转换 + 拷贝构造</span><br><span class="line">	for(int i = 0; i &lt; str.size(); i++)//size()取出长度</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; str[i] &lt;&lt; &quot; &quot;;//operator[]重载的运用</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">	str.append(&quot;abc&quot;);//append()接口</span><br><span class="line">	str.push_back(&apos;d&apos;);//push_back接口使用</span><br><span class="line">	str += &quot;efg&quot;;//operator += 重载使用</span><br><span class="line">	//迭代器的应用</span><br><span class="line">	string::iterator it = str.begin();</span><br><span class="line">	while(it != str.end())</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; * it &lt;&lt; &quot; &quot;;</span><br><span class="line">		it++;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1 2 3 4 5 6</span><br><span class="line">1 2 3 4 5 6 a b c d e f g</span><br></pre></td></tr></table></figure>
<h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>&emsp;&emsp;学习STL要熟用，明理，能扩展，那么第二部明理我们就要自己实现封装一个<code>string</code>类。根据库中<code>string</code>常用接口我们也实现其基本功能。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;assert.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">class String</span><br><span class="line">&#123;</span><br><span class="line">    friend std::ostream &amp;operator&lt;&lt;(std::ostream &amp;os, String str);</span><br><span class="line">public:</span><br><span class="line">    //迭代器</span><br><span class="line">    typedef char* iterator;</span><br><span class="line">    typedef const char* const_iterator;</span><br><span class="line">    iterator begin()</span><br><span class="line">    &#123;</span><br><span class="line">        return _str;</span><br><span class="line">    &#125;</span><br><span class="line">    const_iterator begin() const</span><br><span class="line">    &#123;</span><br><span class="line">        return _str;</span><br><span class="line">    &#125;</span><br><span class="line">    iterator end()</span><br><span class="line">    &#123;</span><br><span class="line">        return _str+_size;</span><br><span class="line">    &#125;</span><br><span class="line">    const_iterator end() const</span><br><span class="line">    &#123;</span><br><span class="line">        return _str+_size;</span><br><span class="line">    &#125;</span><br><span class="line">    static size_t npos;</span><br><span class="line">    //构造函数</span><br><span class="line">    String(const char* str = &quot;&quot;)//要进行深拷贝</span><br><span class="line">        :_str(nullptr)</span><br><span class="line">        ,_capacity(0)</span><br><span class="line">    &#123;</span><br><span class="line">        _size = strlen(str);</span><br><span class="line">        //重新给容量Reserve()</span><br><span class="line">        Reserve(_size);</span><br><span class="line">        //strcpy()拷贝给成员变量</span><br><span class="line">        strcpy(_str, str);</span><br><span class="line">    &#125;</span><br><span class="line">    //拷贝构造，要使用深拷贝</span><br><span class="line">    //所谓深拷贝就是创立独立的内存空间并将目标对象中的值拷贝过来</span><br><span class="line">    //而不是单纯的让指针等于目标拷贝对象中的指针</span><br><span class="line">    //注意：拷贝构造和operator=重载都是不拷贝容量大小的</span><br><span class="line">    //传统写法：创建新的独立内存，销毁原来的内存空间，更新_size, _capacity的值</span><br><span class="line">    //String(const String&amp; str)</span><br><span class="line">    //    :_str(nullptr)</span><br><span class="line">    //    ,_size(0)</span><br><span class="line">    //    ,_capacity(0)</span><br><span class="line">    //&#123;</span><br><span class="line">    //    Resize(str.Size());</span><br><span class="line">    //    strcpy(_str, str._str);</span><br><span class="line">    //&#125;</span><br><span class="line">    ////operator=重载和拷贝构造类似，先用传统写法实现</span><br><span class="line">    //String&amp; operator=(const String&amp; str)</span><br><span class="line">    //&#123;</span><br><span class="line">    //    if(this != &amp;str)</span><br><span class="line">    //    &#123;</span><br><span class="line">    //        Resize(str.Size());</span><br><span class="line">    //        strcpy(_str, str._str);</span><br><span class="line">    //    &#125;</span><br><span class="line">    //&#125;</span><br><span class="line">    //现代写法，另外创建对象让其等于要拷贝的对象，交换两个对象即可</span><br><span class="line">    String(const String&amp; str)</span><br><span class="line">        :_str(nullptr)</span><br><span class="line">        ,_size(0)</span><br><span class="line">        ,_capacity(0)</span><br><span class="line">    &#123;</span><br><span class="line">        String temp(str._str);</span><br><span class="line">        Swap(temp);</span><br><span class="line">    &#125;</span><br><span class="line">    //现代写法，利用拷贝构造函数创建临时对象，交换两个对象，临时对象在函数结束时也会自动释放</span><br><span class="line">    String&amp; operator=(String str)</span><br><span class="line">    &#123;</span><br><span class="line">        Swap(str);</span><br><span class="line">    &#125;</span><br><span class="line">    //交换两个字符串，浅拷贝，不另申请内存空间</span><br><span class="line">    void Swap(String&amp; str)</span><br><span class="line">    &#123;</span><br><span class="line">        std::swap(_str, str._str);</span><br><span class="line">        std::swap(_size, str._size);</span><br><span class="line">        std::swap(_capacity, str._capacity);</span><br><span class="line">    &#125;</span><br><span class="line">    //析构函数</span><br><span class="line">    ~String()</span><br><span class="line">    &#123;</span><br><span class="line">        if(_str)</span><br><span class="line">        &#123;</span><br><span class="line">            delete[] _str;</span><br><span class="line">            _str = nullptr;</span><br><span class="line">            _size = _capacity = 0;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    //返回_size</span><br><span class="line">    size_t Size() const</span><br><span class="line">    &#123;</span><br><span class="line">        return _size;</span><br><span class="line">    &#125;</span><br><span class="line">    //返回_capacity</span><br><span class="line">    size_t Capacity() const</span><br><span class="line">    &#123;</span><br><span class="line">        return _capacity;</span><br><span class="line">    &#125;</span><br><span class="line">    //在某个下标插入一个字符</span><br><span class="line">    void Insert(size_t pos, char ch)</span><br><span class="line">    &#123;</span><br><span class="line">        assert(pos &lt;= _size);</span><br><span class="line">        //容量满了，扩容</span><br><span class="line">        if(_size == _capacity)</span><br><span class="line">        &#123;</span><br><span class="line">            Reserve(2 * _capacity);</span><br><span class="line">        &#125;</span><br><span class="line">        for(int i = _size; i &gt; pos; i--)</span><br><span class="line">        &#123;</span><br><span class="line">            _str[i] = _str[i - 1];</span><br><span class="line">        &#125;</span><br><span class="line">        _str[pos] = ch;</span><br><span class="line">        _size++;</span><br><span class="line">        _str[_size] = &apos;\0&apos;;</span><br><span class="line">    &#125;</span><br><span class="line">    //在某个下标处插入一个字符串</span><br><span class="line">    void Insert(size_t pos, const char* str)</span><br><span class="line">    &#123;</span><br><span class="line">        assert(pos &lt;= _size);</span><br><span class="line">        int len = strlen(str);</span><br><span class="line">        //容量不够扩容</span><br><span class="line">        if(_size + len &gt; _capacity)</span><br><span class="line">        &#123;</span><br><span class="line">            Reserve(len + _size);</span><br><span class="line">        &#125;</span><br><span class="line">        for(int i = len + _size - 1; i &gt; pos + len - 1; i--)</span><br><span class="line">        &#123;</span><br><span class="line">            _str[i] = _str[i - len];        </span><br><span class="line">        &#125;</span><br><span class="line">        for(int i = pos; i &lt; pos + len; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            _str[i] = str[i - pos];</span><br><span class="line">        &#125;</span><br><span class="line">        _size += len;</span><br><span class="line">    &#125;</span><br><span class="line">    //+=运算符重载</span><br><span class="line">    String&amp; operator+=(char ch)</span><br><span class="line">    &#123;</span><br><span class="line">        Push_back(ch);</span><br><span class="line">    &#125;</span><br><span class="line">    String&amp; operator+=(const char* str)</span><br><span class="line">    &#123;</span><br><span class="line">        Append(str);</span><br><span class="line">    &#125;</span><br><span class="line">    //删除pos下标开始的npos个字符</span><br><span class="line">    void Erase(size_t pos, size_t npos)</span><br><span class="line">    &#123;</span><br><span class="line">        assert(pos &lt; _size);</span><br><span class="line">        for(int i = pos; i &lt; _size - npos; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            _str[i] = _str[i + npos];</span><br><span class="line">        &#125;</span><br><span class="line">        _size -= npos;</span><br><span class="line">        _str[_size] = &apos;\0&apos;;</span><br><span class="line">    &#125;</span><br><span class="line">    //从pos开始找第一个字符为ch返回其下标</span><br><span class="line">    size_t Find(const char ch, size_t pos = 0)</span><br><span class="line">    &#123;</span><br><span class="line">        assert(pos &lt; _size);</span><br><span class="line">        for(size_t i = pos; i &lt; _size; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            if(_str[i] == ch)</span><br><span class="line">            &#123;</span><br><span class="line">                return i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return npos;</span><br><span class="line">    &#125;</span><br><span class="line">    //从pos开始找第一个子串为str返回其下标</span><br><span class="line">    size_t Find(const char* str, size_t pos = 0)</span><br><span class="line">    &#123;</span><br><span class="line">        assert(pos &lt; _size);</span><br><span class="line">        for(size_t i = pos; i &lt; _size; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            if(_str[i] == str[0])</span><br><span class="line">            &#123;</span><br><span class="line">                int j = i;</span><br><span class="line">                while (j &lt; i + strlen(str) &amp;&amp; _str[j] != &apos;\0&apos;)</span><br><span class="line">                &#123;</span><br><span class="line">                    if (_str[j] != str[j - i])</span><br><span class="line">                    &#123;</span><br><span class="line">                        break;</span><br><span class="line">                    &#125;</span><br><span class="line">                    j++;</span><br><span class="line">                &#125;</span><br><span class="line">                //子串遍历完毕,子串与要查找的串完全匹配</span><br><span class="line">                if (j == i + strlen(str))</span><br><span class="line">                &#123;</span><br><span class="line">                    return i;</span><br><span class="line">                &#125;</span><br><span class="line">                //主串遇到结尾，长度不够不用继续查找了</span><br><span class="line">                else if(_str[j] == &apos;\0&apos;)</span><br><span class="line">                &#123;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">                //其他情况本次子串与要查找的串匹配不上，继续下一次子串查找</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return npos;</span><br><span class="line">    &#125;</span><br><span class="line">    //在尾部插入字符</span><br><span class="line">    void Push_back(char ch)</span><br><span class="line">    &#123;</span><br><span class="line">        Insert(_size, ch);</span><br><span class="line">    &#125;</span><br><span class="line">    //字符串拼接</span><br><span class="line">    void Append(const char* str)</span><br><span class="line">    &#123;</span><br><span class="line">        Insert(_size, str);</span><br><span class="line">    &#125;</span><br><span class="line">    //重新给容量，并且要求容量永远为8的整数倍</span><br><span class="line">    void Reserve(size_t n)</span><br><span class="line">    &#123;</span><br><span class="line">        if(n &gt; _capacity || (n == 0 &amp;&amp; _capacity == 0))</span><br><span class="line">        &#123;</span><br><span class="line">            size_t newCapacity = n;</span><br><span class="line">            if(newCapacity % 8 != 0)</span><br><span class="line">            &#123;</span><br><span class="line">                newCapacity = (((newCapacity / 8) + 1) * 8);</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">            &#123;</span><br><span class="line">                newCapacity += 8;</span><br><span class="line">            &#125;</span><br><span class="line">            char* newStr = new char[newCapacity];</span><br><span class="line">            if(newStr &amp;&amp; _str)</span><br><span class="line">            &#123;</span><br><span class="line">                strcpy(newStr, _str);</span><br><span class="line">            &#125;</span><br><span class="line">            //释放旧空间</span><br><span class="line">            delete[] _str;</span><br><span class="line">            _str = newStr;</span><br><span class="line">            _capacity = newCapacity - 1;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    void Resize(size_t size, char ch = &apos;\0&apos;)</span><br><span class="line">    &#123;</span><br><span class="line">        if(size &lt; _size)</span><br><span class="line">        &#123;</span><br><span class="line">            _size = size;</span><br><span class="line">            _str[_size] = &apos;\0&apos;;</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            Reserve(size);</span><br><span class="line">            for(size_t i = _size; i &lt; size; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                _str[i] = ch;</span><br><span class="line">            &#125;</span><br><span class="line">            _size = size;</span><br><span class="line">            _str[_size] = &apos;\0&apos;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    //&gt;运算符重载</span><br><span class="line">    bool operator&gt;(const String&amp; str)</span><br><span class="line">    &#123;</span><br><span class="line">        if(strcmp(_str, str._str) &gt; 0)</span><br><span class="line">        &#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    bool operator==(const String&amp; str)</span><br><span class="line">    &#123;</span><br><span class="line">        if(strcmp(_str, str._str) == 0)</span><br><span class="line">        &#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    bool operator&gt;=(const String&amp; str)</span><br><span class="line">    &#123;</span><br><span class="line">        if(*this &gt; str || *this == str)</span><br><span class="line">        &#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    bool operator&lt;(const String&amp; str)</span><br><span class="line">    &#123;</span><br><span class="line">        if(*this &gt;= str)</span><br><span class="line">        &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    bool operator&lt;=(const String&amp; str)</span><br><span class="line">    &#123;</span><br><span class="line">        if(*this &lt; str || *this == str)</span><br><span class="line">        &#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    bool operator!=(const String&amp; str)</span><br><span class="line">    &#123;</span><br><span class="line">        if(*this == str)</span><br><span class="line">        &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    //+运算符重载</span><br><span class="line">    String operator+(char ch)</span><br><span class="line">    &#123;</span><br><span class="line">        String temp(*this);</span><br><span class="line">        temp.Push_back(ch);</span><br><span class="line">        return temp;</span><br><span class="line">    &#125;</span><br><span class="line">    String operator+(const char* str)</span><br><span class="line">    &#123;</span><br><span class="line">        String temp(*this);</span><br><span class="line">        temp.Append(str);</span><br><span class="line">        return temp;</span><br><span class="line">    &#125;</span><br><span class="line">    //取类中的字符串</span><br><span class="line">    char* c_str()</span><br><span class="line">    &#123;</span><br><span class="line">        return _str;    </span><br><span class="line">    &#125;</span><br><span class="line">    //operator[]重载</span><br><span class="line">    char&amp; operator[](size_t pos)</span><br><span class="line">    &#123;</span><br><span class="line">        assert(pos &lt; _size);</span><br><span class="line">        return _str[pos];</span><br><span class="line">    &#125;</span><br><span class="line">    //operator[]重载</span><br><span class="line">    const char&amp; operator[](size_t pos) const</span><br><span class="line">    &#123;</span><br><span class="line">        assert(pos &lt; _size);</span><br><span class="line">        return _str[pos];</span><br><span class="line">    &#125;</span><br><span class="line">private:</span><br><span class="line">    char* _str;</span><br><span class="line">    size_t _size;</span><br><span class="line">    size_t _capacity;</span><br><span class="line">&#125;;</span><br><span class="line">std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, String str)</span><br><span class="line">&#123;</span><br><span class="line">	os &lt;&lt; str._str;</span><br><span class="line">	return os;</span><br><span class="line">&#125;</span><br><span class="line">size_t String::npos = -1;</span><br></pre></td></tr></table></figure></p>

          
        
      
    </div>
    
    
    

    

    <div>
    
    </div>

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/07/20/【算法】第一章-动态规划/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="MisakiFx">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/blog-logo.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Misaki`s blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/07/20/【算法】第一章-动态规划/" itemprop="url">【算法】第一章-动态规划</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-07-20T18:25:03+08:00">
                2019-07-20
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/算法/" itemprop="url" rel="index">
                    <span itemprop="name">算法</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  2.2k
                </span>
              

              

              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="第一章-动态规划"><a href="#第一章-动态规划" class="headerlink" title="第一章-动态规划"></a>第一章-动态规划</h1><h2 id="动态规划求解模式"><a href="#动态规划求解模式" class="headerlink" title="动态规划求解模式"></a>动态规划求解模式</h2><p>&emsp;&emsp;动态规划具备了一下三个特点：<br>&emsp;&emsp;1、把原来的问题分解成了几个相似子问题<br>&emsp;&emsp;2、所有的子问题只需要解决一次<br>&emsp;&emsp;3、储存子问题的解<br>&emsp;&emsp;从以下四个角度考虑：<br>&emsp;&emsp;1、初始状态定义<br>&emsp;&emsp;2、状态间转移方程<br>&emsp;&emsp;3、状态的初始化<br>&emsp;&emsp;4、返回结果<br>&emsp;&emsp;解决问题主要适用于：查找最优解，最大值/最小值，可不可行，是不是，方案个数</p>
<h2 id="例1-斐波那契数列"><a href="#例1-斐波那契数列" class="headerlink" title="例1 斐波那契数列"></a>例1 斐波那契数列</h2><p>&emsp;&emsp;牛客网:<br><a href="https://www.nowcoder.com/questionTerminal/c6c7742f5ba7442aada113136ddea0c3" target="_blank" rel="noopener">https://www.nowcoder.com/questionTerminal/c6c7742f5ba7442aada113136ddea0c3</a><br><br>&emsp;&emsp;动态规划解法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int Fibonacci(int n) &#123;</span><br><span class="line">        vector&lt;int&gt; ret(n + 1, 0);</span><br><span class="line">        //初始状态</span><br><span class="line">        ret[1] = ret[2] = 1;</span><br><span class="line">        //递推公式</span><br><span class="line">        //ret[i] = ret [i - 1] + ret[i - 2];</span><br><span class="line">        for(int i = 3; i &lt;= n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            ret[i] = ret[i - 1] + ret[i - 2];</span><br><span class="line">        &#125;</span><br><span class="line">        return ret[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h2 id="例2-变态青蛙跳台阶"><a href="#例2-变态青蛙跳台阶" class="headerlink" title="例2 变态青蛙跳台阶"></a>例2 变态青蛙跳台阶</h2><p>&emsp;&emsp;牛客网：<br><a href="https://www.nowcoder.com/questionTerminal/22243d016f6b47f2a6928b4313c85387" target="_blank" rel="noopener">https://www.nowcoder.com/questionTerminal/22243d016f6b47f2a6928b4313c85387</a><br></p>
<h3 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h3><h4 id="定义状态"><a href="#定义状态" class="headerlink" title="定义状态"></a>定义状态</h4><p>&emsp;&emsp;跳上i级台阶的方法数</p>
<h4 id="状态转移方程"><a href="#状态转移方程" class="headerlink" title="状态转移方程"></a>状态转移方程</h4><p>&emsp;&emsp;分解：<br>&emsp;&emsp;一次跳1级台阶：1， F(i - 1)<br>&emsp;&emsp;一次跳2级台阶：2， F(i - 2)<br>&emsp;&emsp;……<br>&emsp;&emsp;推得状态转移方程：<br>&emsp;&emsp;F(i) = F(i - 1) + F(i - 2) + … + F(1)<br>&emsp;&emsp;F(i - 1) = F(i - 2) + F(i - 3) + … + F(1)<br>&emsp;&emsp;F(i) = F(i - 1) + F(i - 1) = 2 * F(i - 1);</p>
<h4 id="初始状态和最终状态"><a href="#初始状态和最终状态" class="headerlink" title="初始状态和最终状态"></a>初始状态和最终状态</h4><p>&emsp;&emsp;F(1) = 1,求F(n)。</p>
<h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int jumpFloorII(int number) &#123;</span><br><span class="line">        //初始状态</span><br><span class="line">        int f1 = 1;</span><br><span class="line">        //状态转移方程：F(i) = 2 * F(i - 1)</span><br><span class="line">        for(int i = 2; i &lt;= number; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            f1 = 2 * f1;</span><br><span class="line">        &#125;</span><br><span class="line">        return f1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h3><p>&emsp;&emsp;根据状态转移方程我们可以得知，<code>F(n) = 2 ^ (n - 1)</code>;所以可以得到优化：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int jumpFloorII(int number) &#123;</span><br><span class="line">        return (1 &lt;&lt; (number - 1));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h2 id="例3-求连续最大子数组的和"><a href="#例3-求连续最大子数组的和" class="headerlink" title="例3 求连续最大子数组的和"></a>例3 求连续最大子数组的和</h2><p>&emsp;&emsp;牛客网：</p>
<p><a href="https://www.nowcoder.com/questionTerminal/459bd355da1549fa8a49e350bf3df484" target="_blank" rel="noopener">https://www.nowcoder.com/questionTerminal/459bd355da1549fa8a49e350bf3df484</a></p>
<h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><h4 id="定义状态-1"><a href="#定义状态-1" class="headerlink" title="定义状态"></a>定义状态</h4><p>&emsp;&emsp;到此项为止前i项的连续子序列的最大和</p>
<h4 id="状态转移方程-1"><a href="#状态转移方程-1" class="headerlink" title="状态转移方程"></a>状态转移方程</h4><p>&emsp;&emsp;F(i) = max(F(i - 1) + a[i], a[i]);</p>
<h4 id="初始状态和最终状态-1"><a href="#初始状态和最终状态-1" class="headerlink" title="初始状态和最终状态"></a>初始状态和最终状态</h4><p>&emsp;&emsp;初始状态F[0] = a[0]。<br>&emsp;&emsp;最终结果max(F[i])。</p>
<h3 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int FindGreatestSumOfSubArray(vector&lt;int&gt; array) &#123;</span><br><span class="line">        if(array.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        vector&lt;int&gt; ret(array.size(), 0);</span><br><span class="line">        //初始状态</span><br><span class="line">        ret[0] = array[0];</span><br><span class="line">        //状态转移</span><br><span class="line">        for(int i = 1; i &lt; array.size(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            ret[i] = max(array[i] + ret[i - 1], array[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        //求max(F[i])</span><br><span class="line">        int maxNum = ret[0];</span><br><span class="line">        for(int i = 0; i &lt; ret.size(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            maxNum = max(maxNum, ret[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        return maxNum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="例4-word-break-字符串分割"><a href="#例4-word-break-字符串分割" class="headerlink" title="例4 word-break(字符串分割)"></a>例4 word-break(字符串分割)</h2><p>&emsp;&emsp;牛客网：<br><a href="https://www.nowcoder.com/questionTerminal/5f3b7bf611764c8ba7868f3ed40d6b2c" target="_blank" rel="noopener">https://www.nowcoder.com/questionTerminal/5f3b7bf611764c8ba7868f3ed40d6b2c</a></p>
<h3 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h3><h4 id="定义状态-2"><a href="#定义状态-2" class="headerlink" title="定义状态"></a>定义状态</h4><p>&emsp;&emsp;F(i)：前i个字符能否被分割。</p>
<h4 id="状态转移方程-2"><a href="#状态转移方程-2" class="headerlink" title="状态转移方程"></a>状态转移方程</h4><p>&emsp;&emsp;F(i): F(i)能否被分割取决于前j项能否被分割和j + 1到第i项能否被分割。（此处j取0 ~ i - 1）<br>&emsp;&emsp;得递推方程F(i) : F(j) &amp;&amp; (j + 1 ~ i)能否被分割</p>
<h4 id="初始状态和最终状态-2"><a href="#初始状态和最终状态-2" class="headerlink" title="初始状态和最终状态"></a>初始状态和最终状态</h4><p>&emsp;&emsp;初始状态：F(0) = true。<br>&emsp;&emsp;最终状态F(n)。</p>
<h3 id="实现-2"><a href="#实现-2" class="headerlink" title="实现"></a>实现</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool wordBreak(string s, unordered_set&lt;string&gt; &amp;dict) &#123;</span><br><span class="line">        if(s.empty() || dict.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        vector&lt;bool&gt; Fn(s.size() + 1, false);</span><br><span class="line">        //初始状态</span><br><span class="line">        Fn[0] = true;</span><br><span class="line">        for(int i = 1; i &lt;= s.size(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            //状态转移</span><br><span class="line">            //F(i) = F(j) &amp;&amp; (j + 1 ~ i), (0 &lt;= j &lt; i)能否被分割</span><br><span class="line">            for(int j = i - 1; j &gt;= 0; j--)</span><br><span class="line">            &#123;</span><br><span class="line">                if(Fn[j] &amp;&amp; dict.find(s.substr(j, i - j)) != dict.end())</span><br><span class="line">                &#123;</span><br><span class="line">                    Fn[i] = true;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        //最终状态</span><br><span class="line">        return Fn[s.size()];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="例5-triangle-三角矩阵最短路"><a href="#例5-triangle-三角矩阵最短路" class="headerlink" title="例5 triangle(三角矩阵最短路)"></a>例5 triangle(三角矩阵最短路)</h2><p>&emsp;&emsp;牛客网：<br><a href="https://www.nowcoder.com/questionTerminal/2b7995aa4f7949d99674d975489cb7da" target="_blank" rel="noopener">https://www.nowcoder.com/questionTerminal/2b7995aa4f7949d99674d975489cb7da</a></p>
<h3 id="分析-2"><a href="#分析-2" class="headerlink" title="分析"></a>分析</h3><h4 id="定义状态-3"><a href="#定义状态-3" class="headerlink" title="定义状态"></a>定义状态</h4><p>&emsp;&emsp;F[i][j]: 从(0, 0)到(i, j)的最短路径和。</p>
<h4 id="状态转移方程-3"><a href="#状态转移方程-3" class="headerlink" title="状态转移方程"></a>状态转移方程</h4><p>&emsp;&emsp;一般情况下，走到每个位置的最短路径都可以看作是上一行相邻两个位置的最短路径+这个位置的路径长度，数学描述：F[i][j]:min(F[i - 1][j], F[i - 1][j - 1]) + a[i][j]。<br>&emsp;&emsp;但要考虑边界状态：当在矩阵边缘时只有一种选择的情况，即F[i][0] = F[i - 1][0];F[i][i] = F[i - 1][i - 1]。</p>
<h4 id="初始状态和最终状态-3"><a href="#初始状态和最终状态-3" class="headerlink" title="初始状态和最终状态"></a>初始状态和最终状态</h4><p>&emsp;&emsp;初始状态：F[0][0] = a[0][0]。<br>&emsp;&emsp;最终状态：min(F[n - 1][j])，即最后一行中的最小值。</p>
<h3 id="实现-3"><a href="#实现-3" class="headerlink" title="实现"></a>实现</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int minimumTotal(vector&lt;vector&lt;int&gt; &gt; &amp;triangle) &#123;</span><br><span class="line">        if(triangle.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        //初始状态</span><br><span class="line">        vector&lt;vector&lt;int&gt;&gt; ret(triangle);</span><br><span class="line">        //状态转移</span><br><span class="line">        int row = ret.size();</span><br><span class="line">        for(int i = 1; i &lt; row; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            ret[i][0] = ret[i - 1][0] + triangle[i][0];</span><br><span class="line">        &#125;</span><br><span class="line">        for(int i = 1; i &lt; row; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            ret[i][i] = ret[i - 1][i - 1] + triangle[i][i];</span><br><span class="line">        &#125;</span><br><span class="line">        for(int i = 1; i &lt; row; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            for(int j = 1; j &lt; i; ++j)</span><br><span class="line">            &#123;</span><br><span class="line">                ret[i][j] = min(ret[i - 1][j], ret[i - 1][j - 1]) + triangle[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        //最终状态</span><br><span class="line">        int minSum = ret[row - 1][0];</span><br><span class="line">        for(int i = 1; i &lt; row; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            minSum = min(minSum, ret[row - 1][i]);</span><br><span class="line">        &#125;</span><br><span class="line">        return minSum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="例6-求路径数量"><a href="#例6-求路径数量" class="headerlink" title="例6 求路径数量"></a>例6 求路径数量</h2><p>牛客网：<br><a href="https://www.nowcoder.com/questionTerminal/3cdf08dd4e974260921b712f0a5c8752" target="_blank" rel="noopener">https://www.nowcoder.com/questionTerminal/3cdf08dd4e974260921b712f0a5c8752</a></p>
<h3 id="分析-3"><a href="#分析-3" class="headerlink" title="分析"></a>分析</h3><h4 id="状态定义"><a href="#状态定义" class="headerlink" title="状态定义"></a>状态定义</h4><p>&emsp;&emsp;F[i][j]：从左上角到达下标(i, j)的路径总数</p>
<h4 id="状态转移方程-4"><a href="#状态转移方程-4" class="headerlink" title="状态转移方程"></a>状态转移方程</h4><p>&emsp;&emsp;if(a[i][j] == 1) F[i][j] = 0;<br>&emsp;&emsp;if(a[i][j] == 0) F[i][j] = F[i][j - 1] + F[i - 1][j]。</p>
<h4 id="初始状态和最终状态-4"><a href="#初始状态和最终状态-4" class="headerlink" title="初始状态和最终状态"></a>初始状态和最终状态</h4><p>&emsp;&emsp;初始状态：如果第一行第一列有障碍物表示这条路走不通则路径数置0，否则只有一条路径，置一if(a[0][j]) == 1) F[0][j] = 0，if(a[i][0] == 1) F[i][0] = 0，这种情况下这条路走不通。<br>&emsp;&emsp;最终状态：F[i][j]。</p>
<h3 id="实现-4"><a href="#实现-4" class="headerlink" title="实现"></a>实现</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int uniquePathsWithObstacles(vector&lt;vector&lt;int&gt; &gt; &amp;obstacleGrid) &#123;</span><br><span class="line">        if(obstacleGrid.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        if(obstacleGrid[0][0] == 1)</span><br><span class="line">        &#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        int row = obstacleGrid.size();</span><br><span class="line">        int col = obstacleGrid[0].size();</span><br><span class="line">        vector&lt;vector&lt;int&gt;&gt; pathNum(row, vector&lt;int&gt;(col, 0));</span><br><span class="line">        for(int i = 0; i &lt; row; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            if(obstacleGrid[i][0] == 1)</span><br><span class="line">            &#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">            &#123;</span><br><span class="line">                pathNum[i][0] = 1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        for(int i = 0; i &lt; col; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            if(obstacleGrid[0][i] == 1)</span><br><span class="line">            &#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            else </span><br><span class="line">            &#123;</span><br><span class="line">                pathNum[0][i] = 1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        for(int i = 1; i &lt; row; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            for(int j = 1; j &lt; col; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                if(obstacleGrid[i][j] == 1)</span><br><span class="line">                &#123;</span><br><span class="line">                    pathNum[i][j] = 0;</span><br><span class="line">                &#125;</span><br><span class="line">                else</span><br><span class="line">                &#123;</span><br><span class="line">                    pathNum[i][j] = pathNum[i][j - 1] + pathNum[i - 1][j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return pathNum[row - 1][col - 1];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="例7-背包问题"><a href="#例7-背包问题" class="headerlink" title="例7 背包问题"></a>例7 背包问题</h2><p>&emsp;&emsp;lintcode：<br><a href="https://www.lintcode.com/problem/backpack-ii/description" target="_blank" rel="noopener">https://www.lintcode.com/problem/backpack-ii/description</a></p>
<h3 id="分析-4"><a href="#分析-4" class="headerlink" title="分析"></a>分析</h3><p>&emsp;&emsp;背包问题是一类问题，主要是求解约束条件下的最优解问题。</p>
<h4 id="状态定义-1"><a href="#状态定义-1" class="headerlink" title="状态定义"></a>状态定义</h4><p>&emsp;&emsp;F[i][j]：前i个商品，包的重量为j的最大价值。定义二维数组遍历所有商品，和到当前商品情况下背包容量从0 - max的所有情况下的最大值求解，遍历到最后则可得到n个全部商品情况下背包最大容量max下背包可拿的最大价值F[n][max]。</p>
<h4 id="状态转移方程-5"><a href="#状态转移方程-5" class="headerlink" title="状态转移方程"></a>状态转移方程</h4><p>&emsp;&emsp;当前商品空间大于包能承受的总空间，放不下直接跳过。数学描述：if(w[i] &gt; j) F[i][j] = F[i - 1][j]。<br>&emsp;&emsp;当前商品空间小于等于包能承受总空间，可以选择放可以选择不放，如果不放入，则F[i][j] = F[i - 1][j]；如果放入，则当前重量等于遍历到的上一个商品并且空间还有w[i]这么大的时候的价值+本商品的价值，最大价值F[i][j] = F[i - 1][j - w[i]] + v[i]，选择放入或不放入商品情况中的最大值作为最优解。数学描述：if(w[i] &lt;= j) max(F[i - 1][j], F[i - 1][j - w[i]] + v[i]);</p>
<h4 id="初始状态和最终状态-5"><a href="#初始状态和最终状态-5" class="headerlink" title="初始状态和最终状态"></a>初始状态和最终状态</h4><p>&emsp;&emsp;初始状态：没有商品时，F[0][j] = 0,最大容量为0时F[i][0] = 0。<br>&emsp;&emsp;最终状态：遍历完全部n个商品，并且背包总容量为最大值m时得到最大价值F[n][m]。</p>
<h3 id="实现-5"><a href="#实现-5" class="headerlink" title="实现"></a>实现</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    /**</span><br><span class="line">     * @param m: An integer m denotes the size of a backpack</span><br><span class="line">     * @param A: Given n items with size A[i]</span><br><span class="line">     * @param V: Given n items with value V[i]</span><br><span class="line">     * @return: The maximum value</span><br><span class="line">     */</span><br><span class="line">    int backPackII(int m, vector&lt;int&gt; &amp;A, vector&lt;int&gt; &amp;V) &#123;</span><br><span class="line">        if(A.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        int row = A.size();</span><br><span class="line">        vector&lt;vector&lt;int&gt;&gt; maxValue(row + 1, vector&lt;int&gt;(m + 1, 0));</span><br><span class="line">        for(int i = 1; i &lt;= row; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            for(int j = 1; j &lt;= m; ++j)</span><br><span class="line">            &#123;</span><br><span class="line">                if(A[i - 1] &gt; j)</span><br><span class="line">                &#123;</span><br><span class="line">                    maxValue[i][j] = maxValue[i - 1][j];</span><br><span class="line">                &#125;</span><br><span class="line">                else</span><br><span class="line">                &#123;</span><br><span class="line">                    maxValue[i][j] = max(maxValue[i - 1][j], maxValue[i - 1][j - A[i - 1]] + V[i - 1]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return maxValue[row][m];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
          
        
      
    </div>
    
    
    

    

    <div>
    
    </div>

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/07/15/【Cpp】第四章-模板初阶/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="MisakiFx">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/blog-logo.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Misaki`s blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/07/15/【Cpp】第四章-模板初阶/" itemprop="url">【Cpp】第四章-模板初阶</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-07-15T20:10:18+08:00">
                2019-07-15
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Cpp/" itemprop="url" rel="index">
                    <span itemprop="name">Cpp</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  1.7k
                </span>
              

              

              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="模板初阶"><a href="#模板初阶" class="headerlink" title="模板初阶"></a>模板初阶</h1><h2 id="泛型编程"><a href="#泛型编程" class="headerlink" title="泛型编程"></a>泛型编程</h2><p>&emsp;&emsp;在我们进行大型程序的编写时往往会遇到一类问题，同一个函数或类我们希望多种类型数据传入时都能完成类似或者相同的功能，但是在C语言中我们很难做到这一点因为我们往往在换了一个数据类型后就要重新写一遍函数，这样耽误我们大量的时间，呢么有没有一种语法在Cpp中能够使让我们的代码成为一种模板，不同的数据类型传入也依然能够执行类似的功能呢？<br><br>&emsp;&emsp;正所谓世界是由懒人创造的，于是在C++中引入了模板这一概念，同时也正得益与此使我们可以做到<strong>泛型编程</strong>，是我们的代码极大程度的可以复用。</p>
<h2 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h2><p>&emsp;&emsp;模板是实现泛型编程的基础，其中又可细分为<strong>函数模板</strong>和<strong>类模板</strong>。</p>
<h3 id="函数模板"><a href="#函数模板" class="headerlink" title="函数模板"></a>函数模板</h3><p>&emsp;&emsp;函数模板是生成一个家族的函数，其中我们可以使用任意类型的参数进行传入。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">//定义函数模板,T为任意类型</span><br><span class="line">//class 也可替换为 typename</span><br><span class="line">template&lt;class T&gt;</span><br><span class="line">void Swap(T&amp; a, T&amp; b)</span><br><span class="line">&#123;</span><br><span class="line">    T t = a;</span><br><span class="line">    a = b;</span><br><span class="line">    b = t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int a = 4, b = 5;</span><br><span class="line">    double c = 6, d = 7;</span><br><span class="line">    Swap(a, b);</span><br><span class="line">    Swap(c, d);</span><br><span class="line">    cout &lt;&lt; a &lt;&lt; &quot; &quot; &lt;&lt; b &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; c &lt;&lt; &quot; &quot; &lt;&lt; d &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">5 4</span><br><span class="line">7 6</span><br></pre></td></tr></table></figure></p>
<h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><p>&emsp;&emsp;函数模板在定义完之后并不会直接生成函数，而是在调用时会根据传参类型进行推演，在上面的例子中我们传入了<code>int</code>类型的参数因此在推演时会将<code>T</code>转换为<code>int</code>再进行调用，但有时我们的调用如果出现了让编译器无法推演的情况就会导致报错。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">template&lt;class T&gt;</span><br><span class="line">void Swap(T&amp; a, T&amp; b)</span><br><span class="line">&#123;</span><br><span class="line">    T t = a;</span><br><span class="line">    a = b;</span><br><span class="line">    b = t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int a = 4, b = 5;</span><br><span class="line">    double c = 6, d = 7;</span><br><span class="line">    Swap(a, d);</span><br><span class="line">    Swap(c, b);</span><br><span class="line">    cout &lt;&lt; a &lt;&lt; &quot; &quot; &lt;&lt; b &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; c &lt;&lt; &quot; &quot; &lt;&lt; d &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">.\test.cpp: In function &apos;int main()&apos;:</span><br><span class="line">.\test.cpp:15:14: error: no matching function for call to &apos;Swap(int&amp;, double&amp;)&apos;</span><br><span class="line">     Swap(a, d);</span><br><span class="line">              ^</span><br><span class="line">.\test.cpp:4:6: note: candidate: template&lt;class T&gt; void Swap(T&amp;, T&amp;)</span><br><span class="line"> void Swap(T&amp; a, T&amp; b)</span><br><span class="line">      ^~~~</span><br><span class="line">.\test.cpp:4:6: note:   template argument deduction/substitution failed:</span><br><span class="line">.\test.cpp:15:14: note:   deduced conflicting types for parameter &apos;T&apos; (&apos;int&apos; and &apos;double&apos;)</span><br><span class="line">     Swap(a, d);</span><br><span class="line">              ^</span><br><span class="line">.\test.cpp:16:14: error: no matching function for call to &apos;Swap(double&amp;, int&amp;)&apos;</span><br><span class="line">     Swap(c, b);</span><br><span class="line">              ^</span><br><span class="line">.\test.cpp:4:6: note: candidate: template&lt;class T&gt; void Swap(T&amp;, T&amp;)</span><br><span class="line"> void Swap(T&amp; a, T&amp; b)</span><br><span class="line">      ^~~~</span><br><span class="line">.\test.cpp:4:6: note:   template argument deduction/substitution failed:</span><br><span class="line">.\test.cpp:16:14: note:   deduced conflicting types for parameter &apos;T&apos; (&apos;double&apos; and &apos;int&apos;)</span><br><span class="line">     Swap(c, b);</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;我们会发现在这样只有一个模板参数<code>T</code>进行多类型传入就会混淆编译器，导致报错，因此我们可以定义多个模板参数，也可以进行强转使参数类型唯一，不过这里要提到另一种可以让编译器推演出我们想要的函数的方式，<strong>显示实例化</strong>。</p>
<h4 id="显示实例化"><a href="#显示实例化" class="headerlink" title="显示实例化"></a>显示实例化</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">template&lt;class T&gt;</span><br><span class="line">T Add(T a, T b)</span><br><span class="line">&#123;</span><br><span class="line">    return a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int ret = Add&lt;int&gt;(1, 2);</span><br><span class="line">    cout &lt;&lt; ret &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">3</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;像是这样的情况我们就利用显示实例化给我们的函数模板制定了实例化类型，同时如果类型不匹配，编译器会进行隐式类型转换，如果转换不成功则会报错。</p>
<h4 id="函数模板匹配原则"><a href="#函数模板匹配原则" class="headerlink" title="函数模板匹配原则"></a>函数模板匹配原则</h4><p>&emsp;&emsp;函数模板可以与非模板函数重名，此时会构成类似于函数重载的情况，并且在函数调用时如果出现重名的函数模板和非模板函数都可以构成匹配则会优先调用非模板函数，而不会对函数模板进行实例化，除非我们利用显示实例化指定必须调用模板函数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">template&lt;class T&gt;</span><br><span class="line">T Add(T a, T b)</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; &quot;template function&quot; &lt;&lt; endl;</span><br><span class="line">    return a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int Add(int a, int b)</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; &quot;simple function&quot; &lt;&lt; endl;</span><br><span class="line">    return a + b;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int ret = Add(1, 2);//调用普通函数</span><br><span class="line">    ret = Add&lt;int&gt;(1, 2);//调用模板函数</span><br><span class="line">    cout &lt;&lt; ret &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">simple function</span><br><span class="line">template function</span><br><span class="line">3</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;但是如果模板函数此时可以提供更好的适配性，则会优先调用模板函数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">template&lt;class T1, class T2&gt;</span><br><span class="line">T1 Add(T1 a, T2 b)</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; &quot;template function&quot; &lt;&lt; endl;</span><br><span class="line">    return a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int Add(int a, int b)</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; &quot;simple function&quot; &lt;&lt; endl;</span><br><span class="line">    return a + b;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int ret = Add(1, 2.0);//优先调用函数模板</span><br><span class="line">    ret = Add&lt;int, double&gt;(1, 2.0);</span><br><span class="line">    cout &lt;&lt; ret &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">template function</span><br><span class="line">template function</span><br><span class="line">3</span><br></pre></td></tr></table></figure></p>
<h3 id="类模板"><a href="#类模板" class="headerlink" title="类模板"></a>类模板</h3><p>&emsp;&emsp;类模板与函数模板类似，是使用一个模板参数来构造整个类，并且原理也与函数模板类似，只有在类构造对象时才会推演模板参数进行实例化，实例化出我们想要的类。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;assert.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">template&lt;class T&gt;</span><br><span class="line">class Vector</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    Vector(size_t capacity = 10)</span><br><span class="line">        :_pData(new T[capacity])</span><br><span class="line">        ,_size(0)</span><br><span class="line">        ,_capacity(capacity)</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    ~Vector();</span><br><span class="line">    //返回size</span><br><span class="line">    size_t Size()</span><br><span class="line">    &#123;</span><br><span class="line">        return _size;</span><br><span class="line">    &#125;</span><br><span class="line">    //尾插</span><br><span class="line">    void Push_back(const T&amp; data)</span><br><span class="line">    &#123;</span><br><span class="line">        //检查扩容</span><br><span class="line">        if(_size &gt;= _capacity)</span><br><span class="line">        &#123;//扩容</span><br><span class="line">            Reserve(2 * _capacity);</span><br><span class="line">        &#125;</span><br><span class="line">        _pData[_size] = data;</span><br><span class="line">        _size++;</span><br><span class="line">    &#125;</span><br><span class="line">    //尾删</span><br><span class="line">    void Pop_back()</span><br><span class="line">    &#123;</span><br><span class="line">        _size--;</span><br><span class="line">    &#125;</span><br><span class="line">    //改变容量</span><br><span class="line">    void Reserve(int capacity)</span><br><span class="line">    &#123;</span><br><span class="line">        if(capacity &lt;= _capacity)</span><br><span class="line">        &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        T* newPData = new T[capacity];</span><br><span class="line">        for(int i = 0; i &lt; _size; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            newPData[i] = _pData[i];</span><br><span class="line">        &#125;</span><br><span class="line">        _pData = newPData;</span><br><span class="line">        _capacity = capacity;</span><br><span class="line">    &#125;</span><br><span class="line">    T operator[](size_t pos)</span><br><span class="line">    &#123;</span><br><span class="line">        assert(pos &lt; _size);</span><br><span class="line">        return _pData[pos];</span><br><span class="line">    &#125;</span><br><span class="line">private:</span><br><span class="line">    T* _pData;</span><br><span class="line">    size_t _size;</span><br><span class="line">    size_t _capacity;</span><br><span class="line">&#125;;</span><br><span class="line">//在类外进行函数声明时要加上模板参数</span><br><span class="line">//同时要注意Vector不是一个类，实例化后Vector&lt;T&gt;才是一个类</span><br><span class="line">template&lt;class T&gt;</span><br><span class="line">Vector&lt;T&gt;::~Vector()</span><br><span class="line">&#123;</span><br><span class="line">    if(_pData)</span><br><span class="line">    &#123;</span><br><span class="line">        delete[] _pData;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    Vector&lt;int&gt; arr;</span><br><span class="line">    arr.Push_back(1);</span><br><span class="line">    arr.Push_back(2);</span><br><span class="line">    for(int i = 0; i &lt; arr.Size(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; arr[i] &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1</span><br><span class="line">2</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;这个例子我们模拟简单实现了一个<code>vector</code>模板类，并且使用实例化进行使用，类模板与函数模板不同的是类模板往往无法推演出模板参数类型因此需要我们显示实例化使其实例化为一个具体的类才可以进行使用。</p>

          
        
      
    </div>
    
    
    

    

    <div>
    
    </div>

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/6/">6</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/blog-logo.jpg"
                alt="MisakiFx" />
            
              <p class="site-author-name" itemprop="name">MisakiFx</p>
              <p class="site-description motion-element" itemprop="description">Hard working or giving up!!!</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">57</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">8</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">34</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/MisakiFx" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="mailto:1761607418@qq.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope-open"></i>E-Mail</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://music.163.com/#/user/home?id=432551242" target="_blank" title="网易云音乐">
                      
                        <i class="fa fa-fw fa-music"></i>网易云音乐</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://blog.csdn.net/qq_41669298" target="_blank" title="CSDN">
                      
                        <i class="fa fa-fw fa-crosshairs"></i>CSDN</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        ﻿<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js">
</script>
<div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">MisakiFx</span>

  
</div>


<div class="powered-by">
  <i class="fa fa-user-md"></i>
  <span id="busuanzi_container_site_uv">
    我的网站的访客数:<span id="busuanzi_value_site_uv"></span>
  </span>
</div>



<span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.4</div>




<div class="theme-info">
  <div class="powered-by"></div>
  <span class="post-count">博客全站共142.6k字</span>
</div>

        ﻿







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  


  











  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  

  
  
    <script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

  <!-- 页面点击小红心 -->
        <script type="text/javascript" src="/js/src/love.js"></script>
<script src="/live2dw/lib/L2Dwidget.min.js?0c58a1486de42ac6cc1c59c7d98ae887"></script><script>L2Dwidget.init({"pluginModelPath":"assets/","model":{"jsonPath":"/live2dw/assets/z16.model.json"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":false},"log":false,"pluginJsPath":"lib/","pluginRootPath":"live2dw/","tagMode":false});</script></body>
</html>
