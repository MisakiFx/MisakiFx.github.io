<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.ico?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon_16.ico?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta name="description" content="Hard working or giving up!!!">
<meta property="og:type" content="website">
<meta property="og:title" content="Misaki`s blog">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="Misaki`s blog">
<meta property="og:description" content="Hard working or giving up!!!">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Misaki`s blog">
<meta name="twitter:description" content="Hard working or giving up!!!">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/"/>





  <title>Misaki`s blog</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

<a href="https://github.com/MisakiFx" class="github-corner" aria-label="View source on GitHub"><svg width="80" height="80" viewBox="0 0 250 250" style="fill:#64CEAA; color:#fff; position: absolute; top: 0; border: 0; left: 0; transform: scale(-1, 1);" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Misaki`s blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">学习是一种态度</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/08/12/【Cpp】第十章-模板进阶/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="MisakiFx">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/blog-logo.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Misaki`s blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/08/12/【Cpp】第十章-模板进阶/" itemprop="url">【Cpp】第十章-模板进阶</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-08-12T16:35:22+08:00">
                2019-08-12
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  0
                </span>
              

              

              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            
          
        
      
    </div>
    
    
    

    

    <div>
    
    </div>

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/08/05/【Cpp】第九章-STL-stack类和queue类/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="MisakiFx">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/blog-logo.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Misaki`s blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/08/05/【Cpp】第九章-STL-stack类和queue类/" itemprop="url">【Cpp】第九章-STL_stack类和queue类</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-08-05T18:04:20+08:00">
                2019-08-05
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Cpp/" itemprop="url" rel="index">
                    <span itemprop="name">Cpp</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  3.8k
                </span>
              

              

              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="stack类和queue类"><a href="#stack类和queue类" class="headerlink" title="stack类和queue类"></a>stack类和queue类</h1><p>&emsp;&emsp;<code>stack</code>和<code>queue</code>以及<code>priority_queue</code>(优先级队列)是STL中三大容器适配器，将其称为容器适配器是因为其在底层只是对现有容器进行的了封装而并没有重新实现。因此在容器适配器中都有让传入容器的模板参数。</p>
<h2 id="容器适配器"><a href="#容器适配器" class="headerlink" title="容器适配器"></a>容器适配器</h2><p>&emsp;&emsp;适配器是一种设计模式，在GOF的《设计模式：可复用面向对象软件的基础》中是这样说的：将一个类的接口转换成客户希望的另外一个接口。适配器模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。而容器适配器就是将常见容器的接口进行封装，使之成为我们需要的结构。因此在容器适配的模板参数中我们可以传入我们想要使用的容器作为模板参数进行封装，但是作为适配器的实现容器它们也需要满足一定的要求才可以作为模板参数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//Container就是底层实现的容器的模板参数</span><br><span class="line">template &lt;class T, class Container = deque&lt;T&gt; &gt; class queue;</span><br><span class="line">template &lt;class T, class Container = deque&lt;T&gt; &gt; class stack;</span><br><span class="line">template &lt;class T, class Container = vector&lt;T&gt;,</span><br><span class="line">  class Compare = less&lt;typename Container::value_type&gt; &gt; class priority_queue;</span><br></pre></td></tr></table></figure></p>
<h2 id="stack类"><a href="#stack类" class="headerlink" title="stack类"></a>stack类</h2><p>&emsp;&emsp;<code>stack</code>和我们数据结构中的栈实现了同样的功能，<strong>后进先出</strong>是其最大的特点。它只能从容器的一端进行元素的插入和提取，来满足栈的相关功能。<br>&emsp;&emsp;它底层的容器可以是标准中的容器类也可以是其他的容器类，但是无论如何这些容器类必须满足以下要求。<br>&emsp;&emsp;1、<code>empty()</code>，判空操作。<br>&emsp;&emsp;2、<code>back()</code>，获取尾部元素。<br>&emsp;&emsp;3、<code>push_back()</code>，尾插。<br>&emsp;&emsp;4、<code>pop_back()</code>，尾删。<br>&emsp;&emsp;满足这些要求的容器类才可以被传入，如果没有传入容器的话则默认使用<code>deque</code>。</p>
<h3 id="常用接口"><a href="#常用接口" class="headerlink" title="常用接口"></a>常用接口</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">stack(const container_type &amp;ctnr = container_type()); //构造空的栈</span><br><span class="line">bool empty() const;                                   //检测stack是否为空</span><br><span class="line">size_type size();                                     //const 返回stack中元素的个数</span><br><span class="line">value_type &amp;top();                                    //返回栈顶元素的引用</span><br><span class="line">const value_type &amp;top() const;                        //返回栈顶元素的const引用</span><br><span class="line">void push(const value_type &amp;val);                     //将元素val压入stack中</span><br><span class="line">void pop();                                           //将stack中尾部的元素弹出</span><br><span class="line">template &lt;class... Args&gt;</span><br><span class="line">void emplace(Args &amp;&amp;... args);                        //(C++11) 在stack的栈顶构造元素</span><br><span class="line">void swap(stack &amp;x);                                  //(C++11) 交换两个栈中的元素</span><br></pre></td></tr></table></figure>
<h3 id="栈的应用"><a href="#栈的应用" class="headerlink" title="栈的应用"></a>栈的应用</h3><h4 id="最小栈"><a href="#最小栈" class="headerlink" title="最小栈"></a>最小栈</h4><p>&emsp;&emsp;力扣：<br><a href="https://leetcode-cn.com/problems/min-stack/submissions/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/min-stack/submissions/</a><br>&emsp;&emsp;这道题就是用栈区实现一个可以返回当前栈中最小值的栈，方法有很多种，这里只提供一种方法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">class MinStack &#123;</span><br><span class="line">public:</span><br><span class="line">    /** initialize your data structure here. */</span><br><span class="line">    MinStack()</span><br><span class="line">        :_min(INT_MAX)</span><br><span class="line">    &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    void push(int x) &#123;</span><br><span class="line">        if(x &lt; _min)</span><br><span class="line">        &#123;</span><br><span class="line">            _min = x;</span><br><span class="line">        &#125;</span><br><span class="line">        _elem.push_back(x);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    void pop() &#123;</span><br><span class="line">        if(top() == _min)</span><br><span class="line">        &#123;</span><br><span class="line">            _min = INT_MAX;</span><br><span class="line">            for(int i = 0; i &lt; _elem.size() - 1; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                if(_elem[i] &lt; _min)</span><br><span class="line">                &#123;</span><br><span class="line">                    _min = _elem[i];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        _elem.pop_back();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    int top() &#123;</span><br><span class="line">        return _elem[_elem.size() - 1];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    int getMin() &#123;</span><br><span class="line">        return _min;</span><br><span class="line">    &#125;</span><br><span class="line">private:</span><br><span class="line">    std::vector&lt;int&gt; _elem;</span><br><span class="line">    int _min;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Your MinStack object will be instantiated and called as such:</span><br><span class="line"> * MinStack* obj = new MinStack();</span><br><span class="line"> * obj-&gt;push(x);</span><br><span class="line"> * obj-&gt;pop();</span><br><span class="line"> * int param_3 = obj-&gt;top();</span><br><span class="line"> * int param_4 = obj-&gt;getMin();</span><br><span class="line"> */</span><br></pre></td></tr></table></figure></p>
<h4 id="栈的压入、弹出序列"><a href="#栈的压入、弹出序列" class="headerlink" title="栈的压入、弹出序列"></a>栈的压入、弹出序列</h4><p>&emsp;&emsp;牛客网：<br><a href="https://www.nowcoder.com/practice/d77d11405cc7470d82554cb392585106?tpId=13&amp;&amp;tqId=11174&amp;rp=1&amp;ru=/activity/oj&amp;qru=/ta/coding-interviews/question-ranking" target="_blank" rel="noopener">https://www.nowcoder.com/practice/d77d11405cc7470d82554cb392585106?tpId=13&amp;&amp;tqId=11174&amp;rp=1&amp;ru=/activity/oj&amp;qru=/ta/coding-interviews/question-ranking</a><br>&emsp;&emsp;这道题用到了栈的弹出序列是否匹配压入序列的算法，大致思路是用一个栈进行模拟，并且设立用于分别遍历弹出和压入序列的下标，只要栈顶元素不等于当前遍历到的弹出序列的元素，就将压入序列当前元素压入栈，并且遍历压入序列的下一个元素，如果相等，则将栈顶元素弹出，并且遍历弹出序列的下一个元素。如果当弹出序列还没有遍历完毕而压入序列也始终找不到下一个可以和弹出序列进行匹配的元素则不匹配，返回false，如果弹出序列遍历完毕，则表示匹配，返回true。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool IsPopOrder(vector&lt;int&gt; pushV,vector&lt;int&gt; popV) &#123;</span><br><span class="line">        int pushIndex = 0;</span><br><span class="line">        int popIndex = 0;</span><br><span class="line">        //用栈进行模拟</span><br><span class="line">        stack&lt;int&gt; s;</span><br><span class="line">        //遍历弹出序列</span><br><span class="line">        while(popIndex &lt; popV.size())</span><br><span class="line">        &#123;</span><br><span class="line">            //栈为空或者栈顶元素不等于当天弹出序列遍历到的元素</span><br><span class="line">            while(s.empty() || s.top() != popV[popIndex])</span><br><span class="line">            &#123;</span><br><span class="line">                //压入序列还有元素则压入</span><br><span class="line">                if(pushIndex &lt; pushV.size())</span><br><span class="line">                &#123;</span><br><span class="line">                    s.push(pushV[pushIndex]);</span><br><span class="line">                    pushIndex++;</span><br><span class="line">                &#125;</span><br><span class="line">                //压入序列全部压入无法完成匹配</span><br><span class="line">                else</span><br><span class="line">                &#123;</span><br><span class="line">                    return false;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            //栈顶元素和弹出序列当前元素相同则往后继续遍历</span><br><span class="line">            s.pop();</span><br><span class="line">            popIndex++;</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h4 id="逆波兰表达式求值"><a href="#逆波兰表达式求值" class="headerlink" title="逆波兰表达式求值"></a>逆波兰表达式求值</h4><p>&emsp;&emsp;力扣：<br><a href="https://leetcode-cn.com/problems/evaluate-reverse-polish-notation/submissions/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/evaluate-reverse-polish-notation/submissions/</a><br>&emsp;&emsp;逆波兰表达式也成为后缀表达式，这里的逆波兰表达式求值由于不涉及括号所以比较简单，我们只需要将遇到的操作数放入栈，遇到操作符则取出栈顶两个元素进行计算，然后将结果再次放入栈最后取出栈中最后一个元素就是答案。不过这里要注意负数的处理，以及从栈中取出的两个操作数哪个是前操作数哪个是后操作数的问题。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int evalRPN(vector&lt;string&gt;&amp; tokens) &#123;</span><br><span class="line">        stack&lt;int&gt; s;</span><br><span class="line">        for(int i = 0; i &lt; tokens.size(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            if(tokens[i][0] &lt;= &apos;9&apos; &amp;&amp; tokens[i][0] &gt;= &apos;0&apos;)</span><br><span class="line">            &#123;</span><br><span class="line">                s.push(atoi(tokens[i].c_str()));</span><br><span class="line">            &#125;</span><br><span class="line">            //要处理负数</span><br><span class="line">            else if(tokens[i][0] == &apos;-&apos; &amp;&amp; tokens[i][1] != &apos;\0&apos;)</span><br><span class="line">            &#123;</span><br><span class="line">                string str = tokens[i].substr(1);</span><br><span class="line">                int temp = -1 * atoi(str.c_str());</span><br><span class="line">                s.push(temp);</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">            &#123;</span><br><span class="line">                int num1 = s.top();</span><br><span class="line">                s.pop();</span><br><span class="line">                int num2 = s.top();</span><br><span class="line">                s.pop();</span><br><span class="line">                switch(tokens[i][0])</span><br><span class="line">                &#123;</span><br><span class="line">                    case &apos;+&apos;:</span><br><span class="line">                        s.push(num2 + num1);</span><br><span class="line">                        break;</span><br><span class="line">                    case &apos;-&apos;:</span><br><span class="line">                        s.push(num2 - num1);</span><br><span class="line">                        break;</span><br><span class="line">                    case &apos;*&apos;:</span><br><span class="line">                        s.push(num2 * num1);</span><br><span class="line">                        break;</span><br><span class="line">                    case &apos;/&apos;:</span><br><span class="line">                        s.push(num2 / num1);</span><br><span class="line">                        break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return s.top();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h2 id="queue类"><a href="#queue类" class="headerlink" title="queue类"></a>queue类</h2><p>&emsp;&emsp;和<code>stack</code>相反，<code>queue</code>有着先进先出的特性，这使得他能够按照顺序完成某一功能。它从容器的一端插入另一端删除，因此它的模板参数中的容器要求有以下功能：<br>&emsp;&emsp;1、<code>empty()</code>，判空<br>&emsp;&emsp;2、<code>size()</code>，长度<br>&emsp;&emsp;3、<code>back()</code>，获取尾部元素<br>&emsp;&emsp;4、<code>front()</code>，获取头部元素<br>&emsp;&emsp;5、<code>push_back()</code>，尾插<br>&emsp;&emsp;6、<code>pop_front()</code>，头删<br>&emsp;&emsp;如果没有传入容器的话则默认使用<code>deque</code>。</p>
<h3 id="常用接口-1"><a href="#常用接口-1" class="headerlink" title="常用接口"></a>常用接口</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">queue(const container_type &amp;ctnr = container_type()); //构造空的队列</span><br><span class="line">bool empty() const;                                   //检测队列是否为空，是返回true，否则返回false</span><br><span class="line">size_type size() const;                               //返回队列中有效元素的个数</span><br><span class="line">value_type &amp;front();                                  //返回队头元素的引用</span><br><span class="line">const value_type &amp;front() const;                      //返回队头元素的const引用</span><br><span class="line">value_type &amp;back();                                   //返回队尾元素的引用</span><br><span class="line">const value_type &amp;back() const;                       //返回队尾元素的cosnt引用</span><br><span class="line">void push(value_type &amp; val);                          //在队尾将元素val入队列</span><br><span class="line">void pop();                                           //将队头元素出队列</span><br><span class="line">template &lt;class... Args&gt;</span><br><span class="line">void emplace(Args &amp;&amp; ... args)(C++ 11);               //在队尾构造元素</span><br><span class="line">void swap(queue &amp; x);                                 //交换两个队列中的元素</span><br></pre></td></tr></table></figure>
<h3 id="队列的应用"><a href="#队列的应用" class="headerlink" title="队列的应用"></a>队列的应用</h3><h4 id="用队列实现栈"><a href="#用队列实现栈" class="headerlink" title="用队列实现栈"></a>用队列实现栈</h4><p>&emsp;&emsp;力扣：<br><a href="https://leetcode-cn.com/problems/implement-stack-using-queues/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/implement-stack-using-queues/</a><br>&emsp;&emsp;利用栈进行层序遍历类似于bfs，即广度优先搜索，我们在进行遍历时需要将每一个结点的儿子都压入栈，只要栈不为空就一直遍历下去。但是这个题要求要区分每一层，则我们需要在遍历每一层前都拿到当前队列中结点的个数，则是这一层要遍历的结点数，我们这一层就只遍历这些结点即可。我们甚至由此可以得出N叉树的层序遍历，都可以用类似的思路。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for a binary tree node.</span><br><span class="line"> * struct TreeNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeNode *left;</span><br><span class="line"> *     TreeNode *right;</span><br><span class="line"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><br><span class="line"> * &#125;;</span><br><span class="line"> */</span><br><span class="line">class Solution &#123;</span><br><span class="line">    public:</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; levelOrder(TreeNode* root) &#123;</span><br><span class="line">        vector&lt;vector&lt;int&gt;&gt; res;</span><br><span class="line">        queue&lt;TreeNode*&gt; q;</span><br><span class="line">        //根结点为空直接返回</span><br><span class="line">        if(root == nullptr)</span><br><span class="line">        &#123;</span><br><span class="line">            return res;</span><br><span class="line">        &#125;</span><br><span class="line">        q.push(root);</span><br><span class="line">        while(!q.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            vector&lt;int&gt; line;</span><br><span class="line">            int size = q.size();</span><br><span class="line">            for(int i = 0; i &lt; size; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                TreeNode* node = q.front();</span><br><span class="line">                if(node-&gt;left != nullptr)</span><br><span class="line">                &#123;</span><br><span class="line">                    q.push(node-&gt;left);</span><br><span class="line">                &#125;</span><br><span class="line">                if(node-&gt;right != nullptr)</span><br><span class="line">                &#123;</span><br><span class="line">                    q.push(node-&gt;right);</span><br><span class="line">                &#125;</span><br><span class="line">                q.pop();</span><br><span class="line">                line.push_back(node-&gt;val);</span><br><span class="line">            &#125;</span><br><span class="line">            res.push_back(line);</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h2 id="priority-queue类"><a href="#priority-queue类" class="headerlink" title="priority_queue类"></a>priority_queue类</h2><p>&emsp;&emsp;<code>priority_queue</code>称为优先级队列，它的出队元素永远是队列中优先级最高的那一个，它的底层是用一个堆来完成的，堆顶就是优先级最高的元素。<br>&emsp;&emsp;优先级队列在每次插入删除元素后都会分别调用算法<code>push_heap()</code>和<code>pop_heap()</code>重新建堆，并且还会和容器中的<code>push_back()</code>和<code>pop_back()</code>结合。同时优先级队列中有一个<code>Compare</code>的模板参数，用于传入一个仿函数，建堆会用这个仿函数按照严格弱序进行建堆。<br>&emsp;&emsp;所谓仿函数则是一个类中重载了<code>operator()</code>使其实例化的对象可以像函数一样进行调用，它的特点是可以使类作为模板参数一部分传入模板内，并且使其实例化出的对象可以当作函数使用。标准中给了两个类提供了仿函数的功能，<code>less</code>和<code>greater</code>。<br>&emsp;&emsp;如果在优先级队列中存放自定义类型的数据，要求自定义类型必须重载<code>operator&lt;</code>或<code>operator&gt;</code>取决于<code>Compare</code>的类型，这两个重载在仿函数中将会进行调用用于判断和比较。<br>&emsp;&emsp;同样的优先级队列中的容器也必须满足一些要求才能完成功能：<br>&emsp;&emsp;1、<code>empty()</code>，判空<br>&emsp;&emsp;2、<code>size()</code>，长度<br>&emsp;&emsp;3、<code>front()</code>，获取头部元素<br>&emsp;&emsp;4、<code>push_back()</code>，尾插<br>&emsp;&emsp;5、<code>pop_back()</code>，尾删<br>&emsp;&emsp;容器还需要支持随机访问迭代器，以便始终在内部保持堆结构。<br>&emsp;&emsp;为什么是这些接口？<code>front()</code>用于在建堆和堆调整后可以获得堆顶元素，即优先级最高的元素，即<code>top()</code>；<code>push()</code>在给堆插入元素时是从容器的尾部插入，因此需要<code>push_back()</code>进行尾插，尾插后再用<code>push_heap()</code>调整堆；<code>pop()</code>在出队时要先调用<code>pop_heap()</code>，这个接口会将堆顶元素与堆的最后一个元素交换位置，并且对堆的除最后一个元素进行调整，这个过程类似于堆排序。之后再调用容器的<code>pop_back()</code>即可将原本堆顶优先级最高的元素出队。</p>
<h3 id="常用接口-2"><a href="#常用接口-2" class="headerlink" title="常用接口"></a>常用接口</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">priority_queue(const Compare &amp;x = Compare(),</span><br><span class="line">                   const Container &amp;y = Container());   //构造一个空的优先级队列</span><br><span class="line">template &lt;class InputIterator&gt;</span><br><span class="line">priority_queue(InputIterator first, InputIterator last,</span><br><span class="line">               const Compare &amp;comp = Compare(),</span><br><span class="line">               const Container &amp;ctnr = Container()); //用[first, last)区间中的元素构造优先级队列</span><br><span class="line">bool empty() const;                                  //检测优先级队列是否为空，是返回true，否则返回false</span><br><span class="line">const value_type &amp;top() const;                       //返回优先级队列中最大(最小元素)，即堆顶元素</span><br><span class="line">void push(const T &amp;x);                               //在优先级队列中插入元素x</span><br><span class="line">void pop();                                          //删除优先级队列中最大(最小)元素，即堆顶元素</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;默认情况下，类模板中<code>Compare</code>的类型为<code>less</code>，实例化出来的对象重载时判断的为是否小于，因此会创建大堆，队列出队返回的值也是队中优先级最高的。</p>
<h3 id="优先级队列的应用"><a href="#优先级队列的应用" class="headerlink" title="优先级队列的应用"></a>优先级队列的应用</h3><p>&emsp;&emsp;优先级队列底层是堆的实现，因此优先级队列擅长于结局堆能够解决的问题，例如TopK问题。</p>
<h4 id="数组中的第K个最大的元素"><a href="#数组中的第K个最大的元素" class="headerlink" title="数组中的第K个最大的元素"></a>数组中的第K个最大的元素</h4><p>&emsp;&emsp;力扣：<br><a href="https://leetcode-cn.com/problems/kth-largest-element-in-an-array/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/kth-largest-element-in-an-array/</a><br>&emsp;&emsp;这道题就利用优先级队列找到第k个大的元素即可，也可以先排序后再找。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int findKthLargest(vector&lt;int&gt;&amp; nums, int k) &#123;</span><br><span class="line">        priority_queue&lt;int&gt; que(nums.begin(), nums.end());</span><br><span class="line">        for(int i = 0; i &lt; k - 1; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            que.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        return que.top();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h4 id="前K个高频元素"><a href="#前K个高频元素" class="headerlink" title="前K个高频元素"></a>前K个高频元素</h4><p>力扣：<br><a href="https://leetcode-cn.com/problems/top-k-frequent-elements/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/top-k-frequent-elements/</a><br>&emsp;&emsp;这道题做起来不难，但是是对优先级队列较为综合的运用，我们要考虑到TOPK问题中找前K大要用小根堆，还要考虑到要将出现次数与元素本身联系起来要在优先级队列中存储<code>pair</code>。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; topKFrequent(vector&lt;int&gt;&amp; nums, int k) &#123;</span><br><span class="line">        map&lt;int, int&gt; m;</span><br><span class="line">        for(int i = 0; i &lt; nums.size(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            m[nums[i]]++;</span><br><span class="line">        &#125;</span><br><span class="line">        //topK问题求前K大一定要用小根堆，维护K个数据</span><br><span class="line">        //用大根堆要放入全部数据费时费空间</span><br><span class="line">        priority_queue&lt;pair&lt;int, int&gt;, vector&lt;pair&lt;int, int&gt;&gt;, greater&lt;pair&lt;int, int&gt;&gt;&gt; que;</span><br><span class="line">        for(auto e : m)</span><br><span class="line">        &#123;</span><br><span class="line">            if(que.size() &gt;= k)</span><br><span class="line">            &#123;</span><br><span class="line">                if(e.second &gt; que.top().first)</span><br><span class="line">                &#123;</span><br><span class="line">                    que.pop();</span><br><span class="line">                    que.push(make_pair(e.second, e.first));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">            &#123;</span><br><span class="line">                que.push(make_pair(e.second, e.first)); </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        vector&lt;int&gt; res(k);</span><br><span class="line">        while(!que.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            res[que.size() - 1] = que.top().second;</span><br><span class="line">            que.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>&emsp;&emsp;依旧是实现常用接口，了解底层原理。</p>
<h3 id="stack类的实现"><a href="#stack类的实现" class="headerlink" title="stack类的实现"></a>stack类的实现</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">#pragma once</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;deque&gt;</span><br><span class="line">template&lt;class T, class Container = std::deque&lt;T&gt;&gt;</span><br><span class="line">class Stack</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    void Push(const T&amp; data)</span><br><span class="line">    &#123;</span><br><span class="line">        _con.push_back(data);</span><br><span class="line">    &#125;</span><br><span class="line">    void Pop()</span><br><span class="line">    &#123;</span><br><span class="line">        _con.pop_back();</span><br><span class="line">    &#125;</span><br><span class="line">    bool Empty()</span><br><span class="line">    &#123;</span><br><span class="line">        return _con.empty();</span><br><span class="line">    &#125;</span><br><span class="line">    size_t Size()</span><br><span class="line">    &#123;</span><br><span class="line">        return _con.size();</span><br><span class="line">    &#125;</span><br><span class="line">    T&amp; Top()</span><br><span class="line">    &#123;</span><br><span class="line">        return _con.back();</span><br><span class="line">    &#125;</span><br><span class="line">    const T&amp; Top() const</span><br><span class="line">    &#123;</span><br><span class="line">        return _con.back();</span><br><span class="line">    &#125;</span><br><span class="line">private:</span><br><span class="line">    Container _con;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="queue的实现"><a href="#queue的实现" class="headerlink" title="queue的实现"></a>queue的实现</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">#pragma once</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;deque&gt;</span><br><span class="line">template&lt;class T, class Container = std::deque&lt;T&gt;&gt;</span><br><span class="line">class Queue</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    void Push(const T&amp; data)</span><br><span class="line">    &#123;</span><br><span class="line">        _con.push_back(data);</span><br><span class="line">    &#125;</span><br><span class="line">    void Pop()</span><br><span class="line">    &#123;</span><br><span class="line">        _con.pop_front();</span><br><span class="line">    &#125;</span><br><span class="line">    size_t Size()</span><br><span class="line">    &#123;</span><br><span class="line">        return _con.size();</span><br><span class="line">    &#125;</span><br><span class="line">    bool Empty()</span><br><span class="line">    &#123;</span><br><span class="line">        return _con.empty();</span><br><span class="line">    &#125;</span><br><span class="line">    T&amp; Back()</span><br><span class="line">    &#123;</span><br><span class="line">        return _con.back();</span><br><span class="line">    &#125;</span><br><span class="line">    const T&amp; Back() const</span><br><span class="line">    &#123;</span><br><span class="line">        return _con.back();</span><br><span class="line">    &#125;</span><br><span class="line">    T&amp; Front()</span><br><span class="line">    &#123;</span><br><span class="line">        return _con.front();</span><br><span class="line">    &#125;</span><br><span class="line">    const T&amp; Front() const</span><br><span class="line">    &#123;</span><br><span class="line">        return _con.front();</span><br><span class="line">    &#125;</span><br><span class="line">private:</span><br><span class="line">    Container _con;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="priority-queue的实现"><a href="#priority-queue的实现" class="headerlink" title="priority_queue的实现"></a>priority_queue的实现</h3><p>&emsp;&emsp;在SGI版本的<code>priority_queue</code>中建堆以及调整堆都是调用的<code>algorithm</code>中的算法函数完成的，但是在模拟实现中我们完全自己实现。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line">#pragma once</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;functional&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">template&lt;class T&gt;</span><br><span class="line">struct Less</span><br><span class="line">&#123;</span><br><span class="line">    bool operator()(const T&amp; obj1, const T&amp; obj2)</span><br><span class="line">    &#123;</span><br><span class="line">        return obj1 &lt; obj2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">template&lt;class T&gt;</span><br><span class="line">struct Greater</span><br><span class="line">&#123;</span><br><span class="line">    bool operator()(const T&amp; obj1, const T&amp; obj2)</span><br><span class="line">    &#123;</span><br><span class="line">        return obj1 &gt; obj2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">template&lt;class T, class Container = std::vector&lt;T&gt;, class Compare = Less&lt;T&gt;&gt;</span><br><span class="line">class Priority_queue</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    //向下调整</span><br><span class="line">    void AdjustDown(size_t parent)</span><br><span class="line">    &#123;</span><br><span class="line">        size_t child = parent * 2 + 1;</span><br><span class="line">        Compare com;</span><br><span class="line">        while(child &lt; _con.size())</span><br><span class="line">        &#123;</span><br><span class="line">            if(child + 1 &lt; _con.size() &amp;&amp; com(_con[child], _con[child + 1]))</span><br><span class="line">            &#123;</span><br><span class="line">                child++;    </span><br><span class="line">            &#125;</span><br><span class="line">            if(com(_con[parent], _con[child]))</span><br><span class="line">            &#123;</span><br><span class="line">                std::swap(_con[parent], _con[child]);</span><br><span class="line">                parent = child;</span><br><span class="line">                child = parent * 2 + 1;    </span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">            &#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    //向上调整</span><br><span class="line">    void AdjustUp(size_t child)</span><br><span class="line">    &#123;</span><br><span class="line">        size_t parent = (child - 1) / 2;</span><br><span class="line">        Compare com;</span><br><span class="line">        while(child &gt; 0)</span><br><span class="line">        &#123;</span><br><span class="line">            if(com(_con[parent], _con[child]))</span><br><span class="line">            &#123;</span><br><span class="line">                std::swap(_con[parent], _con[child]);</span><br><span class="line">                child = parent;</span><br><span class="line">                parent = (child - 1) / 2;</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">            &#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    void Push(const T&amp; data)</span><br><span class="line">    &#123;</span><br><span class="line">        _con.push_back(data);</span><br><span class="line">        //模拟push_heap()的功能</span><br><span class="line">        AdjustUp(_con.size() - 1);</span><br><span class="line">    &#125;</span><br><span class="line">    void Pop()</span><br><span class="line">    &#123;</span><br><span class="line">        //模拟pop_heap()的功能</span><br><span class="line">        std::swap(_con[0], _con[_con.size() - 1]);</span><br><span class="line">        _con.pop_back();</span><br><span class="line">        AdjustDown(0);</span><br><span class="line">    &#125;</span><br><span class="line">    size_t Size()</span><br><span class="line">    &#123;</span><br><span class="line">        return _con.size();</span><br><span class="line">    &#125;</span><br><span class="line">    bool Empty()</span><br><span class="line">    &#123;</span><br><span class="line">        return _con.empty();</span><br><span class="line">    &#125;</span><br><span class="line">    T&amp; Top()</span><br><span class="line">    &#123;</span><br><span class="line">        return _con.front();</span><br><span class="line">    &#125;</span><br><span class="line">    const T&amp; Top() const</span><br><span class="line">    &#123;</span><br><span class="line">        return _con.front();</span><br><span class="line">    &#125;</span><br><span class="line">//private:</span><br><span class="line">    Container _con;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>

          
        
      
    </div>
    
    
    

    

    <div>
    
    </div>

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/07/30/【Cpp】第八章-STL-deque类/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="MisakiFx">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/blog-logo.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Misaki`s blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/07/30/【Cpp】第八章-STL-deque类/" itemprop="url">【Cpp】第八章-STL_deque类</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-07-30T16:39:49+08:00">
                2019-07-30
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Cpp/" itemprop="url" rel="index">
                    <span itemprop="name">Cpp</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  1.4k
                </span>
              

              

              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="deque类"><a href="#deque类" class="headerlink" title="deque类"></a>deque类</h1><h2 id="基础介绍"><a href="#基础介绍" class="headerlink" title="基础介绍"></a>基础介绍</h2><p>&emsp;&emsp;<code>deque</code>是双端队列，它提供了和<code>vector</code>类似的接口但是底层的实现与<code>vector</code>完全不同，<code>vector</code>底层用三个指针指向数组的起点，尾部和总容量的尾部，并且所有元素都是连续的，但是在<code>deque</code>中所有元素并不一定都是在连续的内存空间上的。<code>deque</code>在底层实现上是将一个连续的空间分段进行管理，并将它们的首地址用一个指针数组进行管理，这样特殊的存储结构使得它在头部和尾部增加元素比<code>vector</code>更加高效，但是底层实现更为复杂，存储了很多额外信息。如果抛去在头部和尾部增加元素，在中间任意位置添加元素，它的效率比vector更高，但是比list要低。</p>
<h2 id="常用接口"><a href="#常用接口" class="headerlink" title="常用接口"></a>常用接口</h2><h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">deque();                                                  //构造空的双端队列</span><br><span class="line">deque(size_type n, const value_type &amp;val = value_type()); //用n个值为val的元素构造双端队列</span><br><span class="line">deque(InputIterator first, InputIterator last);           //用[first, last)的区间构造双端队列</span><br><span class="line">deque(const deque &amp;x);                                    //双端队列的拷贝构造函数</span><br></pre></td></tr></table></figure>
<h3 id="迭代器相关"><a href="#迭代器相关" class="headerlink" title="迭代器相关"></a>迭代器相关</h3><p>&emsp;&emsp;由于<code>deque</code>在内存上并不完全是连续的因此想要保持deque的连续性，这个任务就落到了迭代器身上。在底层实现上，<code>deque</code>将一段一段连续的内存称为一个缓冲区(buffer)，并将这些缓冲区的首尾地址存储在一个map中用以映射，map中一个存储缓冲区的地址对应一个结点(node)信息用于标记这个键值对，这样就构建好了基础架构。在迭代器中存储了4个信息，分别是当前结点(cur)，当前缓冲区的头(first)，当前缓冲区的尾(last)以及在map中用以标记当前缓冲区的地址的结点(node)信息。并且在<code>deque</code>内部已经存储好了两个迭代器<code>start</code>和<code>finish</code>用于标记<code>deque</code>的头和尾元素。这样即可完成将一段一段连续的空间在逻辑结构上构成一段连续空间的目的。<br>&emsp;&emsp;当从头遍历<code>deque</code>时，<code>start</code>迭代器中<code>first</code>和<code>last</code>已经从map中找到了第一个结点的缓冲区首尾信息并进行了保存，于是<code>cur</code>就从<code>first</code>开始遍历这个缓冲区，当遍历到<code>last</code>时就重新到map中寻找写一个结点的缓冲区收尾地址并且替换掉原来<code>first</code>和<code>last</code>值，继续遍历，这样即可完成遍历直到最后一个结点也遍历完。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">iterator begin();                       //返回deque起始位置迭代器</span><br><span class="line">iterator end();                         //返回deque最后一个元素下一个位置的迭代器</span><br><span class="line">reverse_iterator rbegin();              //返回deque起始位置的反向迭代器(即end())</span><br><span class="line">reverse_iterator rend();                //返回deque最后一个元素下一个位置的反向迭代器(begin())</span><br><span class="line">const_iterator cbegin() const;          //返回deque起始位置的const迭代器</span><br><span class="line">const_iterator cend() const;            //返回deque最后一个元素下一个位置的const迭代器</span><br><span class="line">const_reverse_iterator crbegin() const; //返回deque起始位置的const反向迭代器(即crend())</span><br><span class="line">const_reverse_iterator crend() const;   //返回deque最后一个元素下一个位置的const反向迭代器(crbegin())</span><br></pre></td></tr></table></figure></p>
<h3 id="容量相关"><a href="#容量相关" class="headerlink" title="容量相关"></a>容量相关</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">size_type size() const;               //返回deque中有效元素个数</span><br><span class="line">bool empty() const;                   //检测deque是否为空，是返回true，否则返回false</span><br><span class="line">void resize(size_type sz, T c = T()); //将deque中的元素改变到sz，多出的空间用c填充</span><br></pre></td></tr></table></figure>
<h3 id="增删改查"><a href="#增删改查" class="headerlink" title="增删改查"></a>增删改查</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">reference operator[](size_type n);                         //返回deque中n位置上元素的引用</span><br><span class="line">const_reference operator[](size_type n) const;             //返回deque中n位置上元素的const 引用</span><br><span class="line">reference front();                                         //返回deque中首元素的引用</span><br><span class="line">const_reference front() const;                             //返回deque中首元素的const引用</span><br><span class="line">reference back();                                          //返回deque中最后一个元素的引用</span><br><span class="line">const_reference back() const;                              //返回deque中最后一个元素的const引用</span><br><span class="line">void push_back(const value_type &amp;val);                     //deque尾部插入元素val</span><br><span class="line">void pop_back();                                           //删除deque尾部元素</span><br><span class="line">void push_front(const value_type &amp;val);                    //deque头部插入元素val</span><br><span class="line">void pop_front();                                          //删除deque头部元素</span><br><span class="line">iterator insert(iterator position, const value_type &amp;val); //在deque的position位置插入值为val的元素</span><br><span class="line">void insert(iterator position, size_type n,</span><br><span class="line">            const value_type &amp;val);                                      //在deque的position位置插入n个值为val的元素</span><br><span class="line">void insert(iterator position, InputIterator first, InputIterator last); //在deque的position位置插入[first, last)区间中的元素</span><br><span class="line">iterator erase(iterator position);                                       //删除deque中position位置的元素，并返回该位置的下一个位置</span><br><span class="line">iterator erase(iterator first, iterator last);                           //删除deque中[first, last)区间中的元素，并返回last位置</span><br><span class="line">void swap(deque &amp; x);                                                    //交换两个deque中的内容</span><br><span class="line">void clear();                                                            //将deque中的元素清空</span><br><span class="line">iterator emplace(const_iterator position, Args &amp;&amp; ... args);             //在deque的position位置构造元素，将元素所需内容通过参数类表传入</span><br><span class="line">void emplace_front(Args &amp;&amp; ... args);                                    //在deque的头部构造元素，元素的参数通过参数列表传入</span><br><span class="line">void emplace_back(Args &amp;&amp; ... args);                                     //在deque的尾部构造元素，元素的参数通过参数列表传入</span><br></pre></td></tr></table></figure>
<h3 id="综合运用"><a href="#综合运用" class="headerlink" title="综合运用"></a>综合运用</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;deque&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    deque&lt;int&gt; deq;</span><br><span class="line">    deq.push_front(1);</span><br><span class="line">    deq.push_back(2);</span><br><span class="line">    deque&lt;int&gt;::iterator it = deq.begin();</span><br><span class="line">    it = deq.insert(it, 0);</span><br><span class="line">    while(it != deq.end())</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; *it &lt;&lt; endl;</span><br><span class="line">        it++;</span><br><span class="line">    &#125;</span><br><span class="line">    it = deq.erase(--it);</span><br><span class="line">    it = deq.begin();</span><br><span class="line">    while(it != deq.end())</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; *it &lt;&lt; endl;</span><br><span class="line">        it++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>&emsp;&emsp;双端队列<code>deque</code>是一个设计并不算成功的容器，如果要随机访问单纯的查询多一点可以用<code>vector</code>而且更加方便，如果需要频繁插入那么<code>list</code>效率又会跟高，因此<code>deque</code>并不常用，其最常用的地方就是在作为适配器<code>stack</code>和<code>queue</code>的底层存储容器。</p>

          
        
      
    </div>
    
    
    

    

    <div>
    
    </div>

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/07/29/【Cpp】第七章-STL-list类/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="MisakiFx">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/blog-logo.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Misaki`s blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/07/29/【Cpp】第七章-STL-list类/" itemprop="url">【Cpp】第七章-STL_list类</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-07-29T23:12:49+08:00">
                2019-07-29
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Cpp/" itemprop="url" rel="index">
                    <span itemprop="name">Cpp</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  2.2k
                </span>
              

              

              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="list类"><a href="#list类" class="headerlink" title="list类"></a>list类</h1><h2 id="基础介绍"><a href="#基础介绍" class="headerlink" title="基础介绍"></a>基础介绍</h2><p>&emsp;&emsp;<code>list类</code>是STL中封装的链表模板类，并且底层实现是以双向链表作为基础进行封装的。在数据结构中，线性存储结构中主要分为顺序表和链表，前者在物理结构上拥有连续的内存空间和地址，在STL中<code>vector</code>和<code>string</code>都是使用了这种结构，其最大的特点就是方便进行随机访问并且尾插和尾删都能达到O1的时间复杂度并且使用方便，而链表作为物理结构上内存空间不连续的数据结构，其最大的特点就是方便在任何位置就行插入删除，<code>list</code>就是建立在此数据结构上封装出的模板类。</p>
<h2 id="常用接口"><a href="#常用接口" class="headerlink" title="常用接口"></a>常用接口</h2><h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">list();                                                  //构造空的list</span><br><span class="line">list(size_type n, const value_type &amp;val = value_type()); //构造的list中包含n个值为val的元素</span><br><span class="line">list(const list &amp;x);                                     //拷贝构造函数</span><br><span class="line">list(InputIterator first, InputIterator last);           //用[first, last)区间中的元素构造list</span><br></pre></td></tr></table></figure>
<h3 id="迭代器相关"><a href="#迭代器相关" class="headerlink" title="迭代器相关"></a>迭代器相关</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">begin();   //返回第一个元素的迭代器</span><br><span class="line">end();     //返回最后一个元素下一个位置的迭代器</span><br><span class="line">rbegin();  //返回第一个元素的reverse_iterator,即end位置</span><br><span class="line">rend();    //返回最后一个元素下一个位置的reverse_iterator,即begin位置</span><br><span class="line">cbegin();  //(C++11) 返回第一个元素的cosnt_iterator</span><br><span class="line">cend();    //(C++11) 返回最后一个元素下一个位置的const_iterator</span><br><span class="line">crbegin(); //(C++11) 即crend()位置</span><br><span class="line">crend();   //(C++11) 即crbegin()位置</span><br></pre></td></tr></table></figure>
<h3 id="容量相关"><a href="#容量相关" class="headerlink" title="容量相关"></a>容量相关</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">bool empty() const;  //检测list是否为空，是返回true，否则返回false</span><br><span class="line">size_t size() const; //返回list中有效节点的个数</span><br></pre></td></tr></table></figure>
<h3 id="增删查改"><a href="#增删查改" class="headerlink" title="增删查改"></a>增删查改</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">reference front();                      //返回list的第一个节点中值的引用</span><br><span class="line">const_reference front() const;          //返回list的第一个节点中值的const引用</span><br><span class="line">reference back();                       //返回list的最后一个节点中值的引用</span><br><span class="line">const_reference back() const;           //返回list的最后一个节点中值的const引用</span><br><span class="line">void push_front(const value_type &amp;val); //在list首元素前插入值为val的元素</span><br><span class="line">void pop_front();                       //删除list中第一个元素</span><br><span class="line">void push_back;                         //(const value_type&amp; val)在list尾部插入值为val的元素</span><br><span class="line">void pop_back();                        //删除list中最后一个元素</span><br><span class="line">template &lt;class... Args&gt;</span><br><span class="line">void emplace_front(Args &amp;&amp; ... args); //（C++11）在list第一个元素前根据参数直接构造元素</span><br><span class="line">template &lt;class... Args&gt;</span><br><span class="line">void emplace_back(Args &amp;&amp; ... args); //（C++11）在list最后一个元素后根据参数直接构造元素</span><br><span class="line">template &lt;class... Args&gt;</span><br><span class="line">iterator emplace(const_iterator position, Args &amp;&amp; ... args);             //（C++11）在链表的任意位置根据参数直接构造元素</span><br><span class="line">iterator insert(iterator position, const value_type &amp;val);               //在list position 位置中插入值为val的元素</span><br><span class="line">void insert(iterator position, size_type n, const value_type &amp;val);      //在list position位置插入n个值为val的元素</span><br><span class="line">void insert(iterator position, InputIterator first, InputIterator last); //在list position位置插入[first, last)区间中元素</span><br><span class="line">iterator erase(iterator position);                                       //删除list position位置的元素</span><br><span class="line">iterator erase(iterator first, iterator last);                           //删除list中[first, last)区间中的元素</span><br><span class="line">void swap(list &amp; x);                                                     //交换两个list中的元素</span><br><span class="line">void resize(size_type n, value_type val = value_type());                 //将list中有效元素个数改变到n个，多出的元素用val填充</span><br><span class="line">void clear();                                                            //清空list中的有效元素</span><br></pre></td></tr></table></figure>
<h2 id="emplace与insert"><a href="#emplace与insert" class="headerlink" title="emplace与insert"></a>emplace与insert</h2><p>&emsp;&emsp;在STL很多接口中我们都发现有一个<code>emplace()</code>的接口也是用来进行插入的，那么它与<code>insert()</code>和<code>push_back()</code>有什么区别呢？以下用<code>vector</code>举个例子，从接口调用上就能看出区别。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    struct Foo </span><br><span class="line">    &#123;</span><br><span class="line">        Foo(int n, double x)</span><br><span class="line">            :_n(n)</span><br><span class="line">            ,_x(x)</span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        int _n;</span><br><span class="line">        double _x;</span><br><span class="line">    &#125;;</span><br><span class="line">    vector&lt;Foo&gt; v;</span><br><span class="line">    v.emplace(v.begin(), 42, 3.1416);     // 没有临时变量产生</span><br><span class="line">    v.insert(v.begin(), Foo(42, 3.1416)); // 需要产生一个临时变量</span><br><span class="line">    v.insert(v.begin(), &#123;42, 3.1416&#125;);    // 需要产生一个临时变量</span><br><span class="line">    for(int i = 0; i &lt; v.size(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; v[i]._n &lt;&lt; &quot; &quot; &lt;&lt; v[i]._x &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">42 3.1416</span><br><span class="line">42 3.1416</span><br><span class="line">42 3.1416</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;在进行内置类型和拥有单参构造函数的类型的插入时我们只传入一个参数往往很难发现区别，但在我们必须传入多个参数才能进行插入时我们就会发现在使用<code>insert()</code>这些接口时我们必须插入与容器中元素类型相同的<strong>元素</strong>才能完成接口调用，这让我们不得不构造一个临时匿名对象，而<code>emplace</code>则不需要，我们只要按照构造一个对象那样给构造元素的参数即可省去了构造匿名对象的过程。而这其中需要用到<code>C++11</code>中的新标准<strong>变参模板</strong>和<strong>完美转发</strong>，因此<code>emplace</code>使用的时候要求编译器支持<code>C++11</code>标准。<br>&emsp;&emsp;<code>emplace</code>不光是调用接口上有所不同，在有的时候也可以提高我们的效率。例如在<code>list</code>中如果利用<code>insert</code>传入一个元素的时候我们就需要先调用元素的构造函数构造元素，然后再调用<code>Node</code>的构造函数以及该元素的拷贝构造函数构造一个拥有该元素值的结点，才能进行插入，而<code>emplace</code>则可以在创建结点时直接利用原本要构造临时元素对象的参数来直接构造结点，并且直接构造结点中的元素对象，<strong>相当于少了一次元素的拷贝构造，并且省去了构造临时对象，效率更高</strong>。</p>
<h2 id="list迭代器失效"><a href="#list迭代器失效" class="headerlink" title="list迭代器失效"></a>list迭代器失效</h2><p>&emsp;&emsp;对于<code>list</code>这种链式结构，在插入后是不会迭代器失效的，因为原先位置的迭代器依旧指向原来的结点，不会因为添加结点导致指向位置的变动。而在删除后迭代器原本指向的结点内存被释放，因此删除后删除结点的迭代器失效，但是其他结点迭代器指向不变因此不会发生迭代器失效。<br>&emsp;&emsp;总结：<strong>list只有在删除节点后才会发生迭代器失效，并且之后删除结点的迭代器失效</strong>。</p>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>&emsp;&emsp;<code>list</code>采用链式结构存储，因此实现起来要稍微麻烦一些，迭代器也需要额外进行封装。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;assert.h&gt;</span><br><span class="line">//定义结点类</span><br><span class="line">template&lt;class T&gt;</span><br><span class="line">struct ListNode</span><br><span class="line">&#123;</span><br><span class="line">    ListNode&lt;T&gt;* _prev;</span><br><span class="line">    ListNode&lt;T&gt;* _next;</span><br><span class="line">    T _data;</span><br><span class="line">    ListNode(const T&amp; data = T())</span><br><span class="line">        :_prev(nullptr)</span><br><span class="line">        ,_next(nullptr)</span><br><span class="line">        ,_data(data)</span><br><span class="line">    &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line">//由于const_iterator与iterator除了在迭代器返回值上不一样外其他要求完全一样</span><br><span class="line">//因此这里要进行实现时可以考虑定义两个类</span><br><span class="line">//但是这里使用一种取巧的方法我们将返回值类型当作模板参数传入模板中</span><br><span class="line">template&lt;class T, class Ref, class Ptr&gt;</span><br><span class="line">struct ListIterator</span><br><span class="line">&#123;</span><br><span class="line">    typedef ListNode&lt;T&gt; Node;</span><br><span class="line">    typedef ListIterator&lt;T, Ref, Ptr&gt; Self;</span><br><span class="line">    //构造函数</span><br><span class="line">    ListIterator(Node* node)</span><br><span class="line">        :_node(node)</span><br><span class="line">    &#123;&#125;</span><br><span class="line">    //operator* 为了让其可以和指针一样使用，返回引用</span><br><span class="line">    Ref operator*()</span><br><span class="line">    &#123;</span><br><span class="line">        return _node-&gt;_data;</span><br><span class="line">    &#125;</span><br><span class="line">    //operator-&gt; 为了让其可以和指针一样使用，返回指针</span><br><span class="line">    //这里实际调用it-&gt;只能取到数据的指针，所以正常来说得写成it-&gt;-&gt;</span><br><span class="line">    //但是经过编译器优化，只用写it-&gt;就可以取到值了</span><br><span class="line">    Ptr operator-&gt;()</span><br><span class="line">    &#123;</span><br><span class="line">        return &amp;(_node-&gt;_data);</span><br><span class="line">    &#125;</span><br><span class="line">    Self operator++()</span><br><span class="line">    &#123;</span><br><span class="line">        _node = _node-&gt;_next;</span><br><span class="line">        return _node;    </span><br><span class="line">    &#125;</span><br><span class="line">    Self operator++(int)</span><br><span class="line">    &#123;</span><br><span class="line">        Self temp(_node);</span><br><span class="line">        _node = _node-&gt;_next;</span><br><span class="line">        return temp;</span><br><span class="line">    &#125; </span><br><span class="line">    Self operator--()</span><br><span class="line">    &#123;</span><br><span class="line">        _node = _node-&gt;_prev;</span><br><span class="line">        return _node;    </span><br><span class="line">    &#125;</span><br><span class="line">    Self operator--(int)</span><br><span class="line">    &#123;</span><br><span class="line">        Self temp(_node);</span><br><span class="line">        _node = _node-&gt;_prev;</span><br><span class="line">        return temp;</span><br><span class="line">    &#125; </span><br><span class="line">    bool operator!=(Self it)</span><br><span class="line">    &#123;</span><br><span class="line">        return _node != it._node;</span><br><span class="line">    &#125;</span><br><span class="line">    Node* _node;</span><br><span class="line">&#125;;</span><br><span class="line">//构建一个带头结点双向循环链表来模拟实现list</span><br><span class="line">template&lt;class T&gt;</span><br><span class="line">class List</span><br><span class="line">&#123;</span><br><span class="line">    typedef ListNode&lt;T&gt; Node;</span><br><span class="line">public:</span><br><span class="line">    typedef ListIterator&lt;T, T&amp;, T*&gt; iterator;</span><br><span class="line">    typedef ListIterator&lt;T, const T&amp;, const T*&gt; const_iterator;</span><br><span class="line">    //构造函数j</span><br><span class="line">    List()</span><br><span class="line">    &#123;</span><br><span class="line">        _head = new Node;</span><br><span class="line">        _head-&gt;_next = _head;</span><br><span class="line">        _head-&gt;_prev = _head;</span><br><span class="line">    &#125;</span><br><span class="line">    //拷贝构造</span><br><span class="line">    List(const List&amp; list)</span><br><span class="line">        :_head(new Node)</span><br><span class="line">    &#123;</span><br><span class="line">        _head-&gt;_next = _head;</span><br><span class="line">        _head-&gt;_prev = _head;</span><br><span class="line">        const_iterator it = list.begin();</span><br><span class="line">        while(it != list.end())</span><br><span class="line">        &#123;</span><br><span class="line">            Push_back(*it);</span><br><span class="line">            it++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    //operator=重载</span><br><span class="line">    List&amp; operator=(const List&amp; list)</span><br><span class="line">    &#123;</span><br><span class="line">        List listTemp = list;</span><br><span class="line">        Swap(listTemp);</span><br><span class="line">    &#125;</span><br><span class="line">    //交换</span><br><span class="line">    void Swap(List&amp; list)</span><br><span class="line">    &#123;</span><br><span class="line">        std::swap(_head, list._head);</span><br><span class="line">    &#125;</span><br><span class="line">    //析构函数</span><br><span class="line">    ~List()</span><br><span class="line">    &#123;</span><br><span class="line">        </span><br><span class="line">        while(_head-&gt;_next != _head)</span><br><span class="line">        &#123;</span><br><span class="line">            Pop_back();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    iterator begin()</span><br><span class="line">    &#123;</span><br><span class="line">        return _head-&gt;_next;</span><br><span class="line">    &#125;</span><br><span class="line">    const_iterator begin() const</span><br><span class="line">    &#123;</span><br><span class="line">        return _head-&gt;_next;</span><br><span class="line">    &#125;</span><br><span class="line">    iterator end()</span><br><span class="line">    &#123;</span><br><span class="line">        return _head;</span><br><span class="line">    &#125;</span><br><span class="line">    const_iterator end() const</span><br><span class="line">    &#123;</span><br><span class="line">        return _head;</span><br><span class="line">    &#125;</span><br><span class="line">    iterator Erase(iterator&amp; it)</span><br><span class="line">    &#123;</span><br><span class="line">        assert(it._node != nullptr);</span><br><span class="line">        Node* pTemp = it._node;</span><br><span class="line">        Node* pNew = pTemp-&gt;_next;</span><br><span class="line">        //it-&gt;_node = pTemp-&gt;_next;</span><br><span class="line">        pTemp-&gt;_prev-&gt;_next = pTemp-&gt;_next;</span><br><span class="line">        pTemp-&gt;_next-&gt;_prev = pTemp-&gt;_prev;</span><br><span class="line">        delete pTemp;</span><br><span class="line">        return pNew;</span><br><span class="line">    &#125;</span><br><span class="line">    //插入</span><br><span class="line">    iterator Insert(iterator&amp; it, const T&amp; data = T())</span><br><span class="line">    &#123;</span><br><span class="line">        assert(it._node != nullptr);</span><br><span class="line">        Node* newNode = new Node(data);</span><br><span class="line">        newNode-&gt;_next = it._node;</span><br><span class="line">        newNode-&gt;_prev = it._node-&gt;_prev;</span><br><span class="line">        it._node-&gt;_prev-&gt;_next = newNode;</span><br><span class="line">        it._node-&gt;_prev  = newNode;</span><br><span class="line">        return newNode;</span><br><span class="line">    &#125;</span><br><span class="line">    //尾插</span><br><span class="line">    void Push_back(const T&amp; data)</span><br><span class="line">    &#123;</span><br><span class="line">        assert(_head != nullptr);</span><br><span class="line">        Node* tail = _head-&gt;_prev;</span><br><span class="line">        Node* newNode = new Node(data);</span><br><span class="line">        newNode-&gt;_next = _head;</span><br><span class="line">        newNode-&gt;_prev = tail;</span><br><span class="line">        tail-&gt;_next = newNode;</span><br><span class="line">        _head-&gt;_prev = newNode;</span><br><span class="line">    &#125;</span><br><span class="line">    //尾删</span><br><span class="line">    void Pop_back()</span><br><span class="line">    &#123;</span><br><span class="line">        assert(_head != nullptr);</span><br><span class="line">        if(_head-&gt;_next == _head)</span><br><span class="line">        &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        Node* tail = _head-&gt;_prev;</span><br><span class="line">        tail-&gt;_prev-&gt;_next = _head;</span><br><span class="line">        _head-&gt;_prev = tail-&gt;_prev;</span><br><span class="line">        delete tail;</span><br><span class="line">    &#125;</span><br><span class="line">private:</span><br><span class="line">    Node* _head;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>

          
        
      
    </div>
    
    
    

    

    <div>
    
    </div>

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/07/27/【算法】第二章-搜索/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="MisakiFx">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/blog-logo.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Misaki`s blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/07/27/【算法】第二章-搜索/" itemprop="url">【算法】第二章-搜索</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-07-27T17:46:48+08:00">
                2019-07-27
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/算法/" itemprop="url" rel="index">
                    <span itemprop="name">算法</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  2.2k
                </span>
              

              

              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="搜索"><a href="#搜索" class="headerlink" title="搜索"></a>搜索</h1><h2 id="深度优先搜索-DFS"><a href="#深度优先搜索-DFS" class="headerlink" title="深度优先搜索(DFS)"></a>深度优先搜索(DFS)</h2><p>&emsp;&emsp;深度优先搜索是使用递归的方式以深度为主逐个探索遍历每种情况，在排列组合，迷宫问题中十分常用。深度优先搜索思想简单，但是由于使用递归，要求我们遍历时探索的必须深度有限。不然有可能会使栈溢出。还要注意有时我们在使用深度优先搜索时情况过多，而大部分是无用解时就需要套入<strong>剪枝</strong>。<br>&emsp;&emsp;模型：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">DFS()</span><br><span class="line">&#123;</span><br><span class="line">    //1.判断边界，如果已经到达搜索的最深，则回退尝试其他可能</span><br><span class="line">    //2.尝试当下的每一种可能</span><br><span class="line">    //3.确定一种可能后，继续下一步</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="例1-员工的重要度"><a href="#例1-员工的重要度" class="headerlink" title="例1 员工的重要度"></a>例1 员工的重要度</h3><p>&emsp;&emsp;力扣：<br><a href="https://leetcode-cn.com/problems/employee-importance/submissions/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/employee-importance/submissions/</a></p>
<h4 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h4><p>&emsp;&emsp;抽象模型。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">DFS(id)</span><br><span class="line">&#123;</span><br><span class="line">    //1.获取当前员工的重要度</span><br><span class="line">    //2.累加每一个下属(for)的重要度,DFS(下属id)</span><br><span class="line">    //3.return累加的重要度</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int DFS(unordered_map&lt;int, Employee*&gt; em, int id)</span><br><span class="line">    &#123;</span><br><span class="line">        int curRet = em[id]-&gt;importance;</span><br><span class="line">        for(auto&amp; e : em[id]-&gt;subordinates)</span><br><span class="line">        &#123;</span><br><span class="line">            curRet += DFS(em, e);</span><br><span class="line">        &#125;</span><br><span class="line">        return curRet;</span><br><span class="line">    &#125;</span><br><span class="line">    int getImportance(vector&lt;Employee*&gt; employees, int id) &#123;</span><br><span class="line">        if(employees.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        unordered_map&lt;int, Employee*&gt; em;</span><br><span class="line">        for(auto&amp; e: employees)</span><br><span class="line">        &#123;</span><br><span class="line">            em[e-&gt;id] = e;</span><br><span class="line">        &#125;</span><br><span class="line">        return DFS(em, id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="例2-图像渲染"><a href="#例2-图像渲染" class="headerlink" title="例2 图像渲染"></a>例2 图像渲染</h3><p>&emsp;&emsp;力扣：<br><a href="https://leetcode-cn.com/problems/flood-fill/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/flood-fill/</a></p>
<h4 id="解析-1"><a href="#解析-1" class="headerlink" title="解析"></a>解析</h4><p>&emsp;&emsp;抽象模型。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">DFS()</span><br><span class="line">&#123;</span><br><span class="line">    //1.nx,ny染色</span><br><span class="line">    //2.处理上，下，左，右4个点</span><br><span class="line">    &#123;</span><br><span class="line">        //以深度优先逐个方向遍历周边4个点</span><br><span class="line">        //新位置颜色符合，且没有越界，且没有染过色</span><br><span class="line">        //符合条件处理新位置</span><br><span class="line">        DFS(新的位置)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">static int nextP[4][2] = &#123;&#123;0, 1&#125;, &#123;1, 0&#125;, &#123;0, -1&#125;, &#123;-1, 0&#125;&#125;;</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    void DFS(vector&lt;vector&lt;int&gt;&gt;&amp; image, int row, int col, int nx, int ny, vector&lt;vector&lt;int&gt;&gt; book, int newColor, int oldColor)</span><br><span class="line">    &#123;</span><br><span class="line">        image[nx][ny] = newColor;</span><br><span class="line">        book[nx][ny] = 1;</span><br><span class="line">        //上下左右遍历</span><br><span class="line">        for(int i = 0; i &lt; 4; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            int newx = nx + nextP[i][0];</span><br><span class="line">            int newy = ny + nextP[i][1];</span><br><span class="line">            if(newx &gt;= row || newx &lt; 0 || newy &gt;= col || newy &lt; 0)</span><br><span class="line">            &#123;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">            if(image[newx][newy] == oldColor &amp;&amp; book[newx][newy] == 0)</span><br><span class="line">            &#123;</span><br><span class="line">                DFS(image, row, col, newx, newy, book, newColor, oldColor);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; floodFill(vector&lt;vector&lt;int&gt;&gt;&amp; image, int sr, int sc, int newColor) &#123;</span><br><span class="line">        if(image.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            return image;</span><br><span class="line">        &#125;</span><br><span class="line">        int row = image.size();</span><br><span class="line">        int col = image[0].size();</span><br><span class="line">        int oldColor = image[sr][sc];</span><br><span class="line">        vector&lt;vector&lt;int&gt;&gt; book(row, vector&lt;int&gt;(col, 0));</span><br><span class="line">        DFS(image, row, col, sr, sc, book, newColor, oldColor);</span><br><span class="line">        return image;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="例3-走迷宫"><a href="#例3-走迷宫" class="headerlink" title="例3 走迷宫"></a>例3 走迷宫</h3><p>&emsp;&emsp;牛客：<br><a href="https://www.nowcoder.com/questionTerminal/6276dbbda7094978b0e9ebb183ba37b9" target="_blank" rel="noopener">https://www.nowcoder.com/questionTerminal/6276dbbda7094978b0e9ebb183ba37b9</a></p>
<h4 id="解析-2"><a href="#解析-2" class="headerlink" title="解析"></a>解析</h4><p>&emsp;&emsp;模型：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">DFS()</span><br><span class="line">&#123;</span><br><span class="line">    //1.当前位置已走，路径长度+1，并且置为墙表示走过了</span><br><span class="line">    //2.走到终点，和最短路径长度比较取最优</span><br><span class="line">    //3.遍历四周，如果不是墙且不越界则遍历</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;但是，这种模型在一张只有极少障碍物的迷宫中要消耗很多的时间，因为我们要让每一个结点都被遍历近10次，这其中会消耗大量时间，并且很多是无用的解。因此我们在其中可以加入动态规划的思想。<br>&emsp;&emsp;模型：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">DFS()</span><br><span class="line">&#123;</span><br><span class="line">    //1.遍历四周，如果不是墙且不越界则进行二次判断</span><br><span class="line">    //2.如果本次路径到达这个位置的路径数要小于以往在表中记录的路径数，则将表中最优解进行修改，否则不再遍历此位置。</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="实现-2"><a href="#实现-2" class="headerlink" title="实现"></a>实现</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">//这类迷宫问题不能纯粹使用深度优先搜索，因为要完全遍历一遍很慢，还要加上动态规划算法（剪枝）</span><br><span class="line">//记录到达每个点上的最少步数，如果大于这个步数则不再走这个点，可以剪掉大量冗余无效的走法</span><br><span class="line">using namespace std;</span><br><span class="line">int res[10][10] = &#123; 0 &#125;;</span><br><span class="line">vector&lt;string&gt; mess(10, string(10, 0));</span><br><span class="line">int nextP[4][2] = &#123;&#123;0, 1&#125;, &#123;1, 0&#125;, &#123;0, -1&#125;, &#123;-1, 0&#125;&#125;;</span><br><span class="line">void dfs(int i, int j)</span><br><span class="line">&#123;</span><br><span class="line">    //继续向四周遍历</span><br><span class="line">    for(int m = 0; m &lt; 4; m++)</span><br><span class="line">    &#123;</span><br><span class="line">        int newi = i + nextP[m][0];</span><br><span class="line">        int newj = j + nextP[m][1];</span><br><span class="line">        if(newi &lt; 10 &amp;&amp; newi &gt;= 0 &amp;&amp; newj &lt; 10 &amp;&amp; newj &gt;= 0 &amp;&amp; mess[newi][newj] != &apos;#&apos;)</span><br><span class="line">        &#123;</span><br><span class="line">            if(res[newi][newj] == 0 || res[newi][newj] &gt; res[i][j] + 1)</span><br><span class="line">            &#123;</span><br><span class="line">                res[newi][newj] = res[i][j] + 1;</span><br><span class="line">                dfs(newi, newj);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    while(cin &gt;&gt; mess[0])</span><br><span class="line">    &#123;</span><br><span class="line">        for(int i = 1; i &lt; 10; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            cin &gt;&gt; mess[i];</span><br><span class="line">        &#125;</span><br><span class="line">        dfs(0, 1);</span><br><span class="line">        cout &lt;&lt; res[9][8] &lt;&lt; endl;</span><br><span class="line">        memset(res, 0, sizeof(res));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="广度优先搜索-BFS"><a href="#广度优先搜索-BFS" class="headerlink" title="广度优先搜索(BFS)"></a>广度优先搜索(BFS)</h2><p>&emsp;&emsp;广度优先搜索是以广度为主逐层往外一次遍历，不同于深度优先逐条解进行排列组合，广度优先搜索只会遍历一次所有结点，并且会最先拿到最优解，因此某些情况下广度优先搜索效率优于深度优先搜索。广度优先搜索在迷宫问题的解上效率会更高，在寻找最优解时会更快，因为其不需要列出所有组合的情况。<br>&emsp;&emsp;广度优先搜索在实现时需要借助队列，每一次将下一层要遍历的结点入队，上一层出队。</p>
<h3 id="例1-员工的重要性"><a href="#例1-员工的重要性" class="headerlink" title="例1 员工的重要性"></a>例1 员工的重要性</h3><p>&emsp;&emsp;力扣：<br><a href="https://leetcode-cn.com/problems/employee-importance/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/employee-importance/</a></p>
<h4 id="解析-3"><a href="#解析-3" class="headerlink" title="解析"></a>解析</h4><p>&emsp;&emsp;将要查找的第一个员工入队，之后每次遍历队中元素将其重要度相加，并且将其下属入队。</p>
<h4 id="实现-3"><a href="#实现-3" class="headerlink" title="实现"></a>实现</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">// Employee info</span><br><span class="line">class Employee &#123;</span><br><span class="line">public:</span><br><span class="line">    // It&apos;s the unique ID of each node.</span><br><span class="line">    // unique id of this employee</span><br><span class="line">    int id;</span><br><span class="line">    // the importance value of this employee</span><br><span class="line">    int importance;</span><br><span class="line">    // the id of direct subordinates</span><br><span class="line">    vector&lt;int&gt; subordinates;</span><br><span class="line">&#125;;</span><br><span class="line">*/</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int getImportance(vector&lt;Employee*&gt; employees, int id) &#123;</span><br><span class="line">        unordered_map&lt;int, Employee*&gt; info;</span><br><span class="line">        for(auto&amp; e : employees)</span><br><span class="line">        &#123;</span><br><span class="line">            info[e-&gt;id] = e;</span><br><span class="line">        &#125;</span><br><span class="line">        queue&lt;int&gt; q;</span><br><span class="line">        //将这个员工入队</span><br><span class="line">        q.push(id);</span><br><span class="line">        int ret = 0;</span><br><span class="line">        //广度优先遍历</span><br><span class="line">        while(!q.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            //依次加上队中所有员工的重要度</span><br><span class="line">            int curId = q.front();</span><br><span class="line">            q.pop();</span><br><span class="line">            ret += info[curId]-&gt;importance;</span><br><span class="line">            //将其下属入队</span><br><span class="line">            for(auto&amp; e : info[curId]-&gt;subordinates)</span><br><span class="line">            &#123;</span><br><span class="line">                q.push(e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="例2-N叉树层序遍历"><a href="#例2-N叉树层序遍历" class="headerlink" title="例2 N叉树层序遍历"></a>例2 N叉树层序遍历</h3><p>&emsp;&emsp;力扣：<br><a href="https://leetcode-cn.com/problems/n-ary-tree-level-order-traversal/submissions/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/n-ary-tree-level-order-traversal/submissions/</a></p>
<h4 id="解析-4"><a href="#解析-4" class="headerlink" title="解析"></a>解析</h4><p>&emsp;&emsp;建立队列，将根节点入队，创造循环遍历队中每个结点将其孩子入队，但这题要注意要分树的每一行进行遍历，先遍历这一行的结点将其放到结果数组中，再以此遍历下一行的结点。</p>
<h4 id="实现-4"><a href="#实现-4" class="headerlink" title="实现"></a>实现</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">// Definition for a Node.</span><br><span class="line">class Node &#123;</span><br><span class="line">public:</span><br><span class="line">    int val;</span><br><span class="line">    vector&lt;Node*&gt; children;</span><br><span class="line"></span><br><span class="line">    Node() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    Node(int _val, vector&lt;Node*&gt; _children) &#123;</span><br><span class="line">        val = _val;</span><br><span class="line">        children = _children;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">*/</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; levelOrder(Node* root) &#123;</span><br><span class="line">        //创造队列</span><br><span class="line">        queue&lt;Node*&gt; q;</span><br><span class="line">        vector&lt;vector&lt;int&gt;&gt; treeVec;</span><br><span class="line">        if(root == nullptr)</span><br><span class="line">        &#123;</span><br><span class="line">            return treeVec;</span><br><span class="line">        &#125;</span><br><span class="line">        //放入根结点</span><br><span class="line">        q.push(root);</span><br><span class="line">        //遍历队中结点</span><br><span class="line">        while(!q.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            //得到这一行的长度</span><br><span class="line">            int sz = q.size();</span><br><span class="line">            vector&lt;int&gt; rowNode;</span><br><span class="line">            //遍历这一行</span><br><span class="line">            while(sz--)</span><br><span class="line">            &#123;</span><br><span class="line">                Node* curNode = q.front();</span><br><span class="line">                q.pop();</span><br><span class="line">                //将这一行结点的值放到rowNode中</span><br><span class="line">                rowNode.push_back(curNode-&gt;val);</span><br><span class="line">                //将这一行中每个结点的孩子入队</span><br><span class="line">                for(auto&amp; chd : curNode-&gt;children)</span><br><span class="line">                &#123;</span><br><span class="line">                    q.push(chd);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            treeVec.push_back(rowNode);</span><br><span class="line">        &#125;</span><br><span class="line">        return treeVec;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="例3-腐烂的橘子"><a href="#例3-腐烂的橘子" class="headerlink" title="例3 腐烂的橘子"></a>例3 腐烂的橘子</h3><p>&emsp;&emsp;力扣：<br><a href="https://leetcode-cn.com/problems/rotting-oranges/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/rotting-oranges/</a></p>
<h4 id="解析-5"><a href="#解析-5" class="headerlink" title="解析"></a>解析</h4><p>&emsp;&emsp;类似于N叉树的遍历。每一分钟腐烂一层，遍历每一层即可，最后搜索结束后判断是否还有新鲜橘子。</p>
<h4 id="实现-5"><a href="#实现-5" class="headerlink" title="实现"></a>实现</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">int nextP[4][2] = &#123;&#123;0, 1&#125;, &#123;1, 0&#125;, &#123;-1, 0&#125;, &#123;0, -1&#125;&#125;;</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int orangesRotting(vector&lt;vector&lt;int&gt;&gt;&amp; grid) &#123;</span><br><span class="line">        queue&lt;pair&lt;int, int&gt;&gt; q;</span><br><span class="line">        int row = grid.size();</span><br><span class="line">        int col = grid[0].size();</span><br><span class="line">        //找出第一批已经坏掉的橘子，入队</span><br><span class="line">        for(int i = 0; i &lt; row; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            for(int j = 0; j &lt; col; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                if(grid[i][j] == 2)</span><br><span class="line">                &#123;</span><br><span class="line">                    q.push(make_pair(i, j));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        //初始状态</span><br><span class="line">        int minRet = 0;</span><br><span class="line">        while(!q.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            //跟N叉树遍历一样，这里遍历一层代表要消耗一分钟</span><br><span class="line">            int flag = 0;</span><br><span class="line">            int sz = q.size();</span><br><span class="line">            //遍历这一层</span><br><span class="line">            while(sz--)</span><br><span class="line">            &#123;</span><br><span class="line">                pair&lt;int, int&gt; curPos = q.front();</span><br><span class="line">                q.pop();</span><br><span class="line">                for(int i = 0; i &lt; 4; i++)</span><br><span class="line">                &#123;</span><br><span class="line">                    int nx = curPos.first + nextP[i][0];</span><br><span class="line">                    int ny = curPos.second + nextP[i][1];</span><br><span class="line">                    if(nx &gt;= row || nx &lt; 0 || ny &gt;= col || ny &lt; 0)</span><br><span class="line">                    &#123;</span><br><span class="line">                        continue;</span><br><span class="line">                    &#125;</span><br><span class="line">                    if(grid[nx][ny] == 1)</span><br><span class="line">                    &#123;</span><br><span class="line">                        flag = 1;</span><br><span class="line">                        grid[nx][ny] = 2;</span><br><span class="line">                        q.push(make_pair(nx, ny));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            if(flag)</span><br><span class="line">            &#123;</span><br><span class="line">                ++minRet;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        for(int i = 0; i &lt; row; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            for(int j = 0; j &lt; col; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                if(grid[i][j] == 1)</span><br><span class="line">                &#123;</span><br><span class="line">                    return -1;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return minRet;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
          
        
      
    </div>
    
    
    

    

    <div>
    
    </div>

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/07/24/【Cpp】第六章-STL-vector类/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="MisakiFx">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/blog-logo.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Misaki`s blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/07/24/【Cpp】第六章-STL-vector类/" itemprop="url">【Cpp】第六章-STL_vector类</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-07-24T22:32:14+08:00">
                2019-07-24
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Cpp/" itemprop="url" rel="index">
                    <span itemprop="name">Cpp</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  1.7k
                </span>
              

              

              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="vector类"><a href="#vector类" class="headerlink" title="vector类"></a>vector类</h1><h2 id="基础介绍"><a href="#基础介绍" class="headerlink" title="基础介绍"></a>基础介绍</h2><p>&emsp;&emsp;vector类是STL中另一大容器，它十分类似于一个顺序表，不过经过封装它已经变成了一个可变长度并且拥有各种功能的顺序表，在其内部我们可以通过利用数组进行实现。vector是很常用的容器，因为它支持随机访问，并且尾插和尾删拥有O1的时间复杂度。但是在中间插入时要更高的时间复杂度，最差情况下需要遍历整个数组才能进行插入。它与string的物理与逻辑结构上十分相似，不过它是一个模板类，我们可以在其中存放任意类型的数据。</p>
<h2 id="常用接口"><a href="#常用接口" class="headerlink" title="常用接口"></a>常用接口</h2><h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">vector();                                                  //无参构造</span><br><span class="line">vector(size_type n, const value_type &amp;val = value_type()); //构造并初始化n个val</span><br><span class="line">vector(const vector &amp;x);                                   //拷贝构造</span><br><span class="line">vector(InputIterator first, InputIterator last);           //使用迭代器进行初始化构造</span><br></pre></td></tr></table></figure>
<h3 id="容量相关"><a href="#容量相关" class="headerlink" title="容量相关"></a>容量相关</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">size();     //获取数据个数</span><br><span class="line">capacity(); //获取容量大小</span><br><span class="line">empty();    //判断是否为空</span><br><span class="line">void resize(size_type n, value_type val = value_type());//改变空间大小，如果大于原有空间用val填充</span><br><span class="line">改变vector的size void reserve(size_type n); //改变vector放入capacity</span><br></pre></td></tr></table></figure>
<h3 id="增删查改"><a href="#增删查改" class="headerlink" title="增删查改"></a>增删查改</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">void push_back(const value_type &amp;val);                     //尾插</span><br><span class="line">void pop_back();                                           //尾删</span><br><span class="line">iterator insert(iterator position, constvalue_type &amp; val); //在position之前插入val</span><br><span class="line">iterator erase(iterator position);                         //删除position位置的数据</span><br><span class="line">void swap(vector &amp; x);                                     //交换两个vector的数据空间</span><br><span class="line">reference operator[](size_type n);                         //像数组一样访问</span><br></pre></td></tr></table></figure>
<h3 id="迭代器相关"><a href="#迭代器相关" class="headerlink" title="迭代器相关"></a>迭代器相关</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">begin();  //获取第一个数据位置的iterator</span><br><span class="line">end();    //获取最后一个数据的下一个位置的iterator</span><br><span class="line">rbegin(); //获取最后一个数据位置的reverse_iterator</span><br><span class="line">rend();   //获取第一个数据前一个位置的reverse_iterator</span><br><span class="line">cbegin(); //获取第一个数据位置的const_iterator</span><br><span class="line">cend();   //获取最后一个数据的下一个位置的const_iterator</span><br></pre></td></tr></table></figure>
<h2 id="迭代器失效问题"><a href="#迭代器失效问题" class="headerlink" title="迭代器失效问题"></a>迭代器失效问题</h2><p>&emsp;&emsp;在容器使用中我们经常会要操作迭代器，很多容器接口中也有提供使用迭代器进行增加删除修改的操作。但是迭代器本身是一个指针，在我们使用接口进行增加或是删除的时候这个迭代器的指向的内容会发生改变甚至是指向非法内存，原因是原来的内存已经被释放，称之为<strong>迭代器失效</strong>，迭代器失效会导致指向内容改变，从而引起bug甚至是内存越界访问导致程序崩溃。</p>
<h3 id="常见场景"><a href="#常见场景" class="headerlink" title="常见场景"></a>常见场景</h3><p>&emsp;&emsp;最为常见的是<code>erase</code>和<code>insert</code>导致的迭代器失效。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int a[] = &#123;1, 2, 3, 4&#125;;</span><br><span class="line">    vector&lt;int&gt; v(a, a + sizeof(a) / sizeof(int));</span><br><span class="line">    vector&lt;int&gt;::iterator it = v.begin();</span><br><span class="line">    while (it != v.end())</span><br><span class="line">    &#123;</span><br><span class="line">        if (*it % 2 == 0)</span><br><span class="line">            v.erase(it);</span><br><span class="line">        ++it;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;以上这段程序就会引起迭代器失效，在删除最后一个元素是甚至导致内存越界访问，程序崩溃。因此可以总结在<strong>利用迭代器删除元素后，删除位置及其之后的所有迭代器都会失效</strong>，原因是，之后的所有元素都会前移，之前的迭代器所指向的内容都会发生改变，甚至是指向非法内存。<br>&emsp;&emsp;同理我们在<code>insert</code>之后由于删除位置及其以后的元素会后移进行变动，因此<strong>插入位置及其之后所有的迭代器也都会失效</strong>，并且如果有扩容发生还可能发生内存越界访问。<br>&emsp;&emsp;对于迭代器失效我们要如何避免呢？我们注意看<code>erase</code>的接口可以发现<code>erase</code>返回的是一个迭代器。说明：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">An iterator pointing to the new location of the element that followed the last element erased by the function call. </span><br><span class="line">This is the container end if the operation erased the last element in the sequence.</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;它的返回值是返回在删除位置之后紧接着它的元素的迭代器，这个迭代器保证是有效的，<code>insert</code>的返回值也是一个迭代器，并且是插入位置插入后的元素的迭代器，因此它们的返回值都是保证有效的，所以我们的代码可以改成以下这样就可以避免迭代器失效。</p>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>&emsp;&emsp;我们模拟实现一个Vector类，并且实现常用接口，让其达到和vector相同的功能。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br></pre></td><td class="code"><pre><span class="line">#pragma once</span><br><span class="line">#include &lt;assert.h&gt;</span><br><span class="line">#include &lt;memory.h&gt;</span><br><span class="line">template &lt;class T&gt;</span><br><span class="line">class Vector</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    typedef T* iterator;</span><br><span class="line">    typedef const T* const_iterator;</span><br><span class="line">    //构造函数</span><br><span class="line">    Vector()</span><br><span class="line">        :_start(nullptr)</span><br><span class="line">        ,_finish(nullptr)</span><br><span class="line">        ,_endOfStorge(nullptr)</span><br><span class="line">    &#123;&#125;        </span><br><span class="line">    Vector(size_t n, T val)</span><br><span class="line">        :_start(nullptr)</span><br><span class="line">        ,_finish(nullptr)</span><br><span class="line">        ,_endOfStorge(nullptr)</span><br><span class="line">    &#123;</span><br><span class="line">        Reserve(n);</span><br><span class="line">        for(int i = 0; i &lt; n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            *_finish = val;</span><br><span class="line">            _finish++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    //拷贝构造</span><br><span class="line">    Vector(const Vector&lt;T&gt;&amp; vec)</span><br><span class="line">        :_start(nullptr)</span><br><span class="line">        ,_finish(nullptr)</span><br><span class="line">        ,_endOfStorge(nullptr)</span><br><span class="line">    &#123;</span><br><span class="line">        Resize(vec.Size());</span><br><span class="line">        memcpy(_start, vec._start, vec.Size() * sizeof(T));</span><br><span class="line">        _finish = _start + vec.Size();</span><br><span class="line">    &#125;</span><br><span class="line">    //operator=重载</span><br><span class="line">    Vector&amp; operator=(Vector&lt;T&gt; vec)</span><br><span class="line">    &#123;</span><br><span class="line">        Swap(vec);</span><br><span class="line">        return *this;</span><br><span class="line">    &#125;</span><br><span class="line">    //交换</span><br><span class="line">    void Swap(Vector&lt;T&gt;&amp; vec)</span><br><span class="line">    &#123;</span><br><span class="line">        std::swap(_start, vec._start);</span><br><span class="line">        std::swap(_finish, vec._finish);</span><br><span class="line">        std::swap(_endOfStorge, vec._endOfStorge);</span><br><span class="line">    &#125;</span><br><span class="line">    //析构函数</span><br><span class="line">    ~Vector()</span><br><span class="line">    &#123;</span><br><span class="line">        delete[] _start;</span><br><span class="line">        _start = nullptr;</span><br><span class="line">        _finish = nullptr;</span><br><span class="line">        _endOfStorge = nullptr;</span><br><span class="line">    &#125;</span><br><span class="line">    //迭代器相关</span><br><span class="line">    iterator begin()</span><br><span class="line">    &#123;</span><br><span class="line">        return _start;</span><br><span class="line">    &#125;</span><br><span class="line">    iterator end()</span><br><span class="line">    &#123;</span><br><span class="line">        return _finish;</span><br><span class="line">    &#125;</span><br><span class="line">    const_iterator begin() const</span><br><span class="line">    &#123;</span><br><span class="line">        return _start;</span><br><span class="line">    &#125;</span><br><span class="line">    const_iterator end() const</span><br><span class="line">    &#123;</span><br><span class="line">        return _finish;</span><br><span class="line">    &#125;</span><br><span class="line">    //插入</span><br><span class="line">    iterator Insert(iterator pos, const T&amp; val)</span><br><span class="line">    &#123;</span><br><span class="line">        assert(pos &gt;= _start &amp;&amp; pos &lt;= _finish);</span><br><span class="line">        //扩容，扩容会导致pos要重新指定位置，因为内存地址变更</span><br><span class="line">        if(_finish == _endOfStorge)</span><br><span class="line">        &#123;</span><br><span class="line">            size_t n = pos - _start;</span><br><span class="line">            size_t size = Capacity() == 0 ? 4 : 2 * Capacity();</span><br><span class="line">            Reserve(size);</span><br><span class="line">            pos = _start + n;</span><br><span class="line">        &#125;</span><br><span class="line">        iterator it = _finish;</span><br><span class="line">        while(it != pos)</span><br><span class="line">        &#123;</span><br><span class="line">            *it = *(it - 1);</span><br><span class="line">            it--;</span><br><span class="line">        &#125;</span><br><span class="line">        *pos = val;</span><br><span class="line">        _finish++;</span><br><span class="line">        return pos;</span><br><span class="line">    &#125;</span><br><span class="line">    //删除</span><br><span class="line">    iterator Erase(iterator pos)</span><br><span class="line">    &#123;</span><br><span class="line">        assert(pos &gt;= _start &amp;&amp; pos &lt;= _finish);</span><br><span class="line">        iterator it = pos + 1;</span><br><span class="line">        while(it != _finish)</span><br><span class="line">        &#123;</span><br><span class="line">            *(it - 1) = *it;</span><br><span class="line">            it++;</span><br><span class="line">        &#125;</span><br><span class="line">        _finish--;</span><br><span class="line">        return pos;</span><br><span class="line">    &#125;</span><br><span class="line">    //尾插</span><br><span class="line">    void Push_back(const T&amp; val)</span><br><span class="line">    &#123;</span><br><span class="line">        //扩容</span><br><span class="line">        if(_endOfStorge == _finish)</span><br><span class="line">        &#123;</span><br><span class="line">            size_t capacity = Capacity() == 0 ? 4 : 2 * Capacity();</span><br><span class="line">            Reserve(capacity);</span><br><span class="line">        &#125;</span><br><span class="line">        *_finish = val;</span><br><span class="line">        _finish++;</span><br><span class="line">    &#125;</span><br><span class="line">    //尾删</span><br><span class="line">    void Pop_back()</span><br><span class="line">    &#123;</span><br><span class="line">        assert(_finish &gt; _start);</span><br><span class="line">        _finish--;</span><br><span class="line">    &#125;</span><br><span class="line">    //operator[]重载</span><br><span class="line">    T&amp; operator[](size_t pos)</span><br><span class="line">    &#123;</span><br><span class="line">        return _start[pos];</span><br><span class="line">    &#125;</span><br><span class="line">    const T&amp; operator[](size_t pos) const</span><br><span class="line">    &#123;</span><br><span class="line">        return _start[pos];</span><br><span class="line">    &#125;</span><br><span class="line">    //长度</span><br><span class="line">    size_t Size() const</span><br><span class="line">    &#123;</span><br><span class="line">        return _finish - _start;</span><br><span class="line">    &#125;</span><br><span class="line">    //容量</span><br><span class="line">    size_t Capacity() const</span><br><span class="line">    &#123;</span><br><span class="line">        return _endOfStorge - _start;</span><br><span class="line">    &#125;</span><br><span class="line">    //重新给容量</span><br><span class="line">    void Reserve(size_t capacity)</span><br><span class="line">    &#123;</span><br><span class="line">        if(capacity &gt; Capacity())</span><br><span class="line">        &#123;</span><br><span class="line">            size_t size = Size();</span><br><span class="line">            //分配新的内存空间</span><br><span class="line">            T* newArr = new T[capacity];</span><br><span class="line">            if(_start)</span><br><span class="line">            &#123;</span><br><span class="line">                memcpy(newArr, _start, size * sizeof(T));</span><br><span class="line">            &#125;</span><br><span class="line">            //销毁原有内存空间</span><br><span class="line">            delete[] _start;</span><br><span class="line">            //注意这里更新三个指针都要进行更新，因为三个指针都还指向原来的内存空间</span><br><span class="line">            _start = newArr;</span><br><span class="line">            _finish = _start + size;</span><br><span class="line">            _endOfStorge = _start + capacity;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    //重新给长度,空白部分val填充</span><br><span class="line">    void Resize(size_t size, T val = T())</span><br><span class="line">    &#123;</span><br><span class="line">        Reserve(size);</span><br><span class="line">        if(Size() &lt; size)</span><br><span class="line">        &#123;</span><br><span class="line">            T* ptr = _finish;</span><br><span class="line">            while(ptr != _start + size)</span><br><span class="line">            &#123;</span><br><span class="line">                *ptr = val;</span><br><span class="line">                ptr++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        _finish = _start + size;</span><br><span class="line">    &#125;</span><br><span class="line">private:</span><br><span class="line">    //vecotor的实现与string有所不同</span><br><span class="line">    //其底层使用三个迭代器（指针）用来标记头部，尾部和总容量尾部</span><br><span class="line">    iterator _start;</span><br><span class="line">    iterator _finish;</span><br><span class="line">    iterator _endOfStorge;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>

          
        
      
    </div>
    
    
    

    

    <div>
    
    </div>

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/07/22/【Cpp】第五章-STL-string类/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="MisakiFx">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/blog-logo.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Misaki`s blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/07/22/【Cpp】第五章-STL-string类/" itemprop="url">【Cpp】第五章-STL_string类</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-07-22T20:51:53+08:00">
                2019-07-22
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Cpp/" itemprop="url" rel="index">
                    <span itemprop="name">Cpp</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  2.9k
                </span>
              

              

              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="string类"><a href="#string类" class="headerlink" title="string类"></a>string类</h1><h2 id="STL"><a href="#STL" class="headerlink" title="STL"></a>STL</h2><p>&emsp;&emsp;<strong>STL</strong>是<code>Standard Template Library</code>的简称，中文名为是<strong>标准模板库</strong>，在Cpp中模板是构成泛型编程的基础，我们利用模板可以极大程度地提高我们的代码复用率，但是如果模板要我们现写也有点过于繁琐，不过好在Cpp中为我们写代码方便为我们制作了一套标准地模板库，供我们直接使用十分方便。</p>
<h3 id="STL的版本"><a href="#STL的版本" class="headerlink" title="STL的版本"></a>STL的版本</h3><p>&emsp;&emsp;STL发展至今也不是一气呵成的，随着发展和进化，STL一共出现了四大版本。</p>
<h4 id="HP版本"><a href="#HP版本" class="headerlink" title="HP版本"></a>HP版本</h4><p>&emsp;&emsp;这个版本是STL的原始版本，由Alexander Stepanov、Meng Lee在惠普实验室完成，是所有STL版本的始祖。并且此版本秉承开源精神，允许任何人免费运用，拷贝，商用，传播，修改这些代码，唯一的条件也只是要求需要像原始版本一样开源使用。</p>
<h4 id="P-J-版本"><a href="#P-J-版本" class="headerlink" title="P.J.版本"></a>P.J.版本</h4><p>&emsp;&emsp;这个版本由P. J. Plauger开发，继承自HP版本，被Windows Visual C++采用，不可公开或修改，可读性较差。</p>
<h4 id="RW版本"><a href="#RW版本" class="headerlink" title="RW版本"></a>RW版本</h4><p>&emsp;&emsp;这个版本由Rouge Wage公司开发，继承自HP版本，被C++ Builder采用，不能公开或修改，可读性一般。</p>
<h4 id="SGI版本"><a href="#SGI版本" class="headerlink" title="SGI版本"></a>SGI版本</h4><p>&emsp;&emsp;这个版本由Silicon Graphics Computer Systems，Inc公司开发，继承自HP版本，被GCC采用，可移植性较好，可公开，修改，贩卖，可读性很高。也是我们学习主要参考的版本。</p>
<h3 id="STL六大组件"><a href="#STL六大组件" class="headerlink" title="STL六大组件"></a>STL六大组件</h3><p>&emsp;&emsp;STL中包含六大组件，他们共同组成STL互相协同工作。</p>
<h4 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h4><p>&emsp;&emsp;<code>string, vector, list, deque, map, set, multimap, multiset</code>。</p>
<h4 id="配接器"><a href="#配接器" class="headerlink" title="配接器"></a>配接器</h4><p>&emsp;&emsp;<code>stack, queue, priority_queue</code></p>
<h4 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h4><p>&emsp;&emsp;<code>find, swap, reverse, sort, merge...</code></p>
<h4 id="空间适配器"><a href="#空间适配器" class="headerlink" title="空间适配器"></a>空间适配器</h4><p>&emsp;&emsp;<code>allocator</code></p>
<h4 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h4><p>&emsp;&emsp;<code>iterator, const_iterator, reverse_iterator, const_reverse_iterator</code></p>
<h4 id="仿函数"><a href="#仿函数" class="headerlink" title="仿函数"></a>仿函数</h4><p>&emsp;&emsp;<code>greater, less...</code><br><br>&emsp;&emsp;STL在日常编程中无论是笔试还是项目都十分常用，必须多用多练，并且自己实现一遍才能熟练掌握。STL(包扩Cpp绝大部分库)学习可分为三个层次：<br><br>&emsp;&emsp;1、熟用STL<br>&emsp;&emsp;2、了解泛型技术d的内涵与STL的学理乃至实作<br>&emsp;&emsp;3、扩充STL<br>&emsp;&emsp;总结就是能用，明理，能扩展。</p>
<h2 id="string类-1"><a href="#string类-1" class="headerlink" title="string类"></a>string类</h2><p>&emsp;&emsp;<code>string</code>类时STL中专门用于字符串处理的容器。在C语言中我们利用字符数组或字符指针来构成字符串，所有字符串使用十分不方便，库中为字符串提供的接口也并不便于使用，于是在Cpp中有了<code>string</code>模板类，这个容器可以帮助我们更加方便的使用字符串，并且帮助我们封装了很多字符串相关的常用接口。</p>
<h3 id="常用接口"><a href="#常用接口" class="headerlink" title="常用接口"></a>常用接口</h3><h4 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h4><p>&emsp;&emsp;<code>string</code>中提供了各种构造函数帮助我们构造字符串。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">string(); //构造空的string类对象，即空字符串</span><br><span class="line">string(const char *s);// 用C-string来构造string类对象</span><br><span class="line">string(size_t n, char c);//string类对象中包含n个字符c</span><br><span class="line">string(const string &amp;s);//拷贝构造函数</span><br><span class="line">string(const string &amp;s, size_t n);//用s中的前n个字符构造新的string类对象 return 0;</span><br></pre></td></tr></table></figure></p>
<h4 id="容量相关接口"><a href="#容量相关接口" class="headerlink" title="容量相关接口"></a>容量相关接口</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">size_t size() const;			  // 返回字符串有效字符长度</span><br><span class="line">size_t length() const;			  // 返回字符串有效字符长度</span><br><span class="line">size_t capacity() const;		  // 返回空间总大小</span><br><span class="line">bool empty() const;				  // 检测字符串释放为空串，是返回true，否则返回false</span><br><span class="line">void clear();					  //清空有效字符</span><br><span class="line">void resize(size_t n, char c);	// 将有效字符的个数该成n个，多出的空间用字符c填充</span><br><span class="line">void resize(size_t n);			  // 将有效字符的个数改成n个，多出的空间用0填充</span><br><span class="line">void reserve(size_t res_arg = 0); // 为字符串预留空间</span><br></pre></td></tr></table></figure>
<h4 id="访问相关接口"><a href="#访问相关接口" class="headerlink" title="访问相关接口"></a>访问相关接口</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">char&amp; operator[] (size_t pos); 	  	    //返回pos位置的字符,非const string类对象调用</span><br><span class="line">const char&amp; operator[] (size_t pos);	//const返回pos位置的字符，const string类对象调用</span><br></pre></td></tr></table></figure>
<h4 id="修改相关接口"><a href="#修改相关接口" class="headerlink" title="修改相关接口"></a>修改相关接口</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">void push_back(char c);							//在字符串后尾插字符c</span><br><span class="line">string&amp; append (const char* s); 				//在字符串后追加一个字符串</span><br><span class="line">string&amp; operator+=(const string&amp; str);			//在字符串后追加字符串str</span><br><span class="line">string&amp; operator+=(const char* s);				//在字符串后追加字符串</span><br><span class="line">string&amp; operator+=(char c);						//在字符串后追加字符c</span><br><span class="line">const char* c_str()const;						//返回C格式字符串</span><br><span class="line">size_t find (char c, size_t pos = 0) const;		//从字符串pos位置开始往后找字符c，返回该字符在字符串中的位置</span><br><span class="line">size_t rfind(char c, size_t pos = npos);		//从字符串pos位置开始往前找字符c，返回该字符在字符串中的位置</span><br><span class="line">string substr(size_t pos = 0, size_t n= npos); 	//const在str中从pos位置开始，截取n个字符，然后将其返回</span><br><span class="line">string&amp; erase (size_t pos = 0, size_t len = npos); //从pos位置起删除串中npos个字符</span><br></pre></td></tr></table></figure>
<h4 id="迭代器相关"><a href="#迭代器相关" class="headerlink" title="迭代器相关"></a>迭代器相关</h4><p>&emsp;&emsp;迭代器十分类似于指针，我们可以将其等同于一个自定义类型的指针，用它我们可以完成容器内的遍历，增加，删除等操作，STL中容器的很多功能也为迭代器设计了很多接口，其中最为常用的还是取到一个容器的迭代器。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">iterator begin();					//取到头部迭代器</span><br><span class="line">const_iterator begin() const;		//取到头部常迭代器</span><br><span class="line">iterator end();						//取到尾部迭代器</span><br><span class="line">const_iterator end() const;			//取到尾部常迭代器</span><br></pre></td></tr></table></figure></p>
<h4 id="其他接口"><a href="#其他接口" class="headerlink" title="其他接口"></a>其他接口</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">string operator+ (const string&amp; lhs, const string&amp; rhs); 	//在lhs串后拼接rhs串</span><br><span class="line">istream&amp; operator&gt;&gt; (istream&amp; is, string&amp; str);				//输入运算符重载</span><br><span class="line">istream&amp; getline (istream&amp; is, string&amp; str);				//获取一行字符串</span><br><span class="line">relational operators 										//大小比较</span><br></pre></td></tr></table></figure>
<h4 id="综合运用"><a href="#综合运用" class="headerlink" title="综合运用"></a>综合运用</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	string str = &quot;123456&quot;;//单参构造的隐式类型转换 + 拷贝构造</span><br><span class="line">	for(int i = 0; i &lt; str.size(); i++)//size()取出长度</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; str[i] &lt;&lt; &quot; &quot;;//operator[]重载的运用</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">	str.append(&quot;abc&quot;);//append()接口</span><br><span class="line">	str.push_back(&apos;d&apos;);//push_back接口使用</span><br><span class="line">	str += &quot;efg&quot;;//operator += 重载使用</span><br><span class="line">	//迭代器的应用</span><br><span class="line">	string::iterator it = str.begin();</span><br><span class="line">	while(it != str.end())</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; * it &lt;&lt; &quot; &quot;;</span><br><span class="line">		it++;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1 2 3 4 5 6</span><br><span class="line">1 2 3 4 5 6 a b c d e f g</span><br></pre></td></tr></table></figure>
<h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>&emsp;&emsp;学习STL要熟用，明理，能扩展，那么第二部明理我们就要自己实现封装一个<code>string</code>类。根据库中<code>string</code>常用接口我们也实现其基本功能。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;assert.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">class String</span><br><span class="line">&#123;</span><br><span class="line">    friend std::ostream &amp;operator&lt;&lt;(std::ostream &amp;os, String str);</span><br><span class="line">public:</span><br><span class="line">    //迭代器</span><br><span class="line">    typedef char* iterator;</span><br><span class="line">    typedef const char* const_iterator;</span><br><span class="line">    iterator begin()</span><br><span class="line">    &#123;</span><br><span class="line">        return _str;</span><br><span class="line">    &#125;</span><br><span class="line">    const_iterator begin() const</span><br><span class="line">    &#123;</span><br><span class="line">        return _str;</span><br><span class="line">    &#125;</span><br><span class="line">    iterator end()</span><br><span class="line">    &#123;</span><br><span class="line">        return _str+_size;</span><br><span class="line">    &#125;</span><br><span class="line">    const_iterator end() const</span><br><span class="line">    &#123;</span><br><span class="line">        return _str+_size;</span><br><span class="line">    &#125;</span><br><span class="line">    static size_t npos;</span><br><span class="line">    //构造函数</span><br><span class="line">    String(const char* str = &quot;&quot;)//要进行深拷贝</span><br><span class="line">        :_str(nullptr)</span><br><span class="line">        ,_capacity(0)</span><br><span class="line">    &#123;</span><br><span class="line">        _size = strlen(str);</span><br><span class="line">        //重新给容量Reserve()</span><br><span class="line">        Reserve(_size);</span><br><span class="line">        //strcpy()拷贝给成员变量</span><br><span class="line">        strcpy(_str, str);</span><br><span class="line">    &#125;</span><br><span class="line">    //拷贝构造，要使用深拷贝</span><br><span class="line">    //所谓深拷贝就是创立独立的内存空间并将目标对象中的值拷贝过来</span><br><span class="line">    //而不是单纯的让指针等于目标拷贝对象中的指针</span><br><span class="line">    //注意：拷贝构造和operator=重载都是不拷贝容量大小的</span><br><span class="line">    //传统写法：创建新的独立内存，销毁原来的内存空间，更新_size, _capacity的值</span><br><span class="line">    //String(const String&amp; str)</span><br><span class="line">    //    :_str(nullptr)</span><br><span class="line">    //    ,_size(0)</span><br><span class="line">    //    ,_capacity(0)</span><br><span class="line">    //&#123;</span><br><span class="line">    //    Resize(str.Size());</span><br><span class="line">    //    strcpy(_str, str._str);</span><br><span class="line">    //&#125;</span><br><span class="line">    ////operator=重载和拷贝构造类似，先用传统写法实现</span><br><span class="line">    //String&amp; operator=(const String&amp; str)</span><br><span class="line">    //&#123;</span><br><span class="line">    //    if(this != &amp;str)</span><br><span class="line">    //    &#123;</span><br><span class="line">    //        Resize(str.Size());</span><br><span class="line">    //        strcpy(_str, str._str);</span><br><span class="line">    //    &#125;</span><br><span class="line">    //&#125;</span><br><span class="line">    //现代写法，另外创建对象让其等于要拷贝的对象，交换两个对象即可</span><br><span class="line">    String(const String&amp; str)</span><br><span class="line">        :_str(nullptr)</span><br><span class="line">        ,_size(0)</span><br><span class="line">        ,_capacity(0)</span><br><span class="line">    &#123;</span><br><span class="line">        String temp(str._str);</span><br><span class="line">        Swap(temp);</span><br><span class="line">    &#125;</span><br><span class="line">    //现代写法，利用拷贝构造函数创建临时对象，交换两个对象，临时对象在函数结束时也会自动释放</span><br><span class="line">    String&amp; operator=(String str)</span><br><span class="line">    &#123;</span><br><span class="line">        Swap(str);</span><br><span class="line">    &#125;</span><br><span class="line">    //交换两个字符串，浅拷贝，不另申请内存空间</span><br><span class="line">    void Swap(String&amp; str)</span><br><span class="line">    &#123;</span><br><span class="line">        std::swap(_str, str._str);</span><br><span class="line">        std::swap(_size, str._size);</span><br><span class="line">        std::swap(_capacity, str._capacity);</span><br><span class="line">    &#125;</span><br><span class="line">    //析构函数</span><br><span class="line">    ~String()</span><br><span class="line">    &#123;</span><br><span class="line">        if(_str)</span><br><span class="line">        &#123;</span><br><span class="line">            delete[] _str;</span><br><span class="line">            _str = nullptr;</span><br><span class="line">            _size = _capacity = 0;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    //返回_size</span><br><span class="line">    size_t Size() const</span><br><span class="line">    &#123;</span><br><span class="line">        return _size;</span><br><span class="line">    &#125;</span><br><span class="line">    //返回_capacity</span><br><span class="line">    size_t Capacity() const</span><br><span class="line">    &#123;</span><br><span class="line">        return _capacity;</span><br><span class="line">    &#125;</span><br><span class="line">    //在某个下标插入一个字符</span><br><span class="line">    void Insert(size_t pos, char ch)</span><br><span class="line">    &#123;</span><br><span class="line">        assert(pos &lt;= _size);</span><br><span class="line">        //容量满了，扩容</span><br><span class="line">        if(_size == _capacity)</span><br><span class="line">        &#123;</span><br><span class="line">            Reserve(2 * _capacity);</span><br><span class="line">        &#125;</span><br><span class="line">        for(int i = _size; i &gt; pos; i--)</span><br><span class="line">        &#123;</span><br><span class="line">            _str[i] = _str[i - 1];</span><br><span class="line">        &#125;</span><br><span class="line">        _str[pos] = ch;</span><br><span class="line">        _size++;</span><br><span class="line">        _str[_size] = &apos;\0&apos;;</span><br><span class="line">    &#125;</span><br><span class="line">    //在某个下标处插入一个字符串</span><br><span class="line">    void Insert(size_t pos, const char* str)</span><br><span class="line">    &#123;</span><br><span class="line">        assert(pos &lt;= _size);</span><br><span class="line">        int len = strlen(str);</span><br><span class="line">        //容量不够扩容</span><br><span class="line">        if(_size + len &gt; _capacity)</span><br><span class="line">        &#123;</span><br><span class="line">            Reserve(len + _size);</span><br><span class="line">        &#125;</span><br><span class="line">        for(int i = len + _size - 1; i &gt; pos + len - 1; i--)</span><br><span class="line">        &#123;</span><br><span class="line">            _str[i] = _str[i - len];        </span><br><span class="line">        &#125;</span><br><span class="line">        for(int i = pos; i &lt; pos + len; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            _str[i] = str[i - pos];</span><br><span class="line">        &#125;</span><br><span class="line">        _size += len;</span><br><span class="line">    &#125;</span><br><span class="line">    //+=运算符重载</span><br><span class="line">    String&amp; operator+=(char ch)</span><br><span class="line">    &#123;</span><br><span class="line">        Push_back(ch);</span><br><span class="line">    &#125;</span><br><span class="line">    String&amp; operator+=(const char* str)</span><br><span class="line">    &#123;</span><br><span class="line">        Append(str);</span><br><span class="line">    &#125;</span><br><span class="line">    //删除pos下标开始的npos个字符</span><br><span class="line">    void Erase(size_t pos, size_t npos)</span><br><span class="line">    &#123;</span><br><span class="line">        assert(pos &lt; _size);</span><br><span class="line">        for(int i = pos; i &lt; _size - npos; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            _str[i] = _str[i + npos];</span><br><span class="line">        &#125;</span><br><span class="line">        _size -= npos;</span><br><span class="line">        _str[_size] = &apos;\0&apos;;</span><br><span class="line">    &#125;</span><br><span class="line">    //从pos开始找第一个字符为ch返回其下标</span><br><span class="line">    size_t Find(const char ch, size_t pos = 0)</span><br><span class="line">    &#123;</span><br><span class="line">        assert(pos &lt; _size);</span><br><span class="line">        for(size_t i = pos; i &lt; _size; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            if(_str[i] == ch)</span><br><span class="line">            &#123;</span><br><span class="line">                return i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return npos;</span><br><span class="line">    &#125;</span><br><span class="line">    //从pos开始找第一个子串为str返回其下标</span><br><span class="line">    size_t Find(const char* str, size_t pos = 0)</span><br><span class="line">    &#123;</span><br><span class="line">        assert(pos &lt; _size);</span><br><span class="line">        for(size_t i = pos; i &lt; _size; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            if(_str[i] == str[0])</span><br><span class="line">            &#123;</span><br><span class="line">                int j = i;</span><br><span class="line">                while (j &lt; i + strlen(str) &amp;&amp; _str[j] != &apos;\0&apos;)</span><br><span class="line">                &#123;</span><br><span class="line">                    if (_str[j] != str[j - i])</span><br><span class="line">                    &#123;</span><br><span class="line">                        break;</span><br><span class="line">                    &#125;</span><br><span class="line">                    j++;</span><br><span class="line">                &#125;</span><br><span class="line">                //子串遍历完毕,子串与要查找的串完全匹配</span><br><span class="line">                if (j == i + strlen(str))</span><br><span class="line">                &#123;</span><br><span class="line">                    return i;</span><br><span class="line">                &#125;</span><br><span class="line">                //主串遇到结尾，长度不够不用继续查找了</span><br><span class="line">                else if(_str[j] == &apos;\0&apos;)</span><br><span class="line">                &#123;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">                //其他情况本次子串与要查找的串匹配不上，继续下一次子串查找</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return npos;</span><br><span class="line">    &#125;</span><br><span class="line">    //在尾部插入字符</span><br><span class="line">    void Push_back(char ch)</span><br><span class="line">    &#123;</span><br><span class="line">        Insert(_size, ch);</span><br><span class="line">    &#125;</span><br><span class="line">    //字符串拼接</span><br><span class="line">    void Append(const char* str)</span><br><span class="line">    &#123;</span><br><span class="line">        Insert(_size, str);</span><br><span class="line">    &#125;</span><br><span class="line">    //重新给容量，并且要求容量永远为8的整数倍</span><br><span class="line">    void Reserve(size_t n)</span><br><span class="line">    &#123;</span><br><span class="line">        if(n &gt; _capacity || (n == 0 &amp;&amp; _capacity == 0))</span><br><span class="line">        &#123;</span><br><span class="line">            size_t newCapacity = n;</span><br><span class="line">            if(newCapacity % 8 != 0)</span><br><span class="line">            &#123;</span><br><span class="line">                newCapacity = (((newCapacity / 8) + 1) * 8);</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">            &#123;</span><br><span class="line">                newCapacity += 8;</span><br><span class="line">            &#125;</span><br><span class="line">            char* newStr = new char[newCapacity];</span><br><span class="line">            if(newStr &amp;&amp; _str)</span><br><span class="line">            &#123;</span><br><span class="line">                strcpy(newStr, _str);</span><br><span class="line">            &#125;</span><br><span class="line">            //释放旧空间</span><br><span class="line">            delete[] _str;</span><br><span class="line">            _str = newStr;</span><br><span class="line">            _capacity = newCapacity - 1;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    void Resize(size_t size, char ch = &apos;\0&apos;)</span><br><span class="line">    &#123;</span><br><span class="line">        if(size &lt; _size)</span><br><span class="line">        &#123;</span><br><span class="line">            _size = size;</span><br><span class="line">            _str[_size] = &apos;\0&apos;;</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            Reserve(size);</span><br><span class="line">            for(size_t i = _size; i &lt; size; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                _str[i] = ch;</span><br><span class="line">            &#125;</span><br><span class="line">            _size = size;</span><br><span class="line">            _str[_size] = &apos;\0&apos;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    //&gt;运算符重载</span><br><span class="line">    bool operator&gt;(const String&amp; str)</span><br><span class="line">    &#123;</span><br><span class="line">        if(strcmp(_str, str._str) &gt; 0)</span><br><span class="line">        &#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    bool operator==(const String&amp; str)</span><br><span class="line">    &#123;</span><br><span class="line">        if(strcmp(_str, str._str) == 0)</span><br><span class="line">        &#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    bool operator&gt;=(const String&amp; str)</span><br><span class="line">    &#123;</span><br><span class="line">        if(*this &gt; str || *this == str)</span><br><span class="line">        &#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    bool operator&lt;(const String&amp; str)</span><br><span class="line">    &#123;</span><br><span class="line">        if(*this &gt;= str)</span><br><span class="line">        &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    bool operator&lt;=(const String&amp; str)</span><br><span class="line">    &#123;</span><br><span class="line">        if(*this &lt; str || *this == str)</span><br><span class="line">        &#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    bool operator!=(const String&amp; str)</span><br><span class="line">    &#123;</span><br><span class="line">        if(*this == str)</span><br><span class="line">        &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    //+运算符重载</span><br><span class="line">    String operator+(char ch)</span><br><span class="line">    &#123;</span><br><span class="line">        String temp(*this);</span><br><span class="line">        temp.Push_back(ch);</span><br><span class="line">        return temp;</span><br><span class="line">    &#125;</span><br><span class="line">    String operator+(const char* str)</span><br><span class="line">    &#123;</span><br><span class="line">        String temp(*this);</span><br><span class="line">        temp.Append(str);</span><br><span class="line">        return temp;</span><br><span class="line">    &#125;</span><br><span class="line">    //取类中的字符串</span><br><span class="line">    char* c_str()</span><br><span class="line">    &#123;</span><br><span class="line">        return _str;    </span><br><span class="line">    &#125;</span><br><span class="line">    //operator[]重载</span><br><span class="line">    char&amp; operator[](size_t pos)</span><br><span class="line">    &#123;</span><br><span class="line">        assert(pos &lt; _size);</span><br><span class="line">        return _str[pos];</span><br><span class="line">    &#125;</span><br><span class="line">    //operator[]重载</span><br><span class="line">    const char&amp; operator[](size_t pos) const</span><br><span class="line">    &#123;</span><br><span class="line">        assert(pos &lt; _size);</span><br><span class="line">        return _str[pos];</span><br><span class="line">    &#125;</span><br><span class="line">private:</span><br><span class="line">    char* _str;</span><br><span class="line">    size_t _size;</span><br><span class="line">    size_t _capacity;</span><br><span class="line">&#125;;</span><br><span class="line">std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, String str)</span><br><span class="line">&#123;</span><br><span class="line">	os &lt;&lt; str._str;</span><br><span class="line">	return os;</span><br><span class="line">&#125;</span><br><span class="line">size_t String::npos = -1;</span><br></pre></td></tr></table></figure></p>

          
        
      
    </div>
    
    
    

    

    <div>
    
    </div>

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/07/20/【算法】第一章-动态规划/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="MisakiFx">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/blog-logo.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Misaki`s blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/07/20/【算法】第一章-动态规划/" itemprop="url">【算法】第一章-动态规划</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-07-20T18:25:03+08:00">
                2019-07-20
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/算法/" itemprop="url" rel="index">
                    <span itemprop="name">算法</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  2.2k
                </span>
              

              

              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="第一章-动态规划"><a href="#第一章-动态规划" class="headerlink" title="第一章-动态规划"></a>第一章-动态规划</h1><h2 id="动态规划求解模式"><a href="#动态规划求解模式" class="headerlink" title="动态规划求解模式"></a>动态规划求解模式</h2><p>&emsp;&emsp;动态规划具备了一下三个特点：<br>&emsp;&emsp;1、把原来的问题分解成了几个相似子问题<br>&emsp;&emsp;2、所有的子问题只需要解决一次<br>&emsp;&emsp;3、储存子问题的解<br>&emsp;&emsp;从以下四个角度考虑：<br>&emsp;&emsp;1、初始状态定义<br>&emsp;&emsp;2、状态间转移方程<br>&emsp;&emsp;3、状态的初始化<br>&emsp;&emsp;4、返回结果<br>&emsp;&emsp;解决问题主要适用于：查找最优解，最大值/最小值，可不可行，是不是，方案个数</p>
<h2 id="例1-斐波那契数列"><a href="#例1-斐波那契数列" class="headerlink" title="例1 斐波那契数列"></a>例1 斐波那契数列</h2><p>&emsp;&emsp;牛客网:<br><a href="https://www.nowcoder.com/questionTerminal/c6c7742f5ba7442aada113136ddea0c3" target="_blank" rel="noopener">https://www.nowcoder.com/questionTerminal/c6c7742f5ba7442aada113136ddea0c3</a><br><br>&emsp;&emsp;动态规划解法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int Fibonacci(int n) &#123;</span><br><span class="line">        vector&lt;int&gt; ret(n + 1, 0);</span><br><span class="line">        //初始状态</span><br><span class="line">        ret[1] = ret[2] = 1;</span><br><span class="line">        //递推公式</span><br><span class="line">        //ret[i] = ret [i - 1] + ret[i - 2];</span><br><span class="line">        for(int i = 3; i &lt;= n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            ret[i] = ret[i - 1] + ret[i - 2];</span><br><span class="line">        &#125;</span><br><span class="line">        return ret[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h2 id="例2-变态青蛙跳台阶"><a href="#例2-变态青蛙跳台阶" class="headerlink" title="例2 变态青蛙跳台阶"></a>例2 变态青蛙跳台阶</h2><p>&emsp;&emsp;牛客网：<br><a href="https://www.nowcoder.com/questionTerminal/22243d016f6b47f2a6928b4313c85387" target="_blank" rel="noopener">https://www.nowcoder.com/questionTerminal/22243d016f6b47f2a6928b4313c85387</a><br></p>
<h3 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h3><h4 id="定义状态"><a href="#定义状态" class="headerlink" title="定义状态"></a>定义状态</h4><p>&emsp;&emsp;跳上i级台阶的方法数</p>
<h4 id="状态转移方程"><a href="#状态转移方程" class="headerlink" title="状态转移方程"></a>状态转移方程</h4><p>&emsp;&emsp;分解：<br>&emsp;&emsp;一次跳1级台阶：1， F(i - 1)<br>&emsp;&emsp;一次跳2级台阶：2， F(i - 2)<br>&emsp;&emsp;……<br>&emsp;&emsp;推得状态转移方程：<br>&emsp;&emsp;F(i) = F(i - 1) + F(i - 2) + … + F(1)<br>&emsp;&emsp;F(i - 1) = F(i - 2) + F(i - 3) + … + F(1)<br>&emsp;&emsp;F(i) = F(i - 1) + F(i - 1) = 2 * F(i - 1);</p>
<h4 id="初始状态和最终状态"><a href="#初始状态和最终状态" class="headerlink" title="初始状态和最终状态"></a>初始状态和最终状态</h4><p>&emsp;&emsp;F(1) = 1,求F(n)。</p>
<h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int jumpFloorII(int number) &#123;</span><br><span class="line">        //初始状态</span><br><span class="line">        int f1 = 1;</span><br><span class="line">        //状态转移方程：F(i) = 2 * F(i - 1)</span><br><span class="line">        for(int i = 2; i &lt;= number; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            f1 = 2 * f1;</span><br><span class="line">        &#125;</span><br><span class="line">        return f1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h3><p>&emsp;&emsp;根据状态转移方程我们可以得知，<code>F(n) = 2 ^ (n - 1)</code>;所以可以得到优化：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int jumpFloorII(int number) &#123;</span><br><span class="line">        return (1 &lt;&lt; (number - 1));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h2 id="例3-求连续最大子数组的和"><a href="#例3-求连续最大子数组的和" class="headerlink" title="例3 求连续最大子数组的和"></a>例3 求连续最大子数组的和</h2><p>&emsp;&emsp;牛客网：</p>
<p><a href="https://www.nowcoder.com/questionTerminal/459bd355da1549fa8a49e350bf3df484" target="_blank" rel="noopener">https://www.nowcoder.com/questionTerminal/459bd355da1549fa8a49e350bf3df484</a></p>
<h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><h4 id="定义状态-1"><a href="#定义状态-1" class="headerlink" title="定义状态"></a>定义状态</h4><p>&emsp;&emsp;到此项为止前i项的连续子序列的最大和</p>
<h4 id="状态转移方程-1"><a href="#状态转移方程-1" class="headerlink" title="状态转移方程"></a>状态转移方程</h4><p>&emsp;&emsp;F(i) = max(F(i - 1) + a[i], a[i]);</p>
<h4 id="初始状态和最终状态-1"><a href="#初始状态和最终状态-1" class="headerlink" title="初始状态和最终状态"></a>初始状态和最终状态</h4><p>&emsp;&emsp;初始状态F[0] = a[0]。<br>&emsp;&emsp;最终结果max(F[i])。</p>
<h3 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int FindGreatestSumOfSubArray(vector&lt;int&gt; array) &#123;</span><br><span class="line">        if(array.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        vector&lt;int&gt; ret(array.size(), 0);</span><br><span class="line">        //初始状态</span><br><span class="line">        ret[0] = array[0];</span><br><span class="line">        //状态转移</span><br><span class="line">        for(int i = 1; i &lt; array.size(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            ret[i] = max(array[i] + ret[i - 1], array[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        //求max(F[i])</span><br><span class="line">        int maxNum = ret[0];</span><br><span class="line">        for(int i = 0; i &lt; ret.size(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            maxNum = max(maxNum, ret[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        return maxNum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="例4-word-break-字符串分割"><a href="#例4-word-break-字符串分割" class="headerlink" title="例4 word-break(字符串分割)"></a>例4 word-break(字符串分割)</h2><p>&emsp;&emsp;牛客网：<br><a href="https://www.nowcoder.com/questionTerminal/5f3b7bf611764c8ba7868f3ed40d6b2c" target="_blank" rel="noopener">https://www.nowcoder.com/questionTerminal/5f3b7bf611764c8ba7868f3ed40d6b2c</a></p>
<h3 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h3><h4 id="定义状态-2"><a href="#定义状态-2" class="headerlink" title="定义状态"></a>定义状态</h4><p>&emsp;&emsp;F(i)：前i个字符能否被分割。</p>
<h4 id="状态转移方程-2"><a href="#状态转移方程-2" class="headerlink" title="状态转移方程"></a>状态转移方程</h4><p>&emsp;&emsp;F(i): F(i)能否被分割取决于前j项能否被分割和j + 1到第i项能否被分割。（此处j取0 ~ i - 1）<br>&emsp;&emsp;得递推方程F(i) : F(j) &amp;&amp; (j + 1 ~ i)能否被分割</p>
<h4 id="初始状态和最终状态-2"><a href="#初始状态和最终状态-2" class="headerlink" title="初始状态和最终状态"></a>初始状态和最终状态</h4><p>&emsp;&emsp;初始状态：F(0) = true。<br>&emsp;&emsp;最终状态F(n)。</p>
<h3 id="实现-2"><a href="#实现-2" class="headerlink" title="实现"></a>实现</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool wordBreak(string s, unordered_set&lt;string&gt; &amp;dict) &#123;</span><br><span class="line">        if(s.empty() || dict.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        vector&lt;bool&gt; Fn(s.size() + 1, false);</span><br><span class="line">        //初始状态</span><br><span class="line">        Fn[0] = true;</span><br><span class="line">        for(int i = 1; i &lt;= s.size(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            //状态转移</span><br><span class="line">            //F(i) = F(j) &amp;&amp; (j + 1 ~ i), (0 &lt;= j &lt; i)能否被分割</span><br><span class="line">            for(int j = i - 1; j &gt;= 0; j--)</span><br><span class="line">            &#123;</span><br><span class="line">                if(Fn[j] &amp;&amp; dict.find(s.substr(j, i - j)) != dict.end())</span><br><span class="line">                &#123;</span><br><span class="line">                    Fn[i] = true;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        //最终状态</span><br><span class="line">        return Fn[s.size()];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="例5-triangle-三角矩阵最短路"><a href="#例5-triangle-三角矩阵最短路" class="headerlink" title="例5 triangle(三角矩阵最短路)"></a>例5 triangle(三角矩阵最短路)</h2><p>&emsp;&emsp;牛客网：<br><a href="https://www.nowcoder.com/questionTerminal/2b7995aa4f7949d99674d975489cb7da" target="_blank" rel="noopener">https://www.nowcoder.com/questionTerminal/2b7995aa4f7949d99674d975489cb7da</a></p>
<h3 id="分析-2"><a href="#分析-2" class="headerlink" title="分析"></a>分析</h3><h4 id="定义状态-3"><a href="#定义状态-3" class="headerlink" title="定义状态"></a>定义状态</h4><p>&emsp;&emsp;F[i][j]: 从(0, 0)到(i, j)的最短路径和。</p>
<h4 id="状态转移方程-3"><a href="#状态转移方程-3" class="headerlink" title="状态转移方程"></a>状态转移方程</h4><p>&emsp;&emsp;一般情况下，走到每个位置的最短路径都可以看作是上一行相邻两个位置的最短路径+这个位置的路径长度，数学描述：F[i][j]:min(F[i - 1][j], F[i - 1][j - 1]) + a[i][j]。<br>&emsp;&emsp;但要考虑边界状态：当在矩阵边缘时只有一种选择的情况，即F[i][0] = F[i - 1][0];F[i][i] = F[i - 1][i - 1]。</p>
<h4 id="初始状态和最终状态-3"><a href="#初始状态和最终状态-3" class="headerlink" title="初始状态和最终状态"></a>初始状态和最终状态</h4><p>&emsp;&emsp;初始状态：F[0][0] = a[0][0]。<br>&emsp;&emsp;最终状态：min(F[n - 1][j])，即最后一行中的最小值。</p>
<h3 id="实现-3"><a href="#实现-3" class="headerlink" title="实现"></a>实现</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int minimumTotal(vector&lt;vector&lt;int&gt; &gt; &amp;triangle) &#123;</span><br><span class="line">        if(triangle.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        //初始状态</span><br><span class="line">        vector&lt;vector&lt;int&gt;&gt; ret(triangle);</span><br><span class="line">        //状态转移</span><br><span class="line">        int row = ret.size();</span><br><span class="line">        for(int i = 1; i &lt; row; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            ret[i][0] = ret[i - 1][0] + triangle[i][0];</span><br><span class="line">        &#125;</span><br><span class="line">        for(int i = 1; i &lt; row; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            ret[i][i] = ret[i - 1][i - 1] + triangle[i][i];</span><br><span class="line">        &#125;</span><br><span class="line">        for(int i = 1; i &lt; row; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            for(int j = 1; j &lt; i; ++j)</span><br><span class="line">            &#123;</span><br><span class="line">                ret[i][j] = min(ret[i - 1][j], ret[i - 1][j - 1]) + triangle[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        //最终状态</span><br><span class="line">        int minSum = ret[row - 1][0];</span><br><span class="line">        for(int i = 1; i &lt; row; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            minSum = min(minSum, ret[row - 1][i]);</span><br><span class="line">        &#125;</span><br><span class="line">        return minSum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="例6-求路径数量"><a href="#例6-求路径数量" class="headerlink" title="例6 求路径数量"></a>例6 求路径数量</h2><p>牛客网：<br><a href="https://www.nowcoder.com/questionTerminal/3cdf08dd4e974260921b712f0a5c8752" target="_blank" rel="noopener">https://www.nowcoder.com/questionTerminal/3cdf08dd4e974260921b712f0a5c8752</a></p>
<h3 id="分析-3"><a href="#分析-3" class="headerlink" title="分析"></a>分析</h3><h4 id="状态定义"><a href="#状态定义" class="headerlink" title="状态定义"></a>状态定义</h4><p>&emsp;&emsp;F[i][j]：从左上角到达下标(i, j)的路径总数</p>
<h4 id="状态转移方程-4"><a href="#状态转移方程-4" class="headerlink" title="状态转移方程"></a>状态转移方程</h4><p>&emsp;&emsp;if(a[i][j] == 1) F[i][j] = 0;<br>&emsp;&emsp;if(a[i][j] == 0) F[i][j] = F[i][j - 1] + F[i - 1][j]。</p>
<h4 id="初始状态和最终状态-4"><a href="#初始状态和最终状态-4" class="headerlink" title="初始状态和最终状态"></a>初始状态和最终状态</h4><p>&emsp;&emsp;初始状态：如果第一行第一列有障碍物表示这条路走不通则路径数置0，否则只有一条路径，置一if(a[0][j]) == 1) F[0][j] = 0，if(a[i][0] == 1) F[i][0] = 0，这种情况下这条路走不通。<br>&emsp;&emsp;最终状态：F[i][j]。</p>
<h3 id="实现-4"><a href="#实现-4" class="headerlink" title="实现"></a>实现</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int uniquePathsWithObstacles(vector&lt;vector&lt;int&gt; &gt; &amp;obstacleGrid) &#123;</span><br><span class="line">        if(obstacleGrid.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        if(obstacleGrid[0][0] == 1)</span><br><span class="line">        &#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        int row = obstacleGrid.size();</span><br><span class="line">        int col = obstacleGrid[0].size();</span><br><span class="line">        vector&lt;vector&lt;int&gt;&gt; pathNum(row, vector&lt;int&gt;(col, 0));</span><br><span class="line">        for(int i = 0; i &lt; row; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            if(obstacleGrid[i][0] == 1)</span><br><span class="line">            &#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">            &#123;</span><br><span class="line">                pathNum[i][0] = 1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        for(int i = 0; i &lt; col; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            if(obstacleGrid[0][i] == 1)</span><br><span class="line">            &#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            else </span><br><span class="line">            &#123;</span><br><span class="line">                pathNum[0][i] = 1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        for(int i = 1; i &lt; row; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            for(int j = 1; j &lt; col; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                if(obstacleGrid[i][j] == 1)</span><br><span class="line">                &#123;</span><br><span class="line">                    pathNum[i][j] = 0;</span><br><span class="line">                &#125;</span><br><span class="line">                else</span><br><span class="line">                &#123;</span><br><span class="line">                    pathNum[i][j] = pathNum[i][j - 1] + pathNum[i - 1][j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return pathNum[row - 1][col - 1];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="例7-背包问题"><a href="#例7-背包问题" class="headerlink" title="例7 背包问题"></a>例7 背包问题</h2><p>&emsp;&emsp;lintcode：<br><a href="https://www.lintcode.com/problem/backpack-ii/description" target="_blank" rel="noopener">https://www.lintcode.com/problem/backpack-ii/description</a></p>
<h3 id="分析-4"><a href="#分析-4" class="headerlink" title="分析"></a>分析</h3><p>&emsp;&emsp;背包问题是一类问题，主要是求解约束条件下的最优解问题。</p>
<h4 id="状态定义-1"><a href="#状态定义-1" class="headerlink" title="状态定义"></a>状态定义</h4><p>&emsp;&emsp;F[i][j]：前i个商品，包的重量为j的最大价值。定义二维数组遍历所有商品，和到当前商品情况下背包容量从0 - max的所有情况下的最大值求解，遍历到最后则可得到n个全部商品情况下背包最大容量max下背包可拿的最大价值F[n][max]。</p>
<h4 id="状态转移方程-5"><a href="#状态转移方程-5" class="headerlink" title="状态转移方程"></a>状态转移方程</h4><p>&emsp;&emsp;当前商品空间大于包能承受的总空间，放不下直接跳过。数学描述：if(w[i] &gt; j) F[i][j] = F[i - 1][j]。<br>&emsp;&emsp;当前商品空间小于等于包能承受总空间，可以选择放可以选择不放，如果不放入，则F[i][j] = F[i - 1][j]；如果放入，则当前重量等于遍历到的上一个商品并且空间还有w[i]这么大的时候的价值+本商品的价值，最大价值F[i][j] = F[i - 1][j - w[i]] + v[i]，选择放入或不放入商品情况中的最大值作为最优解。数学描述：if(w[i] &lt;= j) max(F[i - 1][j], F[i - 1][j - w[i]] + v[i]);</p>
<h4 id="初始状态和最终状态-5"><a href="#初始状态和最终状态-5" class="headerlink" title="初始状态和最终状态"></a>初始状态和最终状态</h4><p>&emsp;&emsp;初始状态：没有商品时，F[0][j] = 0,最大容量为0时F[i][0] = 0。<br>&emsp;&emsp;最终状态：遍历完全部n个商品，并且背包总容量为最大值m时得到最大价值F[n][m]。</p>
<h3 id="实现-5"><a href="#实现-5" class="headerlink" title="实现"></a>实现</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    /**</span><br><span class="line">     * @param m: An integer m denotes the size of a backpack</span><br><span class="line">     * @param A: Given n items with size A[i]</span><br><span class="line">     * @param V: Given n items with value V[i]</span><br><span class="line">     * @return: The maximum value</span><br><span class="line">     */</span><br><span class="line">    int backPackII(int m, vector&lt;int&gt; &amp;A, vector&lt;int&gt; &amp;V) &#123;</span><br><span class="line">        if(A.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        int row = A.size();</span><br><span class="line">        vector&lt;vector&lt;int&gt;&gt; maxValue(row + 1, vector&lt;int&gt;(m + 1, 0));</span><br><span class="line">        for(int i = 1; i &lt;= row; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            for(int j = 1; j &lt;= m; ++j)</span><br><span class="line">            &#123;</span><br><span class="line">                if(A[i - 1] &gt; j)</span><br><span class="line">                &#123;</span><br><span class="line">                    maxValue[i][j] = maxValue[i - 1][j];</span><br><span class="line">                &#125;</span><br><span class="line">                else</span><br><span class="line">                &#123;</span><br><span class="line">                    maxValue[i][j] = max(maxValue[i - 1][j], maxValue[i - 1][j - A[i - 1]] + V[i - 1]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return maxValue[row][m];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
          
        
      
    </div>
    
    
    

    

    <div>
    
    </div>

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/07/15/【Cpp】第四章-模板初阶/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="MisakiFx">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/blog-logo.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Misaki`s blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/07/15/【Cpp】第四章-模板初阶/" itemprop="url">【Cpp】第四章-模板初阶</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-07-15T20:10:18+08:00">
                2019-07-15
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Cpp/" itemprop="url" rel="index">
                    <span itemprop="name">Cpp</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  1.7k
                </span>
              

              

              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="模板初阶"><a href="#模板初阶" class="headerlink" title="模板初阶"></a>模板初阶</h1><h2 id="泛型编程"><a href="#泛型编程" class="headerlink" title="泛型编程"></a>泛型编程</h2><p>&emsp;&emsp;在我们进行大型程序的编写时往往会遇到一类问题，同一个函数或类我们希望多种类型数据传入时都能完成类似或者相同的功能，但是在C语言中我们很难做到这一点因为我们往往在换了一个数据类型后就要重新写一遍函数，这样耽误我们大量的时间，呢么有没有一种语法在Cpp中能够使让我们的代码成为一种模板，不同的数据类型传入也依然能够执行类似的功能呢？<br><br>&emsp;&emsp;正所谓世界是由懒人创造的，于是在C++中引入了模板这一概念，同时也正得益与此使我们可以做到<strong>泛型编程</strong>，是我们的代码极大程度的可以复用。</p>
<h2 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h2><p>&emsp;&emsp;模板是实现泛型编程的基础，其中又可细分为<strong>函数模板</strong>和<strong>类模板</strong>。</p>
<h3 id="函数模板"><a href="#函数模板" class="headerlink" title="函数模板"></a>函数模板</h3><p>&emsp;&emsp;函数模板是生成一个家族的函数，其中我们可以使用任意类型的参数进行传入。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">//定义函数模板,T为任意类型</span><br><span class="line">//class 也可替换为 typename</span><br><span class="line">template&lt;class T&gt;</span><br><span class="line">void Swap(T&amp; a, T&amp; b)</span><br><span class="line">&#123;</span><br><span class="line">    T t = a;</span><br><span class="line">    a = b;</span><br><span class="line">    b = t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int a = 4, b = 5;</span><br><span class="line">    double c = 6, d = 7;</span><br><span class="line">    Swap(a, b);</span><br><span class="line">    Swap(c, d);</span><br><span class="line">    cout &lt;&lt; a &lt;&lt; &quot; &quot; &lt;&lt; b &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; c &lt;&lt; &quot; &quot; &lt;&lt; d &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">5 4</span><br><span class="line">7 6</span><br></pre></td></tr></table></figure></p>
<h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><p>&emsp;&emsp;函数模板在定义完之后并不会直接生成函数，而是在调用时会根据传参类型进行推演，在上面的例子中我们传入了<code>int</code>类型的参数因此在推演时会将<code>T</code>转换为<code>int</code>再进行调用，但有时我们的调用如果出现了让编译器无法推演的情况就会导致报错。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">template&lt;class T&gt;</span><br><span class="line">void Swap(T&amp; a, T&amp; b)</span><br><span class="line">&#123;</span><br><span class="line">    T t = a;</span><br><span class="line">    a = b;</span><br><span class="line">    b = t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int a = 4, b = 5;</span><br><span class="line">    double c = 6, d = 7;</span><br><span class="line">    Swap(a, d);</span><br><span class="line">    Swap(c, b);</span><br><span class="line">    cout &lt;&lt; a &lt;&lt; &quot; &quot; &lt;&lt; b &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; c &lt;&lt; &quot; &quot; &lt;&lt; d &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">.\test.cpp: In function &apos;int main()&apos;:</span><br><span class="line">.\test.cpp:15:14: error: no matching function for call to &apos;Swap(int&amp;, double&amp;)&apos;</span><br><span class="line">     Swap(a, d);</span><br><span class="line">              ^</span><br><span class="line">.\test.cpp:4:6: note: candidate: template&lt;class T&gt; void Swap(T&amp;, T&amp;)</span><br><span class="line"> void Swap(T&amp; a, T&amp; b)</span><br><span class="line">      ^~~~</span><br><span class="line">.\test.cpp:4:6: note:   template argument deduction/substitution failed:</span><br><span class="line">.\test.cpp:15:14: note:   deduced conflicting types for parameter &apos;T&apos; (&apos;int&apos; and &apos;double&apos;)</span><br><span class="line">     Swap(a, d);</span><br><span class="line">              ^</span><br><span class="line">.\test.cpp:16:14: error: no matching function for call to &apos;Swap(double&amp;, int&amp;)&apos;</span><br><span class="line">     Swap(c, b);</span><br><span class="line">              ^</span><br><span class="line">.\test.cpp:4:6: note: candidate: template&lt;class T&gt; void Swap(T&amp;, T&amp;)</span><br><span class="line"> void Swap(T&amp; a, T&amp; b)</span><br><span class="line">      ^~~~</span><br><span class="line">.\test.cpp:4:6: note:   template argument deduction/substitution failed:</span><br><span class="line">.\test.cpp:16:14: note:   deduced conflicting types for parameter &apos;T&apos; (&apos;double&apos; and &apos;int&apos;)</span><br><span class="line">     Swap(c, b);</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;我们会发现在这样只有一个模板参数<code>T</code>进行多类型传入就会混淆编译器，导致报错，因此我们可以定义多个模板参数，也可以进行强转使参数类型唯一，不过这里要提到另一种可以让编译器推演出我们想要的函数的方式，<strong>显示实例化</strong>。</p>
<h4 id="显示实例化"><a href="#显示实例化" class="headerlink" title="显示实例化"></a>显示实例化</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">template&lt;class T&gt;</span><br><span class="line">T Add(T a, T b)</span><br><span class="line">&#123;</span><br><span class="line">    return a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int ret = Add&lt;int&gt;(1, 2);</span><br><span class="line">    cout &lt;&lt; ret &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">3</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;像是这样的情况我们就利用显示实例化给我们的函数模板制定了实例化类型，同时如果类型不匹配，编译器会进行隐式类型转换，如果转换不成功则会报错。</p>
<h4 id="函数模板匹配原则"><a href="#函数模板匹配原则" class="headerlink" title="函数模板匹配原则"></a>函数模板匹配原则</h4><p>&emsp;&emsp;函数模板可以与非模板函数重名，此时会构成类似于函数重载的情况，并且在函数调用时如果出现重名的函数模板和非模板函数都可以构成匹配则会优先调用非模板函数，而不会对函数模板进行实例化，除非我们利用显示实例化指定必须调用模板函数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">template&lt;class T&gt;</span><br><span class="line">T Add(T a, T b)</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; &quot;template function&quot; &lt;&lt; endl;</span><br><span class="line">    return a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int Add(int a, int b)</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; &quot;simple function&quot; &lt;&lt; endl;</span><br><span class="line">    return a + b;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int ret = Add(1, 2);//调用普通函数</span><br><span class="line">    ret = Add&lt;int&gt;(1, 2);//调用模板函数</span><br><span class="line">    cout &lt;&lt; ret &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">simple function</span><br><span class="line">template function</span><br><span class="line">3</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;但是如果模板函数此时可以提供更好的适配性，则会优先调用模板函数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">template&lt;class T1, class T2&gt;</span><br><span class="line">T1 Add(T1 a, T2 b)</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; &quot;template function&quot; &lt;&lt; endl;</span><br><span class="line">    return a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int Add(int a, int b)</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; &quot;simple function&quot; &lt;&lt; endl;</span><br><span class="line">    return a + b;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int ret = Add(1, 2.0);//优先调用函数模板</span><br><span class="line">    ret = Add&lt;int, double&gt;(1, 2.0);</span><br><span class="line">    cout &lt;&lt; ret &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">template function</span><br><span class="line">template function</span><br><span class="line">3</span><br></pre></td></tr></table></figure></p>
<h3 id="类模板"><a href="#类模板" class="headerlink" title="类模板"></a>类模板</h3><p>&emsp;&emsp;类模板与函数模板类似，是使用一个模板参数来构造整个类，并且原理也与函数模板类似，只有在类构造对象时才会推演模板参数进行实例化，实例化出我们想要的类。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;assert.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">template&lt;class T&gt;</span><br><span class="line">class Vector</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    Vector(size_t capacity = 10)</span><br><span class="line">        :_pData(new T[capacity])</span><br><span class="line">        ,_size(0)</span><br><span class="line">        ,_capacity(capacity)</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    ~Vector();</span><br><span class="line">    //返回size</span><br><span class="line">    size_t Size()</span><br><span class="line">    &#123;</span><br><span class="line">        return _size;</span><br><span class="line">    &#125;</span><br><span class="line">    //尾插</span><br><span class="line">    void Push_back(const T&amp; data)</span><br><span class="line">    &#123;</span><br><span class="line">        //检查扩容</span><br><span class="line">        if(_size &gt;= _capacity)</span><br><span class="line">        &#123;//扩容</span><br><span class="line">            Reserve(2 * _capacity);</span><br><span class="line">        &#125;</span><br><span class="line">        _pData[_size] = data;</span><br><span class="line">        _size++;</span><br><span class="line">    &#125;</span><br><span class="line">    //尾删</span><br><span class="line">    void Pop_back()</span><br><span class="line">    &#123;</span><br><span class="line">        _size--;</span><br><span class="line">    &#125;</span><br><span class="line">    //改变容量</span><br><span class="line">    void Reserve(int capacity)</span><br><span class="line">    &#123;</span><br><span class="line">        if(capacity &lt;= _capacity)</span><br><span class="line">        &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        T* newPData = new T[capacity];</span><br><span class="line">        for(int i = 0; i &lt; _size; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            newPData[i] = _pData[i];</span><br><span class="line">        &#125;</span><br><span class="line">        _pData = newPData;</span><br><span class="line">        _capacity = capacity;</span><br><span class="line">    &#125;</span><br><span class="line">    T operator[](size_t pos)</span><br><span class="line">    &#123;</span><br><span class="line">        assert(pos &lt; _size);</span><br><span class="line">        return _pData[pos];</span><br><span class="line">    &#125;</span><br><span class="line">private:</span><br><span class="line">    T* _pData;</span><br><span class="line">    size_t _size;</span><br><span class="line">    size_t _capacity;</span><br><span class="line">&#125;;</span><br><span class="line">//在类外进行函数声明时要加上模板参数</span><br><span class="line">//同时要注意Vector不是一个类，实例化后Vector&lt;T&gt;才是一个类</span><br><span class="line">template&lt;class T&gt;</span><br><span class="line">Vector&lt;T&gt;::~Vector()</span><br><span class="line">&#123;</span><br><span class="line">    if(_pData)</span><br><span class="line">    &#123;</span><br><span class="line">        delete[] _pData;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    Vector&lt;int&gt; arr;</span><br><span class="line">    arr.Push_back(1);</span><br><span class="line">    arr.Push_back(2);</span><br><span class="line">    for(int i = 0; i &lt; arr.Size(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; arr[i] &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1</span><br><span class="line">2</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;这个例子我们模拟简单实现了一个<code>vector</code>模板类，并且使用实例化进行使用，类模板与函数模板不同的是类模板往往无法推演出模板参数类型因此需要我们显示实例化使其实例化为一个具体的类才可以进行使用。</p>

          
        
      
    </div>
    
    
    

    

    <div>
    
    </div>

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/06/11/【Cpp】第三章-内存管理/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="MisakiFx">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/blog-logo.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Misaki`s blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/06/11/【Cpp】第三章-内存管理/" itemprop="url">【Cpp】第三章-内存管理</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-06-11T01:34:08+08:00">
                2019-06-11
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Cpp/" itemprop="url" rel="index">
                    <span itemprop="name">Cpp</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  2.6k
                </span>
              

              

              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h1><h2 id="C-内存管理"><a href="#C-内存管理" class="headerlink" title="C++内存管理"></a>C++内存管理</h2><p>&emsp;&emsp;在C语言中，我们想要动态分配内存空间需要使用到<code>malloc,calloc,realloc</code>函数，在C++中我们同样有动态进行内存管理的方式，并且与C语言中的内存管理有着一些区别。</p>
<h3 id="new-delete"><a href="#new-delete" class="headerlink" title="new/delete"></a>new/delete</h3><p>&emsp;&emsp;在C++中我们使用<code>new</code>进行内存的申请，用<code>delete</code>进行内存的释放。他们的使用比<code>malloc</code>和<code>free</code>更加简单方便。</p>
<h4 id="内置类型的内存分配与释放"><a href="#内置类型的内存分配与释放" class="headerlink" title="内置类型的内存分配与释放"></a>内置类型的内存分配与释放</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">  int* a = new int;</span><br><span class="line">  //等同于int* a = (int*)malloc(sizeof(int));</span><br><span class="line">  int* b = new int[10];</span><br><span class="line">  //等同于int* b = (int*)malloc(sizeof(int) * 10);</span><br><span class="line">  int* c = new int(10);</span><br><span class="line">  //new还可以进行内置类型的初始化</span><br><span class="line">  cout &lt;&lt; *c &lt;&lt; endl;</span><br><span class="line">  delete a;</span><br><span class="line">  //等同于free(a);</span><br><span class="line">  delete[] b;//对于多个变量的空间释放要用delete[]</span><br><span class="line">  //等同于free(b);</span><br><span class="line">  delete c;</span><br><span class="line">  //等同于free(c);                                </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[misaki@localhost 第三章-内存管理]$ ./New</span><br><span class="line">10</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;<code>new</code>和<code>malloc</code>一样会在堆上开辟空间同时需要我们手动进行内存的释放，但是<code>new</code>的写法更加简单易于理解同时我们还可以对单个申请的变量进行初始化。</p>
<h4 id="自定义类型的内存分配与释放"><a href="#自定义类型的内存分配与释放" class="headerlink" title="自定义类型的内存分配与释放"></a>自定义类型的内存分配与释放</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;                                 </span><br><span class="line">#include &lt;stdlib.h&gt;  </span><br><span class="line">using namespace std;                           </span><br><span class="line">class Stu                </span><br><span class="line">&#123;                                                   </span><br><span class="line">  public:                </span><br><span class="line">    Stu()                          </span><br><span class="line">    &#123;                  </span><br><span class="line">      cout &lt;&lt; &quot;default building&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;;              </span><br><span class="line">    Stu(int num, string name):_num(num), _name(name)</span><br><span class="line">    &#123;               </span><br><span class="line">      cout &lt;&lt; &quot;custom building&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;               </span><br><span class="line">    ~Stu()                  </span><br><span class="line">    &#123;                                </span><br><span class="line">      cout &lt;&lt; &quot;destroying&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;                         </span><br><span class="line">  private:                  </span><br><span class="line">    int _num;                            </span><br><span class="line">    string _name;        </span><br><span class="line">&#125;;                    </span><br><span class="line">int main()</span><br><span class="line">&#123;         </span><br><span class="line">  cout &lt;&lt; &quot;malloc:&quot; &lt;&lt; endl;</span><br><span class="line">  Stu* a = (Stu*)malloc(sizeof(Stu));</span><br><span class="line">  cout &lt;&lt; &quot;new:&quot; &lt;&lt; endl;</span><br><span class="line">  Stu* b = new Stu(1, &quot;张三&quot;);</span><br><span class="line">  cout &lt;&lt; &quot;malloc:&quot; &lt;&lt; endl;</span><br><span class="line">  Stu* c = (Stu*)malloc(sizeof(Stu) * 5);</span><br><span class="line">  cout &lt;&lt; &quot;new:&quot; &lt;&lt; endl;</span><br><span class="line">  Stu* d = new Stu[5];</span><br><span class="line">  cout &lt;&lt; &quot;free:&quot; &lt;&lt; endl;</span><br><span class="line">  free(a);</span><br><span class="line">  cout &lt;&lt; &quot;delete:&quot; &lt;&lt; endl;</span><br><span class="line">  delete b;</span><br><span class="line">  cout &lt;&lt; &quot;free:&quot; &lt;&lt; endl;</span><br><span class="line">  free(c);</span><br><span class="line">  cout &lt;&lt; &quot;delete:&quot; &lt;&lt; endl;</span><br><span class="line">  delete[] d;</span><br><span class="line">&#125;              </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[misaki@localhost 第三章-内存管理]$ ./New </span><br><span class="line">malloc:</span><br><span class="line">new:</span><br><span class="line">custom building</span><br><span class="line">malloc:</span><br><span class="line">new:</span><br><span class="line">default building</span><br><span class="line">default building</span><br><span class="line">default building</span><br><span class="line">default building</span><br><span class="line">default building</span><br><span class="line">free:</span><br><span class="line">delete:</span><br><span class="line">destroying</span><br><span class="line">free:</span><br><span class="line">delete:</span><br><span class="line">destroying</span><br><span class="line">destroying</span><br><span class="line">destroying</span><br><span class="line">destroying</span><br><span class="line">destroying</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;以上这段代码我分别使用<code>malloc</code>和<code>new</code>对自定义类型进行内存分配和释放，我们可以发现<code>new</code>不但可以在分配内存的时候手动调用指定的构造函数还会在分配多个对象的空间时自动调用默认构造函数，<code>delete</code>也会自动调用析构函数，而<code>malloc</code>和<code>free</code>却做不到这一点。因此可以理解<strong>为<code>malloc</code>和<code>free</code>分配出来的只不过是一个和类一样大小的空间，并不能称作是一个对象，而<code>new</code>和<code>delete</code>分配出来的才能被成为对象</strong>。</p>
<h2 id="new和delete实现原理"><a href="#new和delete实现原理" class="headerlink" title="new和delete实现原理"></a>new和delete实现原理</h2><p>&emsp;&emsp;<code>new</code>和<code>delete</code>在C++中其实被定义为两个运算符，我们在使用这两个运算符的时候它会在底层调用全局函数<code>operator new</code>和<code>operator delete</code>。</p>
<h3 id="operator-new-operator-delete"><a href="#operator-new-operator-delete" class="headerlink" title="operator new/operator delete"></a>operator new/operator delete</h3><p>&emsp;&emsp;我们首先看下这两个函数在底层的实现源码。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">void *__CRTDECL operator new(size_t size) _THROW1(_STD bad_alloc)</span><br><span class="line">&#123;</span><br><span class="line"> // try to allocate size bytes</span><br><span class="line"> void *p;</span><br><span class="line"> while ((p = malloc(size)) == 0)</span><br><span class="line"> if (_callnewh(size) == 0)</span><br><span class="line"> &#123;</span><br><span class="line"> // report no memory</span><br><span class="line"> // 如果申请内存失败了，这里会抛出bad_alloc 类型异常</span><br><span class="line"> static const std::bad_alloc nomem;</span><br><span class="line"> _RAISE(nomem);</span><br><span class="line"> &#125;</span><br><span class="line"> return (p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">void operator delete(void *pUserData)</span><br><span class="line">&#123;</span><br><span class="line"> _CrtMemBlockHeader * pHead;</span><br><span class="line"> RTCCALLBACK(_RTC_Free_hook, (pUserData, 0));</span><br><span class="line"> if (pUserData == NULL)</span><br><span class="line"> return;</span><br><span class="line">  _mlock(_HEAP_LOCK); /* block other threads */</span><br><span class="line"> __TRY</span><br><span class="line"> /* get a pointer to memory block header */</span><br><span class="line"> pHead = pHdr(pUserData);</span><br><span class="line"> /* verify block type */</span><br><span class="line"> _ASSERTE(_BLOCK_TYPE_IS_VALID(pHead-&gt;nBlockUse));</span><br><span class="line"> _free_dbg( pUserData, pHead-&gt;nBlockUse );</span><br><span class="line"> __FINALLY</span><br><span class="line"> _munlock(_HEAP_LOCK); /* release other threads */</span><br><span class="line"> __END_TRY_FINALLY</span><br><span class="line"> return;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;从源码中能看出的是<code>operator new</code>和<code>operator delete</code>在底层也是利用<code>malloc</code>和<code>free</code>分配内存的，因此可以说<code>new</code>和<code>delete</code>不过是<code>malloc</code>和<code>free</code>的一层封装。因此在某些情况下，我们想要用独特的方式给一个类分配内存空间的时候我们就可以重新重载这两个运算符来达到我们的目的。基于这个原理如果有某些类需要特殊的内存分配方式我们可以对其进行运算符的重载。</p>
<h3 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h3><h4 id="内置类型"><a href="#内置类型" class="headerlink" title="内置类型"></a>内置类型</h4><p>&emsp;&emsp;对于内置类型来说<code>new</code>和<code>malloc</code>,<code>delete</code>和<code>free</code>的功能一致，不同的是<code>new[]</code>和<code>delete[]</code>才能分配多个连续的空间。</p>
<h4 id="自定义类型"><a href="#自定义类型" class="headerlink" title="自定义类型"></a>自定义类型</h4><h5 id="单个元素空间分配"><a href="#单个元素空间分配" class="headerlink" title="单个元素空间分配"></a>单个元素空间分配</h5><p>&emsp;&emsp;1、<strong>new</strong>:<br><br>&emsp;&emsp;&emsp;&emsp;1)首先调用<code>operator new</code>为对象分配空间。<br><br>&emsp;&emsp;&emsp;&emsp;2)调用对象的构造函数对对象进行初始化。<br><br>&emsp;&emsp;2、<strong>delete</strong>:<br><br>&emsp;&emsp;&emsp;&emsp;1)调用对象的析构函数进行对象中资源的空间清理。<br><br>&emsp;&emsp;&emsp;&emsp;2)调用<code>operator delete</code>释放对象的空间。</p>
<h5 id="多个元素空间分配"><a href="#多个元素空间分配" class="headerlink" title="多个元素空间分配"></a>多个元素空间分配</h5><p>&emsp;&emsp;1、<strong>new[]</strong>:<br><br>&emsp;&emsp;&emsp;&emsp;1)调用<code>operator new[]</code>，在<code>operator new[]</code>中调用<code>operator new</code>完成N个对象的空间的分配。<br><br>&emsp;&emsp;&emsp;&emsp;2)调用构造函数N次完成N个对象的初始化。<br><br>&emsp;&emsp;2、<strong>delete[]</strong>:<br><br>&emsp;&emsp;&emsp;&emsp;1)调用析构函数N次完成N个对象资源的清理。<br><br>&emsp;&emsp;&emsp;&emsp;2)调用<code>operator delete[]</code>,在<code>operator delete[]</code>中调用<code>operator delete</code>完成N个对象的空间的释放。</p>
<h2 id="定位new表达式"><a href="#定位new表达式" class="headerlink" title="定位new表达式"></a>定位new表达式</h2><p>&emsp;&emsp;当我们用<code>malloc</code>或者其他方式分配了一块和某个类一样大小的空间给，并用某个指针去指向这块空间。但是问题在于这块空间并未执行构造函数因此并不能称为对象。因此定位new表达式就是为了帮助我们对一块已经分配好的空间执行构造函数使之成为对象的一个方式。</p>
<h3 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h3><p>&emsp;&emsp;<code>new (place_address) type(initializer-list)。</code><br><br>&emsp;&emsp;<code>place_address</code>为指向某一块空间的指针，<code>type</code>为自定义类型，<code>initializer-list</code>为参数列表。</p>
<h3 id="例"><a href="#例" class="headerlink" title="例"></a>例</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;                                 </span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class Stu                                          </span><br><span class="line">&#123;                   </span><br><span class="line">  public:    </span><br><span class="line">    Stu()           </span><br><span class="line">    &#123;                         </span><br><span class="line">      cout &lt;&lt; &quot;default building&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;;                     </span><br><span class="line">    Stu(int num, string name):_num(num), _name(name)</span><br><span class="line">    &#123;                         </span><br><span class="line">      cout &lt;&lt; &quot;custom building&quot; &lt;&lt; endl;   </span><br><span class="line">    &#125;                      </span><br><span class="line">    ~Stu()              </span><br><span class="line">    &#123;                       </span><br><span class="line">      cout &lt;&lt; &quot;destroying&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;                         </span><br><span class="line">  private:   </span><br><span class="line">    int _num;               </span><br><span class="line">    string _name;</span><br><span class="line">&#125;;                            </span><br><span class="line">int main()     </span><br><span class="line">&#123;                                    </span><br><span class="line">  Stu* p = (Stu*)malloc(sizeof(Stu));</span><br><span class="line">  cout &lt;&lt; &quot;定位new表达式：&quot; &lt;&lt; endl;</span><br><span class="line">  new(p) Stu(1,&quot;张三&quot;);              </span><br><span class="line">  delete p;              </span><br><span class="line">&#125;                                    </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[misaki@localhost 第三章-内存管理]$ ./New</span><br><span class="line">定位new表达式：</span><br><span class="line">custom building</span><br><span class="line">destroying</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;这样我们就用定位new表达式给已经分配好的空间调用了构造函数。</p>
<h2 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h2><h3 id="new和malloc的异同"><a href="#new和malloc的异同" class="headerlink" title="new和malloc的异同"></a>new和malloc的异同</h3><h4 id="相同"><a href="#相同" class="headerlink" title="相同"></a>相同</h4><p>&emsp;&emsp;1、<code>new</code>和<code>delete</code>都在堆上进行空间的申请。<br><br>&emsp;&emsp;2、都需要手动释放空间。</p>
<h4 id="不同"><a href="#不同" class="headerlink" title="不同"></a>不同</h4><p>&emsp;&emsp;1、<code>malloc</code>和<code>free</code>是函数而<code>new</code>和<code>delete</code>是运算符。<br><br>&emsp;&emsp;2、<code>new</code>可以在分配空间的时候进行初始化。<br><br>&emsp;&emsp;3、<code>malloc</code>返回值是<code>void*</code>需要强转，<code>new</code>会直接返回与分配空间类型一样的类型指针。<br><br>&emsp;&emsp;4、<code>malloc</code>需要手动计算分配空间大小在进行传入，而<code>new</code>只需要类型和元素个数，空间大小会自动计算。<br><br>&emsp;&emsp;5、<code>new</code>在给自定义类型分配空间的时候会自动调用其构造函数，<code>delete</code>会自动调用其析构函数。<br><br>&emsp;&emsp;6、<code>malloc</code>申请空间失败会返回<code>NULL</code>，<code>new</code>会抛异常。<br><br>&emsp;&emsp;7、<code>new</code>和<code>delete</code>是<code>malloc</code>和<code>free</code>的一层封装，因此效率会低一些。</p>
<h3 id="写一个只能在堆上创建对象的类"><a href="#写一个只能在堆上创建对象的类" class="headerlink" title="写一个只能在堆上创建对象的类"></a>写一个只能在堆上创建对象的类</h3><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>&emsp;&emsp;1、将构造函数，赋值构造函数全部封装为私有，不允许外部直接调用构造。<br><br>&emsp;&emsp;2、单独写一个静态函数提供在堆上创建对象的接口。</p>
<h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class HeapOnly</span><br><span class="line">&#123;</span><br><span class="line">  public:</span><br><span class="line">    //开放构造接口                        </span><br><span class="line">    static HeapOnly* Create()</span><br><span class="line">    &#123;</span><br><span class="line">      cout &lt;&lt; &quot;create int heap&quot; &lt;&lt; endl;</span><br><span class="line">      return new HeapOnly();</span><br><span class="line">    &#125;</span><br><span class="line">    ~HeapOnly()</span><br><span class="line">    &#123;</span><br><span class="line">      cout &lt;&lt; &quot;destorying&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">  private:</span><br><span class="line">    //构造函数私有化</span><br><span class="line">    HeapOnly()&#123;&#125;</span><br><span class="line">    HeapOnly(const HeapOnly&amp;)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">  HeapOnly* heapOnly = HeapOnly::Create();</span><br><span class="line">  delete heapOnly;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[misaki@localhost 第三章-内存管理]$ ./HeapOnlyClass</span><br><span class="line">create int heap</span><br><span class="line">destorying</span><br></pre></td></tr></table></figure>
<h3 id="写一个只能在栈上创建对象的类"><a href="#写一个只能在栈上创建对象的类" class="headerlink" title="写一个只能在栈上创建对象的类"></a>写一个只能在栈上创建对象的类</h3><h4 id="思路一"><a href="#思路一" class="headerlink" title="思路一"></a>思路一</h4><p>&emsp;&emsp;1、将构造函数，赋值构造函数全部封装为私有，不允许外部直接调用构造。<br><br>&emsp;&emsp;2、单独写一个静态函数提供在栈上创建对象的接口。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class StackOnly</span><br><span class="line">&#123;</span><br><span class="line">  public:</span><br><span class="line">    static StackOnly Create()</span><br><span class="line">    &#123;</span><br><span class="line">      //创建匿名对象</span><br><span class="line">      return StackOnly();</span><br><span class="line">    &#125;</span><br><span class="line">    static StackOnly a;</span><br><span class="line">    ~StackOnly()</span><br><span class="line">    &#123;</span><br><span class="line">      cout &lt;&lt; &quot;destorying&quot; &lt;&lt; endl;      </span><br><span class="line">    &#125;</span><br><span class="line">  private:</span><br><span class="line">    StackOnly()</span><br><span class="line">    &#123;</span><br><span class="line">      cout &lt;&lt; &quot;create in stack&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    StackOnly(const StackOnly&amp;)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">  StackOnly::a = StackOnly::Create();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[misaki@localhost 第三章-内存管理]$ ./StackOnlyClass </span><br><span class="line">create in stack</span><br><span class="line">destorying</span><br></pre></td></tr></table></figure></p>
<h4 id="思路二"><a href="#思路二" class="headerlink" title="思路二"></a>思路二</h4><p>&emsp;&emsp;1、直接将<code>operator new</code>和<code>operator delete</code>重载并定义为私有。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;                     </span><br><span class="line">using namespace std;               </span><br><span class="line">class StackOnly                  </span><br><span class="line">&#123;</span><br><span class="line">  public:      </span><br><span class="line">    StackOnly()</span><br><span class="line">    &#123;    </span><br><span class="line">      cout &lt;&lt; &quot;create in stack&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    ~StackOnly()    </span><br><span class="line">    &#123;                    </span><br><span class="line">      cout &lt;&lt; &quot;destorying&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;                  </span><br><span class="line">  private:      </span><br><span class="line">    void* operator new(size_t size)&#123;&#125;</span><br><span class="line">    void operator delete(void* p)&#123;&#125;</span><br><span class="line">&#125;;   </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;                   </span><br><span class="line">  StackOnly p;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="实现单例模式"><a href="#实现单例模式" class="headerlink" title="实现单例模式"></a>实现单例模式</h3><p>&emsp;&emsp;单例模式是一种设计模式，在实战中经常会用到。其意思是创建一个类这个类只能唯一的创建一个对象，如果之后还想用这个类创建新对象的时候都会返回最开始创建的呢个对象。<br><br>&emsp;&emsp;要实现这一点有两种思路，分别成为<strong>懒汉模式</strong>和<strong>饿汉模式</strong>。</p>
<h4 id="饿汉模式"><a href="#饿汉模式" class="headerlink" title="饿汉模式"></a>饿汉模式</h4><p>&emsp;&emsp;饿汉模式是在程序启动时就夹在所有需要资源的设计模式，用这种思想实现单例模式时需要在程序一开始就直接声明对象，需要适用对象就返回对象即可。但是坏处是程序启动时会消耗时间可能会造成程序启动缓慢。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;  </span><br><span class="line">using namespace std;  </span><br><span class="line">class Singleton  </span><br><span class="line">&#123;  </span><br><span class="line">  public:  </span><br><span class="line">    Singleton* GetInstance()  </span><br><span class="line">    &#123;  </span><br><span class="line">      return &amp;_instance;  </span><br><span class="line">    &#125;  </span><br><span class="line">  private:  </span><br><span class="line">    //构造函数私有化  </span><br><span class="line">    Singleton()&#123;&#125;  </span><br><span class="line">    Singleton(const Singleton&amp;)&#123;&#125;</span><br><span class="line">    static Singleton _instance;  </span><br><span class="line">&#125;;</span><br><span class="line">Singleton Singleton::_instance;</span><br></pre></td></tr></table></figure></p>
<h4 id="懒汉模式"><a href="#懒汉模式" class="headerlink" title="懒汉模式"></a>懒汉模式</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">class Singleton  </span><br><span class="line">&#123;           </span><br><span class="line">  public:   </span><br><span class="line">  static Singleton* GetInstance()                 </span><br><span class="line">  &#123;</span><br><span class="line">    if(inst == nullptr)//双重判断避免不要的锁竞争</span><br><span class="line">    &#123;</span><br><span class="line">      pthread_mutex_lock(&amp;lock);//加锁保证线程安全</span><br><span class="line">      if(inst == nullptr)</span><br><span class="line">      &#123;                                           </span><br><span class="line">        inst = new Singleton();                   </span><br><span class="line">      &#125;                                           </span><br><span class="line">      pthread_mutex_unlock(&amp;lock);                </span><br><span class="line">    &#125;                                             </span><br><span class="line">    return inst;                                  </span><br><span class="line">  &#125;                                               </span><br><span class="line">  private:                                        </span><br><span class="line">  static Singleton* inst;                         </span><br><span class="line">  static pthread_mutex_t lock;                    </span><br><span class="line">  Singleton()&#123;&#125;                                   </span><br><span class="line">  Singleton(const Singleton&amp;)&#123;&#125;                   </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;懒汉模式就是在第一次使用时才会创建对象，因此我们需要对变量进行判断考虑到线程安全我们需要对其加锁。懒汉模式的坏处是可能造成程序运行卡顿。</p>

          
        
      
    </div>
    
    
    

    

    <div>
    
    </div>

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/6/">6</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/blog-logo.jpg"
                alt="MisakiFx" />
            
              <p class="site-author-name" itemprop="name">MisakiFx</p>
              <p class="site-description motion-element" itemprop="description">Hard working or giving up!!!</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">56</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">8</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">33</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/MisakiFx" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="mailto:1761607418@qq.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope-open"></i>E-Mail</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://music.163.com/#/user/home?id=432551242" target="_blank" title="网易云音乐">
                      
                        <i class="fa fa-fw fa-music"></i>网易云音乐</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://blog.csdn.net/qq_41669298" target="_blank" title="CSDN">
                      
                        <i class="fa fa-fw fa-crosshairs"></i>CSDN</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        ﻿<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js">
</script>
<div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">MisakiFx</span>

  
</div>


<div class="powered-by">
  <i class="fa fa-user-md"></i>
  <span id="busuanzi_container_site_uv">
    我的网站的访客数:<span id="busuanzi_value_site_uv"></span>
  </span>
</div>



<span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.4</div>




<div class="theme-info">
  <div class="powered-by"></div>
  <span class="post-count">博客全站共132.2k字</span>
</div>

        ﻿







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  


  











  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  

  
  
    <script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

  <!-- 页面点击小红心 -->
        <script type="text/javascript" src="/js/src/love.js"></script>
<script src="/live2dw/lib/L2Dwidget.min.js?0c58a1486de42ac6cc1c59c7d98ae887"></script><script>L2Dwidget.init({"pluginModelPath":"assets/","model":{"jsonPath":"/live2dw/assets/z16.model.json"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":false},"log":false,"pluginJsPath":"lib/","pluginRootPath":"live2dw/","tagMode":false});</script></body>
</html>
