<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.ico?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon_16.ico?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta name="description" content="Hard working or giving up!!!">
<meta property="og:type" content="website">
<meta property="og:title" content="Misaki`s blog">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="Misaki`s blog">
<meta property="og:description" content="Hard working or giving up!!!">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Misaki`s blog">
<meta name="twitter:description" content="Hard working or giving up!!!">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/"/>





  <title>Misaki`s blog</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

<a href="https://github.com/MisakiFx" class="github-corner" aria-label="View source on GitHub"><svg width="80" height="80" viewBox="0 0 250 250" style="fill:#64CEAA; color:#fff; position: absolute; top: 0; border: 0; left: 0; transform: scale(-1, 1);" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Misaki`s blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">学习是一种态度</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/07/30/【Cpp】第八章-STL-deque类/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="MisakiFx">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/blog-logo.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Misaki`s blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/07/30/【Cpp】第八章-STL-deque类/" itemprop="url">【Cpp】第八章-STL_deque类</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-07-30T16:39:49+08:00">
                2019-07-30
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Cpp/" itemprop="url" rel="index">
                    <span itemprop="name">Cpp</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  1.4k
                </span>
              

              

              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="deque类"><a href="#deque类" class="headerlink" title="deque类"></a>deque类</h1><h2 id="基础介绍"><a href="#基础介绍" class="headerlink" title="基础介绍"></a>基础介绍</h2><p>&emsp;&emsp;<code>deque</code>是双端队列，它提供了和<code>vector</code>类似的接口但是底层的实现与<code>vector</code>完全不同，<code>vector</code>底层用三个指针指向数组的起点，尾部和总容量的尾部，并且所有元素都是连续的，但是在<code>deque</code>中所有元素并不一定都是在连续的内存空间上的。<code>deque</code>在底层实现上是将一个连续的空间分段进行管理，并将它们的首地址用一个指针数组进行管理，这样特殊的存储结构使得它在头部和尾部增加元素比<code>vector</code>更加高效，但是底层实现更为复杂，存储了很多额外信息。如果抛去在头部和尾部增加元素，在中间任意位置添加元素，它的效率比vector更高，但是比list要低。</p>
<h2 id="常用接口"><a href="#常用接口" class="headerlink" title="常用接口"></a>常用接口</h2><h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">deque();                                                  //构造空的双端队列</span><br><span class="line">deque(size_type n, const value_type &amp;val = value_type()); //用n个值为val的元素构造双端队列</span><br><span class="line">deque(InputIterator first, InputIterator last);           //用[first, last)的区间构造双端队列</span><br><span class="line">deque(const deque &amp;x);                                    //双端队列的拷贝构造函数</span><br></pre></td></tr></table></figure>
<h3 id="迭代器相关"><a href="#迭代器相关" class="headerlink" title="迭代器相关"></a>迭代器相关</h3><p>&emsp;&emsp;由于<code>deque</code>在内存上并不完全是连续的因此想要保持deque的连续性，这个任务就落到了迭代器身上。在底层实现上，<code>deque</code>将一段一段连续的内存称为一个缓冲区(buffer)，并将这些缓冲区的首尾地址存储在一个map中用以映射，map中一个存储缓冲区的地址对应一个结点(node)信息用于标记这个键值对，这样就构建好了基础架构。在迭代器中存储了4个信息，分别是当前结点(cur)，当前缓冲区的头(first)，当前缓冲区的尾(last)以及在map中用以标记当前缓冲区的地址的结点(node)信息。并且在<code>deque</code>内部已经存储好了两个迭代器<code>start</code>和<code>finish</code>用于标记<code>deque</code>的头和尾元素。这样即可完成将一段一段连续的空间在逻辑结构上构成一段连续空间的目的。<br>&emsp;&emsp;当从头遍历<code>deque</code>时，<code>start</code>迭代器中<code>first</code>和<code>last</code>已经从map中找到了第一个结点的缓冲区首尾信息并进行了保存，于是<code>cur</code>就从<code>first</code>开始遍历这个缓冲区，当遍历到<code>last</code>时就重新到map中寻找写一个结点的缓冲区收尾地址并且替换掉原来<code>first</code>和<code>last</code>值，继续遍历，这样即可完成遍历直到最后一个结点也遍历完。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">iterator begin();                       //返回deque起始位置迭代器</span><br><span class="line">iterator end();                         //返回deque最后一个元素下一个位置的迭代器</span><br><span class="line">reverse_iterator rbegin();              //返回deque起始位置的反向迭代器(即end())</span><br><span class="line">reverse_iterator rend();                //返回deque最后一个元素下一个位置的反向迭代器(begin())</span><br><span class="line">const_iterator cbegin() const;          //返回deque起始位置的const迭代器</span><br><span class="line">const_iterator cend() const;            //返回deque最后一个元素下一个位置的const迭代器</span><br><span class="line">const_reverse_iterator crbegin() const; //返回deque起始位置的const反向迭代器(即crend())</span><br><span class="line">const_reverse_iterator crend() const;   //返回deque最后一个元素下一个位置的const反向迭代器(crbegin())</span><br></pre></td></tr></table></figure></p>
<h3 id="容量相关"><a href="#容量相关" class="headerlink" title="容量相关"></a>容量相关</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">size_type size() const;               //返回deque中有效元素个数</span><br><span class="line">bool empty() const;                   //检测deque是否为空，是返回true，否则返回false</span><br><span class="line">void resize(size_type sz, T c = T()); //将deque中的元素改变到sz，多出的空间用c填充</span><br></pre></td></tr></table></figure>
<h3 id="增删改查"><a href="#增删改查" class="headerlink" title="增删改查"></a>增删改查</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">reference operator[](size_type n);                         //返回deque中n位置上元素的引用</span><br><span class="line">const_reference operator[](size_type n) const;             //返回deque中n位置上元素的const 引用</span><br><span class="line">reference front();                                         //返回deque中首元素的引用</span><br><span class="line">const_reference front() const;                             //返回deque中首元素的const引用</span><br><span class="line">reference back();                                          //返回deque中最后一个元素的引用</span><br><span class="line">const_reference back() const;                              //返回deque中最后一个元素的const引用</span><br><span class="line">void push_back(const value_type &amp;val);                     //deque尾部插入元素val</span><br><span class="line">void pop_back();                                           //删除deque尾部元素</span><br><span class="line">void push_front(const value_type &amp;val);                    //deque头部插入元素val</span><br><span class="line">void pop_front();                                          //删除deque头部元素</span><br><span class="line">iterator insert(iterator position, const value_type &amp;val); //在deque的position位置插入值为val的元素</span><br><span class="line">void insert(iterator position, size_type n,</span><br><span class="line">            const value_type &amp;val);                                      //在deque的position位置插入n个值为val的元素</span><br><span class="line">void insert(iterator position, InputIterator first, InputIterator last); //在deque的position位置插入[first, last)区间中的元素</span><br><span class="line">iterator erase(iterator position);                                       //删除deque中position位置的元素，并返回该位置的下一个位置</span><br><span class="line">iterator erase(iterator first, iterator last);                           //删除deque中[first, last)区间中的元素，并返回last位置</span><br><span class="line">void swap(deque &amp; x);                                                    //交换两个deque中的内容</span><br><span class="line">void clear();                                                            //将deque中的元素清空</span><br><span class="line">iterator emplace(const_iterator position, Args &amp;&amp; ... args);             //在deque的position位置构造元素，将元素所需内容通过参数类表传入</span><br><span class="line">void emplace_front(Args &amp;&amp; ... args);                                    //在deque的头部构造元素，元素的参数通过参数列表传入</span><br><span class="line">void emplace_back(Args &amp;&amp; ... args);                                     //在deque的尾部构造元素，元素的参数通过参数列表传入</span><br></pre></td></tr></table></figure>
<h3 id="综合运用"><a href="#综合运用" class="headerlink" title="综合运用"></a>综合运用</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;deque&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    deque&lt;int&gt; deq;</span><br><span class="line">    deq.push_front(1);</span><br><span class="line">    deq.push_back(2);</span><br><span class="line">    deque&lt;int&gt;::iterator it = deq.begin();</span><br><span class="line">    it = deq.insert(it, 0);</span><br><span class="line">    while(it != deq.end())</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; *it &lt;&lt; endl;</span><br><span class="line">        it++;</span><br><span class="line">    &#125;</span><br><span class="line">    it = deq.erase(--it);</span><br><span class="line">    it = deq.begin();</span><br><span class="line">    while(it != deq.end())</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; *it &lt;&lt; endl;</span><br><span class="line">        it++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>&emsp;&emsp;双端队列<code>deque</code>是一个设计并不算成功的容器，如果要随机访问单纯的查询多一点可以用<code>vector</code>而且更加方便，如果需要频繁插入那么<code>list</code>效率又会跟高，因此<code>deque</code>并不常用，其最常用的地方就是在作为适配器<code>stack</code>和<code>queue</code>的底层存储容器。</p>

          
        
      
    </div>
    
    
    

    

    <div>
    
    </div>

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/07/29/【Cpp】第七章-STL-list类/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="MisakiFx">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/blog-logo.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Misaki`s blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/07/29/【Cpp】第七章-STL-list类/" itemprop="url">【Cpp】第七章-STL_list类</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-07-29T23:12:49+08:00">
                2019-07-29
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Cpp/" itemprop="url" rel="index">
                    <span itemprop="name">Cpp</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  2.2k
                </span>
              

              

              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="list类"><a href="#list类" class="headerlink" title="list类"></a>list类</h1><h2 id="基础介绍"><a href="#基础介绍" class="headerlink" title="基础介绍"></a>基础介绍</h2><p>&emsp;&emsp;<code>list类</code>是STL中封装的链表模板类，并且底层实现是以双向链表作为基础进行封装的。在数据结构中，线性存储结构中主要分为顺序表和链表，前者在物理结构上拥有连续的内存空间和地址，在STL中<code>vector</code>和<code>string</code>都是使用了这种结构，其最大的特点就是方便进行随机访问并且尾插和尾删都能达到O1的时间复杂度并且使用方便，而链表作为物理结构上内存空间不连续的数据结构，其最大的特点就是方便在任何位置就行插入删除，<code>list</code>就是建立在此数据结构上封装出的模板类。</p>
<h2 id="常用接口"><a href="#常用接口" class="headerlink" title="常用接口"></a>常用接口</h2><h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">list();                                                  //构造空的list</span><br><span class="line">list(size_type n, const value_type &amp;val = value_type()); //构造的list中包含n个值为val的元素</span><br><span class="line">list(const list &amp;x);                                     //拷贝构造函数</span><br><span class="line">list(InputIterator first, InputIterator last);           //用[first, last)区间中的元素构造list</span><br></pre></td></tr></table></figure>
<h3 id="迭代器相关"><a href="#迭代器相关" class="headerlink" title="迭代器相关"></a>迭代器相关</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">begin();   //返回第一个元素的迭代器</span><br><span class="line">end();     //返回最后一个元素下一个位置的迭代器</span><br><span class="line">rbegin();  //返回第一个元素的reverse_iterator,即end位置</span><br><span class="line">rend();    //返回最后一个元素下一个位置的reverse_iterator,即begin位置</span><br><span class="line">cbegin();  //(C++11) 返回第一个元素的cosnt_iterator</span><br><span class="line">cend();    //(C++11) 返回最后一个元素下一个位置的const_iterator</span><br><span class="line">crbegin(); //(C++11) 即crend()位置</span><br><span class="line">crend();   //(C++11) 即crbegin()位置</span><br></pre></td></tr></table></figure>
<h3 id="容量相关"><a href="#容量相关" class="headerlink" title="容量相关"></a>容量相关</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">bool empty() const;  //检测list是否为空，是返回true，否则返回false</span><br><span class="line">size_t size() const; //返回list中有效节点的个数</span><br></pre></td></tr></table></figure>
<h3 id="增删查改"><a href="#增删查改" class="headerlink" title="增删查改"></a>增删查改</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">reference front();                      //返回list的第一个节点中值的引用</span><br><span class="line">const_reference front() const;          //返回list的第一个节点中值的const引用</span><br><span class="line">reference back();                       //返回list的最后一个节点中值的引用</span><br><span class="line">const_reference back() const;           //返回list的最后一个节点中值的const引用</span><br><span class="line">void push_front(const value_type &amp;val); //在list首元素前插入值为val的元素</span><br><span class="line">void pop_front();                       //删除list中第一个元素</span><br><span class="line">void push_back;                         //(const value_type&amp; val)在list尾部插入值为val的元素</span><br><span class="line">void pop_back();                        //删除list中最后一个元素</span><br><span class="line">template &lt;class... Args&gt;</span><br><span class="line">void emplace_front(Args &amp;&amp; ... args); //（C++11）在list第一个元素前根据参数直接构造元素</span><br><span class="line">template &lt;class... Args&gt;</span><br><span class="line">void emplace_back(Args &amp;&amp; ... args); //（C++11）在list最后一个元素后根据参数直接构造元素</span><br><span class="line">template &lt;class... Args&gt;</span><br><span class="line">iterator emplace(const_iterator position, Args &amp;&amp; ... args);             //（C++11）在链表的任意位置根据参数直接构造元素</span><br><span class="line">iterator insert(iterator position, const value_type &amp;val);               //在list position 位置中插入值为val的元素</span><br><span class="line">void insert(iterator position, size_type n, const value_type &amp;val);      //在list position位置插入n个值为val的元素</span><br><span class="line">void insert(iterator position, InputIterator first, InputIterator last); //在list position位置插入[first, last)区间中元素</span><br><span class="line">iterator erase(iterator position);                                       //删除list position位置的元素</span><br><span class="line">iterator erase(iterator first, iterator last);                           //删除list中[first, last)区间中的元素</span><br><span class="line">void swap(list &amp; x);                                                     //交换两个list中的元素</span><br><span class="line">void resize(size_type n, value_type val = value_type());                 //将list中有效元素个数改变到n个，多出的元素用val填充</span><br><span class="line">void clear();                                                            //清空list中的有效元素</span><br></pre></td></tr></table></figure>
<h2 id="emplace与insert"><a href="#emplace与insert" class="headerlink" title="emplace与insert"></a>emplace与insert</h2><p>&emsp;&emsp;在STL很多接口中我们都发现有一个<code>emplace()</code>的接口也是用来进行插入的，那么它与<code>insert()</code>和<code>push_back()</code>有什么区别呢？以下用<code>vector</code>举个例子，从接口调用上就能看出区别。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    struct Foo </span><br><span class="line">    &#123;</span><br><span class="line">        Foo(int n, double x)</span><br><span class="line">            :_n(n)</span><br><span class="line">            ,_x(x)</span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        int _n;</span><br><span class="line">        double _x;</span><br><span class="line">    &#125;;</span><br><span class="line">    vector&lt;Foo&gt; v;</span><br><span class="line">    v.emplace(v.begin(), 42, 3.1416);     // 没有临时变量产生</span><br><span class="line">    v.insert(v.begin(), Foo(42, 3.1416)); // 需要产生一个临时变量</span><br><span class="line">    v.insert(v.begin(), &#123;42, 3.1416&#125;);    // 需要产生一个临时变量</span><br><span class="line">    for(int i = 0; i &lt; v.size(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; v[i]._n &lt;&lt; &quot; &quot; &lt;&lt; v[i]._x &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">42 3.1416</span><br><span class="line">42 3.1416</span><br><span class="line">42 3.1416</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;在进行内置类型和拥有单参构造函数的类型的插入时我们只传入一个参数往往很难发现区别，但在我们必须传入多个参数才能进行插入时我们就会发现在使用<code>insert()</code>这些接口时我们必须插入与容器中元素类型相同的<strong>元素</strong>才能完成接口调用，这让我们不得不构造一个临时匿名对象，而<code>emplace</code>则不需要，我们只要按照构造一个对象那样给构造元素的参数即可省去了构造匿名对象的过程。而这其中需要用到<code>C++11</code>中的新标准<strong>变参模板</strong>和<strong>完美转发</strong>，因此<code>emplace</code>使用的时候要求编译器支持<code>C++11</code>标准。<br>&emsp;&emsp;<code>emplace</code>不光是调用接口上有所不同，在有的时候也可以提高我们的效率。例如在<code>list</code>中如果利用<code>insert</code>传入一个元素的时候我们就需要先调用元素的构造函数构造元素，然后再调用<code>Node</code>的构造函数以及该元素的拷贝构造函数构造一个拥有该元素值的结点，才能进行插入，而<code>emplace</code>则可以在创建结点时直接利用原本要构造临时元素对象的参数来直接构造结点，并且直接构造结点中的元素对象，<strong>相当于少了一次元素的拷贝构造，并且省去了构造临时对象，效率更高</strong>。</p>
<h2 id="list迭代器失效"><a href="#list迭代器失效" class="headerlink" title="list迭代器失效"></a>list迭代器失效</h2><p>&emsp;&emsp;对于<code>list</code>这种链式结构，在插入后是不会迭代器失效的，因为原先位置的迭代器依旧指向原来的结点，不会因为添加结点导致指向位置的变动。而在删除后迭代器原本指向的结点内存被释放，因此删除后删除结点的迭代器失效，但是其他结点迭代器指向不变因此不会发生迭代器失效。<br>&emsp;&emsp;总结：<strong>list只有在删除节点后才会发生迭代器失效，并且之后删除结点的迭代器失效</strong>。</p>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>&emsp;&emsp;<code>list</code>采用链式结构存储，因此实现起来要稍微麻烦一些，迭代器也需要额外进行封装。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;assert.h&gt;</span><br><span class="line">//定义结点类</span><br><span class="line">template&lt;class T&gt;</span><br><span class="line">struct ListNode</span><br><span class="line">&#123;</span><br><span class="line">    ListNode&lt;T&gt;* _prev;</span><br><span class="line">    ListNode&lt;T&gt;* _next;</span><br><span class="line">    T _data;</span><br><span class="line">    ListNode(const T&amp; data = T())</span><br><span class="line">        :_prev(nullptr)</span><br><span class="line">        ,_next(nullptr)</span><br><span class="line">        ,_data(data)</span><br><span class="line">    &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line">//由于const_iterator与iterator除了在迭代器返回值上不一样外其他要求完全一样</span><br><span class="line">//因此这里要进行实现时可以考虑定义两个类</span><br><span class="line">//但是这里使用一种取巧的方法我们将返回值类型当作模板参数传入模板中</span><br><span class="line">template&lt;class T, class Ref, class Ptr&gt;</span><br><span class="line">struct ListIterator</span><br><span class="line">&#123;</span><br><span class="line">    typedef ListNode&lt;T&gt; Node;</span><br><span class="line">    typedef ListIterator&lt;T, Ref, Ptr&gt; Self;</span><br><span class="line">    //构造函数</span><br><span class="line">    ListIterator(Node* node)</span><br><span class="line">        :_node(node)</span><br><span class="line">    &#123;&#125;</span><br><span class="line">    //operator* 为了让其可以和指针一样使用，返回引用</span><br><span class="line">    Ref operator*()</span><br><span class="line">    &#123;</span><br><span class="line">        return _node-&gt;_data;</span><br><span class="line">    &#125;</span><br><span class="line">    //operator-&gt; 为了让其可以和指针一样使用，返回指针</span><br><span class="line">    //这里实际调用it-&gt;只能取到数据的指针，所以正常来说得写成it-&gt;-&gt;</span><br><span class="line">    //但是经过编译器优化，只用写it-&gt;就可以取到值了</span><br><span class="line">    Ptr operator-&gt;()</span><br><span class="line">    &#123;</span><br><span class="line">        return &amp;(_node-&gt;_data);</span><br><span class="line">    &#125;</span><br><span class="line">    Self operator++()</span><br><span class="line">    &#123;</span><br><span class="line">        _node = _node-&gt;_next;</span><br><span class="line">        return _node;    </span><br><span class="line">    &#125;</span><br><span class="line">    Self operator++(int)</span><br><span class="line">    &#123;</span><br><span class="line">        Self temp(_node);</span><br><span class="line">        _node = _node-&gt;_next;</span><br><span class="line">        return temp;</span><br><span class="line">    &#125; </span><br><span class="line">    Self operator--()</span><br><span class="line">    &#123;</span><br><span class="line">        _node = _node-&gt;_prev;</span><br><span class="line">        return _node;    </span><br><span class="line">    &#125;</span><br><span class="line">    Self operator--(int)</span><br><span class="line">    &#123;</span><br><span class="line">        Self temp(_node);</span><br><span class="line">        _node = _node-&gt;_prev;</span><br><span class="line">        return temp;</span><br><span class="line">    &#125; </span><br><span class="line">    bool operator!=(Self it)</span><br><span class="line">    &#123;</span><br><span class="line">        return _node != it._node;</span><br><span class="line">    &#125;</span><br><span class="line">    Node* _node;</span><br><span class="line">&#125;;</span><br><span class="line">//构建一个带头结点双向循环链表来模拟实现list</span><br><span class="line">template&lt;class T&gt;</span><br><span class="line">class List</span><br><span class="line">&#123;</span><br><span class="line">    typedef ListNode&lt;T&gt; Node;</span><br><span class="line">public:</span><br><span class="line">    typedef ListIterator&lt;T, T&amp;, T*&gt; iterator;</span><br><span class="line">    typedef ListIterator&lt;T, const T&amp;, const T*&gt; const_iterator;</span><br><span class="line">    //构造函数j</span><br><span class="line">    List()</span><br><span class="line">    &#123;</span><br><span class="line">        _head = new Node;</span><br><span class="line">        _head-&gt;_next = _head;</span><br><span class="line">        _head-&gt;_prev = _head;</span><br><span class="line">    &#125;</span><br><span class="line">    //拷贝构造</span><br><span class="line">    List(const List&amp; list)</span><br><span class="line">        :_head(new Node)</span><br><span class="line">    &#123;</span><br><span class="line">        _head-&gt;_next = _head;</span><br><span class="line">        _head-&gt;_prev = _head;</span><br><span class="line">        const_iterator it = list.begin();</span><br><span class="line">        while(it != list.end())</span><br><span class="line">        &#123;</span><br><span class="line">            Push_back(*it);</span><br><span class="line">            it++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    //operator=重载</span><br><span class="line">    List&amp; operator=(const List&amp; list)</span><br><span class="line">    &#123;</span><br><span class="line">        List listTemp = list;</span><br><span class="line">        Swap(listTemp);</span><br><span class="line">    &#125;</span><br><span class="line">    //交换</span><br><span class="line">    void Swap(List&amp; list)</span><br><span class="line">    &#123;</span><br><span class="line">        std::swap(_head, list._head);</span><br><span class="line">    &#125;</span><br><span class="line">    //析构函数</span><br><span class="line">    ~List()</span><br><span class="line">    &#123;</span><br><span class="line">        </span><br><span class="line">        while(_head-&gt;_next != _head)</span><br><span class="line">        &#123;</span><br><span class="line">            Pop_back();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    iterator begin()</span><br><span class="line">    &#123;</span><br><span class="line">        return _head-&gt;_next;</span><br><span class="line">    &#125;</span><br><span class="line">    const_iterator begin() const</span><br><span class="line">    &#123;</span><br><span class="line">        return _head-&gt;_next;</span><br><span class="line">    &#125;</span><br><span class="line">    iterator end()</span><br><span class="line">    &#123;</span><br><span class="line">        return _head;</span><br><span class="line">    &#125;</span><br><span class="line">    const_iterator end() const</span><br><span class="line">    &#123;</span><br><span class="line">        return _head;</span><br><span class="line">    &#125;</span><br><span class="line">    iterator Erase(iterator&amp; it)</span><br><span class="line">    &#123;</span><br><span class="line">        assert(it._node != nullptr);</span><br><span class="line">        Node* pTemp = it._node;</span><br><span class="line">        Node* pNew = pTemp-&gt;_next;</span><br><span class="line">        //it-&gt;_node = pTemp-&gt;_next;</span><br><span class="line">        pTemp-&gt;_prev-&gt;_next = pTemp-&gt;_next;</span><br><span class="line">        pTemp-&gt;_next-&gt;_prev = pTemp-&gt;_prev;</span><br><span class="line">        delete pTemp;</span><br><span class="line">        return pNew;</span><br><span class="line">    &#125;</span><br><span class="line">    //插入</span><br><span class="line">    iterator Insert(iterator&amp; it, const T&amp; data = T())</span><br><span class="line">    &#123;</span><br><span class="line">        assert(it._node != nullptr);</span><br><span class="line">        Node* newNode = new Node(data);</span><br><span class="line">        newNode-&gt;_next = it._node;</span><br><span class="line">        newNode-&gt;_prev = it._node-&gt;_prev;</span><br><span class="line">        it._node-&gt;_prev-&gt;_next = newNode;</span><br><span class="line">        it._node-&gt;_prev  = newNode;</span><br><span class="line">        return newNode;</span><br><span class="line">    &#125;</span><br><span class="line">    //尾插</span><br><span class="line">    void Push_back(const T&amp; data)</span><br><span class="line">    &#123;</span><br><span class="line">        assert(_head != nullptr);</span><br><span class="line">        Node* tail = _head-&gt;_prev;</span><br><span class="line">        Node* newNode = new Node(data);</span><br><span class="line">        newNode-&gt;_next = _head;</span><br><span class="line">        newNode-&gt;_prev = tail;</span><br><span class="line">        tail-&gt;_next = newNode;</span><br><span class="line">        _head-&gt;_prev = newNode;</span><br><span class="line">    &#125;</span><br><span class="line">    //尾删</span><br><span class="line">    void Pop_back()</span><br><span class="line">    &#123;</span><br><span class="line">        assert(_head != nullptr);</span><br><span class="line">        if(_head-&gt;_next == _head)</span><br><span class="line">        &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        Node* tail = _head-&gt;_prev;</span><br><span class="line">        tail-&gt;_prev-&gt;_next = _head;</span><br><span class="line">        _head-&gt;_prev = tail-&gt;_prev;</span><br><span class="line">        delete tail;</span><br><span class="line">    &#125;</span><br><span class="line">private:</span><br><span class="line">    Node* _head;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>

          
        
      
    </div>
    
    
    

    

    <div>
    
    </div>

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/07/27/【算法】第二章-搜索/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="MisakiFx">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/blog-logo.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Misaki`s blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/07/27/【算法】第二章-搜索/" itemprop="url">【算法】第二章-搜索</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-07-27T17:46:48+08:00">
                2019-07-27
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/算法/" itemprop="url" rel="index">
                    <span itemprop="name">算法</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  2.2k
                </span>
              

              

              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="搜索"><a href="#搜索" class="headerlink" title="搜索"></a>搜索</h1><h2 id="深度优先搜索-DFS"><a href="#深度优先搜索-DFS" class="headerlink" title="深度优先搜索(DFS)"></a>深度优先搜索(DFS)</h2><p>&emsp;&emsp;深度优先搜索是使用递归的方式以深度为主逐个探索遍历每种情况，在排列组合，迷宫问题中十分常用。深度优先搜索思想简单，但是由于使用递归，要求我们遍历时探索的必须深度有限。不然有可能会使栈溢出。还要注意有时我们在使用深度优先搜索时情况过多，而大部分是无用解时就需要套入<strong>剪枝</strong>。<br>&emsp;&emsp;模型：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">DFS()</span><br><span class="line">&#123;</span><br><span class="line">    //1.判断边界，如果已经到达搜索的最深，则回退尝试其他可能</span><br><span class="line">    //2.尝试当下的每一种可能</span><br><span class="line">    //3.确定一种可能后，继续下一步</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="例1-员工的重要度"><a href="#例1-员工的重要度" class="headerlink" title="例1 员工的重要度"></a>例1 员工的重要度</h3><p>&emsp;&emsp;力扣：<br><a href="https://leetcode-cn.com/problems/employee-importance/submissions/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/employee-importance/submissions/</a></p>
<h4 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h4><p>&emsp;&emsp;抽象模型。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">DFS(id)</span><br><span class="line">&#123;</span><br><span class="line">    //1.获取当前员工的重要度</span><br><span class="line">    //2.累加每一个下属(for)的重要度,DFS(下属id)</span><br><span class="line">    //3.return累加的重要度</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int DFS(unordered_map&lt;int, Employee*&gt; em, int id)</span><br><span class="line">    &#123;</span><br><span class="line">        int curRet = em[id]-&gt;importance;</span><br><span class="line">        for(auto&amp; e : em[id]-&gt;subordinates)</span><br><span class="line">        &#123;</span><br><span class="line">            curRet += DFS(em, e);</span><br><span class="line">        &#125;</span><br><span class="line">        return curRet;</span><br><span class="line">    &#125;</span><br><span class="line">    int getImportance(vector&lt;Employee*&gt; employees, int id) &#123;</span><br><span class="line">        if(employees.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        unordered_map&lt;int, Employee*&gt; em;</span><br><span class="line">        for(auto&amp; e: employees)</span><br><span class="line">        &#123;</span><br><span class="line">            em[e-&gt;id] = e;</span><br><span class="line">        &#125;</span><br><span class="line">        return DFS(em, id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="例2-图像渲染"><a href="#例2-图像渲染" class="headerlink" title="例2 图像渲染"></a>例2 图像渲染</h3><p>&emsp;&emsp;力扣：<br><a href="https://leetcode-cn.com/problems/flood-fill/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/flood-fill/</a></p>
<h4 id="解析-1"><a href="#解析-1" class="headerlink" title="解析"></a>解析</h4><p>&emsp;&emsp;抽象模型。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">DFS()</span><br><span class="line">&#123;</span><br><span class="line">    //1.nx,ny染色</span><br><span class="line">    //2.处理上，下，左，右4个点</span><br><span class="line">    &#123;</span><br><span class="line">        //以深度优先逐个方向遍历周边4个点</span><br><span class="line">        //新位置颜色符合，且没有越界，且没有染过色</span><br><span class="line">        //符合条件处理新位置</span><br><span class="line">        DFS(新的位置)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">static int nextP[4][2] = &#123;&#123;0, 1&#125;, &#123;1, 0&#125;, &#123;0, -1&#125;, &#123;-1, 0&#125;&#125;;</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    void DFS(vector&lt;vector&lt;int&gt;&gt;&amp; image, int row, int col, int nx, int ny, vector&lt;vector&lt;int&gt;&gt; book, int newColor, int oldColor)</span><br><span class="line">    &#123;</span><br><span class="line">        image[nx][ny] = newColor;</span><br><span class="line">        book[nx][ny] = 1;</span><br><span class="line">        //上下左右遍历</span><br><span class="line">        for(int i = 0; i &lt; 4; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            int newx = nx + nextP[i][0];</span><br><span class="line">            int newy = ny + nextP[i][1];</span><br><span class="line">            if(newx &gt;= row || newx &lt; 0 || newy &gt;= col || newy &lt; 0)</span><br><span class="line">            &#123;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">            if(image[newx][newy] == oldColor &amp;&amp; book[newx][newy] == 0)</span><br><span class="line">            &#123;</span><br><span class="line">                DFS(image, row, col, newx, newy, book, newColor, oldColor);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; floodFill(vector&lt;vector&lt;int&gt;&gt;&amp; image, int sr, int sc, int newColor) &#123;</span><br><span class="line">        if(image.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            return image;</span><br><span class="line">        &#125;</span><br><span class="line">        int row = image.size();</span><br><span class="line">        int col = image[0].size();</span><br><span class="line">        int oldColor = image[sr][sc];</span><br><span class="line">        vector&lt;vector&lt;int&gt;&gt; book(row, vector&lt;int&gt;(col, 0));</span><br><span class="line">        DFS(image, row, col, sr, sc, book, newColor, oldColor);</span><br><span class="line">        return image;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="例3-走迷宫"><a href="#例3-走迷宫" class="headerlink" title="例3 走迷宫"></a>例3 走迷宫</h3><p>&emsp;&emsp;牛客：<br><a href="https://www.nowcoder.com/questionTerminal/6276dbbda7094978b0e9ebb183ba37b9" target="_blank" rel="noopener">https://www.nowcoder.com/questionTerminal/6276dbbda7094978b0e9ebb183ba37b9</a></p>
<h4 id="解析-2"><a href="#解析-2" class="headerlink" title="解析"></a>解析</h4><p>&emsp;&emsp;模型：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">DFS()</span><br><span class="line">&#123;</span><br><span class="line">    //1.当前位置已走，路径长度+1，并且置为墙表示走过了</span><br><span class="line">    //2.走到终点，和最短路径长度比较取最优</span><br><span class="line">    //3.遍历四周，如果不是墙且不越界则遍历</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;但是，这种模型在一张只有极少障碍物的迷宫中要消耗很多的时间，因为我们要让每一个结点都被遍历近10次，这其中会消耗大量时间，并且很多是无用的解。因此我们在其中可以加入动态规划的思想。<br>&emsp;&emsp;模型：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">DFS()</span><br><span class="line">&#123;</span><br><span class="line">    //1.遍历四周，如果不是墙且不越界则进行二次判断</span><br><span class="line">    //2.如果本次路径到达这个位置的路径数要小于以往在表中记录的路径数，则将表中最优解进行修改，否则不再遍历此位置。</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="实现-2"><a href="#实现-2" class="headerlink" title="实现"></a>实现</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">//这类迷宫问题不能纯粹使用深度优先搜索，因为要完全遍历一遍很慢，还要加上动态规划算法（剪枝）</span><br><span class="line">//记录到达每个点上的最少步数，如果大于这个步数则不再走这个点，可以剪掉大量冗余无效的走法</span><br><span class="line">using namespace std;</span><br><span class="line">int res[10][10] = &#123; 0 &#125;;</span><br><span class="line">vector&lt;string&gt; mess(10, string(10, 0));</span><br><span class="line">int nextP[4][2] = &#123;&#123;0, 1&#125;, &#123;1, 0&#125;, &#123;0, -1&#125;, &#123;-1, 0&#125;&#125;;</span><br><span class="line">void dfs(int i, int j)</span><br><span class="line">&#123;</span><br><span class="line">    //继续向四周遍历</span><br><span class="line">    for(int m = 0; m &lt; 4; m++)</span><br><span class="line">    &#123;</span><br><span class="line">        int newi = i + nextP[m][0];</span><br><span class="line">        int newj = j + nextP[m][1];</span><br><span class="line">        if(newi &lt; 10 &amp;&amp; newi &gt;= 0 &amp;&amp; newj &lt; 10 &amp;&amp; newj &gt;= 0 &amp;&amp; mess[newi][newj] != &apos;#&apos;)</span><br><span class="line">        &#123;</span><br><span class="line">            if(res[newi][newj] == 0 || res[newi][newj] &gt; res[i][j] + 1)</span><br><span class="line">            &#123;</span><br><span class="line">                res[newi][newj] = res[i][j] + 1;</span><br><span class="line">                dfs(newi, newj);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    while(cin &gt;&gt; mess[0])</span><br><span class="line">    &#123;</span><br><span class="line">        for(int i = 1; i &lt; 10; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            cin &gt;&gt; mess[i];</span><br><span class="line">        &#125;</span><br><span class="line">        dfs(0, 1);</span><br><span class="line">        cout &lt;&lt; res[9][8] &lt;&lt; endl;</span><br><span class="line">        memset(res, 0, sizeof(res));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="广度优先搜索-BFS"><a href="#广度优先搜索-BFS" class="headerlink" title="广度优先搜索(BFS)"></a>广度优先搜索(BFS)</h2><p>&emsp;&emsp;广度优先搜索是以广度为主逐层往外一次遍历，不同于深度优先逐条解进行排列组合，广度优先搜索只会遍历一次所有结点，并且会最先拿到最优解，因此某些情况下广度优先搜索效率优于深度优先搜索。广度优先搜索在迷宫问题的解上效率会更高，在寻找最优解时会更快，因为其不需要列出所有组合的情况。<br>&emsp;&emsp;广度优先搜索在实现时需要借助队列，每一次将下一层要遍历的结点入队，上一层出队。</p>
<h3 id="例1-员工的重要性"><a href="#例1-员工的重要性" class="headerlink" title="例1 员工的重要性"></a>例1 员工的重要性</h3><p>&emsp;&emsp;力扣：<br><a href="https://leetcode-cn.com/problems/employee-importance/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/employee-importance/</a></p>
<h4 id="解析-3"><a href="#解析-3" class="headerlink" title="解析"></a>解析</h4><p>&emsp;&emsp;将要查找的第一个员工入队，之后每次遍历队中元素将其重要度相加，并且将其下属入队。</p>
<h4 id="实现-3"><a href="#实现-3" class="headerlink" title="实现"></a>实现</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">// Employee info</span><br><span class="line">class Employee &#123;</span><br><span class="line">public:</span><br><span class="line">    // It&apos;s the unique ID of each node.</span><br><span class="line">    // unique id of this employee</span><br><span class="line">    int id;</span><br><span class="line">    // the importance value of this employee</span><br><span class="line">    int importance;</span><br><span class="line">    // the id of direct subordinates</span><br><span class="line">    vector&lt;int&gt; subordinates;</span><br><span class="line">&#125;;</span><br><span class="line">*/</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int getImportance(vector&lt;Employee*&gt; employees, int id) &#123;</span><br><span class="line">        unordered_map&lt;int, Employee*&gt; info;</span><br><span class="line">        for(auto&amp; e : employees)</span><br><span class="line">        &#123;</span><br><span class="line">            info[e-&gt;id] = e;</span><br><span class="line">        &#125;</span><br><span class="line">        queue&lt;int&gt; q;</span><br><span class="line">        //将这个员工入队</span><br><span class="line">        q.push(id);</span><br><span class="line">        int ret = 0;</span><br><span class="line">        //广度优先遍历</span><br><span class="line">        while(!q.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            //依次加上队中所有员工的重要度</span><br><span class="line">            int curId = q.front();</span><br><span class="line">            q.pop();</span><br><span class="line">            ret += info[curId]-&gt;importance;</span><br><span class="line">            //将其下属入队</span><br><span class="line">            for(auto&amp; e : info[curId]-&gt;subordinates)</span><br><span class="line">            &#123;</span><br><span class="line">                q.push(e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="例2-N叉树层序遍历"><a href="#例2-N叉树层序遍历" class="headerlink" title="例2 N叉树层序遍历"></a>例2 N叉树层序遍历</h3><p>&emsp;&emsp;力扣：<br><a href="https://leetcode-cn.com/problems/n-ary-tree-level-order-traversal/submissions/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/n-ary-tree-level-order-traversal/submissions/</a></p>
<h4 id="解析-4"><a href="#解析-4" class="headerlink" title="解析"></a>解析</h4><p>&emsp;&emsp;建立队列，将根节点入队，创造循环遍历队中每个结点将其孩子入队，但这题要注意要分树的每一行进行遍历，先遍历这一行的结点将其放到结果数组中，再以此遍历下一行的结点。</p>
<h4 id="实现-4"><a href="#实现-4" class="headerlink" title="实现"></a>实现</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">// Definition for a Node.</span><br><span class="line">class Node &#123;</span><br><span class="line">public:</span><br><span class="line">    int val;</span><br><span class="line">    vector&lt;Node*&gt; children;</span><br><span class="line"></span><br><span class="line">    Node() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    Node(int _val, vector&lt;Node*&gt; _children) &#123;</span><br><span class="line">        val = _val;</span><br><span class="line">        children = _children;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">*/</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; levelOrder(Node* root) &#123;</span><br><span class="line">        //创造队列</span><br><span class="line">        queue&lt;Node*&gt; q;</span><br><span class="line">        vector&lt;vector&lt;int&gt;&gt; treeVec;</span><br><span class="line">        if(root == nullptr)</span><br><span class="line">        &#123;</span><br><span class="line">            return treeVec;</span><br><span class="line">        &#125;</span><br><span class="line">        //放入根结点</span><br><span class="line">        q.push(root);</span><br><span class="line">        //遍历队中结点</span><br><span class="line">        while(!q.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            //得到这一行的长度</span><br><span class="line">            int sz = q.size();</span><br><span class="line">            vector&lt;int&gt; rowNode;</span><br><span class="line">            //遍历这一行</span><br><span class="line">            while(sz--)</span><br><span class="line">            &#123;</span><br><span class="line">                Node* curNode = q.front();</span><br><span class="line">                q.pop();</span><br><span class="line">                //将这一行结点的值放到rowNode中</span><br><span class="line">                rowNode.push_back(curNode-&gt;val);</span><br><span class="line">                //将这一行中每个结点的孩子入队</span><br><span class="line">                for(auto&amp; chd : curNode-&gt;children)</span><br><span class="line">                &#123;</span><br><span class="line">                    q.push(chd);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            treeVec.push_back(rowNode);</span><br><span class="line">        &#125;</span><br><span class="line">        return treeVec;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="例3-腐烂的橘子"><a href="#例3-腐烂的橘子" class="headerlink" title="例3 腐烂的橘子"></a>例3 腐烂的橘子</h3><p>&emsp;&emsp;力扣：<br><a href="https://leetcode-cn.com/problems/rotting-oranges/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/rotting-oranges/</a></p>
<h4 id="解析-5"><a href="#解析-5" class="headerlink" title="解析"></a>解析</h4><p>&emsp;&emsp;类似于N叉树的遍历。每一分钟腐烂一层，遍历每一层即可，最后搜索结束后判断是否还有新鲜橘子。</p>
<h4 id="实现-5"><a href="#实现-5" class="headerlink" title="实现"></a>实现</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">int nextP[4][2] = &#123;&#123;0, 1&#125;, &#123;1, 0&#125;, &#123;-1, 0&#125;, &#123;0, -1&#125;&#125;;</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int orangesRotting(vector&lt;vector&lt;int&gt;&gt;&amp; grid) &#123;</span><br><span class="line">        queue&lt;pair&lt;int, int&gt;&gt; q;</span><br><span class="line">        int row = grid.size();</span><br><span class="line">        int col = grid[0].size();</span><br><span class="line">        //找出第一批已经坏掉的橘子，入队</span><br><span class="line">        for(int i = 0; i &lt; row; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            for(int j = 0; j &lt; col; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                if(grid[i][j] == 2)</span><br><span class="line">                &#123;</span><br><span class="line">                    q.push(make_pair(i, j));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        //初始状态</span><br><span class="line">        int minRet = 0;</span><br><span class="line">        while(!q.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            //跟N叉树遍历一样，这里遍历一层代表要消耗一分钟</span><br><span class="line">            int flag = 0;</span><br><span class="line">            int sz = q.size();</span><br><span class="line">            //遍历这一层</span><br><span class="line">            while(sz--)</span><br><span class="line">            &#123;</span><br><span class="line">                pair&lt;int, int&gt; curPos = q.front();</span><br><span class="line">                q.pop();</span><br><span class="line">                for(int i = 0; i &lt; 4; i++)</span><br><span class="line">                &#123;</span><br><span class="line">                    int nx = curPos.first + nextP[i][0];</span><br><span class="line">                    int ny = curPos.second + nextP[i][1];</span><br><span class="line">                    if(nx &gt;= row || nx &lt; 0 || ny &gt;= col || ny &lt; 0)</span><br><span class="line">                    &#123;</span><br><span class="line">                        continue;</span><br><span class="line">                    &#125;</span><br><span class="line">                    if(grid[nx][ny] == 1)</span><br><span class="line">                    &#123;</span><br><span class="line">                        flag = 1;</span><br><span class="line">                        grid[nx][ny] = 2;</span><br><span class="line">                        q.push(make_pair(nx, ny));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            if(flag)</span><br><span class="line">            &#123;</span><br><span class="line">                ++minRet;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        for(int i = 0; i &lt; row; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            for(int j = 0; j &lt; col; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                if(grid[i][j] == 1)</span><br><span class="line">                &#123;</span><br><span class="line">                    return -1;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return minRet;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
          
        
      
    </div>
    
    
    

    

    <div>
    
    </div>

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/07/24/【Cpp】第六章-STL-vector类/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="MisakiFx">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/blog-logo.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Misaki`s blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/07/24/【Cpp】第六章-STL-vector类/" itemprop="url">【Cpp】第六章-STL_vector类</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-07-24T22:32:14+08:00">
                2019-07-24
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Cpp/" itemprop="url" rel="index">
                    <span itemprop="name">Cpp</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  1.7k
                </span>
              

              

              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="vector类"><a href="#vector类" class="headerlink" title="vector类"></a>vector类</h1><h2 id="基础介绍"><a href="#基础介绍" class="headerlink" title="基础介绍"></a>基础介绍</h2><p>&emsp;&emsp;vector类是STL中另一大容器，它十分类似于一个顺序表，不过经过封装它已经变成了一个可变长度并且拥有各种功能的顺序表，在其内部我们可以通过利用数组进行实现。vector是很常用的容器，因为它支持随机访问，并且尾插和尾删拥有O1的时间复杂度。但是在中间插入时要更高的时间复杂度，最差情况下需要遍历整个数组才能进行插入。它与string的物理与逻辑结构上十分相似，不过它是一个模板类，我们可以在其中存放任意类型的数据。</p>
<h2 id="常用接口"><a href="#常用接口" class="headerlink" title="常用接口"></a>常用接口</h2><h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">vector();                                                  //无参构造</span><br><span class="line">vector(size_type n, const value_type &amp;val = value_type()); //构造并初始化n个val</span><br><span class="line">vector(const vector &amp;x);                                   //拷贝构造</span><br><span class="line">vector(InputIterator first, InputIterator last);           //使用迭代器进行初始化构造</span><br></pre></td></tr></table></figure>
<h3 id="容量相关"><a href="#容量相关" class="headerlink" title="容量相关"></a>容量相关</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">size();     //获取数据个数</span><br><span class="line">capacity(); //获取容量大小</span><br><span class="line">empty();    //判断是否为空</span><br><span class="line">void resize(size_type n, value_type val = value_type());//改变空间大小，如果大于原有空间用val填充</span><br><span class="line">改变vector的size void reserve(size_type n); //改变vector放入capacity</span><br></pre></td></tr></table></figure>
<h3 id="增删查改"><a href="#增删查改" class="headerlink" title="增删查改"></a>增删查改</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">void push_back(const value_type &amp;val);                     //尾插</span><br><span class="line">void pop_back();                                           //尾删</span><br><span class="line">iterator insert(iterator position, constvalue_type &amp; val); //在position之前插入val</span><br><span class="line">iterator erase(iterator position);                         //删除position位置的数据</span><br><span class="line">void swap(vector &amp; x);                                     //交换两个vector的数据空间</span><br><span class="line">reference operator[](size_type n);                         //像数组一样访问</span><br></pre></td></tr></table></figure>
<h3 id="迭代器相关"><a href="#迭代器相关" class="headerlink" title="迭代器相关"></a>迭代器相关</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">begin();  //获取第一个数据位置的iterator</span><br><span class="line">end();    //获取最后一个数据的下一个位置的iterator</span><br><span class="line">rbegin(); //获取最后一个数据位置的reverse_iterator</span><br><span class="line">rend();   //获取第一个数据前一个位置的reverse_iterator</span><br><span class="line">cbegin(); //获取第一个数据位置的const_iterator</span><br><span class="line">cend();   //获取最后一个数据的下一个位置的const_iterator</span><br></pre></td></tr></table></figure>
<h2 id="迭代器失效问题"><a href="#迭代器失效问题" class="headerlink" title="迭代器失效问题"></a>迭代器失效问题</h2><p>&emsp;&emsp;在容器使用中我们经常会要操作迭代器，很多容器接口中也有提供使用迭代器进行增加删除修改的操作。但是迭代器本身是一个指针，在我们使用接口进行增加或是删除的时候这个迭代器的指向的内容会发生改变甚至是指向非法内存，原因是原来的内存已经被释放，称之为<strong>迭代器失效</strong>，迭代器失效会导致指向内容改变，从而引起bug甚至是内存越界访问导致程序崩溃。</p>
<h3 id="常见场景"><a href="#常见场景" class="headerlink" title="常见场景"></a>常见场景</h3><p>&emsp;&emsp;最为常见的是<code>erase</code>和<code>insert</code>导致的迭代器失效。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int a[] = &#123;1, 2, 3, 4&#125;;</span><br><span class="line">    vector&lt;int&gt; v(a, a + sizeof(a) / sizeof(int));</span><br><span class="line">    vector&lt;int&gt;::iterator it = v.begin();</span><br><span class="line">    while (it != v.end())</span><br><span class="line">    &#123;</span><br><span class="line">        if (*it % 2 == 0)</span><br><span class="line">            v.erase(it);</span><br><span class="line">        ++it;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;以上这段程序就会引起迭代器失效，在删除最后一个元素是甚至导致内存越界访问，程序崩溃。因此可以总结在<strong>利用迭代器删除元素后，删除位置及其之后的所有迭代器都会失效</strong>，原因是，之后的所有元素都会前移，之前的迭代器所指向的内容都会发生改变，甚至是指向非法内存。<br>&emsp;&emsp;同理我们在<code>insert</code>之后由于删除位置及其以后的元素会后移进行变动，因此<strong>插入位置及其之后所有的迭代器也都会失效</strong>，并且如果有扩容发生还可能发生内存越界访问。<br>&emsp;&emsp;对于迭代器失效我们要如何避免呢？我们注意看<code>erase</code>的接口可以发现<code>erase</code>返回的是一个迭代器。说明：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">An iterator pointing to the new location of the element that followed the last element erased by the function call. </span><br><span class="line">This is the container end if the operation erased the last element in the sequence.</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;它的返回值是返回在删除位置之后紧接着它的元素的迭代器，这个迭代器保证是有效的，<code>insert</code>的返回值也是一个迭代器，并且是插入位置插入后的元素的迭代器，因此它们的返回值都是保证有效的，所以我们的代码可以改成以下这样就可以避免迭代器失效。</p>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>&emsp;&emsp;我们模拟实现一个Vector类，并且实现常用接口，让其达到和vector相同的功能。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br></pre></td><td class="code"><pre><span class="line">#pragma once</span><br><span class="line">#include &lt;assert.h&gt;</span><br><span class="line">#include &lt;memory.h&gt;</span><br><span class="line">template &lt;class T&gt;</span><br><span class="line">class Vector</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    typedef T* iterator;</span><br><span class="line">    typedef const T* const_iterator;</span><br><span class="line">    //构造函数</span><br><span class="line">    Vector()</span><br><span class="line">        :_start(nullptr)</span><br><span class="line">        ,_finish(nullptr)</span><br><span class="line">        ,_endOfStorge(nullptr)</span><br><span class="line">    &#123;&#125;        </span><br><span class="line">    Vector(size_t n, T val)</span><br><span class="line">        :_start(nullptr)</span><br><span class="line">        ,_finish(nullptr)</span><br><span class="line">        ,_endOfStorge(nullptr)</span><br><span class="line">    &#123;</span><br><span class="line">        Reserve(n);</span><br><span class="line">        for(int i = 0; i &lt; n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            *_finish = val;</span><br><span class="line">            _finish++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    //拷贝构造</span><br><span class="line">    Vector(const Vector&lt;T&gt;&amp; vec)</span><br><span class="line">        :_start(nullptr)</span><br><span class="line">        ,_finish(nullptr)</span><br><span class="line">        ,_endOfStorge(nullptr)</span><br><span class="line">    &#123;</span><br><span class="line">        Resize(vec.Size());</span><br><span class="line">        memcpy(_start, vec._start, vec.Size() * sizeof(T));</span><br><span class="line">        _finish = _start + vec.Size();</span><br><span class="line">    &#125;</span><br><span class="line">    //operator=重载</span><br><span class="line">    Vector&amp; operator=(Vector&lt;T&gt; vec)</span><br><span class="line">    &#123;</span><br><span class="line">        Swap(vec);</span><br><span class="line">        return *this;</span><br><span class="line">    &#125;</span><br><span class="line">    //交换</span><br><span class="line">    void Swap(Vector&lt;T&gt;&amp; vec)</span><br><span class="line">    &#123;</span><br><span class="line">        std::swap(_start, vec._start);</span><br><span class="line">        std::swap(_finish, vec._finish);</span><br><span class="line">        std::swap(_endOfStorge, vec._endOfStorge);</span><br><span class="line">    &#125;</span><br><span class="line">    //析构函数</span><br><span class="line">    ~Vector()</span><br><span class="line">    &#123;</span><br><span class="line">        delete[] _start;</span><br><span class="line">        _start = nullptr;</span><br><span class="line">        _finish = nullptr;</span><br><span class="line">        _endOfStorge = nullptr;</span><br><span class="line">    &#125;</span><br><span class="line">    //迭代器相关</span><br><span class="line">    iterator begin()</span><br><span class="line">    &#123;</span><br><span class="line">        return _start;</span><br><span class="line">    &#125;</span><br><span class="line">    iterator end()</span><br><span class="line">    &#123;</span><br><span class="line">        return _finish;</span><br><span class="line">    &#125;</span><br><span class="line">    const_iterator begin() const</span><br><span class="line">    &#123;</span><br><span class="line">        return _start;</span><br><span class="line">    &#125;</span><br><span class="line">    const_iterator end() const</span><br><span class="line">    &#123;</span><br><span class="line">        return _finish;</span><br><span class="line">    &#125;</span><br><span class="line">    //插入</span><br><span class="line">    iterator Insert(iterator pos, const T&amp; val)</span><br><span class="line">    &#123;</span><br><span class="line">        assert(pos &gt;= _start &amp;&amp; pos &lt;= _finish);</span><br><span class="line">        //扩容，扩容会导致pos要重新指定位置，因为内存地址变更</span><br><span class="line">        if(_finish == _endOfStorge)</span><br><span class="line">        &#123;</span><br><span class="line">            size_t n = pos - _start;</span><br><span class="line">            size_t size = Capacity() == 0 ? 4 : 2 * Capacity();</span><br><span class="line">            Reserve(size);</span><br><span class="line">            pos = _start + n;</span><br><span class="line">        &#125;</span><br><span class="line">        iterator it = _finish;</span><br><span class="line">        while(it != pos)</span><br><span class="line">        &#123;</span><br><span class="line">            *it = *(it - 1);</span><br><span class="line">            it--;</span><br><span class="line">        &#125;</span><br><span class="line">        *pos = val;</span><br><span class="line">        _finish++;</span><br><span class="line">        return pos;</span><br><span class="line">    &#125;</span><br><span class="line">    //删除</span><br><span class="line">    iterator Erase(iterator pos)</span><br><span class="line">    &#123;</span><br><span class="line">        assert(pos &gt;= _start &amp;&amp; pos &lt;= _finish);</span><br><span class="line">        iterator it = pos + 1;</span><br><span class="line">        while(it != _finish)</span><br><span class="line">        &#123;</span><br><span class="line">            *(it - 1) = *it;</span><br><span class="line">            it++;</span><br><span class="line">        &#125;</span><br><span class="line">        _finish--;</span><br><span class="line">        return pos;</span><br><span class="line">    &#125;</span><br><span class="line">    //尾插</span><br><span class="line">    void Push_back(const T&amp; val)</span><br><span class="line">    &#123;</span><br><span class="line">        //扩容</span><br><span class="line">        if(_endOfStorge == _finish)</span><br><span class="line">        &#123;</span><br><span class="line">            size_t capacity = Capacity() == 0 ? 4 : 2 * Capacity();</span><br><span class="line">            Reserve(capacity);</span><br><span class="line">        &#125;</span><br><span class="line">        *_finish = val;</span><br><span class="line">        _finish++;</span><br><span class="line">    &#125;</span><br><span class="line">    //尾删</span><br><span class="line">    void Pop_back()</span><br><span class="line">    &#123;</span><br><span class="line">        assert(_finish &gt; _start);</span><br><span class="line">        _finish--;</span><br><span class="line">    &#125;</span><br><span class="line">    //operator[]重载</span><br><span class="line">    T&amp; operator[](size_t pos)</span><br><span class="line">    &#123;</span><br><span class="line">        return _start[pos];</span><br><span class="line">    &#125;</span><br><span class="line">    const T&amp; operator[](size_t pos) const</span><br><span class="line">    &#123;</span><br><span class="line">        return _start[pos];</span><br><span class="line">    &#125;</span><br><span class="line">    //长度</span><br><span class="line">    size_t Size() const</span><br><span class="line">    &#123;</span><br><span class="line">        return _finish - _start;</span><br><span class="line">    &#125;</span><br><span class="line">    //容量</span><br><span class="line">    size_t Capacity() const</span><br><span class="line">    &#123;</span><br><span class="line">        return _endOfStorge - _start;</span><br><span class="line">    &#125;</span><br><span class="line">    //重新给容量</span><br><span class="line">    void Reserve(size_t capacity)</span><br><span class="line">    &#123;</span><br><span class="line">        if(capacity &gt; Capacity())</span><br><span class="line">        &#123;</span><br><span class="line">            size_t size = Size();</span><br><span class="line">            //分配新的内存空间</span><br><span class="line">            T* newArr = new T[capacity];</span><br><span class="line">            if(_start)</span><br><span class="line">            &#123;</span><br><span class="line">                memcpy(newArr, _start, size * sizeof(T));</span><br><span class="line">            &#125;</span><br><span class="line">            //销毁原有内存空间</span><br><span class="line">            delete[] _start;</span><br><span class="line">            //注意这里更新三个指针都要进行更新，因为三个指针都还指向原来的内存空间</span><br><span class="line">            _start = newArr;</span><br><span class="line">            _finish = _start + size;</span><br><span class="line">            _endOfStorge = _start + capacity;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    //重新给长度,空白部分val填充</span><br><span class="line">    void Resize(size_t size, T val = T())</span><br><span class="line">    &#123;</span><br><span class="line">        Reserve(size);</span><br><span class="line">        if(Size() &lt; size)</span><br><span class="line">        &#123;</span><br><span class="line">            T* ptr = _finish;</span><br><span class="line">            while(ptr != _start + size)</span><br><span class="line">            &#123;</span><br><span class="line">                *ptr = val;</span><br><span class="line">                ptr++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        _finish = _start + size;</span><br><span class="line">    &#125;</span><br><span class="line">private:</span><br><span class="line">    //vecotor的实现与string有所不同</span><br><span class="line">    //其底层使用三个迭代器（指针）用来标记头部，尾部和总容量尾部</span><br><span class="line">    iterator _start;</span><br><span class="line">    iterator _finish;</span><br><span class="line">    iterator _endOfStorge;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>

          
        
      
    </div>
    
    
    

    

    <div>
    
    </div>

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/07/22/【Cpp】第五章-STL-string类/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="MisakiFx">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/blog-logo.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Misaki`s blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/07/22/【Cpp】第五章-STL-string类/" itemprop="url">【Cpp】第五章-STL_string类</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-07-22T20:51:53+08:00">
                2019-07-22
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Cpp/" itemprop="url" rel="index">
                    <span itemprop="name">Cpp</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  2.9k
                </span>
              

              

              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="string类"><a href="#string类" class="headerlink" title="string类"></a>string类</h1><h2 id="STL"><a href="#STL" class="headerlink" title="STL"></a>STL</h2><p>&emsp;&emsp;<strong>STL</strong>是<code>Standard Template Library</code>的简称，中文名为是<strong>标准模板库</strong>，在Cpp中模板是构成泛型编程的基础，我们利用模板可以极大程度地提高我们的代码复用率，但是如果模板要我们现写也有点过于繁琐，不过好在Cpp中为我们写代码方便为我们制作了一套标准地模板库，供我们直接使用十分方便。</p>
<h3 id="STL的版本"><a href="#STL的版本" class="headerlink" title="STL的版本"></a>STL的版本</h3><p>&emsp;&emsp;STL发展至今也不是一气呵成的，随着发展和进化，STL一共出现了四大版本。</p>
<h4 id="HP版本"><a href="#HP版本" class="headerlink" title="HP版本"></a>HP版本</h4><p>&emsp;&emsp;这个版本是STL的原始版本，由Alexander Stepanov、Meng Lee在惠普实验室完成，是所有STL版本的始祖。并且此版本秉承开源精神，允许任何人免费运用，拷贝，商用，传播，修改这些代码，唯一的条件也只是要求需要像原始版本一样开源使用。</p>
<h4 id="P-J-版本"><a href="#P-J-版本" class="headerlink" title="P.J.版本"></a>P.J.版本</h4><p>&emsp;&emsp;这个版本由P. J. Plauger开发，继承自HP版本，被Windows Visual C++采用，不可公开或修改，可读性较差。</p>
<h4 id="RW版本"><a href="#RW版本" class="headerlink" title="RW版本"></a>RW版本</h4><p>&emsp;&emsp;这个版本由Rouge Wage公司开发，继承自HP版本，被C++ Builder采用，不能公开或修改，可读性一般。</p>
<h4 id="SGI版本"><a href="#SGI版本" class="headerlink" title="SGI版本"></a>SGI版本</h4><p>&emsp;&emsp;这个版本由Silicon Graphics Computer Systems，Inc公司开发，继承自HP版本，被GCC采用，可移植性较好，可公开，修改，贩卖，可读性很高。也是我们学习主要参考的版本。</p>
<h3 id="STL六大组件"><a href="#STL六大组件" class="headerlink" title="STL六大组件"></a>STL六大组件</h3><p>&emsp;&emsp;STL中包含六大组件，他们共同组成STL互相协同工作。</p>
<h4 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h4><p>&emsp;&emsp;<code>string, vector, list, deque, map, set, multimap, multiset</code>。</p>
<h4 id="配接器"><a href="#配接器" class="headerlink" title="配接器"></a>配接器</h4><p>&emsp;&emsp;<code>stack, queue, priority_queue</code></p>
<h4 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h4><p>&emsp;&emsp;<code>find, swap, reverse, sort, merge...</code></p>
<h4 id="空间适配器"><a href="#空间适配器" class="headerlink" title="空间适配器"></a>空间适配器</h4><p>&emsp;&emsp;<code>allocator</code></p>
<h4 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h4><p>&emsp;&emsp;<code>iterator, const_iterator, reverse_iterator, const_reverse_iterator</code></p>
<h4 id="仿函数"><a href="#仿函数" class="headerlink" title="仿函数"></a>仿函数</h4><p>&emsp;&emsp;<code>greater, less...</code><br><br>&emsp;&emsp;STL在日常编程中无论是笔试还是项目都十分常用，必须多用多练，并且自己实现一遍才能熟练掌握。STL(包扩Cpp绝大部分库)学习可分为三个层次：<br><br>&emsp;&emsp;1、熟用STL<br>&emsp;&emsp;2、了解泛型技术d的内涵与STL的学理乃至实作<br>&emsp;&emsp;3、扩充STL<br>&emsp;&emsp;总结就是能用，明理，能扩展。</p>
<h2 id="string类-1"><a href="#string类-1" class="headerlink" title="string类"></a>string类</h2><p>&emsp;&emsp;<code>string</code>类时STL中专门用于字符串处理的容器。在C语言中我们利用字符数组或字符指针来构成字符串，所有字符串使用十分不方便，库中为字符串提供的接口也并不便于使用，于是在Cpp中有了<code>string</code>模板类，这个容器可以帮助我们更加方便的使用字符串，并且帮助我们封装了很多字符串相关的常用接口。</p>
<h3 id="常用接口"><a href="#常用接口" class="headerlink" title="常用接口"></a>常用接口</h3><h4 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h4><p>&emsp;&emsp;<code>string</code>中提供了各种构造函数帮助我们构造字符串。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">string(); //构造空的string类对象，即空字符串</span><br><span class="line">string(const char *s);// 用C-string来构造string类对象</span><br><span class="line">string(size_t n, char c);//string类对象中包含n个字符c</span><br><span class="line">string(const string &amp;s);//拷贝构造函数</span><br><span class="line">string(const string &amp;s, size_t n);//用s中的前n个字符构造新的string类对象 return 0;</span><br></pre></td></tr></table></figure></p>
<h4 id="容量相关接口"><a href="#容量相关接口" class="headerlink" title="容量相关接口"></a>容量相关接口</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">size_t size() const;			  // 返回字符串有效字符长度</span><br><span class="line">size_t length() const;			  // 返回字符串有效字符长度</span><br><span class="line">size_t capacity() const;		  // 返回空间总大小</span><br><span class="line">bool empty() const;				  // 检测字符串释放为空串，是返回true，否则返回false</span><br><span class="line">void clear();					  //清空有效字符</span><br><span class="line">void resize(size_t n, char c);	// 将有效字符的个数该成n个，多出的空间用字符c填充</span><br><span class="line">void resize(size_t n);			  // 将有效字符的个数改成n个，多出的空间用0填充</span><br><span class="line">void reserve(size_t res_arg = 0); // 为字符串预留空间</span><br></pre></td></tr></table></figure>
<h4 id="访问相关接口"><a href="#访问相关接口" class="headerlink" title="访问相关接口"></a>访问相关接口</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">char&amp; operator[] (size_t pos); 	  	    //返回pos位置的字符,非const string类对象调用</span><br><span class="line">const char&amp; operator[] (size_t pos);	//const返回pos位置的字符，const string类对象调用</span><br></pre></td></tr></table></figure>
<h4 id="修改相关接口"><a href="#修改相关接口" class="headerlink" title="修改相关接口"></a>修改相关接口</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">void push_back(char c);							//在字符串后尾插字符c</span><br><span class="line">string&amp; append (const char* s); 				//在字符串后追加一个字符串</span><br><span class="line">string&amp; operator+=(const string&amp; str);			//在字符串后追加字符串str</span><br><span class="line">string&amp; operator+=(const char* s);				//在字符串后追加字符串</span><br><span class="line">string&amp; operator+=(char c);						//在字符串后追加字符c</span><br><span class="line">const char* c_str()const;						//返回C格式字符串</span><br><span class="line">size_t find (char c, size_t pos = 0) const;		//从字符串pos位置开始往后找字符c，返回该字符在字符串中的位置</span><br><span class="line">size_t rfind(char c, size_t pos = npos);		//从字符串pos位置开始往前找字符c，返回该字符在字符串中的位置</span><br><span class="line">string substr(size_t pos = 0, size_t n= npos); 	//const在str中从pos位置开始，截取n个字符，然后将其返回</span><br><span class="line">string&amp; erase (size_t pos = 0, size_t len = npos); //从pos位置起删除串中npos个字符</span><br></pre></td></tr></table></figure>
<h4 id="迭代器相关"><a href="#迭代器相关" class="headerlink" title="迭代器相关"></a>迭代器相关</h4><p>&emsp;&emsp;迭代器十分类似于指针，我们可以将其等同于一个自定义类型的指针，用它我们可以完成容器内的遍历，增加，删除等操作，STL中容器的很多功能也为迭代器设计了很多接口，其中最为常用的还是取到一个容器的迭代器。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">iterator begin();					//取到头部迭代器</span><br><span class="line">const_iterator begin() const;		//取到头部常迭代器</span><br><span class="line">iterator end();						//取到尾部迭代器</span><br><span class="line">const_iterator end() const;			//取到尾部常迭代器</span><br></pre></td></tr></table></figure></p>
<h4 id="其他接口"><a href="#其他接口" class="headerlink" title="其他接口"></a>其他接口</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">string operator+ (const string&amp; lhs, const string&amp; rhs); 	//在lhs串后拼接rhs串</span><br><span class="line">istream&amp; operator&gt;&gt; (istream&amp; is, string&amp; str);				//输入运算符重载</span><br><span class="line">istream&amp; getline (istream&amp; is, string&amp; str);				//获取一行字符串</span><br><span class="line">relational operators 										//大小比较</span><br></pre></td></tr></table></figure>
<h4 id="综合运用"><a href="#综合运用" class="headerlink" title="综合运用"></a>综合运用</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	string str = &quot;123456&quot;;//单参构造的隐式类型转换 + 拷贝构造</span><br><span class="line">	for(int i = 0; i &lt; str.size(); i++)//size()取出长度</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; str[i] &lt;&lt; &quot; &quot;;//operator[]重载的运用</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">	str.append(&quot;abc&quot;);//append()接口</span><br><span class="line">	str.push_back(&apos;d&apos;);//push_back接口使用</span><br><span class="line">	str += &quot;efg&quot;;//operator += 重载使用</span><br><span class="line">	//迭代器的应用</span><br><span class="line">	string::iterator it = str.begin();</span><br><span class="line">	while(it != str.end())</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; * it &lt;&lt; &quot; &quot;;</span><br><span class="line">		it++;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1 2 3 4 5 6</span><br><span class="line">1 2 3 4 5 6 a b c d e f g</span><br></pre></td></tr></table></figure>
<h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>&emsp;&emsp;学习STL要熟用，明理，能扩展，那么第二部明理我们就要自己实现封装一个<code>string</code>类。根据库中<code>string</code>常用接口我们也实现其基本功能。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;assert.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">class String</span><br><span class="line">&#123;</span><br><span class="line">    friend std::ostream &amp;operator&lt;&lt;(std::ostream &amp;os, String str);</span><br><span class="line">public:</span><br><span class="line">    //迭代器</span><br><span class="line">    typedef char* iterator;</span><br><span class="line">    typedef const char* const_iterator;</span><br><span class="line">    iterator begin()</span><br><span class="line">    &#123;</span><br><span class="line">        return _str;</span><br><span class="line">    &#125;</span><br><span class="line">    const_iterator begin() const</span><br><span class="line">    &#123;</span><br><span class="line">        return _str;</span><br><span class="line">    &#125;</span><br><span class="line">    iterator end()</span><br><span class="line">    &#123;</span><br><span class="line">        return _str+_size;</span><br><span class="line">    &#125;</span><br><span class="line">    const_iterator end() const</span><br><span class="line">    &#123;</span><br><span class="line">        return _str+_size;</span><br><span class="line">    &#125;</span><br><span class="line">    static size_t npos;</span><br><span class="line">    //构造函数</span><br><span class="line">    String(const char* str = &quot;&quot;)//要进行深拷贝</span><br><span class="line">        :_str(nullptr)</span><br><span class="line">        ,_capacity(0)</span><br><span class="line">    &#123;</span><br><span class="line">        _size = strlen(str);</span><br><span class="line">        //重新给容量Reserve()</span><br><span class="line">        Reserve(_size);</span><br><span class="line">        //strcpy()拷贝给成员变量</span><br><span class="line">        strcpy(_str, str);</span><br><span class="line">    &#125;</span><br><span class="line">    //拷贝构造，要使用深拷贝</span><br><span class="line">    //所谓深拷贝就是创立独立的内存空间并将目标对象中的值拷贝过来</span><br><span class="line">    //而不是单纯的让指针等于目标拷贝对象中的指针</span><br><span class="line">    //注意：拷贝构造和operator=重载都是不拷贝容量大小的</span><br><span class="line">    //传统写法：创建新的独立内存，销毁原来的内存空间，更新_size, _capacity的值</span><br><span class="line">    //String(const String&amp; str)</span><br><span class="line">    //    :_str(nullptr)</span><br><span class="line">    //    ,_size(0)</span><br><span class="line">    //    ,_capacity(0)</span><br><span class="line">    //&#123;</span><br><span class="line">    //    Resize(str.Size());</span><br><span class="line">    //    strcpy(_str, str._str);</span><br><span class="line">    //&#125;</span><br><span class="line">    ////operator=重载和拷贝构造类似，先用传统写法实现</span><br><span class="line">    //String&amp; operator=(const String&amp; str)</span><br><span class="line">    //&#123;</span><br><span class="line">    //    if(this != &amp;str)</span><br><span class="line">    //    &#123;</span><br><span class="line">    //        Resize(str.Size());</span><br><span class="line">    //        strcpy(_str, str._str);</span><br><span class="line">    //    &#125;</span><br><span class="line">    //&#125;</span><br><span class="line">    //现代写法，另外创建对象让其等于要拷贝的对象，交换两个对象即可</span><br><span class="line">    String(const String&amp; str)</span><br><span class="line">        :_str(nullptr)</span><br><span class="line">        ,_size(0)</span><br><span class="line">        ,_capacity(0)</span><br><span class="line">    &#123;</span><br><span class="line">        String temp(str._str);</span><br><span class="line">        Swap(temp);</span><br><span class="line">    &#125;</span><br><span class="line">    //现代写法，利用拷贝构造函数创建临时对象，交换两个对象，临时对象在函数结束时也会自动释放</span><br><span class="line">    String&amp; operator=(String str)</span><br><span class="line">    &#123;</span><br><span class="line">        Swap(str);</span><br><span class="line">    &#125;</span><br><span class="line">    //交换两个字符串，浅拷贝，不另申请内存空间</span><br><span class="line">    void Swap(String&amp; str)</span><br><span class="line">    &#123;</span><br><span class="line">        std::swap(_str, str._str);</span><br><span class="line">        std::swap(_size, str._size);</span><br><span class="line">        std::swap(_capacity, str._capacity);</span><br><span class="line">    &#125;</span><br><span class="line">    //析构函数</span><br><span class="line">    ~String()</span><br><span class="line">    &#123;</span><br><span class="line">        if(_str)</span><br><span class="line">        &#123;</span><br><span class="line">            delete[] _str;</span><br><span class="line">            _str = nullptr;</span><br><span class="line">            _size = _capacity = 0;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    //返回_size</span><br><span class="line">    size_t Size() const</span><br><span class="line">    &#123;</span><br><span class="line">        return _size;</span><br><span class="line">    &#125;</span><br><span class="line">    //返回_capacity</span><br><span class="line">    size_t Capacity() const</span><br><span class="line">    &#123;</span><br><span class="line">        return _capacity;</span><br><span class="line">    &#125;</span><br><span class="line">    //在某个下标插入一个字符</span><br><span class="line">    void Insert(size_t pos, char ch)</span><br><span class="line">    &#123;</span><br><span class="line">        assert(pos &lt;= _size);</span><br><span class="line">        //容量满了，扩容</span><br><span class="line">        if(_size == _capacity)</span><br><span class="line">        &#123;</span><br><span class="line">            Reserve(2 * _capacity);</span><br><span class="line">        &#125;</span><br><span class="line">        for(int i = _size; i &gt; pos; i--)</span><br><span class="line">        &#123;</span><br><span class="line">            _str[i] = _str[i - 1];</span><br><span class="line">        &#125;</span><br><span class="line">        _str[pos] = ch;</span><br><span class="line">        _size++;</span><br><span class="line">        _str[_size] = &apos;\0&apos;;</span><br><span class="line">    &#125;</span><br><span class="line">    //在某个下标处插入一个字符串</span><br><span class="line">    void Insert(size_t pos, const char* str)</span><br><span class="line">    &#123;</span><br><span class="line">        assert(pos &lt;= _size);</span><br><span class="line">        int len = strlen(str);</span><br><span class="line">        //容量不够扩容</span><br><span class="line">        if(_size + len &gt; _capacity)</span><br><span class="line">        &#123;</span><br><span class="line">            Reserve(len + _size);</span><br><span class="line">        &#125;</span><br><span class="line">        for(int i = len + _size - 1; i &gt; pos + len - 1; i--)</span><br><span class="line">        &#123;</span><br><span class="line">            _str[i] = _str[i - len];        </span><br><span class="line">        &#125;</span><br><span class="line">        for(int i = pos; i &lt; pos + len; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            _str[i] = str[i - pos];</span><br><span class="line">        &#125;</span><br><span class="line">        _size += len;</span><br><span class="line">    &#125;</span><br><span class="line">    //+=运算符重载</span><br><span class="line">    String&amp; operator+=(char ch)</span><br><span class="line">    &#123;</span><br><span class="line">        Push_back(ch);</span><br><span class="line">    &#125;</span><br><span class="line">    String&amp; operator+=(const char* str)</span><br><span class="line">    &#123;</span><br><span class="line">        Append(str);</span><br><span class="line">    &#125;</span><br><span class="line">    //删除pos下标开始的npos个字符</span><br><span class="line">    void Erase(size_t pos, size_t npos)</span><br><span class="line">    &#123;</span><br><span class="line">        assert(pos &lt; _size);</span><br><span class="line">        for(int i = pos; i &lt; _size - npos; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            _str[i] = _str[i + npos];</span><br><span class="line">        &#125;</span><br><span class="line">        _size -= npos;</span><br><span class="line">        _str[_size] = &apos;\0&apos;;</span><br><span class="line">    &#125;</span><br><span class="line">    //从pos开始找第一个字符为ch返回其下标</span><br><span class="line">    size_t Find(const char ch, size_t pos = 0)</span><br><span class="line">    &#123;</span><br><span class="line">        assert(pos &lt; _size);</span><br><span class="line">        for(size_t i = pos; i &lt; _size; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            if(_str[i] == ch)</span><br><span class="line">            &#123;</span><br><span class="line">                return i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return npos;</span><br><span class="line">    &#125;</span><br><span class="line">    //从pos开始找第一个子串为str返回其下标</span><br><span class="line">    size_t Find(const char* str, size_t pos = 0)</span><br><span class="line">    &#123;</span><br><span class="line">        assert(pos &lt; _size);</span><br><span class="line">        for(size_t i = pos; i &lt; _size; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            if(_str[i] == str[0])</span><br><span class="line">            &#123;</span><br><span class="line">                int j = i;</span><br><span class="line">                while (j &lt; i + strlen(str) &amp;&amp; _str[j] != &apos;\0&apos;)</span><br><span class="line">                &#123;</span><br><span class="line">                    if (_str[j] != str[j - i])</span><br><span class="line">                    &#123;</span><br><span class="line">                        break;</span><br><span class="line">                    &#125;</span><br><span class="line">                    j++;</span><br><span class="line">                &#125;</span><br><span class="line">                //子串遍历完毕,子串与要查找的串完全匹配</span><br><span class="line">                if (j == i + strlen(str))</span><br><span class="line">                &#123;</span><br><span class="line">                    return i;</span><br><span class="line">                &#125;</span><br><span class="line">                //主串遇到结尾，长度不够不用继续查找了</span><br><span class="line">                else if(_str[j] == &apos;\0&apos;)</span><br><span class="line">                &#123;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">                //其他情况本次子串与要查找的串匹配不上，继续下一次子串查找</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return npos;</span><br><span class="line">    &#125;</span><br><span class="line">    //在尾部插入字符</span><br><span class="line">    void Push_back(char ch)</span><br><span class="line">    &#123;</span><br><span class="line">        Insert(_size, ch);</span><br><span class="line">    &#125;</span><br><span class="line">    //字符串拼接</span><br><span class="line">    void Append(const char* str)</span><br><span class="line">    &#123;</span><br><span class="line">        Insert(_size, str);</span><br><span class="line">    &#125;</span><br><span class="line">    //重新给容量，并且要求容量永远为8的整数倍</span><br><span class="line">    void Reserve(size_t n)</span><br><span class="line">    &#123;</span><br><span class="line">        if(n &gt; _capacity || (n == 0 &amp;&amp; _capacity == 0))</span><br><span class="line">        &#123;</span><br><span class="line">            size_t newCapacity = n;</span><br><span class="line">            if(newCapacity % 8 != 0)</span><br><span class="line">            &#123;</span><br><span class="line">                newCapacity = (((newCapacity / 8) + 1) * 8);</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">            &#123;</span><br><span class="line">                newCapacity += 8;</span><br><span class="line">            &#125;</span><br><span class="line">            char* newStr = new char[newCapacity];</span><br><span class="line">            if(newStr &amp;&amp; _str)</span><br><span class="line">            &#123;</span><br><span class="line">                strcpy(newStr, _str);</span><br><span class="line">            &#125;</span><br><span class="line">            //释放旧空间</span><br><span class="line">            delete[] _str;</span><br><span class="line">            _str = newStr;</span><br><span class="line">            _capacity = newCapacity - 1;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    void Resize(size_t size, char ch = &apos;\0&apos;)</span><br><span class="line">    &#123;</span><br><span class="line">        if(size &lt; _size)</span><br><span class="line">        &#123;</span><br><span class="line">            _size = size;</span><br><span class="line">            _str[_size] = &apos;\0&apos;;</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            Reserve(size);</span><br><span class="line">            for(size_t i = _size; i &lt; size; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                _str[i] = ch;</span><br><span class="line">            &#125;</span><br><span class="line">            _size = size;</span><br><span class="line">            _str[_size] = &apos;\0&apos;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    //&gt;运算符重载</span><br><span class="line">    bool operator&gt;(const String&amp; str)</span><br><span class="line">    &#123;</span><br><span class="line">        if(strcmp(_str, str._str) &gt; 0)</span><br><span class="line">        &#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    bool operator==(const String&amp; str)</span><br><span class="line">    &#123;</span><br><span class="line">        if(strcmp(_str, str._str) == 0)</span><br><span class="line">        &#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    bool operator&gt;=(const String&amp; str)</span><br><span class="line">    &#123;</span><br><span class="line">        if(*this &gt; str || *this == str)</span><br><span class="line">        &#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    bool operator&lt;(const String&amp; str)</span><br><span class="line">    &#123;</span><br><span class="line">        if(*this &gt;= str)</span><br><span class="line">        &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    bool operator&lt;=(const String&amp; str)</span><br><span class="line">    &#123;</span><br><span class="line">        if(*this &lt; str || *this == str)</span><br><span class="line">        &#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    bool operator!=(const String&amp; str)</span><br><span class="line">    &#123;</span><br><span class="line">        if(*this == str)</span><br><span class="line">        &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    //+运算符重载</span><br><span class="line">    String operator+(char ch)</span><br><span class="line">    &#123;</span><br><span class="line">        String temp(*this);</span><br><span class="line">        temp.Push_back(ch);</span><br><span class="line">        return temp;</span><br><span class="line">    &#125;</span><br><span class="line">    String operator+(const char* str)</span><br><span class="line">    &#123;</span><br><span class="line">        String temp(*this);</span><br><span class="line">        temp.Append(str);</span><br><span class="line">        return temp;</span><br><span class="line">    &#125;</span><br><span class="line">    //取类中的字符串</span><br><span class="line">    char* c_str()</span><br><span class="line">    &#123;</span><br><span class="line">        return _str;    </span><br><span class="line">    &#125;</span><br><span class="line">    //operator[]重载</span><br><span class="line">    char&amp; operator[](size_t pos)</span><br><span class="line">    &#123;</span><br><span class="line">        assert(pos &lt; _size);</span><br><span class="line">        return _str[pos];</span><br><span class="line">    &#125;</span><br><span class="line">    //operator[]重载</span><br><span class="line">    const char&amp; operator[](size_t pos) const</span><br><span class="line">    &#123;</span><br><span class="line">        assert(pos &lt; _size);</span><br><span class="line">        return _str[pos];</span><br><span class="line">    &#125;</span><br><span class="line">private:</span><br><span class="line">    char* _str;</span><br><span class="line">    size_t _size;</span><br><span class="line">    size_t _capacity;</span><br><span class="line">&#125;;</span><br><span class="line">std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, String str)</span><br><span class="line">&#123;</span><br><span class="line">	os &lt;&lt; str._str;</span><br><span class="line">	return os;</span><br><span class="line">&#125;</span><br><span class="line">size_t String::npos = -1;</span><br></pre></td></tr></table></figure></p>

          
        
      
    </div>
    
    
    

    

    <div>
    
    </div>

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/07/20/【算法】第一章-动态规划/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="MisakiFx">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/blog-logo.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Misaki`s blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/07/20/【算法】第一章-动态规划/" itemprop="url">【算法】第一章-动态规划</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-07-20T18:25:03+08:00">
                2019-07-20
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/算法/" itemprop="url" rel="index">
                    <span itemprop="name">算法</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  2.2k
                </span>
              

              

              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="第一章-动态规划"><a href="#第一章-动态规划" class="headerlink" title="第一章-动态规划"></a>第一章-动态规划</h1><h2 id="动态规划求解模式"><a href="#动态规划求解模式" class="headerlink" title="动态规划求解模式"></a>动态规划求解模式</h2><p>&emsp;&emsp;动态规划具备了一下三个特点：<br>&emsp;&emsp;1、把原来的问题分解成了几个相似子问题<br>&emsp;&emsp;2、所有的子问题只需要解决一次<br>&emsp;&emsp;3、储存子问题的解<br>&emsp;&emsp;从以下四个角度考虑：<br>&emsp;&emsp;1、初始状态定义<br>&emsp;&emsp;2、状态间转移方程<br>&emsp;&emsp;3、状态的初始化<br>&emsp;&emsp;4、返回结果<br>&emsp;&emsp;解决问题主要适用于：查找最优解，最大值/最小值，可不可行，是不是，方案个数</p>
<h2 id="例1-斐波那契数列"><a href="#例1-斐波那契数列" class="headerlink" title="例1 斐波那契数列"></a>例1 斐波那契数列</h2><p>&emsp;&emsp;牛客网:<br><a href="https://www.nowcoder.com/questionTerminal/c6c7742f5ba7442aada113136ddea0c3" target="_blank" rel="noopener">https://www.nowcoder.com/questionTerminal/c6c7742f5ba7442aada113136ddea0c3</a><br><br>&emsp;&emsp;动态规划解法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int Fibonacci(int n) &#123;</span><br><span class="line">        vector&lt;int&gt; ret(n + 1, 0);</span><br><span class="line">        //初始状态</span><br><span class="line">        ret[1] = ret[2] = 1;</span><br><span class="line">        //递推公式</span><br><span class="line">        //ret[i] = ret [i - 1] + ret[i - 2];</span><br><span class="line">        for(int i = 3; i &lt;= n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            ret[i] = ret[i - 1] + ret[i - 2];</span><br><span class="line">        &#125;</span><br><span class="line">        return ret[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h2 id="例2-变态青蛙跳台阶"><a href="#例2-变态青蛙跳台阶" class="headerlink" title="例2 变态青蛙跳台阶"></a>例2 变态青蛙跳台阶</h2><p>&emsp;&emsp;牛客网：<br><a href="https://www.nowcoder.com/questionTerminal/22243d016f6b47f2a6928b4313c85387" target="_blank" rel="noopener">https://www.nowcoder.com/questionTerminal/22243d016f6b47f2a6928b4313c85387</a><br></p>
<h3 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h3><h4 id="定义状态"><a href="#定义状态" class="headerlink" title="定义状态"></a>定义状态</h4><p>&emsp;&emsp;跳上i级台阶的方法数</p>
<h4 id="状态转移方程"><a href="#状态转移方程" class="headerlink" title="状态转移方程"></a>状态转移方程</h4><p>&emsp;&emsp;分解：<br>&emsp;&emsp;一次跳1级台阶：1， F(i - 1)<br>&emsp;&emsp;一次跳2级台阶：2， F(i - 2)<br>&emsp;&emsp;……<br>&emsp;&emsp;推得状态转移方程：<br>&emsp;&emsp;F(i) = F(i - 1) + F(i - 2) + … + F(1)<br>&emsp;&emsp;F(i - 1) = F(i - 2) + F(i - 3) + … + F(1)<br>&emsp;&emsp;F(i) = F(i - 1) + F(i - 1) = 2 * F(i - 1);</p>
<h4 id="初始状态和最终状态"><a href="#初始状态和最终状态" class="headerlink" title="初始状态和最终状态"></a>初始状态和最终状态</h4><p>&emsp;&emsp;F(1) = 1,求F(n)。</p>
<h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int jumpFloorII(int number) &#123;</span><br><span class="line">        //初始状态</span><br><span class="line">        int f1 = 1;</span><br><span class="line">        //状态转移方程：F(i) = 2 * F(i - 1)</span><br><span class="line">        for(int i = 2; i &lt;= number; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            f1 = 2 * f1;</span><br><span class="line">        &#125;</span><br><span class="line">        return f1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h3><p>&emsp;&emsp;根据状态转移方程我们可以得知，<code>F(n) = 2 ^ (n - 1)</code>;所以可以得到优化：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int jumpFloorII(int number) &#123;</span><br><span class="line">        return (1 &lt;&lt; (number - 1));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h2 id="例3-求连续最大子数组的和"><a href="#例3-求连续最大子数组的和" class="headerlink" title="例3 求连续最大子数组的和"></a>例3 求连续最大子数组的和</h2><p>&emsp;&emsp;牛客网：</p>
<p><a href="https://www.nowcoder.com/questionTerminal/459bd355da1549fa8a49e350bf3df484" target="_blank" rel="noopener">https://www.nowcoder.com/questionTerminal/459bd355da1549fa8a49e350bf3df484</a></p>
<h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><h4 id="定义状态-1"><a href="#定义状态-1" class="headerlink" title="定义状态"></a>定义状态</h4><p>&emsp;&emsp;到此项为止前i项的连续子序列的最大和</p>
<h4 id="状态转移方程-1"><a href="#状态转移方程-1" class="headerlink" title="状态转移方程"></a>状态转移方程</h4><p>&emsp;&emsp;F(i) = max(F(i - 1) + a[i], a[i]);</p>
<h4 id="初始状态和最终状态-1"><a href="#初始状态和最终状态-1" class="headerlink" title="初始状态和最终状态"></a>初始状态和最终状态</h4><p>&emsp;&emsp;初始状态F[0] = a[0]。<br>&emsp;&emsp;最终结果max(F[i])。</p>
<h3 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int FindGreatestSumOfSubArray(vector&lt;int&gt; array) &#123;</span><br><span class="line">        if(array.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        vector&lt;int&gt; ret(array.size(), 0);</span><br><span class="line">        //初始状态</span><br><span class="line">        ret[0] = array[0];</span><br><span class="line">        //状态转移</span><br><span class="line">        for(int i = 1; i &lt; array.size(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            ret[i] = max(array[i] + ret[i - 1], array[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        //求max(F[i])</span><br><span class="line">        int maxNum = ret[0];</span><br><span class="line">        for(int i = 0; i &lt; ret.size(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            maxNum = max(maxNum, ret[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        return maxNum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="例4-word-break-字符串分割"><a href="#例4-word-break-字符串分割" class="headerlink" title="例4 word-break(字符串分割)"></a>例4 word-break(字符串分割)</h2><p>&emsp;&emsp;牛客网：<br><a href="https://www.nowcoder.com/questionTerminal/5f3b7bf611764c8ba7868f3ed40d6b2c" target="_blank" rel="noopener">https://www.nowcoder.com/questionTerminal/5f3b7bf611764c8ba7868f3ed40d6b2c</a></p>
<h3 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h3><h4 id="定义状态-2"><a href="#定义状态-2" class="headerlink" title="定义状态"></a>定义状态</h4><p>&emsp;&emsp;F(i)：前i个字符能否被分割。</p>
<h4 id="状态转移方程-2"><a href="#状态转移方程-2" class="headerlink" title="状态转移方程"></a>状态转移方程</h4><p>&emsp;&emsp;F(i): F(i)能否被分割取决于前j项能否被分割和j + 1到第i项能否被分割。（此处j取0 ~ i - 1）<br>&emsp;&emsp;得递推方程F(i) : F(j) &amp;&amp; (j + 1 ~ i)能否被分割</p>
<h4 id="初始状态和最终状态-2"><a href="#初始状态和最终状态-2" class="headerlink" title="初始状态和最终状态"></a>初始状态和最终状态</h4><p>&emsp;&emsp;初始状态：F(0) = true。<br>&emsp;&emsp;最终状态F(n)。</p>
<h3 id="实现-2"><a href="#实现-2" class="headerlink" title="实现"></a>实现</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool wordBreak(string s, unordered_set&lt;string&gt; &amp;dict) &#123;</span><br><span class="line">        if(s.empty() || dict.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        vector&lt;bool&gt; Fn(s.size() + 1, false);</span><br><span class="line">        //初始状态</span><br><span class="line">        Fn[0] = true;</span><br><span class="line">        for(int i = 1; i &lt;= s.size(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            //状态转移</span><br><span class="line">            //F(i) = F(j) &amp;&amp; (j + 1 ~ i), (0 &lt;= j &lt; i)能否被分割</span><br><span class="line">            for(int j = i - 1; j &gt;= 0; j--)</span><br><span class="line">            &#123;</span><br><span class="line">                if(Fn[j] &amp;&amp; dict.find(s.substr(j, i - j)) != dict.end())</span><br><span class="line">                &#123;</span><br><span class="line">                    Fn[i] = true;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        //最终状态</span><br><span class="line">        return Fn[s.size()];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="例5-triangle-三角矩阵最短路"><a href="#例5-triangle-三角矩阵最短路" class="headerlink" title="例5 triangle(三角矩阵最短路)"></a>例5 triangle(三角矩阵最短路)</h2><p>&emsp;&emsp;牛客网：<br><a href="https://www.nowcoder.com/questionTerminal/2b7995aa4f7949d99674d975489cb7da" target="_blank" rel="noopener">https://www.nowcoder.com/questionTerminal/2b7995aa4f7949d99674d975489cb7da</a></p>
<h3 id="分析-2"><a href="#分析-2" class="headerlink" title="分析"></a>分析</h3><h4 id="定义状态-3"><a href="#定义状态-3" class="headerlink" title="定义状态"></a>定义状态</h4><p>&emsp;&emsp;F[i][j]: 从(0, 0)到(i, j)的最短路径和。</p>
<h4 id="状态转移方程-3"><a href="#状态转移方程-3" class="headerlink" title="状态转移方程"></a>状态转移方程</h4><p>&emsp;&emsp;一般情况下，走到每个位置的最短路径都可以看作是上一行相邻两个位置的最短路径+这个位置的路径长度，数学描述：F[i][j]:min(F[i - 1][j], F[i - 1][j - 1]) + a[i][j]。<br>&emsp;&emsp;但要考虑边界状态：当在矩阵边缘时只有一种选择的情况，即F[i][0] = F[i - 1][0];F[i][i] = F[i - 1][i - 1]。</p>
<h4 id="初始状态和最终状态-3"><a href="#初始状态和最终状态-3" class="headerlink" title="初始状态和最终状态"></a>初始状态和最终状态</h4><p>&emsp;&emsp;初始状态：F[0][0] = a[0][0]。<br>&emsp;&emsp;最终状态：min(F[n - 1][j])，即最后一行中的最小值。</p>
<h3 id="实现-3"><a href="#实现-3" class="headerlink" title="实现"></a>实现</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int minimumTotal(vector&lt;vector&lt;int&gt; &gt; &amp;triangle) &#123;</span><br><span class="line">        if(triangle.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        //初始状态</span><br><span class="line">        vector&lt;vector&lt;int&gt;&gt; ret(triangle);</span><br><span class="line">        //状态转移</span><br><span class="line">        int row = ret.size();</span><br><span class="line">        for(int i = 1; i &lt; row; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            ret[i][0] = ret[i - 1][0] + triangle[i][0];</span><br><span class="line">        &#125;</span><br><span class="line">        for(int i = 1; i &lt; row; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            ret[i][i] = ret[i - 1][i - 1] + triangle[i][i];</span><br><span class="line">        &#125;</span><br><span class="line">        for(int i = 1; i &lt; row; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            for(int j = 1; j &lt; i; ++j)</span><br><span class="line">            &#123;</span><br><span class="line">                ret[i][j] = min(ret[i - 1][j], ret[i - 1][j - 1]) + triangle[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        //最终状态</span><br><span class="line">        int minSum = ret[row - 1][0];</span><br><span class="line">        for(int i = 1; i &lt; row; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            minSum = min(minSum, ret[row - 1][i]);</span><br><span class="line">        &#125;</span><br><span class="line">        return minSum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="例6-求路径数量"><a href="#例6-求路径数量" class="headerlink" title="例6 求路径数量"></a>例6 求路径数量</h2><p>牛客网：<br><a href="https://www.nowcoder.com/questionTerminal/3cdf08dd4e974260921b712f0a5c8752" target="_blank" rel="noopener">https://www.nowcoder.com/questionTerminal/3cdf08dd4e974260921b712f0a5c8752</a></p>
<h3 id="分析-3"><a href="#分析-3" class="headerlink" title="分析"></a>分析</h3><h4 id="状态定义"><a href="#状态定义" class="headerlink" title="状态定义"></a>状态定义</h4><p>&emsp;&emsp;F[i][j]：从左上角到达下标(i, j)的路径总数</p>
<h4 id="状态转移方程-4"><a href="#状态转移方程-4" class="headerlink" title="状态转移方程"></a>状态转移方程</h4><p>&emsp;&emsp;if(a[i][j] == 1) F[i][j] = 0;<br>&emsp;&emsp;if(a[i][j] == 0) F[i][j] = F[i][j - 1] + F[i - 1][j]。</p>
<h4 id="初始状态和最终状态-4"><a href="#初始状态和最终状态-4" class="headerlink" title="初始状态和最终状态"></a>初始状态和最终状态</h4><p>&emsp;&emsp;初始状态：如果第一行第一列有障碍物表示这条路走不通则路径数置0，否则只有一条路径，置一if(a[0][j]) == 1) F[0][j] = 0，if(a[i][0] == 1) F[i][0] = 0，这种情况下这条路走不通。<br>&emsp;&emsp;最终状态：F[i][j]。</p>
<h3 id="实现-4"><a href="#实现-4" class="headerlink" title="实现"></a>实现</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int uniquePathsWithObstacles(vector&lt;vector&lt;int&gt; &gt; &amp;obstacleGrid) &#123;</span><br><span class="line">        if(obstacleGrid.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        if(obstacleGrid[0][0] == 1)</span><br><span class="line">        &#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        int row = obstacleGrid.size();</span><br><span class="line">        int col = obstacleGrid[0].size();</span><br><span class="line">        vector&lt;vector&lt;int&gt;&gt; pathNum(row, vector&lt;int&gt;(col, 0));</span><br><span class="line">        for(int i = 0; i &lt; row; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            if(obstacleGrid[i][0] == 1)</span><br><span class="line">            &#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">            &#123;</span><br><span class="line">                pathNum[i][0] = 1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        for(int i = 0; i &lt; col; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            if(obstacleGrid[0][i] == 1)</span><br><span class="line">            &#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            else </span><br><span class="line">            &#123;</span><br><span class="line">                pathNum[0][i] = 1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        for(int i = 1; i &lt; row; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            for(int j = 1; j &lt; col; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                if(obstacleGrid[i][j] == 1)</span><br><span class="line">                &#123;</span><br><span class="line">                    pathNum[i][j] = 0;</span><br><span class="line">                &#125;</span><br><span class="line">                else</span><br><span class="line">                &#123;</span><br><span class="line">                    pathNum[i][j] = pathNum[i][j - 1] + pathNum[i - 1][j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return pathNum[row - 1][col - 1];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="例7-背包问题"><a href="#例7-背包问题" class="headerlink" title="例7 背包问题"></a>例7 背包问题</h2><p>&emsp;&emsp;lintcode：<br><a href="https://www.lintcode.com/problem/backpack-ii/description" target="_blank" rel="noopener">https://www.lintcode.com/problem/backpack-ii/description</a></p>
<h3 id="分析-4"><a href="#分析-4" class="headerlink" title="分析"></a>分析</h3><p>&emsp;&emsp;背包问题是一类问题，主要是求解约束条件下的最优解问题。</p>
<h4 id="状态定义-1"><a href="#状态定义-1" class="headerlink" title="状态定义"></a>状态定义</h4><p>&emsp;&emsp;F[i][j]：前i个商品，包的重量为j的最大价值。定义二维数组遍历所有商品，和到当前商品情况下背包容量从0 - max的所有情况下的最大值求解，遍历到最后则可得到n个全部商品情况下背包最大容量max下背包可拿的最大价值F[n][max]。</p>
<h4 id="状态转移方程-5"><a href="#状态转移方程-5" class="headerlink" title="状态转移方程"></a>状态转移方程</h4><p>&emsp;&emsp;当前商品空间大于包能承受的总空间，放不下直接跳过。数学描述：if(w[i] &gt; j) F[i][j] = F[i - 1][j]。<br>&emsp;&emsp;当前商品空间小于等于包能承受总空间，可以选择放可以选择不放，如果不放入，则F[i][j] = F[i - 1][j]；如果放入，则当前重量等于遍历到的上一个商品并且空间还有w[i]这么大的时候的价值+本商品的价值，最大价值F[i][j] = F[i - 1][j - w[i]] + v[i]，选择放入或不放入商品情况中的最大值作为最优解。数学描述：if(w[i] &lt;= j) max(F[i - 1][j], F[i - 1][j - w[i]] + v[i]);</p>
<h4 id="初始状态和最终状态-5"><a href="#初始状态和最终状态-5" class="headerlink" title="初始状态和最终状态"></a>初始状态和最终状态</h4><p>&emsp;&emsp;初始状态：没有商品时，F[0][j] = 0,最大容量为0时F[i][0] = 0。<br>&emsp;&emsp;最终状态：遍历完全部n个商品，并且背包总容量为最大值m时得到最大价值F[n][m]。</p>
<h3 id="实现-5"><a href="#实现-5" class="headerlink" title="实现"></a>实现</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    /**</span><br><span class="line">     * @param m: An integer m denotes the size of a backpack</span><br><span class="line">     * @param A: Given n items with size A[i]</span><br><span class="line">     * @param V: Given n items with value V[i]</span><br><span class="line">     * @return: The maximum value</span><br><span class="line">     */</span><br><span class="line">    int backPackII(int m, vector&lt;int&gt; &amp;A, vector&lt;int&gt; &amp;V) &#123;</span><br><span class="line">        if(A.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        int row = A.size();</span><br><span class="line">        vector&lt;vector&lt;int&gt;&gt; maxValue(row + 1, vector&lt;int&gt;(m + 1, 0));</span><br><span class="line">        for(int i = 1; i &lt;= row; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            for(int j = 1; j &lt;= m; ++j)</span><br><span class="line">            &#123;</span><br><span class="line">                if(A[i - 1] &gt; j)</span><br><span class="line">                &#123;</span><br><span class="line">                    maxValue[i][j] = maxValue[i - 1][j];</span><br><span class="line">                &#125;</span><br><span class="line">                else</span><br><span class="line">                &#123;</span><br><span class="line">                    maxValue[i][j] = max(maxValue[i - 1][j], maxValue[i - 1][j - A[i - 1]] + V[i - 1]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return maxValue[row][m];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
          
        
      
    </div>
    
    
    

    

    <div>
    
    </div>

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/07/15/【Cpp】第四章-模板初阶/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="MisakiFx">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/blog-logo.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Misaki`s blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/07/15/【Cpp】第四章-模板初阶/" itemprop="url">【Cpp】第四章-模板初阶</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-07-15T20:10:18+08:00">
                2019-07-15
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Cpp/" itemprop="url" rel="index">
                    <span itemprop="name">Cpp</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  1.7k
                </span>
              

              

              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="模板初阶"><a href="#模板初阶" class="headerlink" title="模板初阶"></a>模板初阶</h1><h2 id="泛型编程"><a href="#泛型编程" class="headerlink" title="泛型编程"></a>泛型编程</h2><p>&emsp;&emsp;在我们进行大型程序的编写时往往会遇到一类问题，同一个函数或类我们希望多种类型数据传入时都能完成类似或者相同的功能，但是在C语言中我们很难做到这一点因为我们往往在换了一个数据类型后就要重新写一遍函数，这样耽误我们大量的时间，呢么有没有一种语法在Cpp中能够使让我们的代码成为一种模板，不同的数据类型传入也依然能够执行类似的功能呢？<br><br>&emsp;&emsp;正所谓世界是由懒人创造的，于是在C++中引入了模板这一概念，同时也正得益与此使我们可以做到<strong>泛型编程</strong>，是我们的代码极大程度的可以复用。</p>
<h2 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h2><p>&emsp;&emsp;模板是实现泛型编程的基础，其中又可细分为<strong>函数模板</strong>和<strong>类模板</strong>。</p>
<h3 id="函数模板"><a href="#函数模板" class="headerlink" title="函数模板"></a>函数模板</h3><p>&emsp;&emsp;函数模板是生成一个家族的函数，其中我们可以使用任意类型的参数进行传入。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">//定义函数模板,T为任意类型</span><br><span class="line">//class 也可替换为 typename</span><br><span class="line">template&lt;class T&gt;</span><br><span class="line">void Swap(T&amp; a, T&amp; b)</span><br><span class="line">&#123;</span><br><span class="line">    T t = a;</span><br><span class="line">    a = b;</span><br><span class="line">    b = t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int a = 4, b = 5;</span><br><span class="line">    double c = 6, d = 7;</span><br><span class="line">    Swap(a, b);</span><br><span class="line">    Swap(c, d);</span><br><span class="line">    cout &lt;&lt; a &lt;&lt; &quot; &quot; &lt;&lt; b &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; c &lt;&lt; &quot; &quot; &lt;&lt; d &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">5 4</span><br><span class="line">7 6</span><br></pre></td></tr></table></figure></p>
<h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><p>&emsp;&emsp;函数模板在定义完之后并不会直接生成函数，而是在调用时会根据传参类型进行推演，在上面的例子中我们传入了<code>int</code>类型的参数因此在推演时会将<code>T</code>转换为<code>int</code>再进行调用，但有时我们的调用如果出现了让编译器无法推演的情况就会导致报错。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">template&lt;class T&gt;</span><br><span class="line">void Swap(T&amp; a, T&amp; b)</span><br><span class="line">&#123;</span><br><span class="line">    T t = a;</span><br><span class="line">    a = b;</span><br><span class="line">    b = t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int a = 4, b = 5;</span><br><span class="line">    double c = 6, d = 7;</span><br><span class="line">    Swap(a, d);</span><br><span class="line">    Swap(c, b);</span><br><span class="line">    cout &lt;&lt; a &lt;&lt; &quot; &quot; &lt;&lt; b &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; c &lt;&lt; &quot; &quot; &lt;&lt; d &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">.\test.cpp: In function &apos;int main()&apos;:</span><br><span class="line">.\test.cpp:15:14: error: no matching function for call to &apos;Swap(int&amp;, double&amp;)&apos;</span><br><span class="line">     Swap(a, d);</span><br><span class="line">              ^</span><br><span class="line">.\test.cpp:4:6: note: candidate: template&lt;class T&gt; void Swap(T&amp;, T&amp;)</span><br><span class="line"> void Swap(T&amp; a, T&amp; b)</span><br><span class="line">      ^~~~</span><br><span class="line">.\test.cpp:4:6: note:   template argument deduction/substitution failed:</span><br><span class="line">.\test.cpp:15:14: note:   deduced conflicting types for parameter &apos;T&apos; (&apos;int&apos; and &apos;double&apos;)</span><br><span class="line">     Swap(a, d);</span><br><span class="line">              ^</span><br><span class="line">.\test.cpp:16:14: error: no matching function for call to &apos;Swap(double&amp;, int&amp;)&apos;</span><br><span class="line">     Swap(c, b);</span><br><span class="line">              ^</span><br><span class="line">.\test.cpp:4:6: note: candidate: template&lt;class T&gt; void Swap(T&amp;, T&amp;)</span><br><span class="line"> void Swap(T&amp; a, T&amp; b)</span><br><span class="line">      ^~~~</span><br><span class="line">.\test.cpp:4:6: note:   template argument deduction/substitution failed:</span><br><span class="line">.\test.cpp:16:14: note:   deduced conflicting types for parameter &apos;T&apos; (&apos;double&apos; and &apos;int&apos;)</span><br><span class="line">     Swap(c, b);</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;我们会发现在这样只有一个模板参数<code>T</code>进行多类型传入就会混淆编译器，导致报错，因此我们可以定义多个模板参数，也可以进行强转使参数类型唯一，不过这里要提到另一种可以让编译器推演出我们想要的函数的方式，<strong>显示实例化</strong>。</p>
<h4 id="显示实例化"><a href="#显示实例化" class="headerlink" title="显示实例化"></a>显示实例化</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">template&lt;class T&gt;</span><br><span class="line">T Add(T a, T b)</span><br><span class="line">&#123;</span><br><span class="line">    return a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int ret = Add&lt;int&gt;(1, 2);</span><br><span class="line">    cout &lt;&lt; ret &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">3</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;像是这样的情况我们就利用显示实例化给我们的函数模板制定了实例化类型，同时如果类型不匹配，编译器会进行隐式类型转换，如果转换不成功则会报错。</p>
<h4 id="函数模板匹配原则"><a href="#函数模板匹配原则" class="headerlink" title="函数模板匹配原则"></a>函数模板匹配原则</h4><p>&emsp;&emsp;函数模板可以与非模板函数重名，此时会构成类似于函数重载的情况，并且在函数调用时如果出现重名的函数模板和非模板函数都可以构成匹配则会优先调用非模板函数，而不会对函数模板进行实例化，除非我们利用显示实例化指定必须调用模板函数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">template&lt;class T&gt;</span><br><span class="line">T Add(T a, T b)</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; &quot;template function&quot; &lt;&lt; endl;</span><br><span class="line">    return a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int Add(int a, int b)</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; &quot;simple function&quot; &lt;&lt; endl;</span><br><span class="line">    return a + b;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int ret = Add(1, 2);//调用普通函数</span><br><span class="line">    ret = Add&lt;int&gt;(1, 2);//调用模板函数</span><br><span class="line">    cout &lt;&lt; ret &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">simple function</span><br><span class="line">template function</span><br><span class="line">3</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;但是如果模板函数此时可以提供更好的适配性，则会优先调用模板函数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">template&lt;class T1, class T2&gt;</span><br><span class="line">T1 Add(T1 a, T2 b)</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; &quot;template function&quot; &lt;&lt; endl;</span><br><span class="line">    return a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int Add(int a, int b)</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; &quot;simple function&quot; &lt;&lt; endl;</span><br><span class="line">    return a + b;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int ret = Add(1, 2.0);//优先调用函数模板</span><br><span class="line">    ret = Add&lt;int, double&gt;(1, 2.0);</span><br><span class="line">    cout &lt;&lt; ret &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">template function</span><br><span class="line">template function</span><br><span class="line">3</span><br></pre></td></tr></table></figure></p>
<h3 id="类模板"><a href="#类模板" class="headerlink" title="类模板"></a>类模板</h3><p>&emsp;&emsp;类模板与函数模板类似，是使用一个模板参数来构造整个类，并且原理也与函数模板类似，只有在类构造对象时才会推演模板参数进行实例化，实例化出我们想要的类。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;assert.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">template&lt;class T&gt;</span><br><span class="line">class Vector</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    Vector(size_t capacity = 10)</span><br><span class="line">        :_pData(new T[capacity])</span><br><span class="line">        ,_size(0)</span><br><span class="line">        ,_capacity(capacity)</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    ~Vector();</span><br><span class="line">    //返回size</span><br><span class="line">    size_t Size()</span><br><span class="line">    &#123;</span><br><span class="line">        return _size;</span><br><span class="line">    &#125;</span><br><span class="line">    //尾插</span><br><span class="line">    void Push_back(const T&amp; data)</span><br><span class="line">    &#123;</span><br><span class="line">        //检查扩容</span><br><span class="line">        if(_size &gt;= _capacity)</span><br><span class="line">        &#123;//扩容</span><br><span class="line">            Reserve(2 * _capacity);</span><br><span class="line">        &#125;</span><br><span class="line">        _pData[_size] = data;</span><br><span class="line">        _size++;</span><br><span class="line">    &#125;</span><br><span class="line">    //尾删</span><br><span class="line">    void Pop_back()</span><br><span class="line">    &#123;</span><br><span class="line">        _size--;</span><br><span class="line">    &#125;</span><br><span class="line">    //改变容量</span><br><span class="line">    void Reserve(int capacity)</span><br><span class="line">    &#123;</span><br><span class="line">        if(capacity &lt;= _capacity)</span><br><span class="line">        &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        T* newPData = new T[capacity];</span><br><span class="line">        for(int i = 0; i &lt; _size; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            newPData[i] = _pData[i];</span><br><span class="line">        &#125;</span><br><span class="line">        _pData = newPData;</span><br><span class="line">        _capacity = capacity;</span><br><span class="line">    &#125;</span><br><span class="line">    T operator[](size_t pos)</span><br><span class="line">    &#123;</span><br><span class="line">        assert(pos &lt; _size);</span><br><span class="line">        return _pData[pos];</span><br><span class="line">    &#125;</span><br><span class="line">private:</span><br><span class="line">    T* _pData;</span><br><span class="line">    size_t _size;</span><br><span class="line">    size_t _capacity;</span><br><span class="line">&#125;;</span><br><span class="line">//在类外进行函数声明时要加上模板参数</span><br><span class="line">//同时要注意Vector不是一个类，实例化后Vector&lt;T&gt;才是一个类</span><br><span class="line">template&lt;class T&gt;</span><br><span class="line">Vector&lt;T&gt;::~Vector()</span><br><span class="line">&#123;</span><br><span class="line">    if(_pData)</span><br><span class="line">    &#123;</span><br><span class="line">        delete[] _pData;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    Vector&lt;int&gt; arr;</span><br><span class="line">    arr.Push_back(1);</span><br><span class="line">    arr.Push_back(2);</span><br><span class="line">    for(int i = 0; i &lt; arr.Size(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; arr[i] &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1</span><br><span class="line">2</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;这个例子我们模拟简单实现了一个<code>vector</code>模板类，并且使用实例化进行使用，类模板与函数模板不同的是类模板往往无法推演出模板参数类型因此需要我们显示实例化使其实例化为一个具体的类才可以进行使用。</p>

          
        
      
    </div>
    
    
    

    

    <div>
    
    </div>

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/06/11/【Cpp】第三章-内存管理/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="MisakiFx">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/blog-logo.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Misaki`s blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/06/11/【Cpp】第三章-内存管理/" itemprop="url">【Cpp】第三章-内存管理</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-06-11T01:34:08+08:00">
                2019-06-11
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Cpp/" itemprop="url" rel="index">
                    <span itemprop="name">Cpp</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  2.6k
                </span>
              

              

              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h1><h2 id="C-内存管理"><a href="#C-内存管理" class="headerlink" title="C++内存管理"></a>C++内存管理</h2><p>&emsp;&emsp;在C语言中，我们想要动态分配内存空间需要使用到<code>malloc,calloc,realloc</code>函数，在C++中我们同样有动态进行内存管理的方式，并且与C语言中的内存管理有着一些区别。</p>
<h3 id="new-delete"><a href="#new-delete" class="headerlink" title="new/delete"></a>new/delete</h3><p>&emsp;&emsp;在C++中我们使用<code>new</code>进行内存的申请，用<code>delete</code>进行内存的释放。他们的使用比<code>malloc</code>和<code>free</code>更加简单方便。</p>
<h4 id="内置类型的内存分配与释放"><a href="#内置类型的内存分配与释放" class="headerlink" title="内置类型的内存分配与释放"></a>内置类型的内存分配与释放</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">  int* a = new int;</span><br><span class="line">  //等同于int* a = (int*)malloc(sizeof(int));</span><br><span class="line">  int* b = new int[10];</span><br><span class="line">  //等同于int* b = (int*)malloc(sizeof(int) * 10);</span><br><span class="line">  int* c = new int(10);</span><br><span class="line">  //new还可以进行内置类型的初始化</span><br><span class="line">  cout &lt;&lt; *c &lt;&lt; endl;</span><br><span class="line">  delete a;</span><br><span class="line">  //等同于free(a);</span><br><span class="line">  delete[] b;//对于多个变量的空间释放要用delete[]</span><br><span class="line">  //等同于free(b);</span><br><span class="line">  delete c;</span><br><span class="line">  //等同于free(c);                                </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[misaki@localhost 第三章-内存管理]$ ./New</span><br><span class="line">10</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;<code>new</code>和<code>malloc</code>一样会在堆上开辟空间同时需要我们手动进行内存的释放，但是<code>new</code>的写法更加简单易于理解同时我们还可以对单个申请的变量进行初始化。</p>
<h4 id="自定义类型的内存分配与释放"><a href="#自定义类型的内存分配与释放" class="headerlink" title="自定义类型的内存分配与释放"></a>自定义类型的内存分配与释放</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;                                 </span><br><span class="line">#include &lt;stdlib.h&gt;  </span><br><span class="line">using namespace std;                           </span><br><span class="line">class Stu                </span><br><span class="line">&#123;                                                   </span><br><span class="line">  public:                </span><br><span class="line">    Stu()                          </span><br><span class="line">    &#123;                  </span><br><span class="line">      cout &lt;&lt; &quot;default building&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;;              </span><br><span class="line">    Stu(int num, string name):_num(num), _name(name)</span><br><span class="line">    &#123;               </span><br><span class="line">      cout &lt;&lt; &quot;custom building&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;               </span><br><span class="line">    ~Stu()                  </span><br><span class="line">    &#123;                                </span><br><span class="line">      cout &lt;&lt; &quot;destroying&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;                         </span><br><span class="line">  private:                  </span><br><span class="line">    int _num;                            </span><br><span class="line">    string _name;        </span><br><span class="line">&#125;;                    </span><br><span class="line">int main()</span><br><span class="line">&#123;         </span><br><span class="line">  cout &lt;&lt; &quot;malloc:&quot; &lt;&lt; endl;</span><br><span class="line">  Stu* a = (Stu*)malloc(sizeof(Stu));</span><br><span class="line">  cout &lt;&lt; &quot;new:&quot; &lt;&lt; endl;</span><br><span class="line">  Stu* b = new Stu(1, &quot;张三&quot;);</span><br><span class="line">  cout &lt;&lt; &quot;malloc:&quot; &lt;&lt; endl;</span><br><span class="line">  Stu* c = (Stu*)malloc(sizeof(Stu) * 5);</span><br><span class="line">  cout &lt;&lt; &quot;new:&quot; &lt;&lt; endl;</span><br><span class="line">  Stu* d = new Stu[5];</span><br><span class="line">  cout &lt;&lt; &quot;free:&quot; &lt;&lt; endl;</span><br><span class="line">  free(a);</span><br><span class="line">  cout &lt;&lt; &quot;delete:&quot; &lt;&lt; endl;</span><br><span class="line">  delete b;</span><br><span class="line">  cout &lt;&lt; &quot;free:&quot; &lt;&lt; endl;</span><br><span class="line">  free(c);</span><br><span class="line">  cout &lt;&lt; &quot;delete:&quot; &lt;&lt; endl;</span><br><span class="line">  delete[] d;</span><br><span class="line">&#125;              </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[misaki@localhost 第三章-内存管理]$ ./New </span><br><span class="line">malloc:</span><br><span class="line">new:</span><br><span class="line">custom building</span><br><span class="line">malloc:</span><br><span class="line">new:</span><br><span class="line">default building</span><br><span class="line">default building</span><br><span class="line">default building</span><br><span class="line">default building</span><br><span class="line">default building</span><br><span class="line">free:</span><br><span class="line">delete:</span><br><span class="line">destroying</span><br><span class="line">free:</span><br><span class="line">delete:</span><br><span class="line">destroying</span><br><span class="line">destroying</span><br><span class="line">destroying</span><br><span class="line">destroying</span><br><span class="line">destroying</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;以上这段代码我分别使用<code>malloc</code>和<code>new</code>对自定义类型进行内存分配和释放，我们可以发现<code>new</code>不但可以在分配内存的时候手动调用指定的构造函数还会在分配多个对象的空间时自动调用默认构造函数，<code>delete</code>也会自动调用析构函数，而<code>malloc</code>和<code>free</code>却做不到这一点。因此可以理解<strong>为<code>malloc</code>和<code>free</code>分配出来的只不过是一个和类一样大小的空间，并不能称作是一个对象，而<code>new</code>和<code>delete</code>分配出来的才能被成为对象</strong>。</p>
<h2 id="new和delete实现原理"><a href="#new和delete实现原理" class="headerlink" title="new和delete实现原理"></a>new和delete实现原理</h2><p>&emsp;&emsp;<code>new</code>和<code>delete</code>在C++中其实被定义为两个运算符，我们在使用这两个运算符的时候它会在底层调用全局函数<code>operator new</code>和<code>operator delete</code>。</p>
<h3 id="operator-new-operator-delete"><a href="#operator-new-operator-delete" class="headerlink" title="operator new/operator delete"></a>operator new/operator delete</h3><p>&emsp;&emsp;我们首先看下这两个函数在底层的实现源码。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">void *__CRTDECL operator new(size_t size) _THROW1(_STD bad_alloc)</span><br><span class="line">&#123;</span><br><span class="line"> // try to allocate size bytes</span><br><span class="line"> void *p;</span><br><span class="line"> while ((p = malloc(size)) == 0)</span><br><span class="line"> if (_callnewh(size) == 0)</span><br><span class="line"> &#123;</span><br><span class="line"> // report no memory</span><br><span class="line"> // 如果申请内存失败了，这里会抛出bad_alloc 类型异常</span><br><span class="line"> static const std::bad_alloc nomem;</span><br><span class="line"> _RAISE(nomem);</span><br><span class="line"> &#125;</span><br><span class="line"> return (p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">void operator delete(void *pUserData)</span><br><span class="line">&#123;</span><br><span class="line"> _CrtMemBlockHeader * pHead;</span><br><span class="line"> RTCCALLBACK(_RTC_Free_hook, (pUserData, 0));</span><br><span class="line"> if (pUserData == NULL)</span><br><span class="line"> return;</span><br><span class="line">  _mlock(_HEAP_LOCK); /* block other threads */</span><br><span class="line"> __TRY</span><br><span class="line"> /* get a pointer to memory block header */</span><br><span class="line"> pHead = pHdr(pUserData);</span><br><span class="line"> /* verify block type */</span><br><span class="line"> _ASSERTE(_BLOCK_TYPE_IS_VALID(pHead-&gt;nBlockUse));</span><br><span class="line"> _free_dbg( pUserData, pHead-&gt;nBlockUse );</span><br><span class="line"> __FINALLY</span><br><span class="line"> _munlock(_HEAP_LOCK); /* release other threads */</span><br><span class="line"> __END_TRY_FINALLY</span><br><span class="line"> return;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;从源码中能看出的是<code>operator new</code>和<code>operator delete</code>在底层也是利用<code>malloc</code>和<code>free</code>分配内存的，因此可以说<code>new</code>和<code>delete</code>不过是<code>malloc</code>和<code>free</code>的一层封装。因此在某些情况下，我们想要用独特的方式给一个类分配内存空间的时候我们就可以重新重载这两个运算符来达到我们的目的。基于这个原理如果有某些类需要特殊的内存分配方式我们可以对其进行运算符的重载。</p>
<h3 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h3><h4 id="内置类型"><a href="#内置类型" class="headerlink" title="内置类型"></a>内置类型</h4><p>&emsp;&emsp;对于内置类型来说<code>new</code>和<code>malloc</code>,<code>delete</code>和<code>free</code>的功能一致，不同的是<code>new[]</code>和<code>delete[]</code>才能分配多个连续的空间。</p>
<h4 id="自定义类型"><a href="#自定义类型" class="headerlink" title="自定义类型"></a>自定义类型</h4><h5 id="单个元素空间分配"><a href="#单个元素空间分配" class="headerlink" title="单个元素空间分配"></a>单个元素空间分配</h5><p>&emsp;&emsp;1、<strong>new</strong>:<br><br>&emsp;&emsp;&emsp;&emsp;1)首先调用<code>operator new</code>为对象分配空间。<br><br>&emsp;&emsp;&emsp;&emsp;2)调用对象的构造函数对对象进行初始化。<br><br>&emsp;&emsp;2、<strong>delete</strong>:<br><br>&emsp;&emsp;&emsp;&emsp;1)调用对象的析构函数进行对象中资源的空间清理。<br><br>&emsp;&emsp;&emsp;&emsp;2)调用<code>operator delete</code>释放对象的空间。</p>
<h5 id="多个元素空间分配"><a href="#多个元素空间分配" class="headerlink" title="多个元素空间分配"></a>多个元素空间分配</h5><p>&emsp;&emsp;1、<strong>new[]</strong>:<br><br>&emsp;&emsp;&emsp;&emsp;1)调用<code>operator new[]</code>，在<code>operator new[]</code>中调用<code>operator new</code>完成N个对象的空间的分配。<br><br>&emsp;&emsp;&emsp;&emsp;2)调用构造函数N次完成N个对象的初始化。<br><br>&emsp;&emsp;2、<strong>delete[]</strong>:<br><br>&emsp;&emsp;&emsp;&emsp;1)调用析构函数N次完成N个对象资源的清理。<br><br>&emsp;&emsp;&emsp;&emsp;2)调用<code>operator delete[]</code>,在<code>operator delete[]</code>中调用<code>operator delete</code>完成N个对象的空间的释放。</p>
<h2 id="定位new表达式"><a href="#定位new表达式" class="headerlink" title="定位new表达式"></a>定位new表达式</h2><p>&emsp;&emsp;当我们用<code>malloc</code>或者其他方式分配了一块和某个类一样大小的空间给，并用某个指针去指向这块空间。但是问题在于这块空间并未执行构造函数因此并不能称为对象。因此定位new表达式就是为了帮助我们对一块已经分配好的空间执行构造函数使之成为对象的一个方式。</p>
<h3 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h3><p>&emsp;&emsp;<code>new (place_address) type(initializer-list)。</code><br><br>&emsp;&emsp;<code>place_address</code>为指向某一块空间的指针，<code>type</code>为自定义类型，<code>initializer-list</code>为参数列表。</p>
<h3 id="例"><a href="#例" class="headerlink" title="例"></a>例</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;                                 </span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class Stu                                          </span><br><span class="line">&#123;                   </span><br><span class="line">  public:    </span><br><span class="line">    Stu()           </span><br><span class="line">    &#123;                         </span><br><span class="line">      cout &lt;&lt; &quot;default building&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;;                     </span><br><span class="line">    Stu(int num, string name):_num(num), _name(name)</span><br><span class="line">    &#123;                         </span><br><span class="line">      cout &lt;&lt; &quot;custom building&quot; &lt;&lt; endl;   </span><br><span class="line">    &#125;                      </span><br><span class="line">    ~Stu()              </span><br><span class="line">    &#123;                       </span><br><span class="line">      cout &lt;&lt; &quot;destroying&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;                         </span><br><span class="line">  private:   </span><br><span class="line">    int _num;               </span><br><span class="line">    string _name;</span><br><span class="line">&#125;;                            </span><br><span class="line">int main()     </span><br><span class="line">&#123;                                    </span><br><span class="line">  Stu* p = (Stu*)malloc(sizeof(Stu));</span><br><span class="line">  cout &lt;&lt; &quot;定位new表达式：&quot; &lt;&lt; endl;</span><br><span class="line">  new(p) Stu(1,&quot;张三&quot;);              </span><br><span class="line">  delete p;              </span><br><span class="line">&#125;                                    </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[misaki@localhost 第三章-内存管理]$ ./New</span><br><span class="line">定位new表达式：</span><br><span class="line">custom building</span><br><span class="line">destroying</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;这样我们就用定位new表达式给已经分配好的空间调用了构造函数。</p>
<h2 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h2><h3 id="new和malloc的异同"><a href="#new和malloc的异同" class="headerlink" title="new和malloc的异同"></a>new和malloc的异同</h3><h4 id="相同"><a href="#相同" class="headerlink" title="相同"></a>相同</h4><p>&emsp;&emsp;1、<code>new</code>和<code>delete</code>都在堆上进行空间的申请。<br><br>&emsp;&emsp;2、都需要手动释放空间。</p>
<h4 id="不同"><a href="#不同" class="headerlink" title="不同"></a>不同</h4><p>&emsp;&emsp;1、<code>malloc</code>和<code>free</code>是函数而<code>new</code>和<code>delete</code>是运算符。<br><br>&emsp;&emsp;2、<code>new</code>可以在分配空间的时候进行初始化。<br><br>&emsp;&emsp;3、<code>malloc</code>返回值是<code>void*</code>需要强转，<code>new</code>会直接返回与分配空间类型一样的类型指针。<br><br>&emsp;&emsp;4、<code>malloc</code>需要手动计算分配空间大小在进行传入，而<code>new</code>只需要类型和元素个数，空间大小会自动计算。<br><br>&emsp;&emsp;5、<code>new</code>在给自定义类型分配空间的时候会自动调用其构造函数，<code>delete</code>会自动调用其析构函数。<br><br>&emsp;&emsp;6、<code>malloc</code>申请空间失败会返回<code>NULL</code>，<code>new</code>会抛异常。<br><br>&emsp;&emsp;7、<code>new</code>和<code>delete</code>是<code>malloc</code>和<code>free</code>的一层封装，因此效率会低一些。</p>
<h3 id="写一个只能在堆上创建对象的类"><a href="#写一个只能在堆上创建对象的类" class="headerlink" title="写一个只能在堆上创建对象的类"></a>写一个只能在堆上创建对象的类</h3><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>&emsp;&emsp;1、将构造函数，赋值构造函数全部封装为私有，不允许外部直接调用构造。<br><br>&emsp;&emsp;2、单独写一个静态函数提供在堆上创建对象的接口。</p>
<h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class HeapOnly</span><br><span class="line">&#123;</span><br><span class="line">  public:</span><br><span class="line">    //开放构造接口                        </span><br><span class="line">    static HeapOnly* Create()</span><br><span class="line">    &#123;</span><br><span class="line">      cout &lt;&lt; &quot;create int heap&quot; &lt;&lt; endl;</span><br><span class="line">      return new HeapOnly();</span><br><span class="line">    &#125;</span><br><span class="line">    ~HeapOnly()</span><br><span class="line">    &#123;</span><br><span class="line">      cout &lt;&lt; &quot;destorying&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">  private:</span><br><span class="line">    //构造函数私有化</span><br><span class="line">    HeapOnly()&#123;&#125;</span><br><span class="line">    HeapOnly(const HeapOnly&amp;)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">  HeapOnly* heapOnly = HeapOnly::Create();</span><br><span class="line">  delete heapOnly;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[misaki@localhost 第三章-内存管理]$ ./HeapOnlyClass</span><br><span class="line">create int heap</span><br><span class="line">destorying</span><br></pre></td></tr></table></figure>
<h3 id="写一个只能在栈上创建对象的类"><a href="#写一个只能在栈上创建对象的类" class="headerlink" title="写一个只能在栈上创建对象的类"></a>写一个只能在栈上创建对象的类</h3><h4 id="思路一"><a href="#思路一" class="headerlink" title="思路一"></a>思路一</h4><p>&emsp;&emsp;1、将构造函数，赋值构造函数全部封装为私有，不允许外部直接调用构造。<br><br>&emsp;&emsp;2、单独写一个静态函数提供在栈上创建对象的接口。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class StackOnly</span><br><span class="line">&#123;</span><br><span class="line">  public:</span><br><span class="line">    static StackOnly Create()</span><br><span class="line">    &#123;</span><br><span class="line">      //创建匿名对象</span><br><span class="line">      return StackOnly();</span><br><span class="line">    &#125;</span><br><span class="line">    static StackOnly a;</span><br><span class="line">    ~StackOnly()</span><br><span class="line">    &#123;</span><br><span class="line">      cout &lt;&lt; &quot;destorying&quot; &lt;&lt; endl;      </span><br><span class="line">    &#125;</span><br><span class="line">  private:</span><br><span class="line">    StackOnly()</span><br><span class="line">    &#123;</span><br><span class="line">      cout &lt;&lt; &quot;create in stack&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    StackOnly(const StackOnly&amp;)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">  StackOnly::a = StackOnly::Create();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[misaki@localhost 第三章-内存管理]$ ./StackOnlyClass </span><br><span class="line">create in stack</span><br><span class="line">destorying</span><br></pre></td></tr></table></figure></p>
<h4 id="思路二"><a href="#思路二" class="headerlink" title="思路二"></a>思路二</h4><p>&emsp;&emsp;1、直接将<code>operator new</code>和<code>operator delete</code>重载并定义为私有。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;                     </span><br><span class="line">using namespace std;               </span><br><span class="line">class StackOnly                  </span><br><span class="line">&#123;</span><br><span class="line">  public:      </span><br><span class="line">    StackOnly()</span><br><span class="line">    &#123;    </span><br><span class="line">      cout &lt;&lt; &quot;create in stack&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    ~StackOnly()    </span><br><span class="line">    &#123;                    </span><br><span class="line">      cout &lt;&lt; &quot;destorying&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;                  </span><br><span class="line">  private:      </span><br><span class="line">    void* operator new(size_t size)&#123;&#125;</span><br><span class="line">    void operator delete(void* p)&#123;&#125;</span><br><span class="line">&#125;;   </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;                   </span><br><span class="line">  StackOnly p;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="实现单例模式"><a href="#实现单例模式" class="headerlink" title="实现单例模式"></a>实现单例模式</h3><p>&emsp;&emsp;单例模式是一种设计模式，在实战中经常会用到。其意思是创建一个类这个类只能唯一的创建一个对象，如果之后还想用这个类创建新对象的时候都会返回最开始创建的呢个对象。<br><br>&emsp;&emsp;要实现这一点有两种思路，分别成为<strong>懒汉模式</strong>和<strong>饿汉模式</strong>。</p>
<h4 id="饿汉模式"><a href="#饿汉模式" class="headerlink" title="饿汉模式"></a>饿汉模式</h4><p>&emsp;&emsp;饿汉模式是在程序启动时就夹在所有需要资源的设计模式，用这种思想实现单例模式时需要在程序一开始就直接声明对象，需要适用对象就返回对象即可。但是坏处是程序启动时会消耗时间可能会造成程序启动缓慢。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;  </span><br><span class="line">using namespace std;  </span><br><span class="line">class Singleton  </span><br><span class="line">&#123;  </span><br><span class="line">  public:  </span><br><span class="line">    Singleton* GetInstance()  </span><br><span class="line">    &#123;  </span><br><span class="line">      return &amp;_instance;  </span><br><span class="line">    &#125;  </span><br><span class="line">  private:  </span><br><span class="line">    //构造函数私有化  </span><br><span class="line">    Singleton()&#123;&#125;  </span><br><span class="line">    Singleton(const Singleton&amp;)&#123;&#125;</span><br><span class="line">    static Singleton _instance;  </span><br><span class="line">&#125;;</span><br><span class="line">Singleton Singleton::_instance;</span><br></pre></td></tr></table></figure></p>
<h4 id="懒汉模式"><a href="#懒汉模式" class="headerlink" title="懒汉模式"></a>懒汉模式</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">class Singleton  </span><br><span class="line">&#123;           </span><br><span class="line">  public:   </span><br><span class="line">  static Singleton* GetInstance()                 </span><br><span class="line">  &#123;</span><br><span class="line">    if(inst == nullptr)//双重判断避免不要的锁竞争</span><br><span class="line">    &#123;</span><br><span class="line">      pthread_mutex_lock(&amp;lock);//加锁保证线程安全</span><br><span class="line">      if(inst == nullptr)</span><br><span class="line">      &#123;                                           </span><br><span class="line">        inst = new Singleton();                   </span><br><span class="line">      &#125;                                           </span><br><span class="line">      pthread_mutex_unlock(&amp;lock);                </span><br><span class="line">    &#125;                                             </span><br><span class="line">    return inst;                                  </span><br><span class="line">  &#125;                                               </span><br><span class="line">  private:                                        </span><br><span class="line">  static Singleton* inst;                         </span><br><span class="line">  static pthread_mutex_t lock;                    </span><br><span class="line">  Singleton()&#123;&#125;                                   </span><br><span class="line">  Singleton(const Singleton&amp;)&#123;&#125;                   </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;懒汉模式就是在第一次使用时才会创建对象，因此我们需要对变量进行判断考虑到线程安全我们需要对其加锁。懒汉模式的坏处是可能造成程序运行卡顿。</p>

          
        
      
    </div>
    
    
    

    

    <div>
    
    </div>

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/05/28/【Cpp】第二章-类和对象-下/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="MisakiFx">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/blog-logo.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Misaki`s blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/05/28/【Cpp】第二章-类和对象-下/" itemprop="url">【Cpp】第二章-类和对象-下</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-05-28T15:09:14+08:00">
                2019-05-28
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Cpp/" itemprop="url" rel="index">
                    <span itemprop="name">Cpp</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  4.5k
                </span>
              

              

              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="类和对象"><a href="#类和对象" class="headerlink" title="类和对象"></a>类和对象</h1><h2 id="初始化列表"><a href="#初始化列表" class="headerlink" title="初始化列表"></a>初始化列表</h2><p>&emsp;&emsp;我们之前想要在类创建时就对类进行初始化时使用构造函数直接在构造函数中对成员变量进行赋值。但是这种方法并非是最好的方法，并且有一些情况比如说常成员函数我们就无法在构造函数中初始化，因此有了新的对成员进行初始化的方法——<strong>初始化列表</strong>。</p>
<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>&emsp;&emsp;初始化列表是和构造函数写在一起的，会在执行成员函数函数体之前优先利用初始化列表对成员变量赋予初值。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using std::cout;</span><br><span class="line">using std::endl;</span><br><span class="line">class A</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">  A(int x = 4, int y = 5):_x(x), _y(y)                                                      </span><br><span class="line">  &#123;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">  int GetX()</span><br><span class="line">  &#123;</span><br><span class="line">    return _x;</span><br><span class="line">  &#125;</span><br><span class="line">  int GetY()</span><br><span class="line">  &#123;</span><br><span class="line">    return _y;</span><br><span class="line">  &#125;</span><br><span class="line">private:</span><br><span class="line">  int _x;</span><br><span class="line">  int _y;</span><br><span class="line">&#125;;</span><br><span class="line">class Test</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">  Test(int a, int&amp; b, int c, A d):_a(a), _b(b), _c(c), _d(d)</span><br><span class="line">  &#123;</span><br><span class="line">    cout &lt;&lt; _a &lt;&lt; &quot;\t&quot; &lt;&lt; _b &lt;&lt; &quot;\t&quot; &lt;&lt; _c &lt;&lt; &quot;\t&quot; &lt;&lt; _d.GetX() &lt;&lt; &quot;\t&quot; &lt;&lt; d.GetY() &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; &quot;building seccess&quot; &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">private:</span><br><span class="line">  const int _a;</span><br><span class="line">  int&amp; _b;</span><br><span class="line">  int _c;</span><br><span class="line">  A _d;</span><br><span class="line">  </span><br><span class="line">&#125;;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">  int b = 2;</span><br><span class="line">  A d;</span><br><span class="line">  Test(1, b, 3, d);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;在初始化列表中进行成员的初始化是最优的，因为对于自定义的类一定会先用初始化列表进行初始化。</p>
<h3 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h3><p>&emsp;&emsp;1、有几种一定需要在初始化列表中才能进行初始化的成员变量：<strong>常成员，引用，没有默认构造函数的自定义类类型成员</strong>。<br><br>&emsp;&emsp;2、类类型成员不论是否在初始化列表中是否显示初始化都会自动在初始化列表中进行构造函数的调用。<br><br>&emsp;&emsp;3、每个成员在初始化列表中只能出现一次。<br><br>&emsp;&emsp;4、初始化顺序与初始化列表无关，只与成员在类中声明先后有关。<br><br>&emsp;&emsp;5、优先在初始化列表中初始化所有成员，尤其是类类型成员。</p>
<h2 id="explicit关键字"><a href="#explicit关键字" class="headerlink" title="explicit关键字"></a>explicit关键字</h2><p>&emsp;&emsp;我们在对对象进行初始化的时候可以进行这样的构造。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;               </span><br><span class="line">using std::cout;</span><br><span class="line">using std::endl;</span><br><span class="line">class A</span><br><span class="line">&#123;       </span><br><span class="line">public:  </span><br><span class="line">  A(int x, int y = 5):_x(x), _y(y)</span><br><span class="line">  &#123;</span><br><span class="line">            </span><br><span class="line">  &#125;</span><br><span class="line">  int GetX()</span><br><span class="line">  &#123;                               </span><br><span class="line">    return _x;</span><br><span class="line">  &#125;                               </span><br><span class="line">  int GetY()                      </span><br><span class="line">  &#123;  </span><br><span class="line">    return _y;</span><br><span class="line">  &#125;              </span><br><span class="line">private:    </span><br><span class="line">  int _x;  </span><br><span class="line">  int _y;</span><br><span class="line">&#125;;  </span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">  A a = 4;//等同A a(4);</span><br><span class="line">  cout &lt;&lt; a.GetX() &lt;&lt; &quot;\t&quot; &lt;&lt; a.GetY() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;这种构造函数的调用仅适用于调用只有一个参数的构造函数，这种情况下可以达到隐式转换的效果。但是如果我们不想支持这种隐式转换呢？我们就可以在构造函数前加上<code>explicit</code>关键字，这样就可以仅用构造函数的隐式转换。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">explicit A(int x, int y = 5):_x(x), _y(y)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[misaki@localhost 第二章-类和对象]$ make</span><br><span class="line">g++ -g Init.cpp -o Init</span><br><span class="line">Init.cpp: 在函数‘int main()’中:</span><br><span class="line">Init.cpp:40:9: 错误：请求从‘int’转换到非标量类型‘A’</span><br><span class="line">   A a = 4;</span><br><span class="line">         ^</span><br><span class="line">make: *** [Init] 错误 1</span><br></pre></td></tr></table></figure></p>
<h2 id="static静态成员"><a href="#static静态成员" class="headerlink" title="static静态成员"></a>static静态成员</h2><h3 id="静态成员变量和静态成员函数"><a href="#静态成员变量和静态成员函数" class="headerlink" title="静态成员变量和静态成员函数"></a>静态成员变量和静态成员函数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class Test</span><br><span class="line">&#123;</span><br><span class="line">  public:</span><br><span class="line">    Test()</span><br><span class="line">    &#123;</span><br><span class="line">      _num++;</span><br><span class="line">    &#125;</span><br><span class="line">    static int GetNum()</span><br><span class="line">    &#123;</span><br><span class="line">      return _num;</span><br><span class="line">    &#125;</span><br><span class="line">  private:</span><br><span class="line">    static int _num;//静态成员变量</span><br><span class="line">&#125;;</span><br><span class="line">int Test::_num = 0;//在类外进行初始化</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">  Test test[4];</span><br><span class="line">  cout &lt;&lt; Test::GetNum() &lt;&lt; endl;//用类+域限定符调用静态成员函数</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[misaki@localhost 第二章-类和对象]$ ./static</span><br><span class="line">4</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;静态成员是属于整个类的成员，同时也是属于所有类的实例化对象的成员，它们在类被定义后即被初始化，静态成员可以被所有的实例化对象操作。<br><br>&emsp;&emsp;以上这个代码我们用静态成计算类的构造函数调用次数。</p>
<h3 id="特性-1"><a href="#特性-1" class="headerlink" title="特性"></a>特性</h3><p>&emsp;&emsp;1、静态成员变量必须在类外进行初始化。<br><br>&emsp;&emsp;2、静态成员函数中不含<code>this</code>指针因此不可以使用非静态成员。<br><br>&emsp;&emsp;3、静态成员属于这个类和所有实例对象因此用类或者对象都可以调用静态成员，前提其是公有。<br><br>&emsp;&emsp;4、非静态成员函数也可以调用静态成员。</p>
<h3 id="static作用"><a href="#static作用" class="headerlink" title="static作用"></a>static作用</h3><p>&emsp;&emsp;这里我们又了解了<code>static</code>的新的作用，我们总结一下<code>static</code>一共有哪些作用。<br>&emsp;&emsp;1、修饰局部变量，改变生命周期。<br><br>&emsp;&emsp;2、修饰全局变量，改变链接属性，使其只在当前文件可见。<br><br>&emsp;&emsp;3、修饰成员函数，将其变为静态，无<code>this</code>指针。<br><br>&emsp;&emsp;4、修饰成员变量，将其变为静态成员变量。</p>
<h2 id="为成员变量设置默认值（C-11）"><a href="#为成员变量设置默认值（C-11）" class="headerlink" title="为成员变量设置默认值（C++11）"></a>为成员变量设置默认值（C++11）</h2><p>&emsp;&emsp;这个语法只有在支持11版本的编译器上才可以使用，这种语法相当于给成员变量设定了默认值，十分类似于参数缺省。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class Test</span><br><span class="line">&#123;</span><br><span class="line">  public:</span><br><span class="line">    Test()&#123;&#125;</span><br><span class="line">    int _a = 1;</span><br><span class="line">    int _b = 2;</span><br><span class="line">&#125;;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">  Test t;</span><br><span class="line">  cout &lt;&lt; t._a &lt;&lt; &quot;\t&quot; &lt;&lt; t._b &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[misaki@localhost 第二章-类和对象]$ ./default</span><br><span class="line">1	2</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;这种设置默认值的语法如果我们并没有在构造函数中给成员变量赋值则会将其赋为这里的默认值。</p>
<h2 id="友元"><a href="#友元" class="headerlink" title="友元"></a>友元</h2><p>&emsp;&emsp;有的时候我们想要在外部使用一个对象的成员变量但是又不想破坏其封装的时候就需要借助友元的语法，如果一个函数或者类是另一个类的友元，则这个函数或者类就可以自由使用另一个类中的私有成员。</p>
<h3 id="友元函数"><a href="#友元函数" class="headerlink" title="友元函数"></a>友元函数</h3><p>&emsp;&emsp;例如我们要书写一个<code>&lt;&lt;</code>的重载函数让其可以按照我们的规则打印类中的成员，这个函数如果写在类中则左操作数永远被我们的类本身占据我们想要让<code>ostream</code>的对象作为左操作数的时候就只能定义在类外，看这样以来就无法访问类中的私有成员，这是我们就可以借助友元。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class Test</span><br><span class="line">&#123;</span><br><span class="line">  //将其声明为友元函数                                         </span><br><span class="line">  friend ostream&amp; operator&lt;&lt;(ostream&amp; _cout, const Test&amp; test);</span><br><span class="line">  private:         </span><br><span class="line">    int _a;        </span><br><span class="line">    int _b;        </span><br><span class="line">  public:                                  </span><br><span class="line">    Test(int a = 1, int b = 2):_a(a), _b(b)</span><br><span class="line">    &#123;              </span><br><span class="line">                   </span><br><span class="line">    &#125;              </span><br><span class="line">&#125;;                                                   </span><br><span class="line">ostream&amp; operator&lt;&lt;(ostream&amp; _cout, const Test&amp; test)</span><br><span class="line">&#123;                                             </span><br><span class="line">  _cout &lt;&lt; test._a &lt;&lt; &quot;\t&quot; &lt;&lt; test._b &lt;&lt; endl;</span><br><span class="line">  return _cout;    </span><br><span class="line">&#125;                  </span><br><span class="line">int main()         </span><br><span class="line">&#123;                  </span><br><span class="line">  Test test;       </span><br><span class="line">  cout &lt;&lt; test;    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[misaki@localhost 第二章-类和对象]$ ./friend</span><br><span class="line">1	2</span><br></pre></td></tr></table></figure></p>
<h3 id="友元类"><a href="#友元类" class="headerlink" title="友元类"></a>友元类</h3><p>&emsp;&emsp;友元类和友元函数一样，一旦一个类是另一个类的友元，他就可以访问其的私有成员。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;                                           </span><br><span class="line">using namespace std;                         </span><br><span class="line">class B;//前置声明                           </span><br><span class="line">class A                                      </span><br><span class="line">&#123;                                            </span><br><span class="line">  //将其声明为友元类                                          </span><br><span class="line">  friend class B;                            </span><br><span class="line">  //将其声明为友元函数                       </span><br><span class="line"> friend  ostream&amp; operator&lt;&lt;(ostream&amp; _cout, const B&amp; test);</span><br><span class="line">  private:                                   </span><br><span class="line">    int _a;                                  </span><br><span class="line">    int _b;                                  </span><br><span class="line">  public:                                    </span><br><span class="line">    A(int a = 1, int b = 2):_a(a), _b(b)     </span><br><span class="line">    &#123;                                        </span><br><span class="line">                                             </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">class B                                           </span><br><span class="line">&#123;</span><br><span class="line">  friend ostream&amp; operator&lt;&lt;(ostream&amp; _cout, const B&amp; test);</span><br><span class="line">  private:                                                    </span><br><span class="line">    int _a;    </span><br><span class="line">    int _b;</span><br><span class="line">    A _classA;</span><br><span class="line">  public:</span><br><span class="line">    B(int a = 3, int b = 4):_a(a), _b(b)</span><br><span class="line">    &#123;       </span><br><span class="line">      //直接访问A类的私有成员</span><br><span class="line">      _classA._a = a;</span><br><span class="line">      _classA._b = b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">ostream&amp; operator&lt;&lt;(ostream&amp; _cout, const B&amp; test)</span><br><span class="line">&#123;</span><br><span class="line">  _cout &lt;&lt; test._a &lt;&lt; &quot;\t&quot; &lt;&lt; test._b &lt;&lt; endl;</span><br><span class="line">  _cout &lt;&lt; test._classA._a &lt;&lt; &quot;\t&quot; &lt;&lt; test._classA._b &lt;&lt; endl;</span><br><span class="line">  return _cout;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">  B b;</span><br><span class="line">  cout &lt;&lt; b;</span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[misaki@localhost 第二章-类和对象]$ ./friend</span><br><span class="line">3	4</span><br><span class="line">3	4</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;以上这个例子综合使用了友元类和友元函数，友元类让B可以随意访问A的成员，但是要注意友元的关系是单向的，B是A的友元，但是A并不是B的友元，因此A不能访问B的成员。</p>
<h2 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h2><p>&emsp;&emsp;内部类是在一个类内部所定义的类。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;                                         </span><br><span class="line">using namespace std;</span><br><span class="line">class A            </span><br><span class="line">&#123;        </span><br><span class="line">  private:                              </span><br><span class="line">    int _a;</span><br><span class="line">    int _b; </span><br><span class="line">    static int num;</span><br><span class="line">  public:   </span><br><span class="line">    A(int a = 1, int b = 2):_a(a), _b(b)</span><br><span class="line">    &#123;</span><br><span class="line">      num++;  </span><br><span class="line">    &#125;          </span><br><span class="line">    //内部类   </span><br><span class="line">    class B  </span><br><span class="line">    &#123;                                       </span><br><span class="line">      private:</span><br><span class="line">        int _a;</span><br><span class="line">        int _b;</span><br><span class="line">      public:              </span><br><span class="line">        B(int a = 3, int b = 4):_a(a), _b(b)</span><br><span class="line">        &#123;                                                </span><br><span class="line"></span><br><span class="line">        &#125;                     </span><br><span class="line">        void Test(A classA)</span><br><span class="line">        &#123;</span><br><span class="line">          cout &lt;&lt; classA._a &lt;&lt; &quot;\t&quot; &lt;&lt; classA._b &lt;&lt; endl;</span><br><span class="line">          cout &lt;&lt; _a &lt;&lt; &quot;\t&quot; &lt;&lt; _b &lt;&lt; endl;</span><br><span class="line">          cout &lt;&lt; num &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br><span class="line">int A::num = 0;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">  A::B b;//内部类的实例化</span><br><span class="line">  A a;</span><br><span class="line">  b.Test(a);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">[misaki@localhost 第二章-类和对象]$ ./insideclass</span><br><span class="line">1	2</span><br><span class="line">3	4</span><br><span class="line">1</span><br></pre></td></tr></table></figure></p>
<h3 id="特性-2"><a href="#特性-2" class="headerlink" title="特性"></a>特性</h3><p>&emsp;&emsp;1、内部类是外部类的友元类。<br><br>&emsp;&emsp;2、外部类与内部类独立，不能用外部类访问内部类。<br><br>&emsp;&emsp;3、对外部类取大小与内部类无关<br><br>&emsp;&emsp;4、内部类可以不用加访问限定符就可以访问外部类的静态、枚举成员。# 类和对象</p>
<h2 id="初始化列表-1"><a href="#初始化列表-1" class="headerlink" title="初始化列表"></a>初始化列表</h2><p>&emsp;&emsp;我们之前想要在类创建时就对类进行初始化时使用构造函数直接在构造函数中对成员变量进行赋值。但是这种方法并非是最好的方法，并且有一些情况比如说常成员函数我们就无法在构造函数中初始化，因此有了新的对成员进行初始化的方法——<strong>初始化列表</strong>。</p>
<h3 id="使用-1"><a href="#使用-1" class="headerlink" title="使用"></a>使用</h3><p>&emsp;&emsp;初始化列表是和构造函数写在一起的，会在执行成员函数函数体之前优先利用初始化列表对成员变量赋予初值。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using std::cout;</span><br><span class="line">using std::endl;</span><br><span class="line">class A</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">  A(int x = 4, int y = 5):_x(x), _y(y)                                                      </span><br><span class="line">  &#123;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">  int GetX()</span><br><span class="line">  &#123;</span><br><span class="line">    return _x;</span><br><span class="line">  &#125;</span><br><span class="line">  int GetY()</span><br><span class="line">  &#123;</span><br><span class="line">    return _y;</span><br><span class="line">  &#125;</span><br><span class="line">private:</span><br><span class="line">  int _x;</span><br><span class="line">  int _y;</span><br><span class="line">&#125;;</span><br><span class="line">class Test</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">  Test(int a, int&amp; b, int c, A d):_a(a), _b(b), _c(c), _d(d)</span><br><span class="line">  &#123;</span><br><span class="line">    cout &lt;&lt; _a &lt;&lt; &quot;\t&quot; &lt;&lt; _b &lt;&lt; &quot;\t&quot; &lt;&lt; _c &lt;&lt; &quot;\t&quot; &lt;&lt; _d.GetX() &lt;&lt; &quot;\t&quot; &lt;&lt; d.GetY() &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; &quot;building seccess&quot; &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">private:</span><br><span class="line">  const int _a;</span><br><span class="line">  int&amp; _b;</span><br><span class="line">  int _c;</span><br><span class="line">  A _d;</span><br><span class="line">  </span><br><span class="line">&#125;;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">  int b = 2;</span><br><span class="line">  A d;</span><br><span class="line">  Test(1, b, 3, d);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;在初始化列表中进行成员的初始化是最优的，因为对于自定义的类一定会先用初始化列表进行初始化。</p>
<h3 id="特性-3"><a href="#特性-3" class="headerlink" title="特性"></a>特性</h3><p>&emsp;&emsp;1、有几种一定需要在初始化列表中才能进行初始化的成员变量：<strong>常成员，引用，没有默认构造函数的自定义类类型成员</strong>。<br><br>&emsp;&emsp;2、类类型成员不论是否在初始化列表中是否显示初始化都会自动在初始化列表中进行构造函数的调用。<br><br>&emsp;&emsp;3、每个成员在初始化列表中只能出现一次。<br><br>&emsp;&emsp;4、初始化顺序与初始化列表无关，只与成员在类中声明先后有关。<br><br>&emsp;&emsp;5、优先在初始化列表中初始化所有成员，尤其是类类型成员。</p>
<h2 id="explicit关键字-1"><a href="#explicit关键字-1" class="headerlink" title="explicit关键字"></a>explicit关键字</h2><p>&emsp;&emsp;我们在对对象进行初始化的时候可以进行这样的构造。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;               </span><br><span class="line">using std::cout;</span><br><span class="line">using std::endl;</span><br><span class="line">class A</span><br><span class="line">&#123;       </span><br><span class="line">public:  </span><br><span class="line">  A(int x, int y = 5):_x(x), _y(y)</span><br><span class="line">  &#123;</span><br><span class="line">            </span><br><span class="line">  &#125;</span><br><span class="line">  int GetX()</span><br><span class="line">  &#123;                               </span><br><span class="line">    return _x;</span><br><span class="line">  &#125;                               </span><br><span class="line">  int GetY()                      </span><br><span class="line">  &#123;  </span><br><span class="line">    return _y;</span><br><span class="line">  &#125;              </span><br><span class="line">private:    </span><br><span class="line">  int _x;  </span><br><span class="line">  int _y;</span><br><span class="line">&#125;;  </span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">  A a = 4;//等同A a(4);</span><br><span class="line">  cout &lt;&lt; a.GetX() &lt;&lt; &quot;\t&quot; &lt;&lt; a.GetY() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;这种构造函数的调用仅适用于调用只有一个参数的构造函数，这种情况下可以达到隐式转换的效果。但是如果我们不想支持这种隐式转换呢？我们就可以在构造函数前加上<code>explicit</code>关键字，这样就可以禁用单参数构造函数的隐式类型转换。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">explicit A(int x, int y = 5):_x(x), _y(y)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[misaki@localhost 第二章-类和对象]$ make</span><br><span class="line">g++ -g Init.cpp -o Init</span><br><span class="line">Init.cpp: 在函数‘int main()’中:</span><br><span class="line">Init.cpp:40:9: 错误：请求从‘int’转换到非标量类型‘A’</span><br><span class="line">   A a = 4;</span><br><span class="line">         ^</span><br><span class="line">make: *** [Init] 错误 1</span><br></pre></td></tr></table></figure></p>
<h2 id="static静态成员-1"><a href="#static静态成员-1" class="headerlink" title="static静态成员"></a>static静态成员</h2><h3 id="静态成员变量和静态成员函数-1"><a href="#静态成员变量和静态成员函数-1" class="headerlink" title="静态成员变量和静态成员函数"></a>静态成员变量和静态成员函数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class Test</span><br><span class="line">&#123;</span><br><span class="line">  public:</span><br><span class="line">    Test()</span><br><span class="line">    &#123;</span><br><span class="line">      _num++;</span><br><span class="line">    &#125;</span><br><span class="line">    static int GetNum()</span><br><span class="line">    &#123;</span><br><span class="line">      return _num;</span><br><span class="line">    &#125;</span><br><span class="line">  private:</span><br><span class="line">    static int _num;//静态成员变量</span><br><span class="line">&#125;;</span><br><span class="line">int Test::_num = 0;//在类外进行初始化</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">  Test test[4];</span><br><span class="line">  cout &lt;&lt; Test::GetNum() &lt;&lt; endl;//用类+域限定符调用静态成员函数</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[misaki@localhost 第二章-类和对象]$ ./static</span><br><span class="line">4</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;静态成员是属于整个类的成员，同时也是属于所有类的实例化对象的成员，它们在类被定义后即被初始化，静态成员可以被所有的实例化对象操作。<br><br>&emsp;&emsp;以上这个代码我们用静态成计算类的构造函数调用次数。</p>
<h3 id="特性-4"><a href="#特性-4" class="headerlink" title="特性"></a>特性</h3><p>&emsp;&emsp;1、静态成员变量必须在类外进行初始化。<br><br>&emsp;&emsp;2、静态成员函数中不含<code>this</code>指针因此不可以使用非静态成员。<br><br>&emsp;&emsp;3、静态成员属于这个类和所有实例对象因此用类或者对象都可以调用静态成员，前提其是公有。<br><br>&emsp;&emsp;4、非静态成员函数也可以调用静态成员。</p>
<h3 id="static作用-1"><a href="#static作用-1" class="headerlink" title="static作用"></a>static作用</h3><p>&emsp;&emsp;这里我们又了解了<code>static</code>的新的作用，我们总结一下<code>static</code>一共有哪些作用。<br>&emsp;&emsp;1、修饰局部变量，改变生命周期。<br><br>&emsp;&emsp;2、修饰全局变量，改变链接属性，使其只在当前文件可见。<br><br>&emsp;&emsp;3、修饰成员函数，将其变为静态，无<code>this</code>指针。<br><br>&emsp;&emsp;4、修饰成员变量，将其变为静态成员变量。</p>
<h2 id="为成员变量设置默认值（C-11）-1"><a href="#为成员变量设置默认值（C-11）-1" class="headerlink" title="为成员变量设置默认值（C++11）"></a>为成员变量设置默认值（C++11）</h2><p>&emsp;&emsp;这个语法只有在支持11版本的编译器上才可以使用，这种语法相当于给成员变量设定了默认值，十分类似于参数缺省。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class Test</span><br><span class="line">&#123;</span><br><span class="line">  public:</span><br><span class="line">    Test()&#123;&#125;</span><br><span class="line">    int _a = 1;</span><br><span class="line">    int _b = 2;</span><br><span class="line">&#125;;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">  Test t;</span><br><span class="line">  cout &lt;&lt; t._a &lt;&lt; &quot;\t&quot; &lt;&lt; t._b &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[misaki@localhost 第二章-类和对象]$ ./default</span><br><span class="line">1	2</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;这种设置默认值的语法如果我们并没有在构造函数中给成员变量赋值则会将其赋为这里的默认值。</p>
<h2 id="友元-1"><a href="#友元-1" class="headerlink" title="友元"></a>友元</h2><p>&emsp;&emsp;有的时候我们想要在外部使用一个对象的成员变量但是又不想破坏其封装的时候就需要借助友元的语法，如果一个函数或者类是另一个类的友元，则这个函数或者类就可以自由使用另一个类中的私有成员。</p>
<h3 id="友元函数-1"><a href="#友元函数-1" class="headerlink" title="友元函数"></a>友元函数</h3><p>&emsp;&emsp;例如我们要书写一个<code>&lt;&lt;</code>的重载函数让其可以按照我们的规则打印类中的成员，这个函数如果写在类中则左操作数永远被我们的类本身占据我们想要让<code>ostream</code>的对象作为左操作数的时候就只能定义在类外，看这样以来就无法访问类中的私有成员，这是我们就可以借助友元。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class Test</span><br><span class="line">&#123;</span><br><span class="line">  //将其声明为友元函数                                         </span><br><span class="line">  friend ostream&amp; operator&lt;&lt;(ostream&amp; _cout, const Test&amp; test);</span><br><span class="line">  private:         </span><br><span class="line">    int _a;        </span><br><span class="line">    int _b;        </span><br><span class="line">  public:                                  </span><br><span class="line">    Test(int a = 1, int b = 2):_a(a), _b(b)</span><br><span class="line">    &#123;              </span><br><span class="line">                   </span><br><span class="line">    &#125;              </span><br><span class="line">&#125;;                                                   </span><br><span class="line">ostream&amp; operator&lt;&lt;(ostream&amp; _cout, const Test&amp; test)</span><br><span class="line">&#123;                                             </span><br><span class="line">  _cout &lt;&lt; test._a &lt;&lt; &quot;\t&quot; &lt;&lt; test._b &lt;&lt; endl;</span><br><span class="line">  return _cout;    </span><br><span class="line">&#125;                  </span><br><span class="line">int main()         </span><br><span class="line">&#123;                  </span><br><span class="line">  Test test;       </span><br><span class="line">  cout &lt;&lt; test;    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[misaki@localhost 第二章-类和对象]$ ./friend</span><br><span class="line">1	2</span><br></pre></td></tr></table></figure></p>
<h3 id="友元类-1"><a href="#友元类-1" class="headerlink" title="友元类"></a>友元类</h3><p>&emsp;&emsp;友元类和友元函数一样，一旦一个类是另一个类的友元，他就可以访问其的私有成员。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;                                           </span><br><span class="line">using namespace std;                         </span><br><span class="line">class B;//前置声明                           </span><br><span class="line">class A                                      </span><br><span class="line">&#123;                                            </span><br><span class="line">  //将其声明为友元类                                          </span><br><span class="line">  friend class B;                            </span><br><span class="line">  //将其声明为友元函数                       </span><br><span class="line"> friend  ostream&amp; operator&lt;&lt;(ostream&amp; _cout, const B&amp; test);</span><br><span class="line">  private:                                   </span><br><span class="line">    int _a;                                  </span><br><span class="line">    int _b;                                  </span><br><span class="line">  public:                                    </span><br><span class="line">    A(int a = 1, int b = 2):_a(a), _b(b)     </span><br><span class="line">    &#123;                                        </span><br><span class="line">                                             </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">class B                                           </span><br><span class="line">&#123;</span><br><span class="line">  friend ostream&amp; operator&lt;&lt;(ostream&amp; _cout, const B&amp; test);</span><br><span class="line">  private:                                                    </span><br><span class="line">    int _a;    </span><br><span class="line">    int _b;</span><br><span class="line">    A _classA;</span><br><span class="line">  public:</span><br><span class="line">    B(int a = 3, int b = 4):_a(a), _b(b)</span><br><span class="line">    &#123;       </span><br><span class="line">      //直接访问A类的私有成员</span><br><span class="line">      _classA._a = a;</span><br><span class="line">      _classA._b = b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">ostream&amp; operator&lt;&lt;(ostream&amp; _cout, const B&amp; test)</span><br><span class="line">&#123;</span><br><span class="line">  _cout &lt;&lt; test._a &lt;&lt; &quot;\t&quot; &lt;&lt; test._b &lt;&lt; endl;</span><br><span class="line">  _cout &lt;&lt; test._classA._a &lt;&lt; &quot;\t&quot; &lt;&lt; test._classA._b &lt;&lt; endl;</span><br><span class="line">  return _cout;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">  B b;</span><br><span class="line">  cout &lt;&lt; b;</span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[misaki@localhost 第二章-类和对象]$ ./friend</span><br><span class="line">3	4</span><br><span class="line">3	4</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;以上这个例子综合使用了友元类和友元函数，友元类让B可以随意访问A的成员，但是要注意友元的关系是单向的，B是A的友元，但是A并不是B的友元，因此A不能访问B的成员。</p>
<h2 id="内部类-1"><a href="#内部类-1" class="headerlink" title="内部类"></a>内部类</h2><p>&emsp;&emsp;内部类是在一个类内部所定义的类。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;                                         </span><br><span class="line">using namespace std;</span><br><span class="line">class A            </span><br><span class="line">&#123;        </span><br><span class="line">  private:                              </span><br><span class="line">    int _a;</span><br><span class="line">    int _b; </span><br><span class="line">    static int num;</span><br><span class="line">  public:   </span><br><span class="line">    A(int a = 1, int b = 2):_a(a), _b(b)</span><br><span class="line">    &#123;</span><br><span class="line">      num++;  </span><br><span class="line">    &#125;          </span><br><span class="line">    //内部类   </span><br><span class="line">    class B  </span><br><span class="line">    &#123;                                       </span><br><span class="line">      private:</span><br><span class="line">        int _a;</span><br><span class="line">        int _b;</span><br><span class="line">      public:              </span><br><span class="line">        B(int a = 3, int b = 4):_a(a), _b(b)</span><br><span class="line">        &#123;                                                </span><br><span class="line"></span><br><span class="line">        &#125;                     </span><br><span class="line">        void Test(A classA)</span><br><span class="line">        &#123;</span><br><span class="line">          cout &lt;&lt; classA._a &lt;&lt; &quot;\t&quot; &lt;&lt; classA._b &lt;&lt; endl;</span><br><span class="line">          cout &lt;&lt; _a &lt;&lt; &quot;\t&quot; &lt;&lt; _b &lt;&lt; endl;</span><br><span class="line">          cout &lt;&lt; num &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br><span class="line">int A::num = 0;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">  A::B b;//内部类的实例化</span><br><span class="line">  A a;</span><br><span class="line">  b.Test(a);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">[misaki@localhost 第二章-类和对象]$ ./insideclass</span><br><span class="line">1	2</span><br><span class="line">3	4</span><br><span class="line">1</span><br></pre></td></tr></table></figure></p>
<h3 id="特性-5"><a href="#特性-5" class="headerlink" title="特性"></a>特性</h3><p>&emsp;&emsp;1、内部类是外部类的友元类。<br><br>&emsp;&emsp;2、外部类与内部类独立，不能用外部类访问内部类。<br><br>&emsp;&emsp;3、对外部类取大小与内部类无关<br><br>&emsp;&emsp;4、内部类可以不用加访问限定符就可以访问外部类的静态、枚举成员。</p>

          
        
      
    </div>
    
    
    

    

    <div>
    
    </div>

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/05/19/【Linux】第八章-多线程/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="MisakiFx">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/blog-logo.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Misaki`s blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/05/19/【Linux】第八章-多线程/" itemprop="url">【Linux】第八章-多线程</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-05-19T15:13:07+08:00">
                2019-05-19
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Linux/" itemprop="url" rel="index">
                    <span itemprop="name">Linux</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  4k
                </span>
              

              

              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="第八章-多线程"><a href="#第八章-多线程" class="headerlink" title="第八章 多线程"></a>第八章 多线程</h1><h2 id="线程概念"><a href="#线程概念" class="headerlink" title="线程概念"></a>线程概念</h2><p>&emsp;&emsp;多进程任务处理是同时通过多个进程进行任务，多个pcb拥有多个虚拟地址空间，分别执行不同的代码，之间互不关联。而多线程是通过多个pcb共用一个虚拟地址空间，分别执行虚拟地址空间上所对应的多个不同的物理内存中的代码。即一个虚拟地址空间对应多个物理内存。<br><br>&emsp;&emsp;之前我们说linux下pcb是一个进程，但其实linux下线程以进程pcb模拟实现线程，因此linux下pcb是线程；因此linux线程也叫轻量级进程。一个进程可能拥有多个线程，而每个进程势必有一个主线程，我们在主线程中创建其他线程。那么一个进程可以理解为一堆线程的集合，我们称其位线程组，而进程的pid为了不冲突则规定是主线程的pid。<br><br>&emsp;&emsp;因为linux线程是pcb——因此线程是cpu的基本单位。因为进程是线程组，程序运行起来，资源是分配给整个线程组的，因此进程是资源分配的基本单位。</p>
<h3 id="进程与线程的对比"><a href="#进程与线程的对比" class="headerlink" title="进程与线程的对比"></a>进程与线程的对比</h3><p>&emsp;&emsp;一个进程中的线程共用同一个虚拟地址空间，因此线程间通信更加方便；线程的创建/销毁成本更低；线程间切换调度成本更低；线程的执行粒度更细。<br><br>&emsp;&emsp;线程之间缺乏访问控制——系统调用，异常针对的是整个进程，健壮性低。<br><br>&emsp;&emsp;<code>vfork</code>创建一个子进程共用同一个虚拟地址空间，怕出现调用栈混乱，因此子进程运行完毕或程序替换后父进程才开始运行。而线程也共用同一个虚拟地址空间却不会发生调用栈混乱的情况，因为每个线程都会有一些独立的信息，会为每个线程在虚拟地址空间中单独分配一块内存用来存储这些独立的信息：<strong>栈，寄存器，errno，信号屏蔽字，调度优先级</strong>。同时线程间也有共享的数据：<strong>代码段，数据段，文件描述符表，信号处理方式，用户和组，当前工作目录</strong>。</p>
<h3 id="多进程-多线程进行多任务处理的优势体现与细节"><a href="#多进程-多线程进行多任务处理的优势体现与细节" class="headerlink" title="多进程/多线程进行多任务处理的优势体现与细节"></a>多进程/多线程进行多任务处理的优势体现与细节</h3><h4 id="cpu密集型程序"><a href="#cpu密集型程序" class="headerlink" title="cpu密集型程序"></a>cpu密集型程序</h4><p>&emsp;&emsp;对于读写操作比较少，更多的则是计算方面的操作，这类程序尽量少用多线程/进程，因为cpu调度线程/进程会浪费cpu资源。</p>
<h4 id="io密集型程序"><a href="#io密集型程序" class="headerlink" title="io密集型程序"></a>io密集型程序</h4><p>&emsp;&emsp;对于读写操作较多，cpu计算操作较少的程序则应该多使用多进程/线程进行io操作，由此来并行执行程序，减少执行时间。</p>
<h2 id="线程控制"><a href="#线程控制" class="headerlink" title="线程控制"></a>线程控制</h2><h3 id="线程创建"><a href="#线程创建" class="headerlink" title="线程创建"></a>线程创建</h3><p>&emsp;&emsp;操作系统并没有为用户提供直接创建线程的系统调用接口，但是有人自己封装了一套线程库实现线程控制。<br></p>
<h4 id="pthread-create"><a href="#pthread-create" class="headerlink" title="pthread_create"></a>pthread_create</h4><p>&emsp;&emsp;由于<code>pthread_create</code>所在的库<code>pthread</code>并不在gcc默认的链接库中，因此我们在编译时要加参数<code>-pthread</code>或者<code>-lpthread</code>让其连接到这个库中。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 线程创建</span><br><span class="line"> **/</span><br><span class="line">/**</span><br><span class="line"> * int pthread_create(pthread_t *thread, const pthread_attr_t *attr,</span><br><span class="line"> *        void *(*start_routine) (void *), void *arg);</span><br><span class="line"> * thread:输出型参数，获取新创建的线程id</span><br><span class="line"> * attr:  设置线程属性，通常置空</span><br><span class="line"> * start_routine:  线程入口函数</span><br><span class="line"> * arg:通过线程入口函数传递给线程的参数</span><br><span class="line"> **/</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;errno.h&gt;</span><br><span class="line">#include &lt;pthread.h&gt;</span><br><span class="line">void* thr_start(void* arg)</span><br><span class="line">&#123;</span><br><span class="line">  while(1)</span><br><span class="line">  &#123;</span><br><span class="line">    //pthread_self查看此线程的tid</span><br><span class="line">    printf(&quot;i am child---%d\n&quot;,pthread_self());                           </span><br><span class="line">    sleep(1);</span><br><span class="line">  &#125;</span><br><span class="line">  return NULL;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">  pthread_t tid;</span><br><span class="line">      int ret = pthread_create(&amp;tid, NULL, thr_start, (void*)&quot;Misaki&quot;);</span><br><span class="line">  printf(&quot;%d\n&quot;,tid);</span><br><span class="line">  if(ret != 0)//0为成功</span><br><span class="line">  &#123;</span><br><span class="line">    printf(&quot;thread vreate errno!\n&quot;);</span><br><span class="line">    return -1;</span><br><span class="line">  &#125;</span><br><span class="line">  while(1)</span><br><span class="line">  &#123;</span><br><span class="line">    //thread_self查看自己的进程id</span><br><span class="line">    printf(&quot;Misaki!%d\n&quot;,getpid());</span><br><span class="line">    sleep(1);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">[misaki@localhost 第八章-多线程]$ ./create</span><br><span class="line">-1544186112</span><br><span class="line">Misaki!5429</span><br><span class="line">i am child----1544186112</span><br><span class="line">i am child----1544186112</span><br><span class="line">Misaki!5429</span><br><span class="line">i am child----1544186112</span><br><span class="line">Misaki!5429</span><br><span class="line">i am child----1544186112</span><br><span class="line">Misaki!5429</span><br><span class="line">i am child----1544186112</span><br><span class="line">Misaki!5429</span><br><span class="line">i am child----1544186112</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;这个创建线程的函数中的返回值<code>tid</code>为线程在虚拟地址空间上所分配的属于自己的独立空间的首地址，我们以后要靠这个参数来控制线程。一个<code>tid</code>唯一的表示一个线程。<br></p>
<h3 id="线程终止"><a href="#线程终止" class="headerlink" title="线程终止"></a>线程终止</h3><h4 id="在线程入口函数中return"><a href="#在线程入口函数中return" class="headerlink" title="在线程入口函数中return"></a>在线程入口函数中return</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;errno.h&gt;</span><br><span class="line">#include &lt;pthread.h&gt;</span><br><span class="line">void* thr_start(void* arg)</span><br><span class="line">&#123;</span><br><span class="line">  while(1)</span><br><span class="line">  &#123;</span><br><span class="line">      printf(&quot;i am child\n&quot;);</span><br><span class="line">      reutrn NULL;</span><br><span class="line">  &#125;</span><br><span class="line">  return NULL;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">  pthread_t tid;</span><br><span class="line">  int ret = pthread_create(&amp;tid, NULL, thr_start, (void*)&quot;Misaki&quot;);</span><br><span class="line">  printf(&quot;%d\n&quot;,tid);</span><br><span class="line">  if(ret != 0)</span><br><span class="line">  &#123;</span><br><span class="line">    printf(&quot;thread vreate errno!\n&quot;);</span><br><span class="line">    return -1;</span><br><span class="line">  &#125;</span><br><span class="line">  while(1)</span><br><span class="line">  &#123;</span><br><span class="line">    //thread_self查看自己的进程id</span><br><span class="line">    printf(&quot;Misaki!%d\n&quot;,getpid());</span><br><span class="line">    sleep(1);</span><br><span class="line">    return 0;                                                      </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">[misaki@localhost 第八章-多线程]$ ./exit</span><br><span class="line">2052687616</span><br><span class="line">Misaki!5710</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;在线程入口函数中<code>return</code>会让线程退出。当在主函数中使用<code>return</code>退出主函数的时候这时会导致进程终止，由此进程中的所有线程都会终止。<br></p>
<h4 id="pthread-exit"><a href="#pthread-exit" class="headerlink" title="pthread_exit()"></a>pthread_exit()</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;pthread.h&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line"></span><br><span class="line">void* thr_start(void* arg)</span><br><span class="line">&#123;</span><br><span class="line">  while(1)</span><br><span class="line">  &#123;</span><br><span class="line">    printf(&quot;i am child---%s\n&quot;, arg);</span><br><span class="line">    sleep(1);</span><br><span class="line">    //退出调用这个函数的进程         </span><br><span class="line">    pthread_exit(0);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return NULL;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">  pthread_t tid;</span><br><span class="line">  int ret = pthread_create(&amp;tid, NULL, thr_start, (void*)&quot;Misaki&quot;);</span><br><span class="line">  while(1)</span><br><span class="line">  &#123;</span><br><span class="line">    printf(&quot;i am main!\n&quot;);</span><br><span class="line">    sleep(1);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[misaki@localhost 第八章-多线程]$ ./exit</span><br><span class="line">i am main!</span><br><span class="line">i am child---Misaki</span><br><span class="line">i am main!</span><br><span class="line">i am main!</span><br><span class="line">i am main!</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;可以看出我们自己创建的线程在执行<code>pthread_exit()</code>后退出了。如果我们的主线程调用这个函数会怎样呢？<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;pthread.h&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line"></span><br><span class="line">void* thr_start(void* arg)</span><br><span class="line">&#123;</span><br><span class="line">  while(1)</span><br><span class="line">  &#123;</span><br><span class="line">    printf(&quot;i am child---%s\n&quot;, arg);</span><br><span class="line">    sleep(1);</span><br><span class="line">  &#125;</span><br><span class="line">  return NULL;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">  pthread_t tid;</span><br><span class="line">  int ret = pthread_create(&amp;tid, NULL, thr_start, (void*)&quot;Misaki&quot;);</span><br><span class="line">  if(ret != 0)                      </span><br><span class="line">  &#123;             </span><br><span class="line">    printf(&quot;thread create error\n&quot;);</span><br><span class="line">    return -1;</span><br><span class="line">  &#125;</span><br><span class="line">  while(1)</span><br><span class="line">  &#123;</span><br><span class="line">    printf(&quot;i am main!\n&quot;);</span><br><span class="line">    sleep(1);</span><br><span class="line">    //退出调用这个函数的进程                                       </span><br><span class="line">    pthread_exit(0);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[misaki@localhost 第八章-多线程]$ ./exit</span><br><span class="line">i am main!</span><br><span class="line">i am child---Misaki</span><br><span class="line">i am child---Misaki</span><br><span class="line">i am child---Misaki</span><br><span class="line">i am child---Misaki</span><br><span class="line">i am child---Misaki</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;可以看出我们虽然在主线程中调用了退出函数，主线程也确实退出了，但是进程却并没有退出，这说明，<strong>主线程终止并不会让进程终止</strong>。但是我们要注意线程退出也会成为僵尸线程，但是普通线程退出并不会有过于明显大的影响。</p>
<h4 id="pthread-cancel"><a href="#pthread-cancel" class="headerlink" title="pthread_cancel"></a>pthread_cancel</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;pthread.h&gt;                                               </span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line"></span><br><span class="line">void* thr_start(void* arg)</span><br><span class="line">&#123;</span><br><span class="line">  while(1)</span><br><span class="line">  &#123;</span><br><span class="line">    printf(&quot;i am child---%s\n&quot;, arg);</span><br><span class="line">    sleep(1);</span><br><span class="line">  &#125;</span><br><span class="line">  return NULL;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">  pthread_t tid;</span><br><span class="line">  int ret = pthread_create(&amp;tid, NULL, thr_start, (void*)&quot;Misaki&quot;);</span><br><span class="line">  if(ret != 0)</span><br><span class="line">  &#123;</span><br><span class="line">    printf(&quot;thread create error\n&quot;);</span><br><span class="line">    return -1;</span><br><span class="line">  &#125;</span><br><span class="line">  while(1)</span><br><span class="line">  &#123;</span><br><span class="line">    printf(&quot;i am main!\n&quot;);</span><br><span class="line">    sleep(1);</span><br><span class="line">    //退出id = tid的进程</span><br><span class="line">    pthread_cancel(tid);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;                       </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[misaki@localhost 第八章-多线程]$ ./exit</span><br><span class="line">i am main!</span><br><span class="line">i am child---Misaki</span><br><span class="line">i am child---Misaki</span><br><span class="line">i am main!</span><br><span class="line">i am main!</span><br><span class="line">i am main!</span><br></pre></td></tr></table></figure>
<h3 id="线程等待"><a href="#线程等待" class="headerlink" title="线程等待"></a>线程等待</h3><p>&emsp;&emsp;获取指定线程的返回值，因为一个线程运行起来，默认有一个属性：<code>joinable</code>。这个属性决定了线程退出后，必须被等待，否则线程资源无法完全释放，成为僵尸线程，因此我们必须进行线程等待，获取线程返回值，允许系统释放资源。因此线程等待有一个前提，线程能够被等待。</p>
<h4 id="pthread-join"><a href="#pthread-join" class="headerlink" title="pthread_join()"></a>pthread_join()</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * int pthread_join(pthread_t thread, void **retval);</span><br><span class="line"> * 线程等待，获取线程退出返回值。</span><br><span class="line"> * thread:要等待的线程id</span><br><span class="line"> * retval:输出型参数，用于获取退出线程的返回值</span><br><span class="line"> **/</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;pthread.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">void* thr_start(void* arg)</span><br><span class="line">&#123;</span><br><span class="line">  sleep(3);</span><br><span class="line">  return (void*)&quot;Misaki&quot;;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">  pthread_t tid;</span><br><span class="line">  int ret = pthread_create(&amp;tid, NULL, thr_start, NULL);</span><br><span class="line">  if(ret != 0)</span><br><span class="line">  &#123;</span><br><span class="line">    printf(&quot;thread create error\n&quot;);</span><br><span class="line">    return -1;</span><br><span class="line">  &#125;</span><br><span class="line">  char* ptr;</span><br><span class="line">  pthread_join(tid, (void**)&amp;ptr);</span><br><span class="line">  printf(&quot;%s\n&quot;, ptr);                                </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[misaki@localhost 第八章-多线程]$ ./join</span><br><span class="line">Misaki</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;如果一个线程是被取消，则返回值是一个宏：<code>PTHREAD_CANCELED</code>，它的值是-1。</p>
<h3 id="线程分离"><a href="#线程分离" class="headerlink" title="线程分离"></a>线程分离</h3><p>&emsp;&emsp;将线程的一个属性从<code>joinable</code>设置为<code>detach</code>属性。属于<code>detach</code>属性的线程，推出后资源直接自动被回收，这类线程不能被等待。</p>
<h4 id="pthread-detach"><a href="#pthread-detach" class="headerlink" title="pthread_detach()"></a>pthread_detach()</h4><p>&emsp;&emsp;如果用户对一个线程的返回值不关心，则可以在线程入口函数对线程进行分离。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">/**                                                            </span><br><span class="line"> * int pthread_detach(pthread_t thread);</span><br><span class="line"> * 线程分离。</span><br><span class="line"> * thread:要分离的线程id</span><br><span class="line"> **/                </span><br><span class="line">#include &lt;stdio.h&gt;                                          </span><br><span class="line">#include &lt;stdlib.h&gt;                </span><br><span class="line">#include &lt;pthread.h&gt;     </span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;errno.h&gt;</span><br><span class="line">void* thr_start(void* arg)</span><br><span class="line">&#123;               </span><br><span class="line"></span><br><span class="line">  //分离自己这个线程</span><br><span class="line">  //线程的分离对于一个线程来说，任意线程在任意位置调用都可以</span><br><span class="line"> // pthread_detach(pthread_self());</span><br><span class="line">  return (void*)&quot;Misaki&quot;;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">  pthread_t tid;</span><br><span class="line">  int ret = pthread_create(&amp;tid, NULL, thr_start, NULL);</span><br><span class="line">  //分离这个线程</span><br><span class="line">  pthread_detach(tid);</span><br><span class="line">  if(ret != 0)      </span><br><span class="line">  &#123;                                 </span><br><span class="line">    printf(&quot;thread create error\n&quot;);</span><br><span class="line">    return -1;      </span><br><span class="line">  &#125;</span><br><span class="line">  char* ptr;</span><br><span class="line">  ret = pthread_join(tid, (void**)&amp;ptr);</span><br><span class="line">  //如果一个进程无法被等待则返回值为一个宏EINVAL</span><br><span class="line">  if(ret == EINVAL)</span><br><span class="line">  &#123;</span><br><span class="line">    printf(&quot;this thread can not be wait!!\n&quot;);</span><br><span class="line">    return -1;</span><br><span class="line">  &#125;</span><br><span class="line">  printf(&quot;%s\t%d\n&quot;, ptr, ret);</span><br><span class="line">&#125;                                               </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[misaki@localhost 第八章-多线程]$ ./join</span><br><span class="line">this thread can not be wait!!</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;会发现我们已经分离了我们自己创建的线程，这个线程已经无法被等待了，并且我们无法接收到线程的返回值。</p>
<h2 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h2><p>&emsp;&emsp;多个线程同时操作临界资源而不会出现数据二义性就说这个线程是安全的。如果在线程中进行了非原子性操作就可能会导致线程不安全，这些非原子性操作也叫做不可重入函数，即多个执行流中同时进入函数运行会出现问题的函数。<br><br>&emsp;&emsp;如何实现线程安全？这就要靠<strong>同步与互斥</strong>。同步指临界资源的合理访问，互斥指临界资源同一时间唯一访问。</p>
<h3 id="互斥"><a href="#互斥" class="headerlink" title="互斥"></a>互斥</h3><p>&emsp;&emsp;同步和互斥要如何实现呢？我们先从互斥开始讨论。为了保证操作的原子性，在C语言中<strong>互斥锁</strong>可以帮助我们保证互斥，使我们的函数变为可重入函数。</p>
<h4 id="互斥锁"><a href="#互斥锁" class="headerlink" title="互斥锁"></a>互斥锁</h4><p>&emsp;&emsp;互斥锁的值只能为0或1。1表示可以加锁，加锁后值-1，操作结束后就会解锁，解锁就会将值+1。如果一个操作已经加锁则值为0，因此当锁值为0时其他线程则不能加锁，不能加锁线程就会陷入等待。<br><br>&emsp;&emsp;互斥锁操作步骤：<br><br>&emsp;&emsp;1、定义互斥锁变量：<code>pthread_mutex_t</code>。<br><br>&emsp;&emsp;2、初始化互斥锁变量：<code>pthread_mutex_init</code>。<br><br>&emsp;&emsp;3、加锁：<code>pthread_mutex_lock</code>。<br><br>&emsp;&emsp;4、解锁：<code>pthread_mutex_unlock</code>。<br><br>&emsp;&emsp;5、删除锁：<code>pthread_mutex_destroy</code>。<br>&emsp;&emsp;接下来我用互斥锁将一个不可重入的函数使它可重入从而使多个线程同时运行函数时变得安全。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br></pre></td><td class="code"><pre><span class="line">/*实现互斥锁的基本使用以及线程安全的基本认识*/                                    </span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;errno.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;pthread.h&gt;</span><br><span class="line">int ticket = 100;</span><br><span class="line">//互斥锁变量不一定非要非要全局变量的线程都能访问到就行     </span><br><span class="line">//互斥锁变量                                         </span><br><span class="line">pthread_mutex_t mutex;</span><br><span class="line">void* thr_start(void* arg)         </span><br><span class="line">&#123;                  </span><br><span class="line">  while(1)</span><br><span class="line">  &#123;                                                          </span><br><span class="line">    //加锁要在临界资源访问之前</span><br><span class="line">    //int pthread_mutex_lock(pthread_mutex_t* mutex);阻塞加锁</span><br><span class="line">    //int pthread_mutex_trylock(pthread_mutex_t* mutex);非阻塞加锁，加不上锁就返回</span><br><span class="line">    pthread_mutex_lock(&amp;mutex);</span><br><span class="line">    if(ticket &gt; 0)</span><br><span class="line">    &#123;</span><br><span class="line">      printf(&quot;bull --%d--get a ticket:%d\n&quot;, (int)arg, ticket);</span><br><span class="line">      usleep(1000);                                   </span><br><span class="line">      ticket--;</span><br><span class="line">    &#125;                   </span><br><span class="line">    else</span><br><span class="line">    &#123;                          </span><br><span class="line">      pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">      pthread_exit(NULL);</span><br><span class="line">    &#125;                                                          </span><br><span class="line">    pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">  &#125;</span><br><span class="line">  return NULL;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">  pthread_t tid[4];</span><br><span class="line">  int i = 0;</span><br><span class="line">  int ret;</span><br><span class="line">  //初始化互斥锁</span><br><span class="line">  //int pthread_mutex_init(pthread_mutex_t *restrict mutex,</span><br><span class="line">  //       const pthread_mutexattr_t *restrict attr);</span><br><span class="line">  //       </span><br><span class="line">  pthread_mutex_init(&amp;mutex, NULL);</span><br><span class="line">  for(; i &lt; 4; i++)</span><br><span class="line">  &#123;</span><br><span class="line">    ret = pthread_create(&amp;tid[i], NULL, thr_start, (void*)i);</span><br><span class="line">    if(ret != 0)</span><br><span class="line">    &#123;</span><br><span class="line">      printf(&quot;no exist\n&quot;);</span><br><span class="line">      return -1;</span><br><span class="line">    &#125;</span><br><span class="line">      return -1;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  //销毁互斥锁</span><br><span class="line">  //int pthread_mutex_destroy(pthread_mutex_t *mutex);</span><br><span class="line">  pthread_mutex_destroy(&amp;mutex);</span><br><span class="line">  for(i = 0; i &lt; 4; i++)</span><br><span class="line">  &#123;</span><br><span class="line">    pthread_join(tid[i], NULL);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[misaki@localhost 第八章-多线程]$ ./a.out</span><br><span class="line">bull --3--get a ticket:100</span><br><span class="line">bull --1--get a ticket:100</span><br><span class="line">bull --2--get a ticket:100</span><br><span class="line">bull --0--get a ticket:100</span><br><span class="line">bull --1--get a ticket:99</span><br><span class="line">bull --2--get a ticket:98</span><br><span class="line">bull --3--get a ticket:97</span><br><span class="line">bull --0--get a ticket:97</span><br><span class="line">bull --2--get a ticket:96</span><br><span class="line">bull --0--get a ticket:94</span><br><span class="line">bull --3--get a ticket:93</span><br><span class="line">bull --1--get a ticket:95</span><br><span class="line">bull --2--get a ticket:92</span><br><span class="line">bull --3--get a ticket:91</span><br><span class="line">bull --1--get a ticket:90</span><br><span class="line">bull --0--get a ticket:89</span><br><span class="line">bull --3--get a ticket:88</span><br><span class="line">bull --2--get a ticket:87</span><br><span class="line">bull --1--get a ticket:86</span><br><span class="line">bull --0--get a ticket:85</span><br><span class="line">bull --2--get a ticket:84</span><br><span class="line">bull --3--get a ticket:83</span><br><span class="line">bull --1--get a ticket:82</span><br><span class="line">bull --0--get a ticket:81</span><br><span class="line">bull --1--get a ticket:78</span><br><span class="line">bull --2--get a ticket:80</span><br><span class="line">bull --3--get a ticket:79</span><br><span class="line">bull --1--get a ticket:77</span><br><span class="line">bull --2--get a ticket:76</span><br><span class="line">bull --3--get a ticket:75</span><br><span class="line">bull --0--get a ticket:74</span><br><span class="line">bull --0--get a ticket:73</span><br><span class="line">bull --1--get a ticket:72</span><br><span class="line">bull --3--get a ticket:70</span><br><span class="line">bull --2--get a ticket:71</span><br><span class="line">bull --2--get a ticket:68</span><br><span class="line">bull --0--get a ticket:68</span><br><span class="line">bull --3--get a ticket:68</span><br><span class="line">bull --1--get a ticket:68</span><br><span class="line">bull --0--get a ticket:66</span><br><span class="line">bull --2--get a ticket:66</span><br><span class="line">bull --3--get a ticket:65</span><br><span class="line">bull --1--get a ticket:64</span><br><span class="line">bull --0--get a ticket:63</span><br><span class="line">bull --2--get a ticket:62</span><br><span class="line">bull --1--get a ticket:61</span><br><span class="line">bull --3--get a ticket:60</span><br><span class="line">bull --0--get a ticket:59</span><br><span class="line">bull --2--get a ticket:58</span><br><span class="line">bull --1--get a ticket:57</span><br><span class="line">bull --3--get a ticket:56</span><br><span class="line">bull --0--get a ticket:54</span><br><span class="line">bull --3--get a ticket:52</span><br><span class="line">bull --2--get a ticket:54</span><br><span class="line">bull --1--get a ticket:53</span><br><span class="line">bull --2--get a ticket:50</span><br><span class="line">bull --3--get a ticket:49</span><br><span class="line">bull --0--get a ticket:50</span><br><span class="line">bull --1--get a ticket:48</span><br><span class="line">bull --3--get a ticket:47</span><br><span class="line">bull --1--get a ticket:46</span><br><span class="line">bull --2--get a ticket:47</span><br><span class="line">bull --0--get a ticket:45</span><br><span class="line">bull --2--get a ticket:43</span><br><span class="line">bull --1--get a ticket:43</span><br><span class="line">bull --3--get a ticket:42</span><br><span class="line">bull --0--get a ticket:41</span><br><span class="line">bull --0--get a ticket:39</span><br><span class="line">bull --2--get a ticket:38</span><br><span class="line">bull --3--get a ticket:37</span><br><span class="line">bull --1--get a ticket:39</span><br><span class="line">bull --2--get a ticket:36</span><br><span class="line">bull --1--get a ticket:35</span><br><span class="line">bull --0--get a ticket:34</span><br><span class="line">bull --3--get a ticket:33</span><br><span class="line">bull --2--get a ticket:32</span><br><span class="line">bull --1--get a ticket:31</span><br><span class="line">bull --3--get a ticket:29</span><br><span class="line">bull --2--get a ticket:29</span><br><span class="line">bull --0--get a ticket:28</span><br><span class="line">bull --1--get a ticket:27</span><br><span class="line">bull --3--get a ticket:26</span><br><span class="line">bull --0--get a ticket:25</span><br><span class="line">bull --2--get a ticket:24</span><br><span class="line">bull --1--get a ticket:23</span><br><span class="line">bull --1--get a ticket:21</span><br><span class="line">bull --2--get a ticket:21</span><br><span class="line">bull --0--get a ticket:19</span><br><span class="line">bull --3--get a ticket:20</span><br><span class="line">bull --1--get a ticket:18</span><br><span class="line">bull --2--get a ticket:18</span><br><span class="line">bull --0--get a ticket:18</span><br><span class="line">bull --3--get a ticket:17</span><br><span class="line">bull --2--get a ticket:15</span><br><span class="line">bull --3--get a ticket:13</span><br><span class="line">bull --0--get a ticket:15</span><br><span class="line">bull --2--get a ticket:11</span><br><span class="line">bull --1--get a ticket:14</span><br><span class="line">bull --3--get a ticket:10</span><br><span class="line">bull --0--get a ticket:11</span><br><span class="line">bull --2--get a ticket:9</span><br><span class="line">bull --1--get a ticket:8</span><br><span class="line">bull --3--get a ticket:7</span><br><span class="line">bull --0--get a ticket:6</span><br><span class="line">bull --2--get a ticket:5</span><br><span class="line">bull --1--get a ticket:4</span><br><span class="line">bull --3--get a ticket:3</span><br><span class="line">bull --0--get a ticket:2</span><br><span class="line">bull --2--get a ticket:1</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;这样就达成了互斥，在一个线程操作临界资源时，其他线程不会同时干涉。</p>
<h4 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h4><p>&emsp;&emsp;死锁是指因为对一些无法加锁的锁进行加锁操作而导致程序卡死。死锁是我们一定要在使用锁时要注意和避免的<br><br>&emsp;&emsp;死锁产生的四个必要条件：<br><br>&emsp;&emsp;1、互斥条件。一个线程操作时其他线程不能操作。<br><br>&emsp;&emsp;2、不可剥夺条件。一个线程加的锁别的线程不能释放。<br><br>&emsp;&emsp;3、请求与保持条件。一个线程已经有了锁却还在请求其他的锁，但是其他的锁请求不到第一个锁也不释放。<br><br>&emsp;&emsp;4、环路等待条件。<br><br>&emsp;&emsp;死锁产生往往是因为加锁解锁的顺序不同。要想避免死锁就要避免死锁产生的四个必要条件——死锁检测算法，银行家算法。<br></p>
<h3 id="同步"><a href="#同步" class="headerlink" title="同步"></a>同步</h3><p>&emsp;&emsp;临界资源访问的合理性，资源产生后才能进行使用，没有资源则等待，生产资源后则唤醒等待。</p>
<h4 id="条件变量"><a href="#条件变量" class="headerlink" title="条件变量"></a>条件变量</h4><p>&emsp;&emsp;条件变量的使用流程：<br><br>&emsp;&emsp;1、定义条件变量：<code>pthread_cond_t</code>。<br><br>&emsp;&emsp;2、初始化条件变量：<code>pthread_cond_init</code>。<br><br>&emsp;&emsp;3、等待或者唤醒：<code>pthread_cond_wait/pthread_cond_signal</code>。<br><br>&emsp;&emsp;4、销毁条件变量：<code>pthread_cond_destroy</code>。<br></p>
<h3 id="条件变量-1"><a href="#条件变量-1" class="headerlink" title="条件变量"></a>条件变量</h3><h3 id="生产者与消费者模型"><a href="#生产者与消费者模型" class="headerlink" title="生产者与消费者模型"></a>生产者与消费者模型</h3><h3 id="posix标准信号量"><a href="#posix标准信号量" class="headerlink" title="posix标准信号量"></a>posix标准信号量</h3><h3 id="读写锁"><a href="#读写锁" class="headerlink" title="读写锁"></a>读写锁</h3><h3 id="读写者模型"><a href="#读写者模型" class="headerlink" title="读写者模型"></a>读写者模型</h3><h2 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h2><h2 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h2>
          
        
      
    </div>
    
    
    

    

    <div>
    
    </div>

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/6/">6</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/blog-logo.jpg"
                alt="MisakiFx" />
            
              <p class="site-author-name" itemprop="name">MisakiFx</p>
              <p class="site-description motion-element" itemprop="description">Hard working or giving up!!!</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">54</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">8</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">33</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/MisakiFx" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="mailto:1761607418@qq.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope-open"></i>E-Mail</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://music.163.com/#/user/home?id=432551242" target="_blank" title="网易云音乐">
                      
                        <i class="fa fa-fw fa-music"></i>网易云音乐</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://blog.csdn.net/qq_41669298" target="_blank" title="CSDN">
                      
                        <i class="fa fa-fw fa-crosshairs"></i>CSDN</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        ﻿<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js">
</script>
<div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">MisakiFx</span>

  
</div>


<div class="powered-by">
  <i class="fa fa-user-md"></i>
  <span id="busuanzi_container_site_uv">
    我的网站的访客数:<span id="busuanzi_value_site_uv"></span>
  </span>
</div>



<span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.4</div>




<div class="theme-info">
  <div class="powered-by"></div>
  <span class="post-count">博客全站共128.3k字</span>
</div>

        ﻿







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  


  











  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  

  
  
    <script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

  <!-- 页面点击小红心 -->
        <script type="text/javascript" src="/js/src/love.js"></script>
<script src="/live2dw/lib/L2Dwidget.min.js?0c58a1486de42ac6cc1c59c7d98ae887"></script><script>L2Dwidget.init({"pluginModelPath":"assets/","model":{"jsonPath":"/live2dw/assets/z16.model.json"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":false},"log":false,"pluginJsPath":"lib/","pluginRootPath":"live2dw/","tagMode":false});</script></body>
</html>
