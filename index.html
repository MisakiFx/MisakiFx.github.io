<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.ico?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon_16.ico?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta name="description" content="Hard working or giving up!!!">
<meta property="og:type" content="website">
<meta property="og:title" content="Misaki`s blog">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="Misaki`s blog">
<meta property="og:description" content="Hard working or giving up!!!">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Misaki`s blog">
<meta name="twitter:description" content="Hard working or giving up!!!">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/"/>





  <title>Misaki`s blog</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

<a href="https://github.com/MisakiFx" class="github-corner" aria-label="View source on GitHub"><svg width="80" height="80" viewBox="0 0 250 250" style="fill:#64CEAA; color:#fff; position: absolute; top: 0; border: 0; left: 0; transform: scale(-1, 1);" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Misaki`s blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">学习是一种态度</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/01/08/【DS】第五章-排序/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="MisakiFx">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/blog-logo.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Misaki`s blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/01/08/【DS】第五章-排序/" itemprop="url">【DS】第五章-排序</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-01-08T17:31:55+08:00">
                2020-01-08
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/数据结构/" itemprop="url" rel="index">
                    <span itemprop="name">数据结构</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  3.1k
                </span>
              

              

              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h1><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>&emsp;&emsp;本章会介绍并且实现，常用的几种排序算法及其思想，但是关于排序除了时间复杂度和空间复杂度这两个衡量算法的基本标准外，还引入了<strong>稳定</strong>的概念。</p>
<h3 id="稳定"><a href="#稳定" class="headerlink" title="稳定"></a>稳定</h3><p>&emsp;&emsp;如果一个排序算法排序结束后，表中<strong>相同大小的元素依然可用保持和排序前一样的相对顺序则称该排序是稳定的，反之是不稳定的</strong>。<br>&emsp;&emsp;举个例子，以下这个序列中，出现了相同的元素3，为了便于区分，我将其中一个用红色标记出来。<br><img src="/2020/01/08/【DS】第五章-排序/1.png" alt="稳定度"><br><br>&emsp;&emsp;如果我们进行了某种排序算法将其进行了排序，并且排序结果如下。<br><img src="/2020/01/08/【DS】第五章-排序/2.png" alt="稳定度"><br><br>&emsp;&emsp;我们发现结果中红色的3与黑色的3相比排序前的序列依然保持着黑色在前红色在后的相对顺序，此时我们则称这个排序是稳定的，但是如果排序后有可能会使任意一组相同元素的相对顺序出现了改变，则称其是不稳定的。<br>&emsp;&emsp;注意稳定度是一个排序的基本性质，一次结果是稳定的不能说排序是稳定的，必须保证每次都是稳定的才可以说这个排序是稳定的，这就需要根据排序的思想来判断其是否稳定。</p>
<h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><p>&emsp;&emsp;冒泡排序属于交换排序的一种，以升序排序为例，就是根据序列中两个记录键值的比较结果来对换这两个记录在序列中的位置，将键值较大的记录向序列的尾部移动，键值较小的记录向序列的前部移动。这样的过程十分类似于水泡上浮冒泡的过程，所以成为冒泡排序。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">void BubbleSort(std::vector&lt;int&gt;&amp; arr)</span><br><span class="line">&#123;</span><br><span class="line">    int n = arr.size();</span><br><span class="line">    bool flag = true;</span><br><span class="line">    for(int i = 0; i &lt; n - 1; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        if(flag == false)</span><br><span class="line">        &#123;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">        flag = false;</span><br><span class="line">        for(int j = 0; j &lt; n - i - 1; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            if(arr[j] &gt; arr[j + 1])</span><br><span class="line">            &#123;</span><br><span class="line">                flag = true;</span><br><span class="line">                std::swap(arr[j], arr[j + 1]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    std::vector&lt;int&gt; arr = &#123;1, 1, 2, 2, 99, 3, 3, 4, 5, 88, 2&#125;;</span><br><span class="line">    BubbleSort(arr);</span><br><span class="line">    for(const auto&amp; e : arr)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; e &lt;&lt; &quot; &quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1 1 2 2 2 3 3 4 5 88 99</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;冒泡排序十分容易理解，但它是一种十分低效的算法，其时间复杂度为<code>ON^2</code>，空间复杂度为<code>O1</code>，但是该算法是稳定的。</p>
<h2 id="直接插入排序"><a href="#直接插入排序" class="headerlink" title="直接插入排序"></a>直接插入排序</h2><p>&emsp;&emsp;直接插入排序属于插入排序的一种，插入排序是将序列分为两部分，一部分为已经有序部分，一部分为未有序部分。遍历未有序部分将该部分第一个元素插入到有序序列中的合适位置，遍历完毕则完成了排序。<br>&emsp;&emsp;但是在实际实现时为了简化操作，具体流程为将未有序部分与有序部分最后一个比较，如果不满足排序要求则交换，继续与倒数第二个元素比较以此类推，直到满足排序顺序为止。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line"></span><br><span class="line">void InsertSort(std::vector&lt;int&gt;&amp; arr)</span><br><span class="line">&#123;</span><br><span class="line">    if(arr.size() &lt;= 1)</span><br><span class="line">    &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    int n = arr.size();</span><br><span class="line">    for(int i = 1; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        int j = i - 1;</span><br><span class="line">        while(arr[j] &gt; arr[j + 1] &amp;&amp; j &gt;= 0)</span><br><span class="line">        &#123;</span><br><span class="line">            std::swap(arr[j], arr[j + 1]);</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    std::vector&lt;int&gt; arr = &#123;1, 1, 99, 23, 32, 2, 2, 4, 5&#125;;</span><br><span class="line">    InsertSort(arr);</span><br><span class="line">    for(const auto&amp; e : arr)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; e &lt;&lt; &quot; &quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1 1 2 2 4 5 23 32 99</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;直接插入排序也是十分容易理解的排序，但是同样的效率十分低下，其时间复杂度为<code>ON^2</code>，空间复杂度为<code>O1</code>，但是它同样是稳定的。</p>
<h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><p>&emsp;&emsp;选择排序同样是将序列分为两个部分，一个部分为有序部分，一个为无序部分，以升序为例，选择排序每次都从无序部分中选一个最小的放到有序序列的末尾，当无序部分全部变为有序部分则排序结束。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line"></span><br><span class="line">void SelectSort(std::vector&lt;int&gt;&amp; arr)</span><br><span class="line">&#123;</span><br><span class="line">    int n = arr.size();</span><br><span class="line">    for(int i = 0; i &lt; n - 1; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        int min = i;</span><br><span class="line">        for(int j = i + 1; j &lt; n; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            if(arr[j] &lt; arr[min])</span><br><span class="line">            &#123;</span><br><span class="line">                min = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if(min != i)</span><br><span class="line">        &#123;</span><br><span class="line">            std::swap(arr[i], arr[min]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    std::vector&lt;int&gt; arr = &#123;1, 2, 3, 19, 10, 5, 2, 5, 7&#125;;</span><br><span class="line">    SelectSort(arr);</span><br><span class="line">    for(const auto&amp; e : arr)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; e &lt;&lt; &quot; &quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1 2 2 3 5 5 7 10 19</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;选择排序也是十分容易理解但是效率较低的排序方式，其时间复杂度为<code>ON^2</code>，空间复杂度为<code>O1</code>，但是它也是稳定的。</p>
<h2 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h2><p>&emsp;&emsp;希尔排序是插入排序的升级版本。因为插入排序对于越有序的序列所用排序时间越短，时间复杂度越低的特性，希尔排序旨在使用插入排序使每次排序的序列要么足够短，要么就几乎已经有序，来极大程度节省时间，提高效率。<br>&emsp;&emsp;希尔排序思想是将序列通过间隔分为若干子序列，对这些子序列先进行排序，每次减小间隔直到1，就完全变成了直接插入排序，不过此时序列已经几乎有序，可用大大提高直接插入排序的效率。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line"></span><br><span class="line">void InsertSort(int gap, std::vector&lt;int&gt;&amp; arr)</span><br><span class="line">&#123;</span><br><span class="line">    int n = arr.size();</span><br><span class="line">    for(int i = gap; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        for(int j = i - gap; j &gt;= 0; j -= gap)</span><br><span class="line">        &#123;</span><br><span class="line">            if(arr[j + gap] &gt;= arr[j])</span><br><span class="line">            &#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            else </span><br><span class="line">            &#123;</span><br><span class="line">                std::swap(arr[j + gap], arr[j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">void ShellSort(std::vector&lt;int&gt;&amp; arr)</span><br><span class="line">&#123;</span><br><span class="line">    for(int i = arr.size() / 2; i &gt;= 1; i /= 2)</span><br><span class="line">    &#123;</span><br><span class="line">        InsertSort(i, arr);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    std::vector&lt;int&gt; arr = &#123;1, 2, 10, 3, 4, 7, 2, 9, 3, 4, 99, 5&#125;;</span><br><span class="line">    ShellSort(arr);</span><br><span class="line">    for(const auto&amp; e : arr)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; e &lt;&lt; &quot; &quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1 2 2 3 3 4 4 5 7 9 10 99</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;希尔排序是直接插入排序的升级版本，因此它利用自己本身的特性提高了插入排序的效率，平均情况下，它的时间复杂度可用达到<code>ONlogN~ON^2</code>，空间复杂度为<code>O1</code>，但是希尔排序是不稳定的。</p>
<h2 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h2><p>&emsp;&emsp;堆排序时利用二叉树的顺序结构建成二叉堆，利用堆进行排序的排序算法，算法分为两个部分。<br>&emsp;&emsp;首先要对序列建堆，建堆思路及从最后一个父结点开始向下调整，直到第一个父结点为止。<br>&emsp;&emsp;建好堆后将堆顶元素弹出，即将堆顶元素与最后一个元素交换，然后弹出最后一个元素，然后对堆顶进行一次向下调整，此为一次排序，不断重复进行排序，直到堆为空为止，则排序完成。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line"></span><br><span class="line">//堆排序最简单的实现方法就是使用STL中的优先级队列</span><br><span class="line">//优先级队列内部自动维护了一个堆，可用很轻松的帮助我们完成堆排序</span><br><span class="line">//但是为了更好的了解算法思想这里我们手动维护这个堆</span><br><span class="line">void AdjustDown(int start, int end, std::vector&lt;int&gt;&amp; arr)</span><br><span class="line">&#123;</span><br><span class="line">    int parent = start;</span><br><span class="line">    int child = parent * 2 + 1;</span><br><span class="line">    while(child &lt; end)</span><br><span class="line">    &#123;</span><br><span class="line">        if(child + 1 &lt; end &amp;&amp; arr[child + 1] &gt; arr[child])</span><br><span class="line">        &#123;</span><br><span class="line">            child += 1;</span><br><span class="line">        &#125;</span><br><span class="line">        if(arr[child] &lt;= arr[parent])</span><br><span class="line">        &#123;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">        else </span><br><span class="line">        &#123;</span><br><span class="line">            std::swap(arr[child], arr[parent]);</span><br><span class="line">            parent = child;</span><br><span class="line">            child = parent * 2 + 1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">void HeapSort(std::vector&lt;int&gt;&amp; arr)</span><br><span class="line">&#123;</span><br><span class="line">    //建堆</span><br><span class="line">    int n = arr.size();</span><br><span class="line">    for(int i = (n / 2 - 1); i &gt;= 0; i--)</span><br><span class="line">    &#123;</span><br><span class="line">        AdjustDown(i, n, arr);</span><br><span class="line">    &#125;</span><br><span class="line">    //排序</span><br><span class="line">    while(n &gt; 0)</span><br><span class="line">    &#123;</span><br><span class="line">        std::swap(arr[0], arr[n - 1]);</span><br><span class="line">        n--;</span><br><span class="line">        AdjustDown(0, n, arr);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    std::vector&lt;int&gt; arr = &#123;1, 4, 5, 3, 4, 22, 33, 5, 2&#125;;</span><br><span class="line">    HeapSort(arr);</span><br><span class="line">    for(const auto&amp; e : arr)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; e &lt;&lt; &quot; &quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1 2 3 4 4 5 5 22 33</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;堆排序的效率较高，并且序列越无序则效率越高，它的时间复杂度为<code>ONlogN</code>，空间复杂度为<code>O1</code>，但它是不稳定的。</p>
<h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><p>&emsp;&emsp;归并排序的思想是将序列首先拆分成若干不可再分的子序列，然后再将它们一一合并达到有序的效果。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line"></span><br><span class="line">//左闭右开区间</span><br><span class="line">void Merge(std::vector&lt;int&gt;&amp; arr, int start, int mid, int end)</span><br><span class="line">&#123;</span><br><span class="line">    std::vector&lt;int&gt; arr1, arr2;</span><br><span class="line">    for(int i = start; i &lt; mid; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        arr1.push_back(arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    for(int i = mid; i &lt; end; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        arr2.push_back(arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    int i = 0, j = 0, k = start;</span><br><span class="line">    while(i &lt; arr1.size() &amp;&amp; j &lt; arr2.size())</span><br><span class="line">    &#123;</span><br><span class="line">        if(arr1[i] &lt;= arr2[j])</span><br><span class="line">        &#123;</span><br><span class="line">            arr[k] = arr1[i];</span><br><span class="line">            i++;</span><br><span class="line">            k++;</span><br><span class="line">        &#125;</span><br><span class="line">        else </span><br><span class="line">        &#123;</span><br><span class="line">            arr[k] = arr2[j];</span><br><span class="line">            j++;</span><br><span class="line">            k++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    while(i &lt; arr1.size())</span><br><span class="line">    &#123;</span><br><span class="line">        arr[k] = arr1[i];</span><br><span class="line">        i++;</span><br><span class="line">        k++;</span><br><span class="line">    &#125;</span><br><span class="line">    while(j &lt; arr2.size())</span><br><span class="line">    &#123;</span><br><span class="line">        arr[k] = arr2[j];</span><br><span class="line">        j++;</span><br><span class="line">        k++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">void MergeSort(std::vector&lt;int&gt;&amp; arr, int start, int end)</span><br><span class="line">&#123;</span><br><span class="line">    if(end - start &gt; 1)</span><br><span class="line">    &#123;</span><br><span class="line">        int mid = (start + end) &gt;&gt; 1;</span><br><span class="line">        MergeSort(arr, start, mid);</span><br><span class="line">        MergeSort(arr, mid, end);</span><br><span class="line">        Merge(arr, start, mid, end);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    std::vector&lt;int&gt; arr = &#123;1, 2, 22, 1, 5, 4, 55, 44, 3&#125;;</span><br><span class="line">    MergeSort(arr, 0, arr.size());</span><br><span class="line">    for(const auto&amp; e : arr)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; e &lt;&lt; &quot; &quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1 1 2 3 4 5 22 44 55</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;对其进行改进可以写成以下的样子。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line"></span><br><span class="line">//左闭右开区间</span><br><span class="line">void Merge(std::vector&lt;int&gt;&amp; arr, int start, int mid, int end)</span><br><span class="line">&#123;</span><br><span class="line">    std::vector&lt;int&gt; arr1, arr2;</span><br><span class="line">    for(int i = start; i &lt; mid; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        arr1.push_back(arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    //for(int i = mid; i &lt; end; i++)</span><br><span class="line">    //&#123;</span><br><span class="line">    //    arr2.push_back(arr[i]);</span><br><span class="line">    //&#125;</span><br><span class="line">    int i = 0, j = mid, k = start;</span><br><span class="line">    while(i &lt; arr1.size() &amp;&amp; j &lt; end)</span><br><span class="line">    &#123;</span><br><span class="line">        if(arr1[i] &lt;= arr[j])</span><br><span class="line">        &#123;</span><br><span class="line">            arr[k] = arr1[i];</span><br><span class="line">            i++;</span><br><span class="line">            k++;</span><br><span class="line">        &#125;</span><br><span class="line">        else </span><br><span class="line">        &#123;</span><br><span class="line">            arr[k] = arr[j];</span><br><span class="line">            j++;</span><br><span class="line">            k++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    while(i &lt; arr1.size())</span><br><span class="line">    &#123;</span><br><span class="line">        arr[k] = arr1[i];</span><br><span class="line">        i++;</span><br><span class="line">        k++;</span><br><span class="line">    &#125;</span><br><span class="line">    //while(j &lt; arr2.size())</span><br><span class="line">    //&#123;</span><br><span class="line">    //    arr[k] = arr2[j];</span><br><span class="line">    //    j++;</span><br><span class="line">    //    k++;</span><br><span class="line">    //&#125;</span><br><span class="line">&#125;</span><br><span class="line">void MergeSort(std::vector&lt;int&gt;&amp; arr, int start, int end)</span><br><span class="line">&#123;</span><br><span class="line">    if(end - start &gt; 1)</span><br><span class="line">    &#123;</span><br><span class="line">        int mid = (start + end) &gt;&gt; 1;</span><br><span class="line">        MergeSort(arr, start, mid);</span><br><span class="line">        MergeSort(arr, mid, end);</span><br><span class="line">        Merge(arr, start, mid, end);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    std::vector&lt;int&gt; arr = &#123;1, 2, 22, 1, 5, 4, 55, 44, 3&#125;;</span><br><span class="line">    MergeSort(arr, 0, arr.size());</span><br><span class="line">    for(const auto&amp; e : arr)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; e &lt;&lt; &quot; &quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1 1 2 3 4 5 22 44 55</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;归并排序相比内排序更广泛适用于外排序中，在需要有大量数据进行排序的时候需要使用外排序局部读入内存再进行合并的方式进行排序。它的时间复杂度为<code>ONlogN</code>，空间复杂度为<code>ON</code>，并且它是稳定的。</p>
<h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><p>&emsp;&emsp;快速排序是基本排序算法中最快的排序，他和归并算法一样用了分治的思想。它的思路是每次将序列的第一个元素排到合适的位置，使该元素前面的元素都不大于它，后面的元素都不小于它，然后递归整理前面的元素和后面的元素，使所有元素前面的元素都不大于它，后面的元素都不小于它即完成有序。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line"></span><br><span class="line">//左闭右开区间</span><br><span class="line">void QuickSort(std::vector&lt;int&gt;&amp; arr, int start, int end)</span><br><span class="line">&#123;</span><br><span class="line">    if(end - start &lt;= 1)</span><br><span class="line">    &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    int temp = arr[start];</span><br><span class="line">    int ptr1 = start;</span><br><span class="line">    int ptr2 = end - 1;</span><br><span class="line">    while(ptr1 &lt; ptr2)</span><br><span class="line">    &#123;</span><br><span class="line">        while(arr[ptr2] &gt;= temp &amp;&amp; ptr1 &lt; ptr2)</span><br><span class="line">        &#123;</span><br><span class="line">            ptr2--;</span><br><span class="line">        &#125;</span><br><span class="line">        if(ptr1 &gt;= ptr2)</span><br><span class="line">        &#123;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">        arr[ptr1] = arr[ptr2];</span><br><span class="line">        while(arr[ptr1] &lt;= temp &amp;&amp; ptr1 &lt; ptr2)</span><br><span class="line">        &#123;</span><br><span class="line">            ptr1++;</span><br><span class="line">        &#125;</span><br><span class="line">        if(ptr1 &gt;= ptr2)</span><br><span class="line">        &#123;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">        arr[ptr2] = arr[ptr1];</span><br><span class="line">    &#125;</span><br><span class="line">    arr[ptr1] = temp;</span><br><span class="line">    QuickSort(arr, start, ptr1);</span><br><span class="line">    QuickSort(arr, ptr1 + 1, end);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    std::vector&lt;int&gt; arr = &#123;3, 1, 2, 55, 2, 4, 88, 22, 1, 3&#125;;</span><br><span class="line">    QuickSort(arr, 0, arr.size());</span><br><span class="line">    for(const auto&amp; e : arr)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; e &lt;&lt; &quot; &quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1 1 2 2 3 3 4 22 55 88</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;快排使最快的基本排序算法，并且同样的是越有序则排序越快。它的时间复杂度为<code>ONlogN</code>，空间复杂度为<code>OlogN~ON</code>，但它是不稳定的。</p>

          
        
      
    </div>
    
    
    

    

    <div>
    
    </div>

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/12/15/【DS】第四章-二叉树/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="MisakiFx">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/blog-logo.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Misaki`s blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/12/15/【DS】第四章-二叉树/" itemprop="url">【DS】第四章-二叉树</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-12-15T14:39:45+08:00">
                2019-12-15
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/数据结构/" itemprop="url" rel="index">
                    <span itemprop="name">数据结构</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  3.1k
                </span>
              

              

              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="树的概念及结构"><a href="#树的概念及结构" class="headerlink" title="树的概念及结构"></a>树的概念及结构</h1><h2 id="什么是树"><a href="#什么是树" class="headerlink" title="什么是树"></a>什么是树</h2><p>&emsp;&emsp;树是一种非线性的数据结构，它是由n（n&gt;=0）个有限结点组成一个具有层次关系的集合。把它叫做树是因 为它看起来像一棵倒挂的树，也就是说它是根朝上，而叶朝下的。它具有以下的特点：每个结点有零个或多 个子结点；没有父结点的结点称为根结点；每一个非根结点有且只有一个父结点；除了根结点外，每个子结 点可以分为多个不相交的子树。<br>&emsp;&emsp;下图就是一棵常见的树。<br><br><img src="/2019/12/15/【DS】第四章-二叉树/1.png" alt="树"><br></p>
<h2 id="树的常用名词"><a href="#树的常用名词" class="headerlink" title="树的常用名词"></a>树的常用名词</h2><p>&emsp;&emsp;节点的度：一个节点含有的子树的个数称为该节点的度；<br>&emsp;&emsp;叶节点或终端节点：度为0的节点称为叶节点；<br>&emsp;&emsp;非终端节点或分支节点：度不为0的节点； &emsp;&emsp;如上图：D、E、F、G…等节点为分支节点 双亲节点或父节点：若一个节点含有子节点，则这个节点称为其子节点的父节点； &emsp;&emsp;孩子节点或子节点：一个节点含有的子树的根节点称为该节点的子节点；<br>&emsp;&emsp;兄弟节点：具有相同父节点的节点互称为兄弟节点；<br>&emsp;&emsp;树的度：一棵树中，最大的节点的度称为树的度；<br>&emsp;&emsp;节点的层次：从根开始定义起，根为第1层，根的子节点为第2层，以此类推； &emsp;&emsp;树的高度或深度：树中节点的最大层次； &emsp;&emsp;堂兄弟节点：双亲在同一层的节点互为堂兄弟；<br>&emsp;&emsp;节点的祖先：从根到该节点所经分支上的所有节点；<br>&emsp;&emsp;子孙：以某节点为根的子树中任一节点都称为该节点的子孙； &emsp;&emsp;森林：由m（m&gt;=0）棵互不相交的树的集合称为森林；</p>
<h2 id="树的表示"><a href="#树的表示" class="headerlink" title="树的表示"></a>树的表示</h2><p>&emsp;&emsp;树的表示相比线性结构就要复杂一些，因为其是层次结构的，其的下一个结点可能有多个，也可能只有一个，因此十分难以在逻辑结构上进行表示。于是伟大的人类提出了一种方法可以很简单的表示任意一棵二叉树，这种表示方法称之为<strong>孩子兄弟表示法</strong>。<br><img src="/2019/12/15/【DS】第四章-二叉树/2.png" alt="孩子兄弟表示法"><br><br>&emsp;&emsp;所谓孩子兄弟表示法就是让任何一个结点仅指向它的第一个孩子结点和右边相邻的兄弟结点（如果没有孩子或兄弟指向空），由此任意一棵树上的任何一个节点都可以变成一个度最大仅为2结点，由此我们可以将任何一棵树都变成一棵<strong>二叉树</strong>。</p>
<h1 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h1><h2 id="什么是二叉树"><a href="#什么是二叉树" class="headerlink" title="什么是二叉树"></a>什么是二叉树</h2><p>&emsp;&emsp;二叉树是一棵所有节点的度最大为2的树。任何一棵树都可以通过<strong>孩子兄弟表示法</strong>转换为二叉树，因此我们接下来的所有研究都是围绕二叉树进行的。下图就是一棵二叉树。<br><br><img src="/2019/12/15/【DS】第四章-二叉树/3.png" alt="孩子兄弟表示法"><br></p>
<h2 id="二叉树的特点"><a href="#二叉树的特点" class="headerlink" title="二叉树的特点"></a>二叉树的特点</h2><p>&emsp;&emsp;1. 每个结点最多有两棵子树，即二叉树不存在度大于2的结点。<br>&emsp;&emsp;2. 二叉树的子树有左右之分，其子树的次序不能颠倒。<br>&emsp;&emsp;3.若二叉树的层次从0开始，则在二叉树的第i层至多有2^i个结点(i&gt;=0)。<br>&emsp;&emsp;4.高度为k的二叉树最多有2^(k+1) - 1个结点(k&gt;=-1)。 (空树的高度为-1)<br>&emsp;&emsp;5.对任何一棵二叉树，如果其叶子结点(度为0)数为m, 度为2的结点数为n, 则m = n + 1。</p>
<h2 id="特殊的二叉树"><a href="#特殊的二叉树" class="headerlink" title="特殊的二叉树"></a>特殊的二叉树</h2><h3 id="完美二叉树（满二叉树）"><a href="#完美二叉树（满二叉树）" class="headerlink" title="完美二叉树（满二叉树）"></a>完美二叉树（满二叉树）</h3><p>&emsp;&emsp;一个深度为k(&gt;=-1)且有2^(k+1) - 1个结点的二叉树称为完美二叉树。意思是说这棵深度为k的二叉树任意一行的结点都已经是满的了。<br><br><img src="/2019/12/15/【DS】第四章-二叉树/4.png" alt="完美二叉树法"><br></p>
<h3 id="完全二叉树"><a href="#完全二叉树" class="headerlink" title="完全二叉树"></a>完全二叉树</h3><p>&emsp;&emsp;完全二叉树从根结点到倒数第二层满足完美二叉树，最后一层可以不完全填充，其叶子结点都靠左对齐。<br><br><img src="/2019/12/15/【DS】第四章-二叉树/5.png" alt="完全二叉树法"><br></p>
<h3 id="完满二叉树"><a href="#完满二叉树" class="headerlink" title="完满二叉树"></a>完满二叉树</h3><p>&emsp;&emsp;所有非叶子结点的度都是2<br>换句话说就是只要你有孩子，你就必然是有两个孩子。<br><br><img src="/2019/12/15/【DS】第四章-二叉树/6.png" alt="完满二叉树法"><br></p>
<h2 id="二叉树的存储"><a href="#二叉树的存储" class="headerlink" title="二叉树的存储"></a>二叉树的存储</h2><h3 id="顺序存储"><a href="#顺序存储" class="headerlink" title="顺序存储"></a>顺序存储</h3><p>&emsp;&emsp;顺序存储指的是利用链表在连续的地址空间上进行存储。但是顺序存储只适用于完全二叉树，因为这样才不会有空间的浪费，所以顺序的存储方式一般用来存储堆。<br><br><img src="/2019/12/15/【DS】第四章-二叉树/7.png" alt="顺序存储"><br></p>
<h3 id="链式存储"><a href="#链式存储" class="headerlink" title="链式存储"></a>链式存储</h3><p>&emsp;&emsp;链式的二叉树存储方式是最为常用的二叉树存储形式，用一个二叉链（或三叉链）的形式来构成二叉树。</p>
<h4 id="二叉链"><a href="#二叉链" class="headerlink" title="二叉链"></a>二叉链</h4><p>&emsp;&emsp;如下是一个二叉链的存储形式。<br><br><img src="/2019/12/15/【DS】第四章-二叉树/8.png" alt="二叉链"><br><br>&emsp;&emsp;二叉链结构：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">struct BinaryTreeNode</span><br><span class="line">&#123;</span><br><span class="line">    T _data;</span><br><span class="line">    BinaryTreeNode&lt;T&gt;* _left;</span><br><span class="line">    BinartTreeNode&lt;T&gt;* _right;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h4 id="三叉链"><a href="#三叉链" class="headerlink" title="三叉链"></a>三叉链</h4><p>&emsp;&emsp;如下是一个三叉链的存储形式。<br><br><img src="/2019/12/15/【DS】第四章-二叉树/9.png" alt="三叉链"><br><br>&emsp;&emsp;二叉链解雇：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">template&lt;class T&gt;</span><br><span class="line">struct BinaryTreeNode</span><br><span class="line">&#123;</span><br><span class="line">    T _data;</span><br><span class="line">    BinaryTreeNode&lt;T&gt;* _left;</span><br><span class="line">    BinartTreeNode&lt;T&gt;* _right;</span><br><span class="line">    BinartTreeNode&lt;T&gt;* _parent;//多了一个指向父亲的指针</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h1><h2 id="堆的概念"><a href="#堆的概念" class="headerlink" title="堆的概念"></a>堆的概念</h2><p>&emsp;&emsp;堆是典型的通过使用顺序方式存储二叉树来实现的数据结构，因为堆可以保证其必然是一棵完全二叉树。<br>&emsp;&emsp;如果有一个关键码的集合K = {k0，k1， k2，…，kn-1}，把它的所有元素按完全二叉树的顺序存储方式存储 在一个一维数组中，并满足：Ki &lt;= K2i+1 且 Ki&lt;= K2i+2 (Ki &gt;= K2i+1 且 Ki &gt;= K2i+2) i = 0，1，2…，则称为 小堆(或大堆)。将根节点最大的堆叫做最大堆或大根堆，根节点最小的堆叫做最小堆或小根堆。<br>&emsp;&emsp;堆有两点性质：<br>&emsp;&emsp;1、其保证其一定是一棵完全二叉树。<br>&emsp;&emsp;2、堆中任意一个孩子结点必不大于（大根堆）或者不小于（小根堆）其父结点。<br>&emsp;&emsp;下图是一个小根堆：<br><br><img src="/2019/12/15/【DS】第四章-二叉树/10.png" alt="小根堆"><br><br>&emsp;&emsp;下图是一个大根堆：<br><br><img src="/2019/12/15/【DS】第四章-二叉树/11.png" alt="大根堆"><br></p>
<h2 id="堆的实现"><a href="#堆的实现" class="headerlink" title="堆的实现"></a>堆的实现</h2><p>&emsp;&emsp;堆的实现中有三个基础操作，向上调整，向下调整以及建堆，他们三个共同构成了堆的所有基础操作。STL中的<strong>优先级队列</strong>底层就是一个堆，所以平时要使用堆的时候我们不必自己写一个，可以借助优先级队列来实现。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;assert.h&gt;</span><br><span class="line">//T为数据类型，Compare为比较方法，less创建大根堆，greater创建大根堆</span><br><span class="line">template&lt;class T, class Compare&gt;</span><br><span class="line">class Heap</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    Heap()</span><br><span class="line">        :_arr()</span><br><span class="line">        ,_size(0)</span><br><span class="line">    &#123;&#125;</span><br><span class="line">    Heap(const std::vector&lt;T&gt;&amp; arr)</span><br><span class="line">        :_arr(arr)</span><br><span class="line">        ,_size(arr.size())</span><br><span class="line">    &#123;</span><br><span class="line">        //根据已有数组建堆</span><br><span class="line">        //建堆思路即从最后一个开始进行向下调整，一直向下调整到根</span><br><span class="line">        for(int i = (_size - 2) / 2; i &gt;= 0; i--)</span><br><span class="line">        &#123;</span><br><span class="line">            AdjustDown(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    void Pop()</span><br><span class="line">    &#123;</span><br><span class="line">        //弹出根节点</span><br><span class="line">        //思路是将根与最后一个元素交换，然后向下调整，之后弹出最后一个结点    </span><br><span class="line">        std::swap(_arr[0], _arr[_size - 1]);</span><br><span class="line">        _arr.pop_back();</span><br><span class="line">        _size--;</span><br><span class="line">        AdjustDown(0);</span><br><span class="line">    &#125;</span><br><span class="line">    void Push(const T&amp; data)</span><br><span class="line">    &#123;</span><br><span class="line">        _arr.push_back(data);</span><br><span class="line">        //新插入元素要向上调整保证依然是一个堆</span><br><span class="line">        _size++;</span><br><span class="line">        AdjustUp(_size - 1);</span><br><span class="line">    &#125;</span><br><span class="line">    void Print()</span><br><span class="line">    &#123;</span><br><span class="line">        for(const auto&amp; e : _arr)</span><br><span class="line">        &#123;</span><br><span class="line">            std::cout &lt;&lt; e &lt;&lt; &quot; &quot;;</span><br><span class="line">        &#125;</span><br><span class="line">        std::cout &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    const T&amp; Top()</span><br><span class="line">    &#123;</span><br><span class="line">        assert(_size &gt; 0);</span><br><span class="line">        return _arr[0];</span><br><span class="line">    &#125;</span><br><span class="line">    bool Empty()</span><br><span class="line">    &#123;</span><br><span class="line">        assert(_size &gt; 0);</span><br><span class="line">        return _size == 0;</span><br><span class="line">    &#125;</span><br><span class="line">    size_t Size()</span><br><span class="line">    &#123;</span><br><span class="line">        return _size;</span><br><span class="line">    &#125;</span><br><span class="line">    void HeapSort(std::vector&lt;int&gt;&amp; arr)</span><br><span class="line">    &#123;</span><br><span class="line">        //堆排序的思想即建堆将根持续弹出放到尾部</span><br><span class="line">        //升序建大根堆</span><br><span class="line">        //降序建小根堆</span><br><span class="line">        Heap&lt;T, Compare&gt; tempHeap(_arr);</span><br><span class="line">        int tempSize = tempHeap.Size();</span><br><span class="line">        arr.resize(tempSize);</span><br><span class="line">        while(!tempHeap.Empty())</span><br><span class="line">        &#123;</span><br><span class="line">            T top = tempHeap.Top();</span><br><span class="line">            arr[tempSize - 1] = top;</span><br><span class="line">            tempSize--;</span><br><span class="line">            tempHeap.Pop();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">private:</span><br><span class="line">    //向下调整</span><br><span class="line">    //向下调整是堆操作中十分常用的基础操作</span><br><span class="line">    //即我们从一个指定结点开始向下调整直到不需要调整为止，</span><br><span class="line">    //保证调整过的路径满足堆的要求</span><br><span class="line">    void AdjustDown(size_t pos)</span><br><span class="line">    &#123;</span><br><span class="line">        Compare cmp;</span><br><span class="line">        //孩子节点下标为 根节点下标 * 2 + 1 和 根结点下标 * 2 + 2</span><br><span class="line">        size_t child = pos * 2 + 1;</span><br><span class="line">        while(child &lt; _size)</span><br><span class="line">        &#123;</span><br><span class="line">            if((child + 1) &lt; _size &amp;&amp; cmp(_arr[child], _arr[child + 1]))</span><br><span class="line">            &#123;</span><br><span class="line">                child += 1;</span><br><span class="line">            &#125;</span><br><span class="line">            //如果调整了还需要继续向下调整</span><br><span class="line">            if(cmp(_arr[pos], _arr[child]))</span><br><span class="line">            &#123;</span><br><span class="line">                std::swap(_arr[pos], _arr[child]);</span><br><span class="line">            &#125;</span><br><span class="line">            else </span><br><span class="line">            &#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            pos = child;</span><br><span class="line">            child = pos * 2 + 1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    //向上调整与向下调整类似</span><br><span class="line">    void AdjustUp(size_t pos)</span><br><span class="line">    &#123;</span><br><span class="line">        Compare cmp;</span><br><span class="line">        //父结点下标为 (孩子结点下表 - 1) / 2</span><br><span class="line">        size_t parent = (pos - 1) / 2;</span><br><span class="line">        while(pos &gt; 0)</span><br><span class="line">        &#123;</span><br><span class="line">            //如果调整了需要继续向上迭代调整</span><br><span class="line">            if(cmp(_arr[parent], _arr[pos]))</span><br><span class="line">            &#123;</span><br><span class="line">                std::swap(_arr[parent], _arr[pos]);</span><br><span class="line">            &#125;</span><br><span class="line">            else </span><br><span class="line">            &#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            pos = parent;</span><br><span class="line">            parent = (pos - 1) / 2;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">private:</span><br><span class="line">    std::vector&lt;T&gt; _arr;</span><br><span class="line">    size_t _size;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    std::vector&lt;int&gt; arr = &#123;1, 2, 3, 4, 5, 6, 7&#125;;</span><br><span class="line">    Heap&lt;int, std::less&lt;int&gt;&gt; heap(arr);</span><br><span class="line">    heap.Print();</span><br><span class="line">    heap.Pop();</span><br><span class="line">    heap.Print();</span><br><span class="line">    std::vector&lt;int&gt; arr2;</span><br><span class="line">    heap.HeapSort(arr2);</span><br><span class="line">    for(const auto&amp; e : arr2)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; e &lt;&lt; &quot; &quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; heap.Size() &lt;&lt; std::endl;</span><br><span class="line">    heap.Push(7);</span><br><span class="line">    heap.Print();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">7 5 6 4 2 1 3</span><br><span class="line">6 5 3 4 2 1</span><br><span class="line">1 2 3 4 5 6</span><br><span class="line">6</span><br><span class="line">7 5 6 4 2 1 3</span><br></pre></td></tr></table></figure></p>
<h1 id="二叉链实现二叉树"><a href="#二叉链实现二叉树" class="headerlink" title="二叉链实现二叉树"></a>二叉链实现二叉树</h1><p>&emsp;&emsp;二叉树的顺序存储代表为堆，那么链式存储典型就是使用二叉链实现二叉树。<br>&emsp;&emsp;二叉链没什么基础知识了，这里要重点关注的是我们如何在二叉链存储结构下前序，中序，后序以及层序遍历二叉树，这里简单的方法要用到递归。</p>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>&emsp;&emsp;直接上代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line"></span><br><span class="line">//二叉链结构</span><br><span class="line">template&lt;class T&gt;</span><br><span class="line">struct BinaryTreeNode</span><br><span class="line">&#123;</span><br><span class="line">    BinaryTreeNode(const T&amp; data = T())</span><br><span class="line">        :_data(data)</span><br><span class="line">        ,_left(nullptr)</span><br><span class="line">        ,_right(nullptr)</span><br><span class="line">    &#123;&#125;</span><br><span class="line">    T _data;</span><br><span class="line">    BinaryTreeNode&lt;T&gt;* _left;</span><br><span class="line">    BinaryTreeNode&lt;T&gt;* _right;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">template&lt;class T&gt;</span><br><span class="line">class BinaryTree</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    BinaryTree()</span><br><span class="line">        :_head(nullptr)</span><br><span class="line">        ,_size(0)</span><br><span class="line">    &#123;&#125;</span><br><span class="line">    BinaryTree(const std::string&amp; preOrder)</span><br><span class="line">    &#123;</span><br><span class="line">        int i = 0;</span><br><span class="line">        _head = CreateByPreOrder(preOrder, i);</span><br><span class="line">    &#125;</span><br><span class="line">    //前序遍历</span><br><span class="line">    void PreOrder()</span><br><span class="line">    &#123;</span><br><span class="line">        PreOrderCore(_head);</span><br><span class="line">    &#125;</span><br><span class="line">    //中序遍历</span><br><span class="line">    void InOrder()</span><br><span class="line">    &#123;</span><br><span class="line">        InOrderCore(_head);</span><br><span class="line">    &#125;</span><br><span class="line">    //后序遍历</span><br><span class="line">    void PostOrder()</span><br><span class="line">    &#123;</span><br><span class="line">        PostOrderCore(_head);</span><br><span class="line">    &#125;</span><br><span class="line">    //层序遍历</span><br><span class="line">    void LevelOrder()</span><br><span class="line">    &#123;</span><br><span class="line">        std::queue&lt;BinaryTreeNode&lt;T&gt;*&gt; que;</span><br><span class="line">        que.push(_head);</span><br><span class="line">        while(!que.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            BinaryTreeNode&lt;T&gt;*temp = que.front();</span><br><span class="line">            que.pop();</span><br><span class="line">            if(temp == nullptr)</span><br><span class="line">            &#123;</span><br><span class="line">                std::cout &lt;&lt; &quot;#&quot;;</span><br><span class="line">            &#125;</span><br><span class="line">            else </span><br><span class="line">            &#123;</span><br><span class="line">                std::cout &lt;&lt; (char)(temp-&gt;_data + &apos;A&apos;);</span><br><span class="line">                que.push(temp-&gt;_left);</span><br><span class="line">                que.push(temp-&gt;_right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    //判断是不是一棵完全二叉树</span><br><span class="line">    //层序遍历二叉树，遍历到第一个nullptr结点，</span><br><span class="line">    //就遍历整个队列，如果全为空则是完全二叉树</span><br><span class="line">    //否则就不是</span><br><span class="line">    bool IsComplateTree()</span><br><span class="line">    &#123;</span><br><span class="line">        std::queue&lt;BinaryTreeNode&lt;T&gt;*&gt; que;</span><br><span class="line">        que.push(_head);</span><br><span class="line">        while(!que.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            BinaryTreeNode&lt;T&gt;* temp = que.front();</span><br><span class="line">            que.pop();</span><br><span class="line">            if(temp == nullptr)</span><br><span class="line">            &#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">            &#123;</span><br><span class="line">                que.push(temp-&gt;_left);</span><br><span class="line">                que.push(temp-&gt;_right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        while(!que.empty())</span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">            BinaryTreeNode&lt;T&gt;* temp = que.front();</span><br><span class="line">            que.pop();</span><br><span class="line">            if(temp != nullptr)</span><br><span class="line">            &#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">private:</span><br><span class="line">    void InOrderCore(BinaryTreeNode&lt;T&gt;* root)</span><br><span class="line">    &#123;</span><br><span class="line">        if(root == nullptr)</span><br><span class="line">        &#123;</span><br><span class="line">            std::cout &lt;&lt; &quot;#&quot;;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        InOrderCore(root-&gt;_left);</span><br><span class="line">        std::cout &lt;&lt; (char)(root-&gt;_data + &apos;A&apos;);</span><br><span class="line">        InOrderCore(root-&gt;_right);</span><br><span class="line">    &#125;</span><br><span class="line">    void PreOrderCore(BinaryTreeNode&lt;T&gt;* root)</span><br><span class="line">    &#123;</span><br><span class="line">        if(root == nullptr)</span><br><span class="line">        &#123;</span><br><span class="line">            std::cout &lt;&lt; &quot;#&quot;;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        std::cout &lt;&lt; (char)(&apos;A&apos; + root-&gt;_data);</span><br><span class="line">        PreOrderCore(root-&gt;_left);</span><br><span class="line">        PreOrderCore(root-&gt;_right);</span><br><span class="line">    &#125;</span><br><span class="line">    void PostOrderCore(BinaryTreeNode&lt;T&gt;* root)</span><br><span class="line">    &#123;</span><br><span class="line">        if(root == nullptr)</span><br><span class="line">        &#123;</span><br><span class="line">            std::cout &lt;&lt; &quot;#&quot;;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        PostOrderCore(root-&gt;_left);</span><br><span class="line">        PostOrderCore(root-&gt;_right);</span><br><span class="line">        std::cout &lt;&lt; (char)(&apos;A&apos; + root-&gt;_data);</span><br><span class="line">    &#125;</span><br><span class="line">    BinaryTreeNode&lt;T&gt;* CreateByPreOrder(const std::string&amp; preOrder, int&amp; i)</span><br><span class="line">    &#123;</span><br><span class="line">        if(preOrder[i] != &apos;#&apos;)</span><br><span class="line">        &#123;</span><br><span class="line">            BinaryTreeNode&lt;T&gt;* root = new BinaryTreeNode&lt;T&gt;(preOrder[i] - &apos;A&apos;);</span><br><span class="line">            root-&gt;_left = CreateByPreOrder(preOrder, ++i);</span><br><span class="line">            root-&gt;_right = CreateByPreOrder(preOrder, ++i);</span><br><span class="line">            return root;</span><br><span class="line">        &#125;</span><br><span class="line">        else </span><br><span class="line">        &#123;</span><br><span class="line">            return nullptr;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">private:</span><br><span class="line">    BinaryTreeNode&lt;T&gt;* _head;           //与链表一样存储一个头结点即可</span><br><span class="line">    size_t _size;                   //节点个数</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    BinaryTree&lt;int&gt; tree(&quot;ABD##E##CF##G##&quot;);</span><br><span class="line">    tree.PreOrder();</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line">    tree.InOrder();</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line">    tree.PostOrder();</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line">    tree.LevelOrder();</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; &quot;Is Complate Tree: &quot; &lt;&lt; tree.IsComplateTree() &lt;&lt; std::endl;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>

          
        
      
    </div>
    
    
    

    

    <div>
    
    </div>

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/12/14/【DS】第三章-栈和队列/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="MisakiFx">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/blog-logo.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Misaki`s blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/12/14/【DS】第三章-栈和队列/" itemprop="url">【DS】第三章-栈和队列</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-12-14T20:20:28+08:00">
                2019-12-14
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/数据结构/" itemprop="url" rel="index">
                    <span itemprop="name">数据结构</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  1.7k
                </span>
              

              

              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="第三章-栈和队列"><a href="#第三章-栈和队列" class="headerlink" title="第三章 栈和队列"></a>第三章 栈和队列</h1><h2 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h2><h3 id="栈的特性"><a href="#栈的特性" class="headerlink" title="栈的特性"></a>栈的特性</h3><p>&emsp;&emsp;栈是一种线性结构，这种特殊的线性结构有着最大的特点——<strong>后进先出(Last In First Out)</strong>。最后压入栈的元素会最先被弹出。<br>&emsp;&emsp;由于栈只用在同一端进行插入和删除，因此我们优先选择使用顺序表，因为在顺序表的末尾插入和删除的时间复杂度都是O(1)，并且操作简单<br></p>
<h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>&emsp;&emsp;栈的实现可以基于顺序表、链表和双端队列，这里使用最简单方法基于顺序表来实现栈。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;assert.h&gt;</span><br><span class="line">template&lt;class T&gt;</span><br><span class="line">class Stack</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    //构造函数</span><br><span class="line">    Stack()</span><br><span class="line">        :_stack(nullptr)  </span><br><span class="line">        ,_size(0)</span><br><span class="line">        ,_capacity(0)</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    //析构函数</span><br><span class="line">    ~Stack()</span><br><span class="line">    &#123;</span><br><span class="line">        if(_stack != nullptr)</span><br><span class="line">        &#123;</span><br><span class="line">            delete[] _stack;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    //入栈</span><br><span class="line">    void Push(const T&amp; temp)</span><br><span class="line">    &#123;</span><br><span class="line">        //尾插</span><br><span class="line">        //容量检查</span><br><span class="line">        if(_size == _capacity)//满了</span><br><span class="line">        &#123;</span><br><span class="line">            size_t newCapacity = (_capacity == 0 ? 5 : 2 * _capacity);</span><br><span class="line">            T* stackTemp = new T[newCapacity];</span><br><span class="line">            for(int i = 0; i &lt; _size; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                stackTemp[i] = _stack[i];</span><br><span class="line">            &#125;</span><br><span class="line">            //delete空指针是完全安全的</span><br><span class="line">            delete[] _stack;</span><br><span class="line">            _stack = stackTemp;</span><br><span class="line">            _capacity = newCapacity;</span><br><span class="line">            std::cout &lt;&lt; &quot;Expend new capacity:&quot; &lt;&lt; _capacity &lt;&lt; std::endl;</span><br><span class="line">        &#125;</span><br><span class="line">        _stack[_size] = temp;</span><br><span class="line">        _size++;</span><br><span class="line">    &#125;</span><br><span class="line">    //出栈</span><br><span class="line">    void Pop()</span><br><span class="line">    &#123;</span><br><span class="line">        if(_size &lt;= 0)</span><br><span class="line">        &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        _size--;</span><br><span class="line">    &#125;</span><br><span class="line">    //栈顶元素</span><br><span class="line">    const T&amp; Top()</span><br><span class="line">    &#123;</span><br><span class="line">        assert(_size &gt; 0);</span><br><span class="line">        return _stack[_size - 1];</span><br><span class="line">    &#125;</span><br><span class="line">    //元素个数</span><br><span class="line">    size_t Size()</span><br><span class="line">    &#123;</span><br><span class="line">        return _size;</span><br><span class="line">    &#125;</span><br><span class="line">    //是否为空</span><br><span class="line">    bool IsEmpty()</span><br><span class="line">    &#123;</span><br><span class="line">        return (_size &lt;= 0 ? true : false);</span><br><span class="line">    &#125;</span><br><span class="line">private:</span><br><span class="line">    T* _stack;//顺序表</span><br><span class="line">    size_t _size;//长度</span><br><span class="line">    size_t _capacity;//容量</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h3 id="如何判断一个序列是否为出栈序列"><a href="#如何判断一个序列是否为出栈序列" class="headerlink" title="如何判断一个序列是否为出栈序列"></a>如何判断一个序列是否为出栈序列</h3><p>&emsp;&emsp;一个入栈序列有很多种出栈顺序，例如入栈<code>1 2 3 4 5</code>，他的出栈序列可以是<code>5 4 3 2 1</code>也可也是<code>3 2 1 4 5</code>，那么如何判断一个序列是否是一个入栈序列的出栈序列呢？<br>&emsp;&emsp;这道题的思路很简单，我们需要利用一个栈和两个分别指向入栈序列和出栈序列的指针。当栈为空或栈顶元素不等于当前出栈序列指针所指元素时，将入栈序列指针所指元素压入栈，并且入栈序列指针后移；如果相同则将栈顶元素弹出并将出栈序列指针后移。如果在演算过程中还需要向栈中压入元素而入栈序列已经被全部遍历指针指向队尾则可以怕判断当前序列不是入栈序列的出栈序列；如果可以同时遍历完入栈序列和出栈序列并且栈为空则当前序列时一个入栈序列的出栈序列。<br><br><a href="https://misakifx.github.io/2019/10/25/%E3%80%90DS%E3%80%91%E6%A0%88%E7%9A%84%E5%8E%8B%E5%85%A5%E3%80%81%E5%BC%B9%E5%87%BA%E5%BA%8F%E5%88%97/" target="_blank" rel="noopener">https://misakifx.github.io/2019/10/25/%E3%80%90DS%E3%80%91%E6%A0%88%E7%9A%84%E5%8E%8B%E5%85%A5%E3%80%81%E5%BC%B9%E5%87%BA%E5%BA%8F%E5%88%97/</a><br><br>&emsp;&emsp;</p>
<h3 id="栈的应用"><a href="#栈的应用" class="headerlink" title="栈的应用"></a>栈的应用</h3><p>&emsp;&emsp;栈有以下几种应用：判断括号匹配，后缀表达式，迷宫的暴力破解法等。</p>
<h2 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h2><h3 id="队列的特点"><a href="#队列的特点" class="headerlink" title="队列的特点"></a>队列的特点</h3><p>&emsp;&emsp;队列也是一种线性结构，这种线性结构的特点为<strong>先进先出(First in First out)</strong>。由于队列需要在队列两端进行插入或删除，因此我们优先选择链表来进行实现。当然使用数组实现也可以，只是数组在头部插入和删除元素需要<code>ON</code>的时间复杂度，因此选择链表更优。<br></p>
<h3 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;assert.h&gt;</span><br><span class="line">template&lt;class T&gt;</span><br><span class="line">struct QueueNode</span><br><span class="line">&#123;</span><br><span class="line">    QueueNode()</span><br><span class="line">        :_data(T())</span><br><span class="line">        ,_next(nullptr)</span><br><span class="line">    &#123;&#125;</span><br><span class="line">    QueueNode(const T&amp; data, QueueNode* next)</span><br><span class="line">        :_data(data)</span><br><span class="line">        ,_next(next)</span><br><span class="line">    &#123;&#125;</span><br><span class="line">    T _data;</span><br><span class="line">    QueueNode* _next;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//用单向带头不循环链表实现队列</span><br><span class="line">template&lt;class T&gt;</span><br><span class="line">class Queue</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    Queue()</span><br><span class="line">        :_head(nullptr)</span><br><span class="line">        ,_rear(nullptr)</span><br><span class="line">        ,_size(0)</span><br><span class="line">    &#123;</span><br><span class="line">        _head = new QueueNode&lt;T&gt;;</span><br><span class="line">        _rear = _head;</span><br><span class="line">    &#125;</span><br><span class="line">    ~Queue()</span><br><span class="line">    &#123;</span><br><span class="line">        while(!Empty())</span><br><span class="line">        &#123;</span><br><span class="line">            Pop();</span><br><span class="line">        &#125;</span><br><span class="line">        delete _head;</span><br><span class="line">        _head = nullptr;</span><br><span class="line">        _rear = nullptr;</span><br><span class="line">    &#125;</span><br><span class="line">    void Push(const T&amp; data)</span><br><span class="line">    &#123;</span><br><span class="line">        QueueNode&lt;T&gt;* newNode = new QueueNode&lt;T&gt;(data, nullptr);</span><br><span class="line">        _rear-&gt;_next = newNode;</span><br><span class="line">        _rear = newNode;</span><br><span class="line">        _size++;</span><br><span class="line">    &#125;</span><br><span class="line">    bool Empty()</span><br><span class="line">    &#123;</span><br><span class="line">        return _rear == _head;</span><br><span class="line">    &#125;</span><br><span class="line">    void Pop()</span><br><span class="line">    &#123;</span><br><span class="line">        QueueNode&lt;T&gt;* temp = _head-&gt;_next;</span><br><span class="line">        _head-&gt;_next = _head-&gt;_next-&gt;_next;</span><br><span class="line">        //队列中只有一个元素</span><br><span class="line">        if(temp == _rear)</span><br><span class="line">        &#123;</span><br><span class="line">            _rear = _head;</span><br><span class="line">        &#125;</span><br><span class="line">        delete temp;</span><br><span class="line">        temp = nullptr;</span><br><span class="line">        _size--;</span><br><span class="line">    &#125;</span><br><span class="line">    const T&amp; Front()</span><br><span class="line">    &#123;</span><br><span class="line">        assert(_head-&gt;_next != nullptr);</span><br><span class="line">        return _head-&gt;_next-&gt;_data;</span><br><span class="line">    &#125;</span><br><span class="line">    const T&amp; Back()</span><br><span class="line">    &#123;</span><br><span class="line">        assert(_rear != _head);</span><br><span class="line">        return _rear-&gt;_data;</span><br><span class="line">    &#125;</span><br><span class="line">    size_t Size()</span><br><span class="line">    &#123;</span><br><span class="line">        return _size;</span><br><span class="line">    &#125;</span><br><span class="line">private:</span><br><span class="line">    QueueNode&lt;T&gt;* _head;    //指向头部结点</span><br><span class="line">    QueueNode&lt;T&gt;* _rear;    //指向最后一个元素</span><br><span class="line">    size_t _size;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    Queue&lt;int&gt; que;</span><br><span class="line">    que.Push(1);</span><br><span class="line">    que.Push(2);</span><br><span class="line">    que.Push(3);</span><br><span class="line">    que.Push(4);</span><br><span class="line">    while(!que.Empty())</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; &quot;size = &quot; &lt;&lt; que.Size() &lt;&lt; std::endl;</span><br><span class="line">        std::cout &lt;&lt; que.Front() &lt;&lt; std::endl;</span><br><span class="line">        que.Pop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">size = 4</span><br><span class="line">1</span><br><span class="line">size = 3</span><br><span class="line">2</span><br><span class="line">size = 2</span><br><span class="line">3</span><br><span class="line">size = 1</span><br><span class="line">4</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;以上代码完成了队列的基本功能。</p>
<h3 id="环形队列"><a href="#环形队列" class="headerlink" title="环形队列"></a>环形队列</h3><h4 id="环形队列实现思路"><a href="#环形队列实现思路" class="headerlink" title="环形队列实现思路"></a>环形队列实现思路</h4><p>&emsp;&emsp;环形队列是一种特殊的队列，队列依然保证先进先出的特点，但是在逻辑结构上队列呈一个环状，可以保证在给定的<strong>有限空间</strong>内利用数组实现操作达到<code>O1</code>的队列。其需要用到两个指针，一个指针<code>head</code>指向向队头，一个指针<code>rear</code>指向队尾的后一个位置用来标记当前队列空间的使用情况，如果队满则禁止继续插入。<br>&emsp;&emsp;当插入元素时，将元素插入到队尾指针指向的位置，然后将<code>rear</code>指针后移；当弹出元素时只需将<code>head</code>指针后移即可。但是要注意由于是环形队列，因此当两个指针走到数组末尾时需要做特殊处理让他们重新指回到数组头部。<br>&emsp;&emsp;但是环形队列两个指针的位置都是不固定的，我们又该如何判断队满和队空以及计算数组元素呢？<br><br><img src="/2019/12/14/【DS】第三章-栈和队列/1.png" alt="环形队列"><br></p>
<h4 id="实现-2"><a href="#实现-2" class="headerlink" title="实现"></a>实现</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;assert.h&gt;</span><br><span class="line"></span><br><span class="line">template&lt;class T&gt;</span><br><span class="line">class CircleQueue</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    CircleQueue(size_t capacity)</span><br><span class="line">        :_arr(nullptr)</span><br><span class="line">        ,_head(0)</span><br><span class="line">        ,_rear(0)</span><br><span class="line">        ,_capacity(capacity)</span><br><span class="line">    &#123;</span><br><span class="line">        assert(capacity &gt;= 2);</span><br><span class="line">        _arr = new T[_capacity];</span><br><span class="line">    &#125;</span><br><span class="line">    ~CircleQueue()</span><br><span class="line">    &#123;</span><br><span class="line">        delete _arr;</span><br><span class="line">        _arr = nullptr;</span><br><span class="line">    &#125;</span><br><span class="line">    //判断满</span><br><span class="line">    bool IsFull()</span><br><span class="line">    &#123;</span><br><span class="line">        if((_rear + 1) % _capacity == _head)</span><br><span class="line">        &#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    ///判断空</span><br><span class="line">    bool IsEmpty()</span><br><span class="line">    &#123;</span><br><span class="line">        if(_head == _rear)</span><br><span class="line">        &#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    bool Push(const T&amp; data)</span><br><span class="line">    &#123;</span><br><span class="line">        if(IsFull())</span><br><span class="line">        &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        _arr[_rear] = data;</span><br><span class="line">        _rear = (_rear + 1) % _capacity; </span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    bool Pop()</span><br><span class="line">    &#123;</span><br><span class="line">        if(IsEmpty())</span><br><span class="line">        &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        _head = (_head + 1) % _capacity;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    const T&amp; Front()</span><br><span class="line">    &#123;</span><br><span class="line">        assert(!IsEmpty());</span><br><span class="line">        return _arr[_head];</span><br><span class="line">    &#125;</span><br><span class="line">    const T&amp; Back()</span><br><span class="line">    &#123;</span><br><span class="line">        assert(!IsEmpty());</span><br><span class="line">        size_t temp = (_rear + _capacity - 1) % _capacity;</span><br><span class="line">        return _arr[temp];</span><br><span class="line">    &#125;</span><br><span class="line">    size_t Capacity()</span><br><span class="line">    &#123;</span><br><span class="line">        return _capacity;</span><br><span class="line">    &#125;</span><br><span class="line">    size_t Size()</span><br><span class="line">    &#123;</span><br><span class="line">        return (_rear + _capacity - _head) % _capacity;</span><br><span class="line">    &#125;</span><br><span class="line">private:</span><br><span class="line">    T* _arr;            //存储环形队列的数组</span><br><span class="line">    size_t _head;       //指向队头</span><br><span class="line">    size_t _rear;       //指向队尾</span><br><span class="line">    size_t _capacity;   //环形队列的总容量，一旦确定不可再改变</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    CircleQueue&lt;int&gt; circleQueue(5);</span><br><span class="line">    circleQueue.Push(1);</span><br><span class="line">    circleQueue.Push(2);</span><br><span class="line">    circleQueue.Push(3);</span><br><span class="line">    circleQueue.Push(4);</span><br><span class="line">    circleQueue.Push(5);</span><br><span class="line">    while(!circleQueue.IsEmpty())</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; &quot;size = &quot; &lt;&lt; circleQueue.Size() &lt;&lt; std::endl;</span><br><span class="line">        std::cout &lt;&lt; circleQueue.Front() &lt;&lt; std::endl;</span><br><span class="line">        circleQueue.Pop();</span><br><span class="line">    &#125;</span><br><span class="line">    //std::cout &lt;&lt; circleQueue.Front() &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">size = 4</span><br><span class="line">1</span><br><span class="line">size = 3</span><br><span class="line">2</span><br><span class="line">size = 2</span><br><span class="line">3</span><br><span class="line">size = 1</span><br><span class="line">4</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;以上实现了环形队列的基本功能。</p>

          
        
      
    </div>
    
    
    

    

    <div>
    
    </div>

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/12/02/【项目】文章相似度检索工具/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="MisakiFx">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/blog-logo.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Misaki`s blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/12/02/【项目】文章相似度检索工具/" itemprop="url">【项目】文章相似度检索工具</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-12-02T16:43:42+08:00">
                2019-12-02
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/项目/" itemprop="url" rel="index">
                    <span itemprop="name">项目</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  2.2k
                </span>
              

              

              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="文章相似度检索工具"><a href="#文章相似度检索工具" class="headerlink" title="文章相似度检索工具"></a>文章相似度检索工具</h1><h2 id="开发环境"><a href="#开发环境" class="headerlink" title="开发环境"></a>开发环境</h2><p>&emsp;&emsp;基于Windows操作系统，使用vs进行开发。</p>
<h2 id="项目介绍"><a href="#项目介绍" class="headerlink" title="项目介绍"></a>项目介绍</h2><h3 id="功能介绍"><a href="#功能介绍" class="headerlink" title="功能介绍"></a>功能介绍</h3><p>&emsp;&emsp;本项目实现的是一个根据词频获取两篇文章相似度的工具。文本相似度检索经常使用在文本聚类，文本分类，文本挖掘，信息检索上，像是常见的论文查重工具也都是基于文本相似度进行检索分析的。<br>&emsp;&emsp;本项目分别利用相对词频，tf-idf计算两篇文章的相似度，计算结果较为可靠。</p>
<h3 id="检索原理"><a href="#检索原理" class="headerlink" title="检索原理"></a>检索原理</h3><p>&emsp;&emsp;基于词频进行文本相似度的检索需要统计词频，构建词频特征向量，利用特征向量夹角余弦来表示文本相似度。步骤可以概括为：<strong>分词-&gt;统计词频-&gt;词频向量-&gt;相似度计算</strong>。<br>&emsp;&emsp;分词是中文检索要加上的特殊的环节，中文不像英文词之间有空格作为间隔，中文是连贯的，为了词频统计我们需要将其按照语义进行分词。<br>&emsp;&emsp;分词的原理也较为复杂，这里给出一篇讲解分词原理的博客。<br><a href="https://www.cnblogs.com/BaiYiShaoNian/p/5071802.html" target="_blank" rel="noopener">https://www.cnblogs.com/BaiYiShaoNian/p/5071802.html</a><br>&emsp;&emsp;接下来统计词频。但在统计次品的时候要注意不计算<strong>停用词</strong>的词频。停用词是指<strong>没有什么实际含义的词</strong>，例如：数字，标点，代词，语气助词，副词，介词，连接词等。我们要先去除文章中的停用词，再统计词频。词频即为单词在文章中出现的次数，词频越大一般可认为该词越重要。<br>&emsp;&emsp;构建词频向量需要对词进行编码，确定统计出来的向量的每一维都该表示相同的词的词频，这样构建出来的向量才有意义。把两个文本中的所有有效词全部编码，对于长文本可以按词频从大到小排序，取前n个关键词，再按照编码构建词频向量。<br>&emsp;&emsp;最后计算向量相似度。这里可以使用欧几里得距离，余弦相似度，曼哈顿距离等来计算。我这里通过余弦相似度来进行计算。公式为：<code>cos(θ) = (A * B) / (||A|| * ||B||)</code>。<br>&emsp;&emsp;计算文本相似度过程举例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">文本1：今天有事，没办法去学校上课了。</span><br><span class="line">文本2：真想去学校上课，但是今天有事，去不了学校了。</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;分词后：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">文本1：今天/有事/，/没办法/去/学校/上课/了。</span><br><span class="line">文本2：真想/去/学校/上课/，/但是/今天/有事/，/去不了/学校/了。</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;去掉停用词后统计有效词的词频：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">文本1：有事：1，没办法：1，去：1，学校：1，上课：1</span><br><span class="line">文本2：真想：1，去：1，学校：2，上课：1，有事：1，去不了：1</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;提取所有有效词：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">学校，去，真想，上课，有事，去不了，没办法</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;对有效词进行编码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">学校：0，去：1，真想：2，上课：3，有事：4，去不了：5，没办法：6</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;根据编码构建两个文本的词频向量：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">文档1的词频：&#123;[0 : 1], [1 : 1], [2, 0], [3 : 1], [4 : 1], [5 : 0], [6 : 1]&#125;</span><br><span class="line">文档2的词频：&#123;[0 : 2], [1 : 1], [2 : 1], [3 : 1], [4 : 1], [5 : 1], [6 : 0]&#125;</span><br><span class="line">文档1词频向量：&#123;1, 1, 0, 1, 1, 0, 1&#125;</span><br><span class="line">文档2词频向量：&#123;2, 1, 1, 1, 1, 1, 0&#125;</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;最后计算向量相似度即可。</p>
<h3 id="功能模块"><a href="#功能模块" class="headerlink" title="功能模块"></a>功能模块</h3><h4 id="分词模块"><a href="#分词模块" class="headerlink" title="分词模块"></a>分词模块</h4><p>&emsp;&emsp;分词模块主要利用github上的开源工具<code>结巴分词</code>完成分词工作，其可以将文本内容按照词义分成词组放到<code>vector</code>中。但是要注意<code>结巴分词</code>只支持UTF8编码，而Windows上默认使用GBK编码因此中间我们要想对读取到的文本进行一次转码操作。</p>
<h4 id="词频获取模块"><a href="#词频获取模块" class="headerlink" title="词频获取模块"></a>词频获取模块</h4><p>&emsp;&emsp;词频获取即遍历分词后的<code>vector</code>统计词语出现次数即可，注意这里还要过滤掉没有用的停用词。但是这样统计出的词频知识绝对词频，在两篇长度差距较大的文章中可信度角度，因此在这个模块中我将<code>绝对词频 / 总词数 = 相对词频</code>得出相对词频，相对词频可以提高词频可靠性。同时为了进一步提高可靠度我利用<code>tf-idf</code>算法二次统计词频。<code>tf-idf = tf * idf</code>，其中<code>idf</code>为逆文档率，它表示每一个词重要性的权重，一个词越少见它的值越大，反之越小。这样的词频统计方法是经过大数据分析后的产物，因此可靠程度更高。</p>
<h4 id="排序编码模块"><a href="#排序编码模块" class="headerlink" title="排序编码模块"></a>排序编码模块</h4><p>&emsp;&emsp;要获取词频向量要先对其进行编码，但是我们不能将文章中所有此都作为编码构建向量，因为那样的向量太长了且没有针对性，因此我选择对两篇文章中出现频率最高的前n个词进行提取，最后根据去重后的n个词进行编码再构建词频向量。<br>&emsp;&emsp;这里需要先对每篇文章中统计好的词频根据词频大小进行排序，得出前n个出现频率最高的词，再将其放到一个容器中进行去重，去重我们可以选择使用<code>set</code>容器，去重后<code>set</code>中词就是我们需要构建词频向量的码值。</p>
<h4 id="构建词频向量及计算相似度模块"><a href="#构建词频向量及计算相似度模块" class="headerlink" title="构建词频向量及计算相似度模块"></a>构建词频向量及计算相似度模块</h4><p>&emsp;&emsp;对两种的两种词频分别构建好码值后，对两篇文章依次利用码值和统计好的词频构建词频向量，构建好词频向量后分别计算两种词频向量的余弦相似度，得出结果。</p>
<h4 id="文件配置模块"><a href="#文件配置模块" class="headerlink" title="文件配置模块"></a>文件配置模块</h4><p>&emsp;&emsp;检索工具有两种使用模式，我们可以在命令行通过参数直接给入字典位置，两个文章路径直接使用，也可以通过编写配置文件的方式进行使用，配置文件的路径需要在参数中提交。<br>&emsp;&emsp;配置文件中可以配置两篇文章获取码值的大小，字典路径，文件路径等。</p>
<h2 id="项目效果预览"><a href="#项目效果预览" class="headerlink" title="项目效果预览"></a>项目效果预览</h2><p>&emsp;&emsp;文章相似度检索。<br><br><img src="/2019/12/02/【项目】文章相似度检索工具/1.png" alt="相似度检索"><br><br><img src="/2019/12/02/【项目】文章相似度检索工具/2.png" alt="相似度检索"><br><br><img src="/2019/12/02/【项目】文章相似度检索工具/3.png" alt="相似度检索"><br></p>
<h2 id="项目中遇到的问题"><a href="#项目中遇到的问题" class="headerlink" title="项目中遇到的问题"></a>项目中遇到的问题</h2><h3 id="编码转换"><a href="#编码转换" class="headerlink" title="编码转换"></a>编码转换</h3><p>&emsp;&emsp;在使用分词工具时发现分词工具无法达到满意的效果，无法将词合理的提取，在网上看了官方说明后发现其仅支持UTF8编码，而Windows默认GBK编码，因此其之间必须进行转码才能协同工作。而转码工作需要用的系统函数，并不能直接从GBK转换至UTF8，需要用宽字符也就是UTF16作为桥梁才能进行转换。转码的编写让我了解了Windows下转码的接口以及宽字符和多字节编码转换的应用。</p>
<h3 id="相对词频"><a href="#相对词频" class="headerlink" title="相对词频"></a>相对词频</h3><p>&emsp;&emsp;一开始项目利用绝对词频作为词频统计，但是发现如果两篇文章长度有极大差别的情况下，相似度的计算并不准确，于是我考虑计算出相对词频作为依据再进行统计。<br>&emsp;&emsp;为了进一步提高准确率我又在网上学习了<code>idf</code>逆文档率的作用，从而通过相对词频和<code>tf-idf</code>两种依据计算文章相似度，提高准确率。</p>
<h2 id="项目扩展方向"><a href="#项目扩展方向" class="headerlink" title="项目扩展方向"></a>项目扩展方向</h2><h3 id="文章查重"><a href="#文章查重" class="headerlink" title="文章查重"></a>文章查重</h3><p>&emsp;&emsp;目前工具仅可以比较两篇文章之间的相似度，而在实际应用中我们往往要比较多篇文章之间的相似度，例如在文章查重的使用上。接下来项目可以进一步扩展为可以查取多篇文章之间的重复度，并且反馈给用户，为了查取效率我们可以开启多线程进行并行查取。在查重后我们还可以显示相似度较高的几组文章，对用户进行提醒，也可以筛选出相似度最高的两篇文章。</p>
<h3 id="文章归纳"><a href="#文章归纳" class="headerlink" title="文章归纳"></a>文章归纳</h3><p>&emsp;&emsp;对所给文章依次比较得出相似度，相似度较高的文章可以归纳为一类文章，同时我们还可以通过<code>idf</code>得出文章的关键字，以此为依据对文章进行归纳整理，从而可以将其扩展为一个文章归纳工具。</p>
<h2 id="项目发布"><a href="#项目发布" class="headerlink" title="项目发布"></a>项目发布</h2><p>&emsp;&emsp;GitHub:<a href="https://github.com/MisakiFx/ASS-Tool" target="_blank" rel="noopener">https://github.com/MisakiFx/ASS-Tool</a></p>

          
        
      
    </div>
    
    
    

    

    <div>
    
    </div>

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/11/10/【Cpp】第十九章-Cpp11新特性/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="MisakiFx">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/blog-logo.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Misaki`s blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/11/10/【Cpp】第十九章-Cpp11新特性/" itemprop="url">【Cpp】第十九章-Cpp11新特性</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-11-10T15:49:52+08:00">
                2019-11-10
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Cpp/" itemprop="url" rel="index">
                    <span itemprop="name">Cpp</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  4.7k
                </span>
              

              

              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Cpp11新特性"><a href="#Cpp11新特性" class="headerlink" title="Cpp11新特性"></a>Cpp11新特性</h1><p>&emsp;&emsp;Cpp11中新增了很多新的语法，很多之前我们都已经有介绍过</p>
<h2 id="初始化列表"><a href="#初始化列表" class="headerlink" title="初始化列表"></a>初始化列表</h2><h3 id="如何使用"><a href="#如何使用" class="headerlink" title="如何使用"></a>如何使用</h3><p>&emsp;&emsp;在Cpp11中允许使用初始化列表初始化任何类型，不论是内置类型还是自定义类型都可以使用初始化列表进行初始化，而在Cpp98的版本中是不能初始化自定义类型的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">class Test</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    Test(int a, int b)</span><br><span class="line">        :_a(a)</span><br><span class="line">        ,_b(b)</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    void Print()</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; _a &lt;&lt; &quot; &quot; &lt;&lt; _b &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">private:</span><br><span class="line">    int _a;</span><br><span class="line">    int _b;</span><br><span class="line">&#125;;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    //内置类型的初始化列表初始化</span><br><span class="line">    int a = &#123;10&#125;;</span><br><span class="line">    int b = &#123;3 + 4&#125;;</span><br><span class="line">    std::cout &lt;&lt; a &lt;&lt; &quot; &quot; &lt;&lt; b &lt;&lt; std::endl;</span><br><span class="line">    int arr[] = &#123;1, 2, 3, 4&#125;;</span><br><span class="line">    for(int i = 0; i &lt; sizeof(arr) / sizeof(arr[0]); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; arr[i] &lt;&lt; &quot; &quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line">    //自定义类型初始化列表初始化</span><br><span class="line">    std::vector&lt;int&gt; arr2 = &#123;4, 3, 2, 1&#125;;</span><br><span class="line">    for(auto e : arr2)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; e &lt;&lt; &quot; &quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line">    Test test = &#123;7, 8&#125;;</span><br><span class="line">    test.Print();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">10 7</span><br><span class="line">1 2 3 4</span><br><span class="line">4 3 2 1</span><br><span class="line">7 8</span><br></pre></td></tr></table></figure></p>
<h3 id="initializer-list"><a href="#initializer-list" class="headerlink" title="initializer_list"></a>initializer_list</h3><p>&emsp;&emsp;但是自定义类型想要支持像<code>vector</code>这样的初始化列表并不是天然就支持的，而是在Cpp11中新增了一个容器叫<code>initializer_list</code>，初始化列表，借助这个容器我们可以实现<code>vector</code>这样的初始化。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">class Test</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    Test(int a, int b)</span><br><span class="line">        :_a(a)</span><br><span class="line">        ,_b(b)</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    void Print()</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; _a &lt;&lt; &quot; &quot; &lt;&lt; _b &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">private:</span><br><span class="line">    int _a;</span><br><span class="line">    int _b;</span><br><span class="line">&#125;;</span><br><span class="line">template&lt;class T&gt;</span><br><span class="line">class Vector</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    Vector(size_t n = 0)</span><br><span class="line">        :_start(new T[n])</span><br><span class="line">        ,_finish(_start + n)</span><br><span class="line">        ,_endOfStorge(_start + n)</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    //我们想要使用初始化列表初始化vector多亏下面这样的构造函数</span><br><span class="line">    Vector(const std::initializer_list&lt;T&gt;&amp; list)//初始化列表容器</span><br><span class="line">        :_start(new T[list.size()])</span><br><span class="line">        ,_finish(_start + list.size())</span><br><span class="line">        ,_endOfStorge(_start + list.size())</span><br><span class="line">    &#123;</span><br><span class="line">        //std::initializer_list容器有三个公有接口，start(), end()提供遍历，size()提供大小</span><br><span class="line">        int index = 0;</span><br><span class="line">        for(auto e : list)</span><br><span class="line">        &#123;</span><br><span class="line">            _start[index] = e;</span><br><span class="line">            index++;</span><br><span class="line">        &#125;   </span><br><span class="line">    &#125;</span><br><span class="line">    void Print()</span><br><span class="line">    &#123;</span><br><span class="line">        T* start = _start;</span><br><span class="line">        while(start != _finish)</span><br><span class="line">        &#123;</span><br><span class="line">            std::cout &lt;&lt; *start &lt;&lt; &quot; &quot;;</span><br><span class="line">            start++;</span><br><span class="line">        &#125;</span><br><span class="line">        std::cout &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">private:</span><br><span class="line">    T* _start;</span><br><span class="line">    T* _finish;</span><br><span class="line">    T* _endOfStorge;</span><br><span class="line">&#125;;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    Vector&lt;int&gt; vec = &#123;1, 2, 3, 4, 5&#125;;</span><br><span class="line">    vec.Print();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1 2 3 4 5</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;因此如果我们在自己今后写自定义类型时，想要在初始化时利用初始化列表进行不定长参数的初始化时，就可以借助<code>initializer_list</code>来实现。<br>&emsp;&emsp;如果我们想让一个自定义类型不再支持初始化列表进行初始化我们也可以通过加<code>explicit</code>关键字来禁用。</p>
<h2 id="变量类型推导"><a href="#变量类型推导" class="headerlink" title="变量类型推导"></a>变量类型推导</h2><p>&emsp;&emsp;变量类型推导其中的典型代表就是我们一直在使用的<code>auto</code>关键字，它可以帮助我们简化代码书写，一些很复杂的类型一个<code>auto</code>即可代替，但是<code>auto</code>是编译时类型识别，除此之外还有一个关键字这里要提一下，即<code>decltype</code>，这个关键字我们之前并没有使用过，不过这个关键字是<code>RTTI</code>的，它可以在运行时进行类型识别。<br>&emsp;&emsp;<code>auto</code>和<code>decltype</code>之间最显著的差别就是，<code>auto</code>在编译时就将变量类型确定下来，因此如果我们声明一个变量而不去定义它那么编译器此时就无法识别它的变量类型，因此这是不合法的书写方式，但是<code>decltype</code>却有办法去识别类型。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line"></span><br><span class="line">int fun()</span><br><span class="line">&#123;</span><br><span class="line">    return 10;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    //auto a;//这是不合法的，因为编译器此时无法判断它的类型</span><br><span class="line">    decltype(3 + 1) b;//decltype可以通过推导括号中表达式的类型来定义变量</span><br><span class="line">    std::cout &lt;&lt; typeid(b).name() &lt;&lt; std::endl;//typeid可以识别变量类型，它也以RTTI的思想来实现的</span><br><span class="line">    decltype(fun()) c;</span><br><span class="line">    std::cout &lt;&lt; typeid(c).name() &lt;&lt; std::endl;//typeid可以识别变量类型，它也以RTTI的思想来实现的</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">i</span><br><span class="line">i</span><br></pre></td></tr></table></figure></p>
<h2 id="委派构造函数"><a href="#委派构造函数" class="headerlink" title="委派构造函数"></a>委派构造函数</h2><p>&emsp;&emsp;委派构造函数即在一个类的构造函数中可以调用这个类的其它构造函数。Cpp11之前是不允许这样的语法的，但是在Cpp11中加入了这样的新特性，但是却也带来了问题，就像是下面这样的情况。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line"></span><br><span class="line">class A</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    A()</span><br><span class="line">        :A(10, 20)//无参构造中调用带参构造</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    A(int a, int b)</span><br><span class="line">        :A()//带参构造中调用无参构造</span><br><span class="line">    &#123;</span><br><span class="line">        _a = a;</span><br><span class="line">        _b = b;</span><br><span class="line">    &#125;</span><br><span class="line">private:</span><br><span class="line">    int _a;</span><br><span class="line">    int _b;</span><br><span class="line">&#125;;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    A a;</span><br><span class="line">    std::cout &lt;&lt; &quot;finish&quot; &lt;&lt; std::endl;//这里调用就会出现死递归调用，从而崩掉</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">崩溃</span><br></pre></td></tr></table></figure></p>
<h2 id="默认函数控制"><a href="#默认函数控制" class="headerlink" title="默认函数控制"></a>默认函数控制</h2><p>&emsp;&emsp;默认函数控制可以帮助我们很好的管理一个类中的默认成员函数，控制其是否应该自动生成。我们之前想要禁用拷贝构造，赋值运算符重载往往是将他们的声明放在<code>private</code>中，但是在Cpp11中我们可以这样写。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line"></span><br><span class="line">class A</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    A(int a)</span><br><span class="line">        :_a(a)</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    A(const A&amp; a) = delete;</span><br><span class="line">    A&amp; operator=(const A&amp; a) = delete;</span><br><span class="line">private:</span><br><span class="line">    int _a;</span><br><span class="line">&#125;;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    A a(1);</span><br><span class="line">    //A b(a);//禁用拷贝</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;同时我们也可也让编译器自动帮我们生成默认构造函数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line"></span><br><span class="line">class A</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    A(int a)</span><br><span class="line">        :_a(a)</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    A() = default;//生成默认构造</span><br><span class="line">    A(const A&amp; a) = delete;</span><br><span class="line">    A&amp; operator=(const A&amp; a) = delete;</span><br><span class="line">private:</span><br><span class="line">    int _a;</span><br><span class="line">&#125;;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    A a(1);</span><br><span class="line">    A b;//合法</span><br><span class="line">    //A b(a);//禁用拷贝</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="右值引用"><a href="#右值引用" class="headerlink" title="右值引用"></a>右值引用</h2><h3 id="左值和右值"><a href="#左值和右值" class="headerlink" title="左值和右值"></a>左值和右值</h3><p>&emsp;&emsp;什么是右值呢？在C语言中就有左值和右值的概念，这里简单总结下可以理解为：<br>&emsp;&emsp;1、左值就是可以出现在复制运算符左右两边的值，左值往往是可以取地址的。<br>&emsp;&emsp;2、右值就是只可以出现在赋值运算符右边的值，右值往往不可以取地址。<br>&emsp;&emsp;常见的右值有常量，临时变量和将亡值（即将销毁的值）。</p>
<h3 id="左值引用和右值引用"><a href="#左值引用和右值引用" class="headerlink" title="左值引用和右值引用"></a>左值引用和右值引用</h3><p>&emsp;&emsp;我们之前所使用的引用都是左值引用，左值引用既可以引用左值，也可也引用右值，因为我们可以使用指向常量的引用去引用常量，例如<code>const int&amp; ra = 10;</code>这条语句是合法的。<br>&emsp;&emsp;而右值引用只可以引用右值。例如<code>int&amp;&amp; rra = 10;</code>，此时不需要加<code>const</code>就可以直接引用右值，这就是一条典型的右值引用。，当然右值引用也可也引用临时变量和将亡值。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line"></span><br><span class="line">int fun(int a)</span><br><span class="line">&#123;</span><br><span class="line">    return a;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int a = 10;</span><br><span class="line">    fun(a);</span><br><span class="line">    const int &amp; ra = fun(a);//这里fun(a)返回的是一个临时变量，我们不可以直接使用引用指向它，但是左值引用加上const就可以指向右值</span><br><span class="line">    int&amp;&amp; rra = fun(a);//但是我们如果使用右值引用就可以直接引用临时变量</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="移动语义"><a href="#移动语义" class="headerlink" title="移动语义"></a>移动语义</h3><p>&emsp;&emsp;如果我想要右值引用去引用左值可以么？在Cpp中<strong>移动语义</strong>可以帮助我们完成将一个左值变为右值，从而可以让右值引用去引用它。我们可以通过调用<code>std::move()</code>完成移动语义。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int a = 10;</span><br><span class="line">    int &amp;&amp; ra = std::move(a);//移动语义，将左值改为右值</span><br><span class="line">    const int&amp; rra = std::move(a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="移动构造"><a href="#移动构造" class="headerlink" title="移动构造"></a>移动构造</h3><p>&emsp;&emsp;既然左值引用既可以引用左值也可也引用右值，那还要右值引用有什么用呢？我们先看一下这个例子。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line"></span><br><span class="line">//实现一个简单的string类</span><br><span class="line">class String</span><br><span class="line">&#123;</span><br><span class="line">	friend std::ostream&amp; operator&lt;&lt;(std::ostream&amp; out, const String&amp; str);</span><br><span class="line">public:</span><br><span class="line">	String(const char* str = &quot;&quot;)</span><br><span class="line">		:_str(new char[strlen(str) + 1])</span><br><span class="line">	&#123;</span><br><span class="line">		strcpy(_str, str);</span><br><span class="line">		std::cout &lt;&lt; &quot;String(char* str = )&quot; &lt;&lt; std::endl;</span><br><span class="line">	&#125;</span><br><span class="line">	String(const String&amp; s)</span><br><span class="line">		:_str(new char[strlen(s._str) + 1])</span><br><span class="line">	&#123;</span><br><span class="line">		strcpy(_str, s._str);</span><br><span class="line">		std::cout &lt;&lt; &quot;String(const String&amp; s)&quot; &lt;&lt; std::endl;</span><br><span class="line">	&#125;</span><br><span class="line">	String&amp; operator=(const String&amp; s)</span><br><span class="line">	&#123;</span><br><span class="line">		if (this != &amp;s)</span><br><span class="line">		&#123;</span><br><span class="line">			char* temp = _str;</span><br><span class="line">			_str = new char[strlen(s._str) + 1];</span><br><span class="line">			strcpy(_str, s._str);</span><br><span class="line">			delete[] temp;</span><br><span class="line">		&#125;</span><br><span class="line">		return *this;</span><br><span class="line">	&#125;</span><br><span class="line">	~String()</span><br><span class="line">	&#123;</span><br><span class="line">		delete[] _str;</span><br><span class="line">	&#125;</span><br><span class="line">private:</span><br><span class="line">	char* _str;</span><br><span class="line">&#125;;</span><br><span class="line">std::ostream&amp; operator&lt;&lt;(std::ostream&amp; out, const String&amp; str)</span><br><span class="line">&#123;</span><br><span class="line">	out &lt;&lt; str._str;</span><br><span class="line">	return out;</span><br><span class="line">&#125;</span><br><span class="line">String getString(const char* str)</span><br><span class="line">&#123;</span><br><span class="line">	String temp(str);</span><br><span class="line">	return temp;</span><br><span class="line">&#125;</span><br><span class="line">void test()</span><br><span class="line">&#123;</span><br><span class="line">	String str = getString(&quot;Misaki&quot;);</span><br><span class="line">	std::cout &lt;&lt; str &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	test();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">String(char* str = )</span><br><span class="line">String(const String&amp; s)</span><br><span class="line">Misaki</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;这个例子中细心的同学会发现，在这个例子中其实会生成三个对象。首先有参构造一个，然后由于我们的函数返回值返回对象，于是拷贝构造临时对象，然后再用临时对象拷贝构造最终我们需要的<code>str</code>对象，于是会发生依次构造，两次拷贝构造，但是由于编译器的优化会帮我们减少为一次构造一次拷贝构造（如果是更厉害的编译器会直接优化成一次构造，比如<code>MinGW</code>，为此为了演示我换上了<code>vs</code>），但是仍然有多余的损耗，因为我们为了构造<code>str</code>而构造了<code>temp</code>，<code>temp</code>构造后是一个将亡值，随后很快会进行释放，紧接着我们用它构造<code>str</code>又开辟了新的空间，为了构造<code>str</code>我们先释放了<code>temp</code>的空间又重新为<code>str</code>开辟了空间，尽管他们空间中的内容应该是一样的。所以这是多次一举的行为，十分低效。<br>&emsp;&emsp;那么有没有一种办法可以让我们的<code>str</code>直接利用<code>temp</code>开辟好的空间，而不再多此一举自己重新开辟空间呢？这样的做法明显是更加高效的，答案是有的。在Cpp11中由于右值引用的出现，于是出现了<strong>移动构造</strong>，即利用右值引用进行构造。这里右值引用的多是一个将亡值，即即将释放资源的值，既然他们的资源即将要释放，而我们构造新对象所需要的资源刚好和他们要释放的资源一样，那不如直接把他们的资源拿来用。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line"></span><br><span class="line">//实现一个简单的string类</span><br><span class="line">class String</span><br><span class="line">&#123;</span><br><span class="line">	friend std::ostream&amp; operator&lt;&lt;(std::ostream&amp; out, const String&amp; str);</span><br><span class="line">public:</span><br><span class="line">	String(const char* str = &quot;&quot;)</span><br><span class="line">		:_str(new char[strlen(str) + 1])</span><br><span class="line">	&#123;</span><br><span class="line">		strcpy(_str, str);</span><br><span class="line">		std::cout &lt;&lt; &quot;String(char* str = )&quot; &lt;&lt; std::endl;</span><br><span class="line">	&#125;</span><br><span class="line">	String(const String&amp; s)</span><br><span class="line">		:_str(new char[strlen(s._str) + 1])</span><br><span class="line">	&#123;</span><br><span class="line">		strcpy(_str, s._str);</span><br><span class="line">		std::cout &lt;&lt; &quot;String(const String&amp; s)&quot; &lt;&lt; std::endl;</span><br><span class="line">	&#125;</span><br><span class="line">	//移动构造</span><br><span class="line">	String(String&amp;&amp; s)</span><br><span class="line">		:_str(s._str)</span><br><span class="line">	&#123;</span><br><span class="line">		s._str = nullptr;//这里一定要记着将将亡值的原本指针置空，否则会把我们拿来用的资源释放了</span><br><span class="line">		std::cout &lt;&lt; &quot;String(String&amp;&amp; s)&quot; &lt;&lt; std::endl;</span><br><span class="line">	&#125;</span><br><span class="line">	String&amp; operator=(const String&amp; s)</span><br><span class="line">	&#123;</span><br><span class="line">		if (this != &amp;s)</span><br><span class="line">		&#123;</span><br><span class="line">			char* temp = _str;</span><br><span class="line">			_str = new char[strlen(s._str) + 1];</span><br><span class="line">			strcpy(_str, s._str);</span><br><span class="line">			delete[] temp;</span><br><span class="line">		&#125;</span><br><span class="line">		return *this;</span><br><span class="line">	&#125;</span><br><span class="line">	~String()</span><br><span class="line">	&#123;</span><br><span class="line">		delete[] _str;</span><br><span class="line">	&#125;</span><br><span class="line">private:</span><br><span class="line">	char* _str;</span><br><span class="line">&#125;;</span><br><span class="line">std::ostream&amp; operator&lt;&lt;(std::ostream&amp; out, const String&amp; str)</span><br><span class="line">&#123;</span><br><span class="line">	out &lt;&lt; str._str;</span><br><span class="line">	return out;</span><br><span class="line">&#125;</span><br><span class="line">String getString(const char* str)</span><br><span class="line">&#123;</span><br><span class="line">	String temp(str);</span><br><span class="line">	return temp;</span><br><span class="line">&#125;</span><br><span class="line">void test()</span><br><span class="line">&#123;</span><br><span class="line">	String str = getString(&quot;Misaki&quot;);</span><br><span class="line">	std::cout &lt;&lt; str &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	test();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">String(char* str = )</span><br><span class="line">String(String&amp;&amp; s)</span><br><span class="line">Misaki</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;这里编译器判断<code>temp</code>是一个右值，自动调用了移动构造，移动构造中所做的事情就是将即将释放的资源直接拿来给新创建的对象使用，于是省掉了一次先释放空间再申请空间的过程。移动构造可以提升代码效率，减少拷贝。</p>
<h3 id="移动赋值"><a href="#移动赋值" class="headerlink" title="移动赋值"></a>移动赋值</h3><p>&emsp;&emsp;有移动构造就有移动赋值。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line"></span><br><span class="line">//实现一个简单的string类</span><br><span class="line">class String</span><br><span class="line">&#123;</span><br><span class="line">	friend std::ostream&amp; operator&lt;&lt;(std::ostream&amp; out, const String&amp; str);</span><br><span class="line">public:</span><br><span class="line">	String(const char* str = &quot;&quot;)</span><br><span class="line">		:_str(new char[strlen(str) + 1])</span><br><span class="line">	&#123;</span><br><span class="line">		strcpy(_str, str);</span><br><span class="line">		std::cout &lt;&lt; &quot;String(char* str = )&quot; &lt;&lt; std::endl;</span><br><span class="line">	&#125;</span><br><span class="line">	String(const String&amp; s)</span><br><span class="line">		:_str(new char[strlen(s._str) + 1])</span><br><span class="line">	&#123;</span><br><span class="line">		strcpy(_str, s._str);</span><br><span class="line">		std::cout &lt;&lt; &quot;String(const String&amp; s)&quot; &lt;&lt; std::endl;</span><br><span class="line">	&#125;</span><br><span class="line">	//移动构造</span><br><span class="line">	String(String&amp;&amp; s)</span><br><span class="line">		:_str(s._str)</span><br><span class="line">	&#123;</span><br><span class="line">		s._str = nullptr;//这里一定要记着将将亡值的原本指针置空，否则会把我们拿来用的资源释放了</span><br><span class="line">		std::cout &lt;&lt; &quot;String(String&amp;&amp; s)&quot; &lt;&lt; std::endl;</span><br><span class="line">	&#125;</span><br><span class="line">	String&amp; operator=(const String&amp; s)</span><br><span class="line">	&#123;</span><br><span class="line">		if (this != &amp;s)</span><br><span class="line">		&#123;</span><br><span class="line">			char* temp = _str;</span><br><span class="line">			_str = new char[strlen(s._str) + 1];</span><br><span class="line">			strcpy(_str, s._str);</span><br><span class="line">			delete[] temp;</span><br><span class="line">		&#125;</span><br><span class="line">		return *this;</span><br><span class="line">	&#125;</span><br><span class="line">	//移动赋值</span><br><span class="line">	String&amp; operator=(String&amp;&amp; s)</span><br><span class="line">	&#123;</span><br><span class="line">		if (this != &amp;s)</span><br><span class="line">		&#123;</span><br><span class="line">			char* temp = _str;</span><br><span class="line">			_str = s._str;</span><br><span class="line">			s._str = temp;</span><br><span class="line">			std::cout &lt;&lt; &quot;String&amp; operator=(String&amp;&amp;)&quot; &lt;&lt; std::endl;</span><br><span class="line">		&#125;</span><br><span class="line">		return *this;</span><br><span class="line">	&#125;</span><br><span class="line">	~String()</span><br><span class="line">	&#123;</span><br><span class="line">		delete[] _str;</span><br><span class="line">	&#125;</span><br><span class="line">private:</span><br><span class="line">	char* _str;</span><br><span class="line">&#125;;</span><br><span class="line">std::ostream&amp; operator&lt;&lt;(std::ostream&amp; out, const String&amp; str)</span><br><span class="line">&#123;</span><br><span class="line">	out &lt;&lt; str._str;</span><br><span class="line">	return out;</span><br><span class="line">&#125;</span><br><span class="line">String getString(const char* str)</span><br><span class="line">&#123;</span><br><span class="line">	String temp(str);</span><br><span class="line">	return temp;</span><br><span class="line">&#125;</span><br><span class="line">void test()</span><br><span class="line">&#123;</span><br><span class="line">	String str = getString(&quot;Misaki&quot;);</span><br><span class="line">	str = String(&quot;misaki&quot;);</span><br><span class="line">	std::cout &lt;&lt; str &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	test();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">String(char* str = )</span><br><span class="line">String(String&amp;&amp; s)</span><br><span class="line">String(char* str = )</span><br><span class="line">String&amp; operator=(String&amp;&amp;)</span><br><span class="line">misaki</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;我们在写移动构造和移动赋值的时候要注意如果一个类中有自定义类型成员，我们也应该让他们进行移动构造或移动赋值，可以通过移动语义将内部成员从左值转换为右值从而调用他们的移动构造或移动赋值。</p>
<h3 id="完美转发"><a href="#完美转发" class="headerlink" title="完美转发"></a>完美转发</h3><p>&emsp;&emsp;我们看下面一段代码。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line"></span><br><span class="line">void Fun(int&amp; x)</span><br><span class="line">&#123;</span><br><span class="line">    std::cout &lt;&lt; &quot;lvalue ref&quot; &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line">void Fun(const int&amp; x)</span><br><span class="line">&#123;</span><br><span class="line">    std::cout &lt;&lt; &quot;const lvalue ref&quot; &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line">void Fun(int&amp;&amp; x)</span><br><span class="line">&#123;</span><br><span class="line">    std::cout &lt;&lt; &quot;rvalue ref&quot; &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line">void Fun(const int&amp;&amp; x)</span><br><span class="line">&#123;</span><br><span class="line">    std::cout &lt;&lt; &quot;const rvalue ref&quot; &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line">template&lt;class T&gt;</span><br><span class="line">void PerfectForward(T t)</span><br><span class="line">&#123;</span><br><span class="line">    Fun(t);</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    PerfectForward(10);//rvalue ref</span><br><span class="line">    int a = 10;</span><br><span class="line">    PerfectForward(a);//lvalue refj</span><br><span class="line">    PerfectForward(std::move(a));//rvalue ref</span><br><span class="line">    const int b = 8;</span><br><span class="line">    PerfectForward(b);//const lvalue ref</span><br><span class="line">    PerfectForward(std::move(b));//const rvalue ref</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">lvalue ref</span><br><span class="line">lvalue ref</span><br><span class="line">lvalue ref</span><br><span class="line">lvalue ref</span><br><span class="line">lvalue ref</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;我们明明传入了不同的类型进入函数模板，本应该产生不同的结果，为什么进到函数模板中就全部变成了左值引用呢？<br>&emsp;&emsp;这里就是在我们把值传递进函数模板时编译器会将所有值的属性全部更改为左值。那么有没有办法让值在传递过程中属性不发生改变呢？这里就要用到<strong>完美转发</strong>，来让值的属性不变。在使用完美转发之前我们还要直到一点，在模板中，自定义类型加<code>&amp;&amp;</code>表示未定义类型，表示传入模板的是什么类型参数，此时就使用什么类型的参数，例如下面这样。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line"></span><br><span class="line">void Fun(int&amp; x)</span><br><span class="line">&#123;</span><br><span class="line">    std::cout &lt;&lt; &quot;lvalue ref&quot; &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line">void Fun(const int&amp; x)</span><br><span class="line">&#123;</span><br><span class="line">    std::cout &lt;&lt; &quot;const lvalue ref&quot; &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line">void Fun(int&amp;&amp; x)</span><br><span class="line">&#123;</span><br><span class="line">    std::cout &lt;&lt; &quot;rvalue ref&quot; &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line">void Fun(const int&amp;&amp; x)</span><br><span class="line">&#123;</span><br><span class="line">    std::cout &lt;&lt; &quot;const rvalue ref&quot; &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line">template&lt;class T&gt;</span><br><span class="line">void PerfectForward(T&amp;&amp; t)//在模板中这里不是右值引用，代表未定义类型</span><br><span class="line">&#123;</span><br><span class="line">    Fun(t);</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    PerfectForward(10);//rvalue ref</span><br><span class="line">    int a = 10;</span><br><span class="line">    PerfectForward(a);//lvalue refj</span><br><span class="line">    PerfectForward(std::move(a));//rvalue ref</span><br><span class="line">    const int b = 8;</span><br><span class="line">    PerfectForward(b);//const lvalue ref</span><br><span class="line">    PerfectForward(std::move(b));//const rvalue ref</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">lvalue ref</span><br><span class="line">lvalue ref</span><br><span class="line">lvalue ref</span><br><span class="line">const lvalue ref</span><br><span class="line">const lvalue ref</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;但是至此结果还是不对，于是我们再加上完美转发。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line"></span><br><span class="line">void Fun(int&amp; x)</span><br><span class="line">&#123;</span><br><span class="line">    std::cout &lt;&lt; &quot;lvalue ref&quot; &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line">void Fun(const int&amp; x)</span><br><span class="line">&#123;</span><br><span class="line">    std::cout &lt;&lt; &quot;const lvalue ref&quot; &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line">void Fun(int&amp;&amp; x)</span><br><span class="line">&#123;</span><br><span class="line">    std::cout &lt;&lt; &quot;rvalue ref&quot; &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line">void Fun(const int&amp;&amp; x)</span><br><span class="line">&#123;</span><br><span class="line">    std::cout &lt;&lt; &quot;const rvalue ref&quot; &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line">template&lt;class T&gt;</span><br><span class="line">void PerfectForward(T&amp;&amp; t)//在模板中这里不是右值引用，代表未定义类型</span><br><span class="line">&#123;</span><br><span class="line">    Fun(std::forward&lt;T&gt;(t));</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    PerfectForward(10);//rvalue ref</span><br><span class="line">    int a = 10;</span><br><span class="line">    PerfectForward(a);//lvalue refj</span><br><span class="line">    PerfectForward(std::move(a));//rvalue ref</span><br><span class="line">    const int b = 8;</span><br><span class="line">    PerfectForward(b);//const lvalue ref</span><br><span class="line">    PerfectForward(std::move(b));//const rvalue ref</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">rvalue ref</span><br><span class="line">lvalue ref</span><br><span class="line">rvalue ref</span><br><span class="line">const lvalue ref</span><br><span class="line">const rvalue ref</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;至此结果就正确了，完美转发可以帮助我们保证值在参数传递过程中属性不会改变。</p>
<h2 id="lambda表达式"><a href="#lambda表达式" class="headerlink" title="lambda表达式"></a>lambda表达式</h2><p>&emsp;&emsp;<code>lambda表达式</code>是为了方便我们传入回调函数的语法。之前我们在传入回调函数时往往是利用仿函数，传入一个对象，随后在方法内通过调用对象的<code>operator()</code>来回调函数，但是在Cpp11中为了更加方便我们书写回调函数，加入了<code>lambda</code>表达式。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    std::vector&lt;int&gt; arr = &#123;1, 10, 3, 4, 5, 2, 5, 7&#125;;</span><br><span class="line">    std::sort(arr.begin(), arr.end(), std::less&lt;int&gt;());//通过仿函数的方式传入，从小到大排序</span><br><span class="line">    for(auto e : arr)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; e &lt;&lt; &quot; &quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line">    std::sort(arr.begin(), arr.end(), //lambda表达式传入</span><br><span class="line">        [](int a, int b)-&gt;bool</span><br><span class="line">        &#123;</span><br><span class="line">            return a &gt; b;</span><br><span class="line">        &#125;</span><br><span class="line">    );</span><br><span class="line">    for(auto e : arr)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; e &lt;&lt; &quot; &quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1 2 3 4 5 5 7 10</span><br><span class="line">10 7 5 5 4 3 2 1</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;<code>lambda表达式</code>就是一个匿名函数，可以分为以下几个部分：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[]:捕捉列表</span><br><span class="line">():参数列表</span><br><span class="line">-&gt;:返回值</span><br><span class="line">&#123;&#125;:函数体</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;捕捉列表或许是比较特殊的一个部分，我们可以通过它来捕捉外层作用域内的变量。<code>[=]</code>表示以值得形式捕捉外部作用域内所有变量；<code>[a, b]</code>表示以值的形式捕捉<code>a,b</code>变量；<code>[&amp;]</code>表示以引用的形式获取外部所有变量；<code>[this]</code>表示获取成员变量的<code>this</code>指针，只能在成员函数内部使用。捕捉到的变量可以直接在函数内部使用。<br>&emsp;&emsp;我们默认从外部捕捉的变量都是<code>const</code>的，不可修改，要想修改外部捕获进来的值，需要在参数列表后面加<code>mutable</code>关键字。<br>&emsp;&emsp;<code>lambda表达式</code>的返回值和参数部分都可以省略掉，因此<code>[]{}</code>也可以看作是一个<code>lambda表达式</code>。</p>

          
        
      
    </div>
    
    
    

    

    <div>
    
    </div>

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/11/06/【Cpp】第十八章-空间配置器/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="MisakiFx">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/blog-logo.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Misaki`s blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/11/06/【Cpp】第十八章-空间配置器/" itemprop="url">【Cpp】第十八章-空间配置器</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-11-06T20:41:05+08:00">
                2019-11-06
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Cpp/" itemprop="url" rel="index">
                    <span itemprop="name">Cpp</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  1.5k
                </span>
              

              

              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="空间配置器"><a href="#空间配置器" class="headerlink" title="空间配置器"></a>空间配置器</h1><h2 id="什么是空间配置器"><a href="#什么是空间配置器" class="headerlink" title="什么是空间配置器"></a>什么是空间配置器</h2><p>&emsp;&emsp;空间配置器是为各个容器高效管理空间的工具，负责空间的申请与回收，虽然一般情况下我们用不到它，但是研究空间配置器可以让我们对STL有更深的理解。</p>
<h2 id="为什么需要空间配置器"><a href="#为什么需要空间配置器" class="headerlink" title="为什么需要空间配置器"></a>为什么需要空间配置器</h2><p>&emsp;&emsp;我们之前在实现各个容器的时候，需要申请空间大的地方都是通过<code>new</code>申请的，但是这样的申请方式有着很大的缺陷：<br>&emsp;&emsp;1、空间申请和释放需要自己管理，容易造成内存泄露。<br>&emsp;&emsp;2、频繁向系统申请小块内存，造成内存碎片。<br>&emsp;&emsp;3、频繁向系统申请内存，影响程序效率。<br>&emsp;&emsp;4、无法应对申请空间失败的情况。<br>&emsp;&emsp;5、代码复用度不高。<br>&emsp;&emsp;6、代码韧性较差。<br>&emsp;&emsp;7、没有考虑线程安全的问题。</p>
<h2 id="空间配置器实现原理"><a href="#空间配置器实现原理" class="headerlink" title="空间配置器实现原理"></a>空间配置器实现原理</h2><p>&emsp;&emsp;以上所说的不足，主要原因就是<strong>程序频繁向操作系统申请小块内存</strong>导致的。在SGI-STL中以128字节作为小块内存和大块内存的分界线，同时也将空间配置器分为两级结构。一级空间配置器处理大块内存，二级空间配置器处理小块内存。</p>
<h3 id="一级空间配置器"><a href="#一级空间配置器" class="headerlink" title="一级空间配置器"></a>一级空间配置器</h3><p>&emsp;&emsp;以及空间配置器的实现较为简单，它主要是对<code>malloc</code>和<code>free</code>进行了一层封装，和我们曾经说过的<code>new</code>和<code>delete</code>的实现类似，其封装具体添加的内容主要是用来处理异常的。并且向其中添加了一个回调函数<code>handler</code>，当空间申请失败时会执行其中的处理操作，我们可以选择抛异常，中断或是其他行为都可以自定义。</p>
<h3 id="二级空间配置器"><a href="#二级空间配置器" class="headerlink" title="二级空间配置器"></a>二级空间配置器</h3><p>&emsp;&emsp;二级空间配置器所作的事情会更多一些，因为为了避免频繁向系统申请小内存空间，每次我们在释放小内存的时候空间配置器其实并不会将其让系统回收，而是自己进行了回收，等到用户重新想要申请小空间的时候，再从自己回收的内存中拿出一部分交给用户。<br>&emsp;&emsp;二级空间配置器在内部实现了一个内存池，空间配置器通过维护这个内存池来给用户分配空间。<br>&emsp;&emsp;当用户想要申请一小块内存的时候，空间配置器会先从内存池中拉出一份交给用户，当用户释放这块空间的时候，空间配置器并不会将这块内存还给内存池，而是当用户想要申请新的小空间时，优先使用这块已经从内存池中分配出来的空间。<br>&emsp;&emsp;当内存池中的所有空间都用完时，空间配置器才会重新去向操作系统申请一块大空间来补充内存池。<br>&emsp;&emsp;空间配置器中是通过哈希桶来向用户分配小块内存空间的，空间配置器将哈希桶分为一共16个桶，每个桶下面管理一部分小块字节的空间，此时的哈希函数为<code>申请空间大小 / 8</code>，例如我们要申请8字节空间，则会到一号桶下面拿到它下面的内存空间，因为对应桶会保证当前下面所挂内存空间至少为<code>桶号 * 8</code>的大小，例如1号桶下面的内存空间大小都是8字节，2号桶都是16字节的，以此类推，因此一共16个桶16号桶下面的空间都是128字节的，刚好以8字节为单位平分小内存空间。一开始所有内存都是在内存池中的，当有内存从内存池中分配出去，或者要回收回来时就会有新的空间挂到哈希桶对应的桶下面，方便下次我们继续分配。也正是因为这样的哈希关系，我们获取的内存空间一般都会向上取整为8的整数倍字节。<br>&emsp;&emsp;当拿到要分配的空间的大小<code>n</code>时（这里假设&lt;=128byte使用二级空间配置器）会进行以下操作：<br>&emsp;&emsp;1、向上对其为8字节的整数倍。<br>&emsp;&emsp;2、计算桶的位置，这里的哈希函数即为<code>n / 16</code>。<br>&emsp;&emsp;3、查看桶中是否有内存块，如果有内存块则取出一块内存，如果没有，则向内存池索要。此时会调用<code>chunk_alloc(size_t n, size_t&amp; nobj)</code>，<code>n为一块空间大小，nobj为一共申请多少块，默认nobj = 20</code>，共向内存池申请<code>total = n * nobj</code>的空间。<br>&emsp;&emsp;4、如果内存池剩余空间大于<code>total</code>，则直接分配，并且把一块交给用户，其他块交给哈希桶挂起；如果内存池剩余空间小于<code>total</code>，但是至少有一块的空间，则会重新计算<code>nobj</code>的大小，<code>nobj = 剩余空间 / n</code>，然后将能分配的空间交给用户，多余的挂到哈希桶上；如果内存池目前剩余空间已经不足一块要申请的空间，则会向系统申请大内存空间，并将剩余的一部分空间挂到对应的哈希桶上。<br>&emsp;&emsp;5、向系统申请新内存也会出现两种情况，如果申请成功，则放入内存池，递归<code>chunk_alloc</code>，如果申请失败则去搜索哈希桶，取出桶中尚未使用的内存放入内存池，再调用<code>chunk_alloc</code>。<br>&emsp;&emsp;6、如果连哈希桶中也没有多余空间，则会调用一级空间配置器，这里又出现两种情况，如果一级空间配置器申请内存成功则放入内存池，递归<code>chunk_alloc</code>，如果申请失败则会抛异常，处理异常。</p>

          
        
      
    </div>
    
    
    

    

    <div>
    
    </div>

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/11/06/【Cpp】哈希的应用/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="MisakiFx">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/blog-logo.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Misaki`s blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/11/06/【Cpp】哈希的应用/" itemprop="url">【Cpp】哈希的应用</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-11-06T15:50:45+08:00">
                2019-11-06
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Cpp/" itemprop="url" rel="index">
                    <span itemprop="name">Cpp</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  1.9k
                </span>
              

              

              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="哈希的应用"><a href="#哈希的应用" class="headerlink" title="哈希的应用"></a>哈希的应用</h1><p>&emsp;&emsp;哈希思想在算法中的应用繁多其重要性是不言而喻的，这里简单介绍两种哈希在大数据中的应用。</p>
<h2 id="位图"><a href="#位图" class="headerlink" title="位图"></a>位图</h2><h3 id="算法思路"><a href="#算法思路" class="headerlink" title="算法思路"></a>算法思路</h3><p>&emsp;&emsp;假如说有这么一种情景：给40亿个不重复的无符号整数，没排过序，判断一个无符号整数是否在这40亿个数中。<br>&emsp;&emsp;首先我们从时间考虑，假如说我们遍历40亿个数，事件复杂度是<code>On</code>的，如果我们先排序再用二分查找，排序要<code>ONlogN</code>二分查找要<code>OlogN</code>也还是不够快。不过这道题最重要的不是它的时间，而是空间，如果我们把40亿个整形全放到内存中需要<code>4G * 4 = 16G</code>内存，<code>40亿字节 == 4G</code>，不难发现我们根本存不下，那么怎么办呢？这里就需要用到<strong>位图</strong>。<br>&emsp;&emsp;我们标记一个数是否存在根本不需要存储完整整数，我们只需要用存在或者不存在两种状态对其进行标记即可，而两种状态的标记，只需要1位数据即可，由此我们可以用40亿比特位来标记40亿个数是否存在。并且无符号整形的上限差不多也就在42亿，我们就算标记完全部数字用到40亿位也只需要<code>4 G / 8 = 500M</code>内存，由此我们使用位图进行标记差不多相当于将空间压缩了32倍。<br>&emsp;&emsp;标记思路就是40多亿位分表标识40多亿无符号整型，一个数如果存在则它对应位标记为<code>1</code>，否则为<code>0</code>。假如说0存在，则第0位标记为<code>1</code>，32不存在则第32位标记为0，而无符号整形也是有上限的，40多亿位完全可以标记所有无符合整形。 </p>
<h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">class BitSet</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    //要保证每一个数据都能映射到一个唯一的位置，位图的大小与最大映射数据上限有关</span><br><span class="line">    //因此这里的range代表的是映射的最大数据</span><br><span class="line">    BitSet(size_t range)</span><br><span class="line">    &#123;</span><br><span class="line">        _bs.resize((range &gt;&gt; 5) + 1);</span><br><span class="line">    &#125;</span><br><span class="line">    //存储</span><br><span class="line">    void Set(int num)</span><br><span class="line">    &#123;</span><br><span class="line">        int index = num &gt;&gt; 5;</span><br><span class="line">        int bitIdx = num % 32;</span><br><span class="line">        _bs[index] |= (1 &lt;&lt; bitIdx);</span><br><span class="line">    &#125;</span><br><span class="line">    bool Find(int num)</span><br><span class="line">    &#123;</span><br><span class="line">        int index = num &gt;&gt; 5;</span><br><span class="line">        int bitIdx = num % 32;</span><br><span class="line">        return 1 &amp; (_bs[index] &gt;&gt; bitIdx);</span><br><span class="line">    &#125;</span><br><span class="line">    void ReSet(int num)</span><br><span class="line">    &#123;</span><br><span class="line">        int index = num &gt;&gt; 5;</span><br><span class="line">        int bitIdx = num % 32;</span><br><span class="line">        _bs[index] &amp;= (~(1 &lt;&lt; bitIdx));</span><br><span class="line">    &#125;</span><br><span class="line">private:</span><br><span class="line">    std::vector&lt;int&gt; _bs;</span><br><span class="line">&#125;;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    BitSet bs(64);</span><br><span class="line">    bs.Set(1);</span><br><span class="line">    bs.Set(64);</span><br><span class="line">    bs.Set(4);</span><br><span class="line">    std::cout &lt;&lt; bs.Find(1) &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; bs.Find(64) &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; bs.Find(4) &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; bs.Find(3) &lt;&lt; std::endl;</span><br><span class="line">    bs.ReSet(4);</span><br><span class="line">    std::cout &lt;&lt; bs.Find(4) &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1</span><br><span class="line">1</span><br><span class="line">1</span><br><span class="line">0</span><br><span class="line">0</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;但是使用位图有一个缺陷，就是我们无法解决哈希冲突，如果我们想要判断字符串，当字符串转换为整数时就有可能会造成哈希冲突，因为算法的原因两个不同的字符串可能会最终会转换为相同的整数，所以在判断字符串等其他需要转换并且可能会造成哈希冲突的类型时不能直接使用位图，于是一种进化版的位图诞生了。</p>
<h2 id="布隆过滤器"><a href="#布隆过滤器" class="headerlink" title="布隆过滤器"></a>布隆过滤器</h2><h3 id="思想"><a href="#思想" class="headerlink" title="思想"></a>思想</h3><p>&emsp;&emsp;布隆过滤器是专门为了解决为途中转换会造成哈希冲突的情况。例如我们现在要用位图标记字符串，我们两个不相同的字符串经过哈希函数转换后可能会出现最终一样的转换结果于是便出现了哈希冲突，例如<code>str1</code>哈希转换后为<code>24</code>于是我们将第24位置1表示<code>str1</code>存在，但是此时我们在判断<code>str2</code>是否存在的时候发现<code>str2</code>哈希后的值也为<code>24</code>，但是<code>str2</code>并不存在，于是这里就出现了哈希冲突，进行了误判。<br>&emsp;&emsp;为了解决它，布隆过滤器会选择利用多个不同的哈希函数对一个字符串进行哈希，并将所有哈希结果的对应位全部置1，这里与位图的思想无异。当我们查找一个字符串是否存在时再用同样的多个哈希函数对其进行哈希，然后依次查找每一位哈希结果，如果全为1则可大几率认定为这个字符串是存在的。例如<code>str1</code>存储利用三个哈希函数得到结果为<code>24, 26, 28</code>，于是我们将这3位置，我们在查找<code>str2</code>时利用同样三个哈希函数转换得到结果<code>24, 25, 27</code>，虽然<code>24</code>造成了冲突，但是由于<code>25, 26</code>并不为1，所以也并不会误判<code>str2</code>存在，只有<code>str1</code>三次哈希后结果在位图中全都为1时才会判断其存在，这样可以大概率解决冲突。<br>&emsp;&emsp;为什么说是大几率存在的呢？因为也有可能这个字符串的所有哈希结果都与其他字符串造成冲突，此时也会有误判，不过这种情况的几率很小，布隆过滤器可以保证绝大多数情况是正确的，但偶尔也难免会有特殊情况发生。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">#include &quot;BitSet.hpp&quot;</span><br><span class="line">struct HFun1</span><br><span class="line">&#123;</span><br><span class="line">    size_t operator()(const std::string&amp; str)</span><br><span class="line">    &#123;</span><br><span class="line">        size_t hash = 0;</span><br><span class="line">        for(auto&amp; ch : str)</span><br><span class="line">        &#123;</span><br><span class="line">            hash = hash * 131 + ch;</span><br><span class="line">        &#125;</span><br><span class="line">        return hash;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">struct HFun2</span><br><span class="line">&#123;</span><br><span class="line">    size_t operator()(const std::string&amp; str)</span><br><span class="line">    &#123;</span><br><span class="line">        size_t hash = 0;</span><br><span class="line">        for(auto&amp; ch : str)</span><br><span class="line">        &#123;</span><br><span class="line">            hash = hash * 65599 + ch;</span><br><span class="line">        &#125;</span><br><span class="line">        return hash;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">struct HFun3</span><br><span class="line">&#123;</span><br><span class="line">    size_t operator()(const std::string&amp; str)</span><br><span class="line">    &#123;</span><br><span class="line">        size_t hash = 0;</span><br><span class="line">        size_t magic = 63689;</span><br><span class="line">        for(auto&amp; ch : str)</span><br><span class="line">        &#123;</span><br><span class="line">            hash = hash * magic + ch;</span><br><span class="line">            magic *= 378551;</span><br><span class="line">        &#125;</span><br><span class="line">        return hash;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">//HFun为3个自定义的哈希函数</span><br><span class="line">template&lt;class T, class HFun1, class HFun2, class HFun3&gt;</span><br><span class="line">class BloomFilter</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    //k = (m / n) * ln2</span><br><span class="line">    //k:哈希函数数量</span><br><span class="line">    //m:位图大小</span><br><span class="line">    //n:元素个数</span><br><span class="line">    //m = k * n / ln2</span><br><span class="line">    //number表示元素个数，布隆这里不用元素最大上限作为位图的大小，因为可能会造成大量数据浪费</span><br><span class="line">    //这里利用二次哈希，节省空间</span><br><span class="line">    BloomFilter(size_t number)</span><br><span class="line">        :_bitCount(5 * number)</span><br><span class="line">        ,_bs(_bitCount)</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    void Set(const T&amp; data)</span><br><span class="line">    &#123;</span><br><span class="line">        int index1 = HFun1()(data) % _bitCount;</span><br><span class="line">        int index2 = HFun2()(data) % _bitCount;</span><br><span class="line">        int index3 = HFun3()(data) % _bitCount;</span><br><span class="line">        _bs.Set(index1);</span><br><span class="line">        _bs.Set(index2);</span><br><span class="line">        _bs.Set(index3);</span><br><span class="line">    &#125;</span><br><span class="line">    bool Find(const T&amp; data)</span><br><span class="line">    &#123;</span><br><span class="line">        int index1 = HFun1()(data) % _bitCount;</span><br><span class="line">        int index2 = HFun2()(data) % _bitCount;</span><br><span class="line">        int index3 = HFun3()(data) % _bitCount;</span><br><span class="line">        if(!_bs.Find(index1) || !_bs.Find(index2) || !_bs.Find(index3))</span><br><span class="line">        &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        return true;//可能会有误判</span><br><span class="line">    &#125;</span><br><span class="line">    //布隆为了防止误判不提供删除操作</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">    BitSet _bs;</span><br><span class="line">    size_t _bitCount;</span><br><span class="line">&#125;;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    BloomFilter&lt;std::string, HFun1, HFun2, HFun3&gt; bf(1000);</span><br><span class="line">    std::string str1 = &quot;https://misakifx.github.io/&quot;;</span><br><span class="line">    std::string str2 = &quot;https://blog.csdn.net/qq_41669298&quot;;</span><br><span class="line">    std::string str3 = &quot;https://space.bilibili.com/14406161/#/fans/follow&quot;;</span><br><span class="line">    std::string str4 = &quot;https://space.bilibili.com/#/fans/follow&quot;;</span><br><span class="line">    std::string str5 = &quot;https://space.bilibili.com/4406161/#/fans/follow&quot;;</span><br><span class="line">    std::string str6 = &quot;https://space.bilibili.com/146161/#/fans/follow&quot;;</span><br><span class="line">    bf.Set(str1);</span><br><span class="line">    bf.Set(str2);</span><br><span class="line">    bf.Set(str3);</span><br><span class="line">    bool ret = bf.Find(str1);</span><br><span class="line">    std::cout &lt;&lt; ret &lt;&lt; std::endl;</span><br><span class="line">    ret = bf.Find(str2);</span><br><span class="line">    std::cout &lt;&lt; ret &lt;&lt; std::endl;</span><br><span class="line">    ret = bf.Find(str3);</span><br><span class="line">    std::cout &lt;&lt; ret &lt;&lt; std::endl;</span><br><span class="line">    ret = bf.Find(str4);</span><br><span class="line">    std::cout &lt;&lt; ret &lt;&lt; std::endl;</span><br><span class="line">    ret = bf.Find(str5);</span><br><span class="line">    std::cout &lt;&lt; ret &lt;&lt; std::endl;</span><br><span class="line">    ret = bf.Find(str6);</span><br><span class="line">    std::cout &lt;&lt; ret &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1</span><br><span class="line">1</span><br><span class="line">1</span><br><span class="line">0</span><br><span class="line">0</span><br><span class="line">0</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;布隆过滤器一般来说不提供删除操作，但是其实是可以实现的，但是这里就需要借助引用计数，如果借用引用计数那么一个位肯定解决不了，就需要用多个位，那么就需要开辟更多空间，这里就需要根据需求来设计。</p>

          
        
      
    </div>
    
    
    

    

    <div>
    
    </div>

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/11/03/【Cpp】第十七章-unordered版本关联式容器/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="MisakiFx">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/blog-logo.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Misaki`s blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/11/03/【Cpp】第十七章-unordered版本关联式容器/" itemprop="url">【Cpp】第十七章-unordered版本关联式容器</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-11-03T15:25:26+08:00">
                2019-11-03
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Cpp/" itemprop="url" rel="index">
                    <span itemprop="name">Cpp</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  6.5k
                </span>
              

              

              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="unordered系列关联式容器"><a href="#unordered系列关联式容器" class="headerlink" title="unordered系列关联式容器"></a>unordered系列关联式容器</h1><h2 id="什么是unordered系列"><a href="#什么是unordered系列" class="headerlink" title="什么是unordered系列"></a>什么是unordered系列</h2><p>&emsp;&emsp;<code>unordered</code>系列的关联式容器有<code>unordered-map/unordered-set/unordered-multimap/unordered-multiset</code>，这些版本的关联式容器和普通版本的又有什么区别呢？我们简单使用下和普通版本的做一个对比。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;map&gt;</span><br><span class="line">#include &lt;unordered_map&gt;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    std::map&lt;int, int&gt; m;</span><br><span class="line">    m.insert(std::make_pair(1, 1));</span><br><span class="line">    m.insert(std::make_pair(4, 4));</span><br><span class="line">    m.insert(std::make_pair(2, 2));</span><br><span class="line">    m.insert(std::make_pair(4, 4));</span><br><span class="line">    m.insert(std::make_pair(6, 6));</span><br><span class="line">    std::cout &lt;&lt; &quot;map:&quot; &lt;&lt; std::endl;</span><br><span class="line">    for(auto e : m)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; e.first &lt;&lt; &quot; &quot; &lt;&lt; e.second &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    std::unordered_map&lt;int, int&gt; um;</span><br><span class="line">    um.insert(std::make_pair(1, 1));</span><br><span class="line">    um.insert(std::make_pair(4, 4));</span><br><span class="line">    um.insert(std::make_pair(2, 2));</span><br><span class="line">    um.insert(std::make_pair(4, 4));</span><br><span class="line">    um.insert(std::make_pair(6, 6));</span><br><span class="line">    std::cout &lt;&lt; &quot;unordered-map:&quot; &lt;&lt; std::endl;</span><br><span class="line">    for(auto e : um)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; e.first &lt;&lt; &quot; &quot; &lt;&lt; e.second &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">map:</span><br><span class="line">1 1</span><br><span class="line">2 2</span><br><span class="line">4 4</span><br><span class="line">6 6</span><br><span class="line">unordered-map:</span><br><span class="line">6 6</span><br><span class="line">2 2</span><br><span class="line">1 1</span><br><span class="line">4 4</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;对比结果很明显，我们发现<code>map</code>往往会将插入的键值对按照<code>key</code>的大小比较排序，因此打印出来的数据是有序的，因为其底层是一棵红黑树，因此这样的结果也是理所应当的，但是<code>unordered-map</code>就如它的名字一样遍历出来的数据是无序的，但是依然能完成键值对的查找功能，<code>unordered-map</code>与<code>map</code>最为显著的差距就在这里，看上去<code>unordered-map</code>并不如<code>map</code>强大，那为什么还要存在<code>unordered</code>系列呢？因为其查找索引能够达到<code>O1</code>的时间复杂度，比红黑树更快，因为其底层数据结构是一个哈希桶，关于底层实现我们之后再讨论，我们解析来首先介绍一下<code>unordered</code>系列的使用。</p>
<h2 id="unordered系列的使用"><a href="#unordered系列的使用" class="headerlink" title="unordered系列的使用"></a>unordered系列的使用</h2><p>&emsp;&emsp;<code>unordered</code>系列共有四种关联式容器，与普通版本的互相对应，除了数据在内部存储及遍历结果无序外，其他的使用方法与普通版本的几乎没有区别，因此这里不再详细讨论接口的使用，我们这里主要要关心的是为什么<code>unordered</code>系列可以在舍弃有序的情况下变得更快，其底层的数据结构又是怎么样的。</p>
<h2 id="底层结构"><a href="#底层结构" class="headerlink" title="底层结构"></a>底层结构</h2><p>&emsp;&emsp;虽然看上去<code>unordered</code>系列关联式容器的使用方法与普通版本的关联式容器使用没有太大区别，但他们两个的底层实现却完全不一样，这也是导致为什么<code>unordered</code>可以更快，并且不能有序的原因。</p>
<h3 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h3><h4 id="什么是哈希表"><a href="#什么是哈希表" class="headerlink" title="什么是哈希表"></a>什么是哈希表</h4><p>&emsp;&emsp;哈希表是一种根据映射来存储数据的结构，我们可以自定义一个哈希函数，通过<code>key</code>和哈希函数算出各个<code>value</code>实际在空间中存储的位置，然后进行<code>value</code>的存储，我们想要查找某个数据的时候也只需要通过同样的方法找到对应位置就可以拿到<code>value</code>。<br>&emsp;&emsp;举个例子，我们现在有个数组，我们约定数组对应下标就存储对应<code>key</code>的数据<code>value</code>。如<code>arr[1] = value1, arr[2] = value2, ... , arr[n] = valuen</code>。由此一来我们想要根据<code>key</code>查找某个<code>value</code>就直接访问数组中对应下标的元素<code>arr[key]</code>即可。例如我们要找<code>key == 1</code>时<code>value</code>的值，我们直接访问<code>arr[1]</code>就可以直接拿到<code>value1</code>，这就是通过哈希建立映射的方法，并且这里的查找速度只需要<code>O1</code>，这就是典型的以空间换时间的做法，因为这里可能会出现空间的大量浪费。如果发生这么一种情况，<code>key</code>的上限过大，几千万或者几亿，但是中间的数据可能十分零散，此时我们为了继续建立映射不得不创建一个长度为几千万甚至几忆的数组，并且由于数据十分零散，会导致中间可能会有很多空间根本没有映射来存<code>value</code>，例如现在要存储两个映射<code>key == 1, key == 10000000</code>，我们发现这两个映射之间在没有其他映射了，那么这一个长度为<code>10000000</code>的数组中就只存了两个值，由此就算我们节省了时间却浪费了过多的空间，这也是哈希所要解决的一个问题。总之哈希表就是这么一种通过哈希函数建立<code>key</code>和<code>value</code>之间映射的结构。</p>
<h4 id="哈希函数"><a href="#哈希函数" class="headerlink" title="哈希函数"></a>哈希函数</h4><p>&emsp;&emsp;正如刚才所说，我们的<code>value</code>得通过哈希函数和<code>key</code>来确定数据存放位置并且也能找到对应数据，因此哈希函数的确定十分重要，向我们刚刚所举的例子中我们采用的哈希函数就是直接导致我们造成大量空间浪费的原因，因此在适当的时机选取何时的哈希函数也是十分重要的，接下来简单介绍几种哈希函数。</p>
<h5 id="直接定址法"><a href="#直接定址法" class="headerlink" title="直接定址法"></a>直接定址法</h5><p>&emsp;&emsp;取关键字的某个线性函数为散列地址：<code>Hash(key) = A * key + b</code>。这种哈希函数的优点也很明显，十分简单，均匀，但是它只适用于<code>key</code>的范围确定，且值较小还比较连续的情景，一但<code>key</code>过大，或者不连续就会出现大量空间被浪费的情况。</p>
<h5 id="除留余数法"><a href="#除留余数法" class="headerlink" title="除留余数法"></a>除留余数法</h5><p>&emsp;&emsp;这种方法是最为常用的哈希函数。假设我们散列表中允许的最大地址为<code>m</code>，我们可以取一个小于等于<code>m</code>的质数<code>p</code>作为除数，然后执行哈希函数<code>Hash(key) = key % p(p &lt;= m)</code>，将余数作为地址进行定址。一般来说我们为了使得哈希表可以增容都会将除数设置为随着哈希表总长度而改变的变量，并且在不考虑其他因素的情况下，<code>除数==容量</code>的情况可以最大程度的利用空间。</p>
<h5 id="平方取中法"><a href="#平方取中法" class="headerlink" title="平方取中法"></a>平方取中法</h5><p>&emsp;&emsp;假设关键字为1234，对它平方就是1522756，抽取中间的3位227作为哈希地址； 再比如关键字为 4321，对它平方就是18671041，抽取中间的3位671(或710)作为哈希地址 平方取中法比较适合：不知 道关键字的分布，而位数又不是很大的情况。</p>
<h5 id="折叠法"><a href="#折叠法" class="headerlink" title="折叠法"></a>折叠法</h5><p>&emsp;&emsp;折叠法是将关键字从左到右分割成位数相等的几部分(最后一部分位数可以短些)，然后将这几部分叠加 求和，并按散列表表长，取后几位作为散列地址。 折叠法适合事先不需要知道关键字的分布，适合关键字位数比较多的情况。<br>&emsp;&emsp;初次之外还有很多哈希方法，但是除了<strong>直接定址法</strong>和<strong>除留余数法</strong>外其他都不常用，所以可以仅作了解。</p>
<h4 id="哈希冲突"><a href="#哈希冲突" class="headerlink" title="哈希冲突"></a>哈希冲突</h4><p>&emsp;&emsp;我们在利用哈希函数进行寻址的时候，很容易发生一种情况，就是两个数同时可能会寻到同一块地址，例如我们使用除留余数法进行寻址，除数为11，现在有<code>key</code>为11和22，余数都为0，我们都要存在地址为0的位置上，此时该怎么办呢，我们一个位置又不能存储两个数啊，于是这里就牵扯到了如何解决哈希冲突。哈希冲突的解决可以分为两大类，<strong>闭散列</strong>和<strong>开散列</strong>。</p>
<h4 id="负载因子"><a href="#负载因子" class="headerlink" title="负载因子"></a>负载因子</h4><p>&emsp;&emsp;在具体讨论哈希冲突解决方法前我们还要关心一个概念即<strong>负载因子</strong>，一会我们就会知道无论是采用哪种哈希函数使用闭散列解决哈希冲突还是开散列解决哈希冲突，哈希表总会有被存满的时候，尤其是采用闭散列的时候，如果存放数据越多，就会发生越来越多的冲突，我们在解决起来可能就要遍历整张表，使得哈希表的性能下降，因此我们要尽可能避免一张哈希表被存满，不过这种情况虽然对于开散列来说可能还好，但是一段哈希表为了维持性能也一定是有它的负载上限的，这里就要对哈希表进行扩容，那么什么时候扩容怎么扩容就成了问题。我们先说如何解决什么时候扩容的难题。<br>&emsp;&emsp;假设我们现在使用除留余数法在一段长为<code>c</code>的线性空间上进行散列，此时为了充分利用空间和使得可以增容，我们的除数不定，与容量保持一致也为<code>c</code>，于是此时的哈希函数为<code>Hash(key) = key % c</code>；我们所采用的冲突解决方法为线性探测法。为了避免大面积冲突降低性能，我们引入负载因子的概念，<code>负载因子 = _size / c,(_size为哈希表中有效结点的个数)</code>。这个公式可知负载因子是不可能大于1的，等于1时则哈希表已满，那么我们必须选取一个合适的值，当哈希表还没满，性能降低还不太明显的时候就进行增容，当然增容也不能太过频繁，因为哈希表的增容也会付出很大代价，一般来说对于闭散列我们的负载因子要求其大于等于0.8就可以开始增容了。<br>&emsp;&emsp;说完什么时候增容，再说怎么增容。假如增容一次容量扩大一倍，可以知道的是，增容一次除数就会改变一次，那么原本算好地址的元素在新的哈希表中的地址也许就会改变，我们不得不遍历所有元素重新计算他们的地址然后再放到新的哈希表中，这也是为什么不能过于频繁的增容会有极大消耗的原因。</p>
<h4 id="闭散列"><a href="#闭散列" class="headerlink" title="闭散列"></a>闭散列</h4><p>&emsp;&emsp;闭散列：也叫开放定址法，当发生哈希冲突时，如果哈希表未被装满，说明在哈希表中必然还有空位置，那 么可以把key存放到冲突位置中的“下一个” 空位置中去，于是问题就变成了如何找到一个合适的空位置让我们存储当前数据，还能保证我们在查找时能够再次准确的找到当前位置。</p>
<h5 id="线性探测再散列"><a href="#线性探测再散列" class="headerlink" title="线性探测再散列"></a>线性探测再散列</h5><p>&emsp;&emsp;线性探测：从发生冲突的位置开始，依次向后探测，直到寻找到下一个空位置为止。 例如除留余数法除数为11，<code>key</code>为11和22，当11先散列要存储在地址为0的位置时，22再进行散列的时候发现地址为0的位置已经存储过11的数据了，则它就继续向后线性探索，直到找到第一个空位置就将22的数据存储进去。</p>
<h5 id="二次探测再散列"><a href="#二次探测再散列" class="headerlink" title="二次探测再散列"></a>二次探测再散列</h5><p>&emsp;&emsp;线性探测的缺陷是产生冲突的数据堆积在一块，这与其找下一个空位置有关系，因为找空位置的方式就 是挨着往后逐个去找，因此二次探测为了避免该问题，找下一个空位置的方法为： <code>Hi= (H0 + i ^ 2) % m</code>, 或者：<code>H0 = (Hi - i ^ 2) % m</code>。其中： <code>i = 1,2,3…</code>  ， <code>H0</code>是通过散列函数Hash(x)对元素的关键码<code>key</code>进行计算得到的位置，<code>m</code>是表的大小。 </p>
<h5 id="基于闭散列实现哈希表"><a href="#基于闭散列实现哈希表" class="headerlink" title="基于闭散列实现哈希表"></a>基于闭散列实现哈希表</h5><p>&emsp;&emsp;这里使用除留余数法+线性探测法实现哈希表。在实现时要注意为了标记散列表一个位置当前是否已经存在元素，我们要给每个结点都附加一个状态值，<strong>空/存在/删除</strong>三种状态，空和存在状态很好理解，删除状态的定义是为了方便再哈希表中删除结点所定义的状态，因为如果我们直接删除一个结点的话可能会影响其他结点的查找，因此我们一般删除都是采用该表状态为删除状态的这种伪删除法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br></pre></td><td class="code"><pre><span class="line">hash.hpp:</span><br><span class="line">#pragma once</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;utility&gt;</span><br><span class="line"></span><br><span class="line">//定义三种状态，DELETE状态是为了方便我们对结点进行删除</span><br><span class="line">enum STATE</span><br><span class="line">&#123;</span><br><span class="line">    EMPTY,</span><br><span class="line">    EXIST,</span><br><span class="line">    DELETE</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">template&lt;class K, class V&gt;</span><br><span class="line">struct HashNode</span><br><span class="line">&#123;</span><br><span class="line">    //为了更好的可以找到映射，哈希表往往存的是一个K-V结构</span><br><span class="line">    std::pair&lt;K, V&gt; _data;</span><br><span class="line">    //状态默认为空</span><br><span class="line">    STATE _state = EMPTY;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">template&lt;class K, class V&gt;</span><br><span class="line">class HashTable</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    typedef HashNode&lt;K, V&gt; Node;</span><br><span class="line">    HashTable(const size_t n = 10)</span><br><span class="line">        :_size(n)</span><br><span class="line">    &#123;</span><br><span class="line">        _ht.resize(n);</span><br><span class="line">    &#125;</span><br><span class="line">    bool Insert(const std::pair&lt;K, V&gt;&amp; data)</span><br><span class="line">    &#123;</span><br><span class="line">        //检查容量</span><br><span class="line">        checkCapacity();</span><br><span class="line">        //计算索引，进行散列</span><br><span class="line">        int index = data.first % _ht.size();</span><br><span class="line">        //1、判断当前地方是否有元素，没有直接插入</span><br><span class="line">        //元素可以放在EMPTY和DELETE</span><br><span class="line">        while(_ht[index]._state == EXIST)</span><br><span class="line">        &#123;</span><br><span class="line">            //2、如果有，判断当前位置的元素的key是否和插入的相同，如果相同则插入失败直接返回</span><br><span class="line">            if (_ht[index]._data.first == data.first)</span><br><span class="line">            &#123;</span><br><span class="line">                //插入失败</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">            //3、如果有，且key不同则利用哈希冲突解决方法解决哈希冲突</span><br><span class="line">            ++index;</span><br><span class="line">            if(index == _ht.size())</span><br><span class="line">            &#123;</span><br><span class="line">                index = 0;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        //元素插入</span><br><span class="line">        _ht[index]._data = data;</span><br><span class="line">        _ht[index]._state = EXIST;</span><br><span class="line">        ++_size;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    //检查容量，负载因子超过阈值则扩容</span><br><span class="line">    void checkCapacity()</span><br><span class="line">    &#123;</span><br><span class="line">        //这里选取负载因子大于等于0.8扩容</span><br><span class="line">        if(_ht.size() == 0 || _size * 10 / _ht.size() &gt;= 8)</span><br><span class="line">        &#123;</span><br><span class="line">            //增容</span><br><span class="line">            int newC = _ht.size() == 0 ? 10 : 2 * _ht.size();</span><br><span class="line">            HashTable&lt;K, V&gt; newHt(newC);</span><br><span class="line">            //旧元素插入到新表</span><br><span class="line">            for(int i = 0; i &lt; _ht.size(); i++)</span><br><span class="line">            &#123;</span><br><span class="line">                if(_ht[i]._state == EXIST)</span><br><span class="line">                &#123;</span><br><span class="line">                    newHt.Insert(_ht[i]._data);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            //_ht = newHt._ht;深拷贝，太慢了，直接交换值比较快</span><br><span class="line">            std::swap(_ht, newHt._ht);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    //搜索</span><br><span class="line">    Node* Find(const K&amp; key)</span><br><span class="line">    &#123;</span><br><span class="line">        int index = key % _ht.size();</span><br><span class="line">        while(_ht[index]._state != EMPTY)</span><br><span class="line">        &#123;</span><br><span class="line">            if(_ht[index]._state == EXIST)</span><br><span class="line">            &#123;</span><br><span class="line">                if(_ht[index]._data.first == key)</span><br><span class="line">                &#123;</span><br><span class="line">                    return &amp;_ht[index];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            index++;</span><br><span class="line">            if(index == _ht.size())</span><br><span class="line">            &#123;</span><br><span class="line">                index = 0;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return nullptr;</span><br><span class="line">    &#125;</span><br><span class="line">    //删除</span><br><span class="line">    bool Erase(const K&amp; key)</span><br><span class="line">    &#123;</span><br><span class="line">        Node* pos = find(key);</span><br><span class="line">        if(pos)</span><br><span class="line">        &#123;</span><br><span class="line">            pos-&gt;_state = DELETE;</span><br><span class="line">            --_size;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">private:</span><br><span class="line">    //散列表</span><br><span class="line">    std::vector&lt;Node&gt; _ht;</span><br><span class="line">    size_t _size;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">test.cpp:</span><br><span class="line">#include &quot;hash.hpp&quot;</span><br><span class="line">void test()</span><br><span class="line">&#123;</span><br><span class="line">    HashTable&lt;int, int&gt; ht;</span><br><span class="line">    ht.Insert(std::make_pair(5, 5));</span><br><span class="line">    ht.Insert(std::make_pair(1, 1));</span><br><span class="line">    ht.Insert(std::make_pair(0, 0));</span><br><span class="line">    ht.Insert(std::make_pair(10, 10));</span><br><span class="line">    ht.Insert(std::make_pair(30, 30));</span><br><span class="line">    ht.Insert(std::make_pair(32, 32));</span><br><span class="line">    ht.Insert(std::make_pair(8, 8));</span><br><span class="line">    ht.Insert(std::make_pair(110, 110));</span><br><span class="line">    ht.Insert(std::make_pair(23, 23));</span><br><span class="line">    ht.Insert(std::make_pair(24, 23));</span><br><span class="line">    ht.Insert(std::make_pair(25, 23));</span><br><span class="line">    ht.Insert(std::make_pair(26, 23));</span><br><span class="line">    HashNode&lt;int, int&gt;* node =  ht.Find(32);</span><br><span class="line">    if(node != nullptr)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; (node-&gt;_data.first) &lt;&lt; &quot; &quot; &lt;&lt; node-&gt;_data.second;</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; &quot;nullptr&quot; &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line">    node =  ht.Find(110);</span><br><span class="line">    if(node != nullptr)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; (node-&gt;_data.first) &lt;&lt; &quot; &quot; &lt;&lt; node-&gt;_data.second;</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; &quot;nullptr&quot; &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    test();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">32 32</span><br><span class="line">110 110</span><br></pre></td></tr></table></figure>
<h4 id="开散列"><a href="#开散列" class="headerlink" title="开散列"></a>开散列</h4><p>&emsp;&emsp;开散列：也叫哈希桶或拉链法。开散列相比闭散列，可以更加有效的解决哈希冲突，因为其的结构是在哈希表的每一个节点上添加一个链表，所有经过哈希函数计算得出地址的结点直接添加到对应的链表上即可，这样一个地址上就不止可以存放一个元素，而是可以存放无限个，更好的处理了哈希冲突。其结构如下：<br><br><img src="/2019/11/03/【Cpp】第十七章-unordered版本关联式容器/1.png" alt="哈希桶"><br><br>&emsp;&emsp;要注意虽然哈希桶每个结点下面可以挂无数个结点，但是这里的单链表不易过长，否则每次查找结点都要遍历单链表，性能又会有很大程度的降低，于是我们还是需要利用负载因子进行扩容处理。<br>&emsp;&emsp;对于开散列来说我们还是不得不遍历所有结点然后重新计算地址，但是有一种可以减少消耗的方法。本来我们需要遍历完原哈希表所有结点，然后依次释放原哈希表上每个链表的空间，再在新的哈希表上开辟新空间插入结点，但是这样一释放一申请的举动无异于脱裤子放屁，我们可以直接将原哈希表上的结点连接到新哈希表上，省去释放空间再申请空间的步骤，毕竟链表结点与结点之间本来就不一定是连续的，所以这样的操作替我们节省了很多开销。<br>&emsp;&emsp;这里使用除留余数法实现哈希桶。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br></pre></td><td class="code"><pre><span class="line">#pragma once</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;utility&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">template&lt;class K, class V&gt;</span><br><span class="line">//这里现在存的就是链表结点</span><br><span class="line">//这里我们使用单链表就行了</span><br><span class="line">struct HashNode</span><br><span class="line">&#123;</span><br><span class="line">    HashNode(const std::pair&lt;K, V&gt;&amp; data = std::pair&lt;K, V&gt;())</span><br><span class="line">        :_data(data)</span><br><span class="line">        ,_next(nullptr)</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    std::pair&lt;K, V&gt; _data;</span><br><span class="line">    HashNode&lt;K, V&gt;* _next;</span><br><span class="line">&#125;;</span><br><span class="line">template&lt;class K, class V&gt;</span><br><span class="line">class HashTable</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    typedef HashNode&lt;K, V&gt; Node;</span><br><span class="line">    HashTable(size_t n = 10)</span><br><span class="line">        :_size(0)</span><br><span class="line">    &#123;</span><br><span class="line">        _ht.resize(n);</span><br><span class="line">    &#125;</span><br><span class="line">    //插入</span><br><span class="line">    bool Insert(const std::pair&lt;K, V&gt;&amp; data)</span><br><span class="line">    &#123;</span><br><span class="line">        //检查负载因子，超过阈值进行扩容</span><br><span class="line">        CheckCapacity();</span><br><span class="line">        //计算位置</span><br><span class="line">        int index = data.first % _ht.size();</span><br><span class="line">        //遍历单链表</span><br><span class="line">        Node* cur = _ht[index];</span><br><span class="line">        while(cur)</span><br><span class="line">        &#123;</span><br><span class="line">            if(cur-&gt;_data.first == data.first)</span><br><span class="line">            &#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">            cur = cur-&gt;_next;</span><br><span class="line">        &#125;</span><br><span class="line">        //插入，这里用头插其实比较方便，尾插也可以</span><br><span class="line">        cur = new Node(data);</span><br><span class="line">        cur-&gt;_next = _ht[index];</span><br><span class="line">        _ht[index] = cur;</span><br><span class="line">        ++_size;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    //查找</span><br><span class="line">    Node* Find(const K&amp; key)</span><br><span class="line">    &#123;</span><br><span class="line">        int index = key % _ht.size();</span><br><span class="line">        Node* cur = _ht[index];</span><br><span class="line">        while(cur)</span><br><span class="line">        &#123;</span><br><span class="line">            if(cur-&gt;_data.first == key)</span><br><span class="line">            &#123;</span><br><span class="line">                return cur;</span><br><span class="line">            &#125;</span><br><span class="line">            cur = cur-&gt;_next;</span><br><span class="line">        &#125;</span><br><span class="line">        return nullptr;</span><br><span class="line">    &#125;</span><br><span class="line">    //删除</span><br><span class="line">    bool Erase(const K&amp; key)</span><br><span class="line">    &#123;</span><br><span class="line">        int index = key % _ht.size();</span><br><span class="line">        Node* cur = _ht[index];</span><br><span class="line">        Node* parent = nullptr;</span><br><span class="line">        while(cur)</span><br><span class="line">        &#123;</span><br><span class="line">            if(cur-&gt;_data.first == key)</span><br><span class="line">            &#123;</span><br><span class="line">                //删除</span><br><span class="line">                if(parent == nullptr)</span><br><span class="line">                &#123;</span><br><span class="line">                    _ht[index] = cur-&gt;_next;</span><br><span class="line">                &#125;</span><br><span class="line">                else</span><br><span class="line">                &#123;</span><br><span class="line">                    parent-&gt;_next = cur-&gt;_next;</span><br><span class="line">                &#125;</span><br><span class="line">                delete cur;</span><br><span class="line">                --_size;</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">            parent = cur;</span><br><span class="line">            cur = cur-&gt;_next;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    void CheckCapacity()</span><br><span class="line">    &#123;</span><br><span class="line">        //这里的阈值可以设置的稍微高一些，毕竟哈希桶的冲突不会像闭散列呢样严重</span><br><span class="line">        //这里我们设定为插入元素数 &gt;= 哈希表总长度时扩容</span><br><span class="line">        if(_size &gt;= _ht.size())</span><br><span class="line">        &#123;</span><br><span class="line">            //扩容</span><br><span class="line">            size_t newC = _ht.size() == 0 ? 10 : 2 * _ht.size();</span><br><span class="line">            std::vector&lt;Node*&gt; newHt;</span><br><span class="line">            newHt.resize(newC);</span><br><span class="line">            //搬运数据，将原哈希表中的结点连接到新哈希表上</span><br><span class="line">            for(int i = 0; i &lt; _ht.size(); i++)</span><br><span class="line">            &#123;</span><br><span class="line">                Node* cur = _ht[i];</span><br><span class="line">                while(cur)</span><br><span class="line">                &#123;</span><br><span class="line">                    int index = cur-&gt;_data.first % newHt.size();</span><br><span class="line">                    Node* next = _ht[i]-&gt;_next;</span><br><span class="line">                    //头插进新表</span><br><span class="line">                    cur-&gt;_next = newHt[index];</span><br><span class="line">                    newHt[index] = cur;</span><br><span class="line">                    cur = next;</span><br><span class="line">                &#125;</span><br><span class="line">                _ht[i] = nullptr;</span><br><span class="line">            &#125;</span><br><span class="line">            //_ht = newHt;   //这里会进行深拷贝，消耗很大，为了防止深拷贝我们直接交换</span><br><span class="line">            std::swap(_ht, newHt);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">    //此时哈希表就相当于一个链表指针数组</span><br><span class="line">    std::vector&lt;Node*&gt; _ht;</span><br><span class="line">    size_t _size;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h3 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h3><p>&emsp;&emsp;最后我们再将我们写好的哈希桶封装为<code>unordered_map/unordered_set</code>。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br></pre></td><td class="code"><pre><span class="line">hash_bucketMod.hpp:</span><br><span class="line">#pragma once</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;utility&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">//这里现在存的就是链表结点</span><br><span class="line">//这里我们使用单链表就行了</span><br><span class="line">//这里依然为了更好的封装对原有的哈希桶进行了修改</span><br><span class="line">template&lt;class V&gt;</span><br><span class="line">struct HashNode</span><br><span class="line">&#123;</span><br><span class="line">    HashNode(const V&amp; data = V())</span><br><span class="line">        :_data(data)</span><br><span class="line">        ,_next(nullptr)</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    V _data;</span><br><span class="line">    HashNode&lt;V&gt;* _next;</span><br><span class="line">&#125;;</span><br><span class="line">template&lt;class K, class V, class KeyOfCalue&gt;</span><br><span class="line">class HashTable;</span><br><span class="line">template&lt;class K, class V, class KeyOfValue&gt;</span><br><span class="line">class _HashIterator</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    typedef HashNode&lt;V&gt; Node;</span><br><span class="line">    typedef _HashIterator&lt;K, V, KeyOfValue&gt; Self;</span><br><span class="line">    typedef HashTable&lt;K, V, KeyOfValue&gt; HTable;</span><br><span class="line">    _HashIterator(Node* node, HTable* pht)</span><br><span class="line">        :_node(node)</span><br><span class="line">        ,_pht(pht)</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    V&amp; operator*()</span><br><span class="line">    &#123;</span><br><span class="line">        return _node-&gt;_data;</span><br><span class="line">    &#125;</span><br><span class="line">    V* operator-&gt;()</span><br><span class="line">    &#123;</span><br><span class="line">        return &amp;_node-&gt;_data;</span><br><span class="line">    &#125;</span><br><span class="line">    bool operator!=(const Self&amp; it)</span><br><span class="line">    &#123;</span><br><span class="line">        return _node != it._node;</span><br><span class="line">    &#125;</span><br><span class="line">    Self&amp; operator++()</span><br><span class="line">    &#123;</span><br><span class="line">        if(_node-&gt;_next)</span><br><span class="line">        &#123;</span><br><span class="line">            _node = _node-&gt;_next;</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            KeyOfValue kov;</span><br><span class="line">            //找到下一个非空链表头</span><br><span class="line">            //1、首先确定当前迭代器在哈希表中的位置</span><br><span class="line">            int index = kov(_node-&gt;_data) % _pht-&gt;_ht.size();</span><br><span class="line">            ++index;</span><br><span class="line">            while(index &lt; _pht-&gt;_ht.size())</span><br><span class="line">            &#123;</span><br><span class="line">                if(_pht-&gt;_ht[index])</span><br><span class="line">                &#123;</span><br><span class="line">                    _node = _pht-&gt;_ht[index];</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">                ++index;</span><br><span class="line">            &#125;</span><br><span class="line">            if(index == _pht-&gt;_ht.size())</span><br><span class="line">            &#123;</span><br><span class="line">                _node = nullptr;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return *this;</span><br><span class="line">    &#125;</span><br><span class="line">private:</span><br><span class="line">    Node* _node;</span><br><span class="line">    HTable* _pht;</span><br><span class="line">&#125;;</span><br><span class="line">template&lt;class K, class V, class KeyOfValue&gt;</span><br><span class="line">class HashTable</span><br><span class="line">&#123;</span><br><span class="line">    friend class _HashIterator&lt;K, V, KeyOfValue&gt;;</span><br><span class="line">public:</span><br><span class="line">    typedef HashNode&lt;V&gt; Node;</span><br><span class="line">    typedef _HashIterator&lt;K, V, KeyOfValue&gt; iterator;</span><br><span class="line">    //迭代器相关</span><br><span class="line">    iterator begin()</span><br><span class="line">    &#123;</span><br><span class="line">        for(int i = 0; i &lt; _ht.size(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            if(_ht[i] != nullptr)</span><br><span class="line">            &#123;</span><br><span class="line">                return iterator(_ht[i], this);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return iterator(nullptr, this);</span><br><span class="line">    &#125;</span><br><span class="line">    iterator end()</span><br><span class="line">    &#123;</span><br><span class="line">        return iterator(nullptr, this);</span><br><span class="line">    &#125;</span><br><span class="line">    HashTable(size_t n = 10)</span><br><span class="line">        :_size(0)</span><br><span class="line">    &#123;</span><br><span class="line">        _ht.resize(n, nullptr);</span><br><span class="line">    &#125;</span><br><span class="line">    //插入</span><br><span class="line">    std::pair&lt;iterator, bool&gt; Insert(const V&amp; data)</span><br><span class="line">    &#123;</span><br><span class="line">        //检查负载因子，超过阈值进行扩容</span><br><span class="line">        CheckCapacity();</span><br><span class="line">        //计算位置</span><br><span class="line">        KeyOfValue kov;</span><br><span class="line">        int index = kov(data) % _ht.size();</span><br><span class="line">        //遍历单链表</span><br><span class="line">        Node* cur = _ht[index];</span><br><span class="line">        while(cur)</span><br><span class="line">        &#123;</span><br><span class="line">            if(kov(cur-&gt;_data) == kov(data))</span><br><span class="line">            &#123;</span><br><span class="line">                return std::make_pair(iterator(cur, this), false);</span><br><span class="line">            &#125;</span><br><span class="line">            cur = cur-&gt;_next;</span><br><span class="line">        &#125;</span><br><span class="line">        //插入，这里用头插其实比较方便，尾插也可以</span><br><span class="line">        cur = new Node(data);</span><br><span class="line">        cur-&gt;_next = _ht[index];</span><br><span class="line">        _ht[index] = cur;</span><br><span class="line">        ++_size;</span><br><span class="line">        return std::make_pair(iterator(cur, this), true);</span><br><span class="line">    &#125;</span><br><span class="line">    //查找</span><br><span class="line">    Node* Find(const K&amp; key)</span><br><span class="line">    &#123;</span><br><span class="line">        KeyOfValue kov;</span><br><span class="line">        int index = key % _ht.size();</span><br><span class="line">        Node* cur = _ht[index];</span><br><span class="line">        while(cur)</span><br><span class="line">        &#123;</span><br><span class="line">            if(kov(cur-&gt;_data) == key)</span><br><span class="line">            &#123;</span><br><span class="line">                return cur;</span><br><span class="line">            &#125;</span><br><span class="line">            cur = cur-&gt;_next;</span><br><span class="line">        &#125;</span><br><span class="line">        return nullptr;</span><br><span class="line">    &#125;</span><br><span class="line">    //删除</span><br><span class="line">    bool Erase(const K&amp; key)</span><br><span class="line">    &#123;</span><br><span class="line">        int index = key % _ht.size();</span><br><span class="line">        Node* cur = _ht[index];</span><br><span class="line">        Node* parent = nullptr;</span><br><span class="line">        KeyOfValue kov;</span><br><span class="line">        while(cur)</span><br><span class="line">        &#123;</span><br><span class="line">            if(kov(cur-&gt;_data) == key)</span><br><span class="line">            &#123;</span><br><span class="line">                //删除</span><br><span class="line">                if(parent == nullptr)</span><br><span class="line">                &#123;</span><br><span class="line">                    _ht[index] = cur-&gt;_next;</span><br><span class="line">                &#125;</span><br><span class="line">                else</span><br><span class="line">                &#123;</span><br><span class="line">                    parent-&gt;_next = cur-&gt;_next;</span><br><span class="line">                &#125;</span><br><span class="line">                delete cur;</span><br><span class="line">                --_size;</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">            parent = cur;</span><br><span class="line">            cur = cur-&gt;_next;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    void CheckCapacity()</span><br><span class="line">    &#123;</span><br><span class="line">        //这里的阈值可以设置的稍微高一些，毕竟哈希桶的冲突不会像闭散列呢样严重</span><br><span class="line">        //这里我们设定为插入元素数 &gt;= 哈希表总长度时扩容</span><br><span class="line">        if(_size &gt;= _ht.size())</span><br><span class="line">        &#123;</span><br><span class="line">            //扩容</span><br><span class="line">            size_t newC = _ht.size() == 0 ? 10 : 2 * _ht.size();</span><br><span class="line">            std::vector&lt;Node*&gt; newHt;</span><br><span class="line">            newHt.resize(newC);</span><br><span class="line">            KeyOfValue kov;</span><br><span class="line">            //搬运数据，将原哈希表中的结点连接到新哈希表上</span><br><span class="line">            for(int i = 0; i &lt; _ht.size(); i++)</span><br><span class="line">            &#123;</span><br><span class="line">                Node* cur = _ht[i];</span><br><span class="line">                while(cur)</span><br><span class="line">                &#123;</span><br><span class="line">                    int index = kov(cur-&gt;_data) % newHt.size();</span><br><span class="line">                    Node* next = _ht[i]-&gt;_next;</span><br><span class="line">                    //头插进新表</span><br><span class="line">                    cur-&gt;_next = newHt[index];</span><br><span class="line">                    newHt[index] = cur;</span><br><span class="line">                    cur = next;</span><br><span class="line">                &#125;</span><br><span class="line">                _ht[i] = nullptr;</span><br><span class="line">            &#125;</span><br><span class="line">            //_ht = newHt;   //这里会进行深拷贝，消耗很大，为了防止深拷贝我们直接交换</span><br><span class="line">            std::swap(_ht, newHt);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">    //此时哈希表就相当于一个链表指针数组</span><br><span class="line">    std::vector&lt;Node*&gt; _ht;</span><br><span class="line">    size_t _size;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">unordered_map.hpp:</span><br><span class="line">#pragma once</span><br><span class="line">#include &quot;hash_bucketMod.hpp&quot;</span><br><span class="line">template&lt;class K, class V&gt;</span><br><span class="line">class Unordered_Map</span><br><span class="line">&#123;</span><br><span class="line">    struct MapKeyOfValue</span><br><span class="line">    &#123;</span><br><span class="line">        const K&amp; operator()(const std::pair&lt;K, V&gt;&amp; data)</span><br><span class="line">        &#123;</span><br><span class="line">            return data.first;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">public:</span><br><span class="line">    typedef typename HashTable&lt;K, std::pair&lt;K, V&gt;, MapKeyOfValue&gt;::iterator iterator;</span><br><span class="line">    iterator begin()</span><br><span class="line">    &#123;</span><br><span class="line">        return _ht.begin();</span><br><span class="line">    &#125;</span><br><span class="line">    iterator end()</span><br><span class="line">    &#123;</span><br><span class="line">        return _ht.end();</span><br><span class="line">    &#125;</span><br><span class="line">    std::pair&lt;iterator, bool&gt; Insert(const std::pair&lt;K, V&gt;&amp; data)</span><br><span class="line">    &#123;</span><br><span class="line">        return _ht.Insert(data);</span><br><span class="line">    &#125;</span><br><span class="line">    V&amp; operator[](const K&amp; key)</span><br><span class="line">    &#123;</span><br><span class="line">        return (_ht.Insert(std::make_pair(key, V())).first)-&gt;second;</span><br><span class="line">    &#125;</span><br><span class="line">private:</span><br><span class="line">    HashTable&lt;K, std::pair&lt;K, V&gt;, MapKeyOfValue&gt; _ht;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">unordered_set.hpp:</span><br><span class="line">#pragma once</span><br><span class="line">#include &quot;hash_bucketMod.hpp&quot;</span><br><span class="line">template&lt;class K&gt;</span><br><span class="line">class Unordered_set</span><br><span class="line">&#123;</span><br><span class="line">    struct SetKeyOfValue</span><br><span class="line">    &#123;</span><br><span class="line">        const K&amp; operator()(const K&amp; data)</span><br><span class="line">        &#123;</span><br><span class="line">            return data;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">public:</span><br><span class="line">    typedef typename HashTable&lt;K, K, SetKeyOfValue&gt;::iterator iterator;</span><br><span class="line">    iterator begin()</span><br><span class="line">    &#123;</span><br><span class="line">        return _ht.begin();</span><br><span class="line">    &#125;</span><br><span class="line">    iterator end()</span><br><span class="line">    &#123;</span><br><span class="line">        return _ht.end();</span><br><span class="line">    &#125;</span><br><span class="line">    std::pair&lt;iterator, bool&gt; Insert(const K&amp; data)</span><br><span class="line">    &#123;</span><br><span class="line">        return _ht.Insert(data);</span><br><span class="line">    &#125;</span><br><span class="line">private:</span><br><span class="line">    HashTable&lt;K, K, SetKeyOfValue&gt; _ht;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">test.cpp:</span><br><span class="line">#include &quot;unordered_map.hpp&quot;</span><br><span class="line">#include &quot;unordered_set.hpp&quot;</span><br><span class="line">void test3()</span><br><span class="line">&#123;</span><br><span class="line">    Unordered_Map&lt;int, int&gt; umap;</span><br><span class="line">    umap.Insert(std::make_pair(1, 1));</span><br><span class="line">    umap.Insert(std::make_pair(5, 5));</span><br><span class="line">    umap.Insert(std::make_pair(6, 6));</span><br><span class="line">    umap.Insert(std::make_pair(9, 9));</span><br><span class="line">    for(auto e : umap)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; e.first &lt;&lt; &quot; &quot; &lt;&lt; e.second &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    umap[6] = 11;</span><br><span class="line">    umap[10] = 10;</span><br><span class="line">    umap[25] = 1;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line">    for (auto e : umap)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; e.first &lt;&lt; &quot; &quot; &lt;&lt; e.second &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    Unordered_set&lt;int&gt; uset;</span><br><span class="line">    uset.Insert(1);</span><br><span class="line">    uset.Insert(5);</span><br><span class="line">    uset.Insert(6);</span><br><span class="line">    uset.Insert(9);</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line">    for (auto e : uset)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; e &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    test3();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1 1</span><br><span class="line">5 5</span><br><span class="line">6 6</span><br><span class="line">9 9</span><br><span class="line"></span><br><span class="line">10 10</span><br><span class="line">1 1</span><br><span class="line">25 1</span><br><span class="line">5 5</span><br><span class="line">6 11</span><br><span class="line">9 9</span><br><span class="line"></span><br><span class="line">1</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">9</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;从结果上来看我们的实现目前成功了。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>&emsp;&emsp;通过这两章对关联式容器两种底层原理的探索和实现我们可以总结出以下结论。<br>&emsp;&emsp;1、普通版本的<code>map/set</code>底层使用的红黑树可以将搜索、插入和删除的操作时间复杂度优化为<code>OlogN</code>。<br>&emsp;&emsp;2、要求<code>map/set</code>中的<code>key</code>必须是可以比较的，不然就无法达成二叉搜索树中需要比较大小的操作，那么就无法成立红黑树。<br>&emsp;&emsp;3、<code>unordered</code>系列的<code>map/set</code>底层结构是一个哈希桶，可以将搜索、插入和删除的操作优化为<code>O1</code>，但是在每次需要增容的时候则不得不需要执行一次<code>On</code>的遍历操作，代价极大。<br>&emsp;&emsp;4、<code>unordered</code>系列的<code>map/set</code>插入数据的<code>key</code>要求必须有合适的哈希函数能够对其进行哈希，否则将无法计算出合适的下标存储数据，例如我们实现的时候写死了哈希函数，因此其只能存储<code>key</code>可以取模的数据，而如果<code>key</code>是一个字符串我们将束手无策，不过也有字符串的哈希方法，会将字符串转为整数在进行哈希，这里不再深入讨论。<br>&emsp;&emsp;5、<code>map/set</code>可以对数据根据<code>key</code>进行排序，且每次操作的事件复杂度十分平均都为<code>OlogN</code>；<code>unordered_map/unordered_set</code>不会对数据进行排序，虽然大多数情况下的操作都是<code>O1</code>的，但是一旦在插入时遇到增容的情况，则会造成极大消耗从而变成<code>ON</code>的时间复杂度，同时<code>unordered</code>系列有可能会消耗更多的内存空间。</p>

          
        
      
    </div>
    
    
    

    

    <div>
    
    </div>

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/10/25/【DS】栈的压入、弹出序列/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="MisakiFx">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/blog-logo.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Misaki`s blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/10/25/【DS】栈的压入、弹出序列/" itemprop="url">【DS】栈的压入、弹出序列</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-10-25T10:17:16+08:00">
                2019-10-25
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/数据结构/" itemprop="url" rel="index">
                    <span itemprop="name">数据结构</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  553
                </span>
              

              

              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="栈的压入、弹出序列"><a href="#栈的压入、弹出序列" class="headerlink" title="栈的压入、弹出序列"></a>栈的压入、弹出序列</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>&emsp;&emsp;输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否可能为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如序列1,2,3,4,5是某栈的压入顺序，序列4,5,3,2,1是该压栈序列对应的一个弹出序列，但4,3,5,1,2就不可能是该压栈序列的弹出序列。（注意：这两个序列的长度是相等的）<br><br>&emsp;&emsp;<a href="https://www.nowcoder.com/practice/d77d11405cc7470d82554cb392585106?tpId=13&amp;&amp;tqId=11174&amp;rp=2&amp;ru=/activity/oj&amp;qru=/ta/coding-interviews/question-ranking" target="_blank" rel="noopener">https://www.nowcoder.com/practice/d77d11405cc7470d82554cb392585106?tpId=13&amp;&amp;tqId=11174&amp;rp=2&amp;ru=/activity/oj&amp;qru=/ta/coding-interviews/question-ranking</a></p>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>&emsp;&emsp;这道题我们可以使用笨点的方法列举出所有弹出序列然乎一一比较判断，但是这样的实现方法事件复杂度很高，并不高效，于是采用以下的解法，只需要O(n)的时间复杂度。<br><br>&emsp;&emsp;1、首先我们初始化入栈序列和出栈序列和一个空栈，并用两个指针<code>ptr1 ptr2</code>首先指向两个序列的第一个元素。<br><img src="/2019/10/25/【DS】栈的压入、弹出序列/1.png" alt="题解"><br><br>&emsp;&emsp;2、只要<strong>栈为空</strong>或者<strong>当前栈顶元素与出栈序列中<code>ptr2</code>所指的元素不相同</strong>，则将入栈序列中<code>ptr1</code>所指的元素压入栈，并将<code>ptr1</code>后移。<br><br><img src="/2019/10/25/【DS】栈的压入、弹出序列/2.png" alt="题解"><br><br><img src="/2019/10/25/【DS】栈的压入、弹出序列/3.png" alt="题解"><br><br><img src="/2019/10/25/【DS】栈的压入、弹出序列/4.png" alt="题解"><br><br><img src="/2019/10/25/【DS】栈的压入、弹出序列/5.png" alt="题解"><br><br>&emsp;&emsp;3、如果<strong>当前栈顶元素与出栈序列中<code>ptr2</code>所指元素相同</strong>，则将当前栈顶元素出栈，并将<code>ptr2</code>后移。<br><img src="/2019/10/25/【DS】栈的压入、弹出序列/6.png" alt="题解"><br><br>&emsp;&emsp;4、重复第2第3步，如果<code>ptr2</code>可以遍历完出栈序列，则说明出栈序列是该栈的一个弹出顺序。如果<code>ptr1</code>中的入栈元素已经全部压入栈但是栈顶元素依然与出栈序列中<code>ptr2</code>所指元素不相同，还需要入栈，则说明出栈序列不是该栈的一个弹出顺序。<br><img src="/2019/10/25/【DS】栈的压入、弹出序列/7.png" alt="题解"><br><br><img src="/2019/10/25/【DS】栈的压入、弹出序列/11.png" alt="题解"><br><br><img src="/2019/10/25/【DS】栈的压入、弹出序列/8.png" alt="题解"><br><br><img src="/2019/10/25/【DS】栈的压入、弹出序列/9.png" alt="题解"><br><br><img src="/2019/10/25/【DS】栈的压入、弹出序列/10.png" alt="题解"><br></p>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool IsPopOrder(vector&lt;int&gt; pushV,vector&lt;int&gt; popV) &#123;</span><br><span class="line">        int pushi = 0, popi = 0;</span><br><span class="line">        stack&lt;int&gt; sta;</span><br><span class="line">        while(popi &lt; popV.size())</span><br><span class="line">        &#123;</span><br><span class="line">            if(sta.empty() || (sta.top() != popV[popi]))</span><br><span class="line">            &#123;</span><br><span class="line">                if(pushi &lt; pushV.size())</span><br><span class="line">                &#123;</span><br><span class="line">                    sta.push(pushV[pushi]);</span><br><span class="line">                    pushi++;</span><br><span class="line">                &#125;</span><br><span class="line">                else</span><br><span class="line">                &#123;</span><br><span class="line">                    return false;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">            &#123;</span><br><span class="line">                sta.pop();</span><br><span class="line">                popi++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
          
        
      
    </div>
    
    
    

    

    <div>
    
    </div>

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/10/24/【Linux】请问下面的程序一共输出多少个“-”？/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="MisakiFx">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/blog-logo.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Misaki`s blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/10/24/【Linux】请问下面的程序一共输出多少个“-”？/" itemprop="url">【Linux】请问下面的程序一共输出多少个“-”？</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-10-24T11:35:16+08:00">
                2019-10-24
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Linux/" itemprop="url" rel="index">
                    <span itemprop="name">Linux</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  1.1k
                </span>
              

              

              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="请问下面的程序一共输出多少个“-”？"><a href="#请问下面的程序一共输出多少个“-”？" class="headerlink" title="请问下面的程序一共输出多少个“-”？"></a>请问下面的程序一共输出多少个“-”？</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">    int i;</span><br><span class="line">    for (i = 0; i &lt; 2; i++) &#123; </span><br><span class="line">        fork(); </span><br><span class="line">        printf(&quot;-&quot;); </span><br><span class="line">    &#125; </span><br><span class="line">    return 0; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[misaki@localhost test]$ ./main </span><br><span class="line">--------</span><br></pre></td></tr></table></figure>
<h2 id="结果分析"><a href="#结果分析" class="headerlink" title="结果分析"></a>结果分析</h2><p>&emsp;&emsp;为啥会有8个’-‘呢？我们把这个程序稍微修改一下再看下结果。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">  int i;</span><br><span class="line">  for (i = 0; i &lt; 2; i++) </span><br><span class="line">  &#123;                          </span><br><span class="line">    fork();      </span><br><span class="line">    printf(&quot;-&quot;);   </span><br><span class="line">    fflush(stdout);</span><br><span class="line">  &#125;        </span><br><span class="line">  sleep(1);</span><br><span class="line">  return 0;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[misaki@localhost test]$ ./main</span><br><span class="line">------</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;现在又变成了6个’-‘，我们先从以上这段程序开始分析。我们分别打印各个进程的pid和他们的ppid来让我们看的更清楚一些，并且查看以下进程树。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">  int i;</span><br><span class="line">  for (i = 0; i &lt; 2; i++)</span><br><span class="line">  &#123;</span><br><span class="line">    fork();</span><br><span class="line">    printf(&quot;ppid:%d, pid:%d\n&quot;, getppid(), getpid());</span><br><span class="line">    fflush(stdout);</span><br><span class="line">  &#125;</span><br><span class="line">  sleep(10);                                         </span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[misaki@localhost test]$ ./main</span><br><span class="line">ppid:2221, pid:4846</span><br><span class="line">ppid:4846, pid:4847</span><br><span class="line">ppid:2221, pid:4846</span><br><span class="line">ppid:4846, pid:4848</span><br><span class="line">ppid:4846, pid:4847</span><br><span class="line">ppid:4847, pid:4849</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[misaki@localhost ~]$ pstree -ap misaki</span><br><span class="line">sshd,2220</span><br><span class="line">  ├─bash,2221</span><br><span class="line">  │   └─main,4846</span><br><span class="line">  │       ├─main,4847</span><br><span class="line">  │       │   └─main,4849</span><br><span class="line">  │       └─main,4848</span><br><span class="line">  └─bash,3571</span><br><span class="line">      └─pstree,4850 -ap misaki</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;<code>fork()</code>执行后子进程会赋值父进程的代码段，以及<code>PCB</code>中的部分数据其中包括程序计数器，上下文数据等来保证自己会按照父进程当前的执行流和代码继续执行下去。<br>&emsp;&emsp;我们的父进程<code>4846</code>进入循环后首先创建了子进程<code>4847</code>然后打印一次，然后再次执行一次循环有创建了一个子进程<code>4848</code>然后又打印一次，至此父进程执行完毕循环进入<code>sleep()</code>，于是父进程会打印两次。<br>&emsp;&emsp;子进程<code>4847</code>在创建后先打印一次，然后继续执行流再次执行循环又会创建一个子进程<code>4849</code>，然后再打印一次，随后循环结束，于是子进程<code>4847</code>也会打印两次。<br>&emsp;&emsp;子进程<code>4848</code>是在父进程<code>4846</code>第二次循环创建出来的，于是只打印一次退出循环，子进程<code>4848</code>只会打印一次。<br>&emsp;&emsp;孙子进程<code>4849</code>是在子进程<code>4847</code>第二次循环创建出来的，于是也只打印一次便结束了循环，子进程<code>4849</code>也只打印一次。<br>&emsp;&emsp;至此一共打印六次全部完毕。<br>&emsp;&emsp;我们回到最初的问题，那么这道题为什么会是8次，而我每次打印后刷新一次缓冲区结果就变成了6次.<br>&emsp;&emsp;其实我们的子进程会复制父进程的缓冲区。关于缓冲区，Unix下的设备<strong>块设备</strong>和<strong>字符设备</strong>的概念，所谓块设备，就是以一块一块的数据存取的设备，字符设备是一次存取一个字符的设备。磁盘、内存都是块设备，字符设备如键盘和串口。块设备一般都有缓存，而字符设备一般都没有缓存。<br>&emsp;&emsp;程序遇到“\n”，或是EOF，或是缓冲区满，或是文件描述符关闭，或是主动<code>flush</code>，或是程序退出，就会把数据刷出缓冲区。需要注意的是，标准输出是行缓冲，所以遇到“\n”的时候会刷出缓冲区，但对于磁盘这个块设备来说，“\n”并不会引起缓冲区刷出的动作，那是全缓冲，你可以使用setvbuf来设置缓冲区大小，或是用fflush刷缓存。<br>&emsp;&emsp;我们的子进程在创建时复制了父进程的缓冲区，而此时的父进程的标准输入的缓冲区并没有刷新，就会导致在<code>printf</code>后面创建的子进程复制的缓冲区中还存有父进程打印的’-‘，以上的例子中的<code>4848</code>和<code>4849</code>这两个进程如果在没有刷新缓冲区的情况下就会复制上父进程输出的’-‘导致多打出两个’-‘，于是这样就解释的通为什么会打印8个了。<br>&emsp;&emsp;这道题还是有一点坑的，需要对<code>fork()</code>创建子进程的底层实现有清楚的认识和了解，也需要对缓冲区相关的知识有一定了解。</p>

          
        
      
    </div>
    
    
    

    

    <div>
    
    </div>

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/9/">9</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/blog-logo.jpg"
                alt="MisakiFx" />
            
              <p class="site-author-name" itemprop="name">MisakiFx</p>
              <p class="site-description motion-element" itemprop="description">Hard working or giving up!!!</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">83</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">9</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">60</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/MisakiFx" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="mailto:1761607418@qq.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope-open"></i>E-Mail</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://music.163.com/#/user/home?id=432551242" target="_blank" title="网易云音乐">
                      
                        <i class="fa fa-fw fa-music"></i>网易云音乐</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://blog.csdn.net/qq_41669298" target="_blank" title="CSDN">
                      
                        <i class="fa fa-fw fa-crosshairs"></i>CSDN</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        ﻿<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js">
</script>
<div class="copyright">&copy; <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">MisakiFx</span>

  
</div>


<div class="powered-by">
  <i class="fa fa-user-md"></i>
  <span id="busuanzi_container_site_uv">
    我的网站的访客数:<span id="busuanzi_value_site_uv"></span>
  </span>
</div>



<span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.4</div>




<div class="theme-info">
  <div class="powered-by"></div>
  <span class="post-count">博客全站共250.9k字</span>
</div>

        ﻿







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  


  











  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  

  
  
    <script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

  <!-- 页面点击小红心 -->
        <script type="text/javascript" src="/js/src/love.js"></script>
<script src="/live2dw/lib/L2Dwidget.min.js?0c58a1486de42ac6cc1c59c7d98ae887"></script><script>L2Dwidget.init({"pluginModelPath":"assets/","model":{"jsonPath":"/live2dw/assets/z16.model.json"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":false},"log":false,"pluginJsPath":"lib/","pluginRootPath":"live2dw/","tagMode":false});</script></body>
</html>
