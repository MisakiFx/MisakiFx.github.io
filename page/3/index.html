<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.ico?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon_16.ico?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta name="description" content="Hard working or giving up!!!">
<meta property="og:type" content="website">
<meta property="og:title" content="Misaki`s blog">
<meta property="og:url" content="http://yoursite.com/page/3/index.html">
<meta property="og:site_name" content="Misaki`s blog">
<meta property="og:description" content="Hard working or giving up!!!">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Misaki`s blog">
<meta name="twitter:description" content="Hard working or giving up!!!">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/page/3/"/>





  <title>Misaki`s blog</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

<a href="https://github.com/MisakiFx" class="github-corner" aria-label="View source on GitHub"><svg width="80" height="80" viewBox="0 0 250 250" style="fill:#64CEAA; color:#fff; position: absolute; top: 0; border: 0; left: 0; transform: scale(-1, 1);" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Misaki`s blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">学习是一种态度</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/09/09/【网络】第一章-网络基础/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="MisakiFx">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/blog-logo.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Misaki`s blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/09/09/【网络】第一章-网络基础/" itemprop="url">【网络】第一章-网络基础</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-09-09T19:21:08+08:00">
                2019-09-09
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/网络/" itemprop="url" rel="index">
                    <span itemprop="name">网络</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  1.8k
                </span>
              

              

              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="网络基础"><a href="#网络基础" class="headerlink" title="网络基础"></a>网络基础</h1><p>&emsp;&emsp;在这个章节先对计算机网络进行大概简单的介绍，之后的章节会逐个进行深入的讨论。</p>
<h2 id="网络发展背景"><a href="#网络发展背景" class="headerlink" title="网络发展背景"></a>网络发展背景</h2><h2 id="网络的构成"><a href="#网络的构成" class="headerlink" title="网络的构成"></a>网络的构成</h2><p>&emsp;&emsp;网络一开始先利用<strong>交换机</strong>进行两台计算机之间的互联及数据交换，一台主机将数据发给交换机，交换机再发送给另一台，不会起任何冲突。<br><br><img src="/2019/09/09/【网络】第一章-网络基础/1.png" alt="交换机"><br><br>&emsp;&emsp;但是假如又要加入一台主机，交换机就会起矛盾，它不知道该将数据发给哪台主机。为此又出现了新的数据交换工具，<strong>路由器</strong>，路由器可以自己选择将数据发送给合适的主机。<br><img src="/2019/09/09/【网络】第一章-网络基础/2.png" alt="路由器"><br><br>&emsp;&emsp;由此便构成了一个小型局域网。<br><img src="/2019/09/09/【网络】第一章-网络基础/3.png" alt="局域网"><br><br>&emsp;&emsp;假如此时又有一个这样的<strong>局域网</strong>，他们之间又通过路由器进行数据交换，于是它们又构成了一个更大一些的局域网。一旦局域网变得更大，就会变成城域网，之后是广域网，由此构成网络环境。局域网城域网与广域网之间的区别<strong>由网络的覆盖范围而决定</strong>。<br><img src="/2019/09/09/【网络】第一章-网络基础/4.png" alt="局域网"><br></p>
<h2 id="IP地址"><a href="#IP地址" class="headerlink" title="IP地址"></a>IP地址</h2><p>&emsp;&emsp;IP地址在网络中唯一的标识了一个主机，数据从哪里来要到哪里去都要用到ip地址。IP地址由一个4个字节的无符号整数组成，因此一共可以标识42亿个主机，这在计算机发明之初大家可能都认为这是一个天文数字了，肯定够用了，但在现在来看这明显不够用啊，怎么办呢？</p>
<h3 id="DHCP-NAT"><a href="#DHCP-NAT" class="headerlink" title="DHCP/NAT"></a>DHCP/NAT</h3><p>&emsp;&emsp;伟大的人类想到两种缓兵之计，<strong>DHCP/NAT</strong>技术。DHCP技术使路由器可以动态给连接到自己的主机分配ip地址，也就是内网IP地址（这个IP地址外网是连接不到的），谁上网给谁分配，这样可以减少ip地址的使用情况。但是还是不够啊，怎么办？呢就让大家共用同一个ip地址吧，于是路由器建立映射，将内网所有主机的内网ip建立映射，收集所有数据统一使用自己的ip地址进行数据发送到外网，等收取数据时再根据映射发给内网中的主机，这样就可以极大减少IP地址的使用。但是目前来看ip地址依然十分紧张，因此现在国家也在强力发展ipv6，这是一个16个字节的整数，这个足够用了，不过困难的是ipv6不兼容ipv4因此目前发展并不是很好。</p>
<h2 id="端口"><a href="#端口" class="headerlink" title="端口"></a>端口</h2><p>&emsp;&emsp;端口(port)，在一台主机上唯一标识一个进程，在网络通讯中用来表示数据从主机上的哪一个进程发出，并发送给另一台主机上的哪一个进程。网络通信每一条数据中，都会包含两条信息：源端口，目的端口。<br>&emsp;&emsp;端口的是一个<code>uint16_t</code>类型的，因此端口范围从0-65535。并且一个端口只能被一个进程占用，但一个进程可以使用多个端口。</p>
<h2 id="网络协议"><a href="#网络协议" class="headerlink" title="网络协议"></a>网络协议</h2><p>&emsp;&emsp;网络通信中，为了保证字符编码，数据格式，传输方式的一致性，需要通信双方使用数据格式的约定，若要实现网络互联，就需要定理网络通信协议标准，统一网络通信数据格式。<br>&emsp;&emsp;在网络通信中每条数据都会包含一个五元组（源ip地址/源端口/目的IP地址/目的端口/协议）。</p>
<h2 id="协议分层"><a href="#协议分层" class="headerlink" title="协议分层"></a>协议分层</h2><p>&emsp;&emsp;按照提供的服务，协议，接口对环境进行分层，从底层来说就是一种封装，上层并不需要关心下层的一个实现，直接使用就可以，使用的更加灵活方便。协议分层之后，通信环境层次清晰，并且每一次的功能具体实现会变得简单化，更容易形成标准。<br>&emsp;&emsp;在网络通信中环境也是十分复杂的，因此为了更加容易的去实现网络通信功能因此对整个通信环境进行分层。</p>
<h3 id="OSI七层模型"><a href="#OSI七层模型" class="headerlink" title="OSI七层模型"></a>OSI七层模型</h3><p>&emsp;&emsp;OSI七层模型(由上至下)：<strong>应用层-&gt;表示层-&gt;会话层-&gt;传输层-&gt;网络层-&gt;链路层-&gt;物理层</strong>。<br>&emsp;&emsp;但是这种模型并不实用，因为表示层，会话层和应用层功能相近分开进行实现反倒十分麻烦，因此现在并不常用这套模型，因为有更好的模型进行替代。</p>
<h3 id="tcp-ip五层模型"><a href="#tcp-ip五层模型" class="headerlink" title="tcp/ip五层模型"></a>tcp/ip五层模型</h3><p>&emsp;&emsp;tcp/ip五层模型(由上至下)：<strong>应用层-&gt;传输层-&gt;网络层-&gt;链路层-&gt;物理层</strong>。<br>&emsp;&emsp;<strong>tcp/ip</strong>协议是一个协议簇，其中有着很多的协议，而tcp/ip是其中的代表协议，因此以此命名。其中还有很多常用的协议。<br>&emsp;&emsp;五层模型每一层都有属于自己的协议，组织不同的数据形式，以下由高至低讨论。<br>&emsp;&emsp;应用层：负责应用程序之间的数据沟通。这个层中的协议一部分是软件开发者为了组织数据的同时进行数据加密自己定制的协议，被称为<strong>自定制协议</strong>；当然还有一部分是由于协议定制的十分方便，广为流传大家都在使用，这类协议被称为<strong>知名协议</strong>，例如<strong>HTTP</strong>协议。<br>&emsp;&emsp;传输层：负责端与端之间的数据沟通。封装端口信息，用来标识数据由哪个进程发出，目标到哪个进程中去。常见协议有<strong>TCP/UDP</strong>协议。<br>&emsp;&emsp;网络层：负责地址管理与路由选择。负责选择让数据如何通过最合适的路径传达到目标路由器上。常见协议：<strong>IP</strong>协议，常用设备有<strong>路由器</strong>。<br>&emsp;&emsp;链路层：相邻设备之间的数据传输。在实际中要将数据实际发送到与自己相邻的主机，一般来说是通过广电信号进行传输，但是为了能够找到目标主机，在底层网卡往往有着自己的一个地址用来标识自己，这个地址叫做<strong>MAC</strong>地址，链路层就是通过<strong>MAC</strong>地址找到实际要传输数据的网卡并将数据交给它。常见协议<strong>以太网协议Ethernt</strong>，常见设备<strong>交换机</strong>。<br>&emsp;&emsp;物理层：负责光电信号的传输。这一侧就是物理的信号传输了。常见协议<strong>以太网协议</strong>，常见设备<strong>集线器</strong>。</p>
<h2 id="网络通信数据的传输流程"><a href="#网络通信数据的传输流程" class="headerlink" title="网络通信数据的传输流程"></a>网络通信数据的传输流程</h2><p><img src="/2019/09/09/【网络】第一章-网络基础/5.png" alt="交换机"><br><br>&emsp;&emsp;以上标识的就是数据在网络通信中传输的流程，发送数据时每一层都会在信息中加入类似结构体的东西对数据进行封装，接受数据时也会一层一层解开响应的结构体获取数据。</p>

          
        
      
    </div>
    
    
    

    

    <div>
    
    </div>

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/08/31/【Cpp】《Effective-C-》第一章-让自己习惯C/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="MisakiFx">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/blog-logo.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Misaki`s blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/08/31/【Cpp】《Effective-C-》第一章-让自己习惯C/" itemprop="url">【Cpp】《Effective C++》第一章-让自己习惯C++</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-08-31T22:28:00+08:00">
                2019-08-31
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Cpp/" itemprop="url" rel="index">
                    <span itemprop="name">Cpp</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  7.3k
                </span>
              

              

              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>&emsp;&emsp;这是我在学习《Effective C++》中总结得出的心得与体会，完全是以我自己的理解所作的笔记，是对个人经验的积累。基于第三版我以每个章节进行总结，全书一共九个章节。</p>
<h1 id="第一章-让自己习惯C"><a href="#第一章-让自己习惯C" class="headerlink" title="第一章-让自己习惯C++"></a>第一章-让自己习惯C++</h1><h2 id="条款01：视C-为一个语言联邦"><a href="#条款01：视C-为一个语言联邦" class="headerlink" title="条款01：视C++为一个语言联邦"></a>条款01：视C++为一个语言联邦</h2><p>&emsp;&emsp;<strong>View C++ as a federation of languages.</strong><br>&emsp;&emsp;在初期Cpp被开发之初，Cpp并没有如今这样丰富的功能，它更应该被称为仅是一个带有面向对象特性的C，即<strong>C with Classes</strong>。但如今的Cpp已经在其基础纸上新增了诸多特性例如模板更好的支持了泛型编程，STL给我们提供了更多的工具，加上其完全兼容C使其既可以面向对象编程也可以面向过程编程，这就使Cpp成为了一个历史上独一无二绝无仅有的强大存在，其也可以被理解为多个语言的组合，我们这些语言称为<strong>次语言(sublanguage)</strong>。<br>&emsp;&emsp;也正因Cpp可以被看为多个次语言的组合，使它的语法更为复杂，标准更加难以捉摸，但是当我们在使用某个次语言的时候，守则与通例都会变得更加简单易懂。然而当我们从一个次语言切换到另一个时，守则往往也会改变。<br>&emsp;&emsp;在《Effective C++》中将Cpp分为了四种次语言，是我们可以更加直观的正视这门复杂的语言。<br>&emsp;&emsp;<strong>4种次语言：</strong><br>&emsp;&emsp;<strong>1、C</strong>：Cpp是以C为基础，Cpp的编程是更为高级的C编程，其可以是为是对C的封装及升级，并且Cpp中的诸多语法都是来自于C，例如指针、数组、预处理等等。但当我们仅仅使用C这一次语言的时候的我们则要考虑守则与规范在这一次语言中的极限，因为在这里没有模板，没有异常，没有重载。因此当我们在Cpp内使用纯C进行编程时要注意让自己遵守的规范从C的角度出发，考虑更为底层更为细节的方面。<br>&emsp;&emsp;<strong>2、Object-Oriented C++</strong>：这一部分可以看作是Cpp开发之初<strong>C with Classes</strong>所实现的部分，是带面向对象版本的C。在这一次语言中凸显了Cpp面向对象的特点例如封装、继承、多态、动态绑定等。在使用这部分的次语言时我们则要遵守面向对象在Cpp上的守则。<br>&emsp;&emsp;<strong>3、Template C++</strong>：这是Cpp的泛型编程部分，在这一部分有着模板这一概念，而模板的书写往往是在给高级编程搭轮子。模板编程弥漫了整个Cpp，并且带来了崭新的编程范型<strong>模板元编程(template meteprogramming/TMP)</strong>。唯独模板才适用的规范也并不在少数，但是这些与Cpp主流编程并不冲突。<br>&emsp;&emsp;<strong>4、STL</strong>：STL是Cpp中标准的模板库，也是最常用最常见的工具库，其中六大组件互相配合，当然如果你使用STL那么也要遵守STL独有的规范。<br>&emsp;&emsp;在使用不同的次语言时就有着不同的规范守则，当你从一个次语言切换到另一个时高效编程守则有可能需要你改变策略。例如在对内置类型传参时用值传参(pass-by-value)往往比传引用(pass-by-reference)更加高效，但当你如果从<strong>C part of C++</strong>这一次语言移往<strong>Object-Oriented C++</strong>，对于用户自定义的类型在传参时往往是传引用(pass-by-reference)更加高效，因为省略掉了一次拷贝构造，避免了不必要的开销，对于<strong>Template C++</strong> 来说也是这样。<br>&emsp;&emsp;由以上可以看出当我们在使用Cpp进行编程时，使用不同部分的次语言为了更加高效的进行编程往往就需要遵守不同的守则，这些守则有可能在不同的次语言间是相互违背的，所以<strong>在不同的次语言见进行转换时我们的策略可能也需要进行改变</strong>。这也是为什么要将Cpp分为这些次语言的原因这点很重要。<br>&emsp;&emsp;牢记一点：Cpp的高效编程视情况而变化，取决于使用Cpp的哪一部分。</p>
<h2 id="尽量以const-enum-inline替换-define"><a href="#尽量以const-enum-inline替换-define" class="headerlink" title="尽量以const,enum,inline替换#define"></a>尽量以const,enum,inline替换#define</h2><p>&emsp;&emsp;<strong>Prefer consts,enums,and inlines to #defines.</strong><br>&emsp;&emsp;在这一条款中，要求程序员最好可以<strong>用编译器来代替预编译器</strong>，因为预编译器并不可以视为语言的一部分。</p>
<h3 id="用const-enum替代宏定义常量"><a href="#用const-enum替代宏定义常量" class="headerlink" title="用const,enum替代宏定义常量"></a>用const,enum替代宏定义常量</h3><p>&emsp;&emsp;预编译器中你定义的宏的名称并不会计入符号表内，从而使得调试及排错十分困难。因此我们尽量使用常量定义来代替宏定义，首当其冲就是为了避免宏定义使得其名称无法计入符号表。<br>&emsp;&emsp;但是对于定义常量来代替宏有两点特殊情况需要讨论：<br>&emsp;&emsp;1、定义常量指针(constant pointers)。关于常量指针和指向常量的指针在C语言章节就有解释。在本书中这里指的是一个完全是常量的指针，即是一个既是本身无法改变并且所指内容也无法改变的指针，因此我们为了定义这样一个常量需要将<code>const</code>写两遍才行。例：<code>const char* const authorName = &quot;Misaki&quot;;</code>，但这种情况下利用Cpp中的STL中的<code>string</code>类反倒更好定义。<br>&emsp;&emsp;2、类的成员专属常量。这种常量为了让其只有一份实体，因此要让其成为<code>static</code>的。一般情况下我们在定义一个静态的成员变量时都需要在类外进行定义，然而<strong>如果这个静态成员变量具有常性，即是<code>const</code>的，并且它为整数类型(integral type)，再并且只要不取它们的地址</strong>则它无需在类外进行定义。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class GamePlayer</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    static const int NumTurns = 5;</span><br><span class="line">    int scores[NumTurns];</span><br><span class="line">&#125;;</span><br><span class="line">//const int GamePlayer::NumTurns; //不给予数值的定义式</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; GamePlayer::NumTurns &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">5</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;当然如果你要取他们的地址或者你的编译器坚持要看到定义式则也是可以加上定义式的，但是 不可以再次给予数值，因为其载声明时已经获得初值了。<br>&emsp;&emsp;但是我们无法使用宏定义的方式来定义一个成员常量，宏并不在乎作用域，受<code>#define</code>和<code>#undef</code>等宏的控制，因此宏并不具备封装性。<br>&emsp;&emsp;但是有的编译器也许不支持在声明中就获得初值的<code>in-class初值设定</code>，呢么我们只好在定义中加入初值。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class GamePlayer</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    static const int NumTurns;</span><br><span class="line">    //int scores[NumTurns];//编译器要求在编译时就能确定数组的大小</span><br><span class="line">&#125;;</span><br><span class="line">const int GamePlayer::NumTurns = 5; </span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; GamePlayer::NumTurns &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">5</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;但这种情况下我们并无法在编译期间获得一个常量值，因此无法用其定义数组，但是也有其他解决方法，改用<code>the enum hack</code>的补偿做法。一个枚举类型的数值可权充<code>int</code>被使用。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class GamePlayer</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    //static const int NumTurns;</span><br><span class="line">    enum </span><br><span class="line">    &#123;</span><br><span class="line">        NumTurns = 5</span><br><span class="line">    &#125;;</span><br><span class="line">    int scores[NumTurns];//编译器要求在编译时就能确定数组的大小</span><br><span class="line">&#125;;</span><br><span class="line">//const int GamePlayer::NumTurns = 5; </span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; GamePlayer::NumTurns &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">5</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;这样也可以在编译时就确定常量的值。通过这个<code>enum hack</code>我们也可以直接在编译期间使用常量，然而<code>enum hack</code>在某些方面的表现更接近于<code>#define</code>宏定义而不是<code>const</code>常量，例如取一个<code>const</code>常量的地址是合法的，然而取<code>#define</code>和<code>enum</code>的地址是不合法的。<code>enum hack</code>在很多方面都很实用，并且是模板元编程的而基础技术。</p>
<h3 id="用inline替代宏函数"><a href="#用inline替代宏函数" class="headerlink" title="用inline替代宏函数"></a>用inline替代宏函数</h3><p>&emsp;&emsp;另一个<code>#define</code>很坑的地方就是用它去实现宏函数。因为宏只是单纯的文本替换因此我们经常要给所有实参都加上括号来防止意外发生，但这样会大大降低代码可读性。因此书中极大程度建议使用<code>inline</code>函数来代替宏函数，它同样可以节省函数调用的额外开销，但是有着更好的可读性。并且在类中还可以定义专属于类内的<code>private inline</code>函数，而宏定义做不到此事。<br>&emsp;&emsp;我们总结一下<strong>宏的缺点</strong>：<br>&emsp;&emsp;1、定义常量不会计入记号表(symbol table)，因此不便于调试。<br>&emsp;&emsp;2、无法定义成员常量，宏并不重视作用域。<br>&emsp;&emsp;3、宏的使用，尤其是宏函数会使代码可读性变差，不便于理解。<br>&emsp;&emsp;因此<strong>对于常量，最好以<code>const</code>或<code>enum</code>替代<code>#define</code>；对于宏函数最好用<code>inline</code>函数替代<code>#define</code></strong>。在用<code>const</code>定义常量的时候也有两点特殊情况需要注意，一个是常量指针一个是类专属常量。<br>&emsp;&emsp;我们基本可以用<code>enum,const,inline</code>替代<code>#define</code>所有使用场景，降低了对预处理器的使用，但是也并非完全消除，预处理器依然有举足轻重的作用，我们只能尽可能减少对其的使用。比如说当我们在写日志检错时就需要用到宏，需要知道具体是哪一行发生了错误，而如果使用函数则会跳转到函数中。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>&emsp;&emsp;1、对于单纯常量，最好以const对象或enums替换#define。<br>&emsp;&emsp;2、对于宏函数，最好以inline函数替代。</p>
<h2 id="尽可能使用const"><a href="#尽可能使用const" class="headerlink" title="尽可能使用const"></a>尽可能使用const</h2><p>&emsp;&emsp;<strong>Use const whenever possible.</strong><br>&emsp;&emsp;<code>const</code>多才多艺，可以用来修饰相当多的变量或函数，一旦被修饰则该对象会被编译器强制约束来保持它自身不会被改变。</p>
<h3 id="const对于指针和迭代器"><a href="#const对于指针和迭代器" class="headerlink" title="const对于指针和迭代器"></a>const对于指针和迭代器</h3><p>&emsp;&emsp;对于指针而言 <strong><code>const</code>出现在<code>*</code>左边表示被指示物是常量，如果出现在<code>*</code>右边则表示指针本身是常量，当然其也可以两边都出现表示被指示物和指针本身都是常量。</strong><br>&emsp;&emsp;通过对STL中容器的模拟实现我们也可以很清楚的知道迭代器底层的实现其实就是一个指针，因此迭代器对<code>const</code>来说也有着和指针一样的应用。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    vector&lt;int&gt; vec = &#123;1, 2, 3, 4&#125;;</span><br><span class="line">    //我们给接下来这个迭代器加上const</span><br><span class="line">    //其类似于T* const指针，注意不是const T*虽然const写在前面，但这里const强调的是迭代器自身的不可变</span><br><span class="line">    //迭代器也不过是一个typedef类型而已</span><br><span class="line">    const vector&lt;int&gt;::iterator iter = vec.begin();</span><br><span class="line">    *iter = 5;//合法，迭代器所指对象可变</span><br><span class="line">    //iter++;//不合法，迭代器自身不可变</span><br><span class="line">    cout &lt;&lt; vec[0] &lt;&lt; endl;</span><br><span class="line">    //这里相当于一个const T*指针，指向内容不可改，自身可改</span><br><span class="line">    vector&lt;int&gt;::const_iterator const_iter = vec.begin();</span><br><span class="line">    //*const_iter = 1;//不合法，指向内容不可改</span><br><span class="line">    const_iter++;//合法，自身可变</span><br><span class="line">    cout &lt;&lt; *const_iter &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">5</span><br><span class="line">2</span><br></pre></td></tr></table></figure></p>
<h3 id="const对于函数的应用"><a href="#const对于函数的应用" class="headerlink" title="const对于函数的应用"></a>const对于函数的应用</h3><p>&emsp;&emsp;<code>const</code>可以与一个函数的返回值、参数、自身产生关联。在这里我们先讨论对返回值以及参数的关联。<br>&emsp;&emsp;对于函数的返回值，我们用<code>const</code>进行修饰来避免产生一些意外情况。这里我用书中举得例子，来重载一个有理数类的<code>operator*</code>运算符。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">class Rational&#123; ... &#125;;</span><br><span class="line">const Rational operator*(const Rational&amp; lhs, const Rational&amp; rhs);</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;这里参数设置为引用加<code>const</code>修饰的原因是为了减少拷贝构造加快效率同时避免对操作数的修改，很好理解，但是返回值加<code>const</code>或许比较难以想到，这是因为总可能有人会写出这样违法的代码。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Rational a, b, c;</span><br><span class="line">(a * b) = c;//在a * b结果上调用operator=</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;这段代码如果我们对<code>operator*</code>重载的返回值并未加上<code>const</code>编译器是允许编的过这样违法的操作的，但这明显是不合常理的是我们想命令禁止的，因此对于用<code>const</code>来修饰函数的返回值也有着莫大的必要。<br>&emsp;&emsp;对于<code>const</code>修饰参数已经再熟悉不过了，只要你不想修改它都建议将其定义为<code>const</code>，这是很好的习惯。</p>
<h3 id="const成员函数"><a href="#const成员函数" class="headerlink" title="const成员函数"></a>const成员函数</h3><p>&emsp;&emsp;接下来我们着重讨论如何<code>const</code>对于函数自身的修饰，而这些修饰都与类成员函数有关。<br>&emsp;&emsp;<code>const</code>修饰成员函数自身就是将其修饰为常成员函数，在这种函数中无法修改调用对象自身的数据，因为传入的是一个<code>const</code>的<code>this</code>指针。同时我们还要注意一点很重要的语法，<strong>常成员函数与普通成员函数间会构成重载</strong>，即使两个成员函数的参数列表完全相同，但只要他们在同一个类中并且函数名相同，仅由常量性<code>constness</code>不同也是可以构成重载的。但是注意<strong>此时其构成重载的原因并非是<code>this</code>指针这个参数被<code>const</code>修饰，因为<code>const</code>修饰参数是构不成函数重载的，这里的重载原因是因为函数常量性的不同，与参数无关</strong>。<br>&emsp;&emsp;下面这个例子就展现了利用成员函数常量性的不同所构成重载。当普通成员函数与常成员函数发生重载时，普通对象会优先自动调用普通成员函数，常对象会优先自动调用常成员函数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class TextBook</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    //重载operator[]</span><br><span class="line">    //这里返回值加const是为了让const对象自身不被修改不造成错误</span><br><span class="line">    const char&amp; operator[](size_t position) const</span><br><span class="line">    &#123;</span><br><span class="line">        return text[position];</span><br><span class="line">    &#125;</span><br><span class="line">    char&amp; operator[](size_t position)</span><br><span class="line">    &#123;</span><br><span class="line">        return text[position];</span><br><span class="line">    &#125;</span><br><span class="line">private:</span><br><span class="line">    string text = &quot;123456&quot;;</span><br><span class="line">&#125;;</span><br><span class="line">void Print(const TextBook&amp; book1, TextBook&amp; book2)</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; book1[0] &lt;&lt; endl;//合法</span><br><span class="line">    cout &lt;&lt; book2[0] &lt;&lt; endl;//合法</span><br><span class="line">    book2[0] = &apos;5&apos;;//合法，普通对象调用普通成员函数，返回值可改</span><br><span class="line">    cout &lt;&lt; static_cast&lt;const TextBook&amp;&gt;(book2)[0] &lt;&lt; endl;</span><br><span class="line">    //static_cast&lt;const TextBook&amp;&gt;(book2)[0] = &apos;1&apos;;//非法这里我们将其转换为const类型对象发现可以主动调用常成员函数</span><br><span class="line">    //book1[0] = &apos;5&apos;;//非法，常量对象调用常成员函数而其返回值是const修饰的因此不可改</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    TextBook book;</span><br><span class="line">    Print(book, book);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1</span><br><span class="line">1</span><br><span class="line">5</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;并且通过以上的代码我还发现虽然普通对象可以调用常成员函数，但是当其与普通成员函数构成重载时我们想要显示调用常成员函数必须将对象转换为<code>const</code>的，这完全没有必要，属于脱裤子放屁的一种手段。</p>
<h3 id="bitwise-constness和logical-constness"><a href="#bitwise-constness和logical-constness" class="headerlink" title="bitwise constness和logical constness"></a>bitwise constness和logical constness</h3><p>&emsp;&emsp;如果一个成员函数是常成员函数，则就会引申出这样两个流行概念。<br>&emsp;&emsp;<code>bitwise const</code>阵营的人相信只有成员函数不改变成员的任何变量的时候才可以说其为<code>const</code>的，这也是Cpp中对常量性的定义，<code>const</code>成员函数不可以更改对象内任何的<code>non-static</code>成员变量。<br>&emsp;&emsp;但是不幸的是在Cpp中很容易对这一观点进行反驳，很多<code>const</code>尽管已经对对象的成员进行了更改依然可以编译通过。比如说成员中有指针的存在。比如以下这个例子。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class CTextBook</span><br><span class="line">&#123;</span><br><span class="line">friend ostream&amp; operator&lt;&lt;(ostream &amp;cout, const CTextBook&amp; text);</span><br><span class="line">public:</span><br><span class="line">    CTextBook(const char* str)</span><br><span class="line">        :_text(nullptr)</span><br><span class="line">    &#123;</span><br><span class="line">        int capacity = strlen(str) + 1;</span><br><span class="line">        _text = new char[capacity];</span><br><span class="line">        strcpy(_text, str);</span><br><span class="line">    &#125;</span><br><span class="line">    ~CTextBook()</span><br><span class="line">    &#123;</span><br><span class="line">        if(_text != nullptr)</span><br><span class="line">        &#123;</span><br><span class="line">            delete[] _text;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    char&amp; operator[](size_t position) const</span><br><span class="line">    &#123;</span><br><span class="line">        return _text[position];</span><br><span class="line">    &#125;</span><br><span class="line">private:</span><br><span class="line">    char* _text;</span><br><span class="line">&#125;;</span><br><span class="line">ostream&amp; operator&lt;&lt;(ostream &amp;cout, const CTextBook&amp; text)</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; text._text &lt;&lt; endl;</span><br><span class="line">    return cout;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    CTextBook text(&quot;Hello&quot;);</span><br><span class="line">    text[0] = &apos;J&apos;;</span><br><span class="line">    cout &lt;&lt; text;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Jello</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;以上这个例子中我们在<code>const</code>成员函数中并没有改变成员变量，因此编译器并没有报错，以此欺骗了编译器，但是并不代表我们不能通过<code>const</code>成员函数改变成员内的对象。由此即产生了第二个阵营对<code>const</code>成员函数的理解即<code>logical constness</code>。<br>&emsp;&emsp;这个阵营中的人主张<code>const</code>成员函数可以改变其所处理的对象中的某些成员变量，但是只有在客户端侦测不出的情况下才可以这样。但是还有一些情况下我们要修改一些本身可以修改的成员变量，他们的修改从逻辑角度考虑是合理的，是必须的，但是此时编译器由于语法的关系判定其不符合<code>bitwise constness</code>，因此判定其报错不通过编译。例如以下这种情况。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class CTextBook</span><br><span class="line">&#123;</span><br><span class="line">friend ostream&amp; operator&lt;&lt;(ostream &amp;cout, const CTextBook&amp; text);</span><br><span class="line">public:</span><br><span class="line">    CTextBook(const char* str)</span><br><span class="line">        :_text(nullptr)</span><br><span class="line">    &#123;</span><br><span class="line">        int capacity = strlen(str) + 1;</span><br><span class="line">        _text = new char[capacity];</span><br><span class="line">        strcpy(_text, str);</span><br><span class="line">    &#125;</span><br><span class="line">    ~CTextBook()</span><br><span class="line">    &#123;</span><br><span class="line">        if(_text != nullptr)</span><br><span class="line">        &#123;</span><br><span class="line">            delete[] _text;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    char&amp; operator[](size_t position) const</span><br><span class="line">    &#123;</span><br><span class="line">        return _text[position];</span><br><span class="line">    &#125;</span><br><span class="line">    size_t length() const</span><br><span class="line">    &#123;</span><br><span class="line">        if(!_lengthIsValid)</span><br><span class="line">        &#123;</span><br><span class="line">            //这里明显是编译不过的，因为其不是bitwiss constness的</span><br><span class="line">            _len = strlen(_text);</span><br><span class="line">            _lengthIsValid = true;</span><br><span class="line">        &#125;</span><br><span class="line">        return _len;</span><br><span class="line">    &#125;</span><br><span class="line">private:</span><br><span class="line">    char* _text;</span><br><span class="line">    int _len;</span><br><span class="line">    bool _lengthIsValid;</span><br><span class="line">&#125;;</span><br><span class="line">ostream&amp; operator&lt;&lt;(ostream &amp;cout, CTextBook&amp; text)</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; text._text &lt;&lt; endl;</span><br><span class="line">    return cout;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    CTextBook text(&quot;Hello&quot;);</span><br><span class="line">    text[0] = &apos;J&apos;;</span><br><span class="line">    cout &lt;&lt; text;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;以上这个例子肯定是编译不过的，其不符合编译器的编译标准，但是从逻辑角度来看这些赋值和改变我们是可以接受了，但是编译器不同意怎么办呢？解决这个问题需要用到<code>mutable</code>释放掉<code>non-static</code>成员变量的<code>bitwiss constness</code>约束。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class CTextBook</span><br><span class="line">&#123;</span><br><span class="line">friend ostream&amp; operator&lt;&lt;(ostream &amp;cout, const CTextBook&amp; text);</span><br><span class="line">public:</span><br><span class="line">    CTextBook(const char* str)</span><br><span class="line">        :_text(nullptr)</span><br><span class="line">        ,_len(0)</span><br><span class="line">        ,_lengthIsValid(false)</span><br><span class="line">    &#123;</span><br><span class="line">        int capacity = strlen(str) + 1;</span><br><span class="line">        _text = new char[capacity];</span><br><span class="line">        strcpy(_text, str);</span><br><span class="line">    &#125;</span><br><span class="line">    ~CTextBook()</span><br><span class="line">    &#123;</span><br><span class="line">        if(_text != nullptr)</span><br><span class="line">        &#123;</span><br><span class="line">            delete[] _text;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    char&amp; operator[](size_t position) const</span><br><span class="line">    &#123;</span><br><span class="line">        return _text[position];</span><br><span class="line">    &#125;</span><br><span class="line">    size_t length() const</span><br><span class="line">    &#123;</span><br><span class="line">        if(!_lengthIsValid)</span><br><span class="line">        &#123;</span><br><span class="line">            //这里明显是编译不过的，因为其不是bitwiss constness的</span><br><span class="line">            _len = strlen(_text);</span><br><span class="line">            _lengthIsValid = true;</span><br><span class="line">        &#125;</span><br><span class="line">        return _len;</span><br><span class="line">    &#125;</span><br><span class="line">private:</span><br><span class="line">    char* _text;</span><br><span class="line">    mutable int _len;</span><br><span class="line">    mutable bool _lengthIsValid;</span><br><span class="line">&#125;;</span><br><span class="line">ostream&amp; operator&lt;&lt;(ostream &amp;cout, const CTextBook&amp; text)</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; text._text &lt;&lt; endl;</span><br><span class="line">    return cout;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    CTextBook text(&quot;Hello&quot;);</span><br><span class="line">    text[0] = &apos;J&apos;;</span><br><span class="line">    cout &lt;&lt; text;</span><br><span class="line">    cout &lt;&lt; text.length() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Jello</span><br><span class="line">5</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;<code>mutable</code>虽然可以解决<code>bitwise constness</code>而不是<code>logical constness</code>的问题。但是不能解决所有的问题，比如<code>const</code>和<code>non-const</code>成员函数中代码冗余的问题，我们要实现两个功能完全相同的函数只是为了让常量性不同的对象调用，这样就会造成代码冗余。最好的解决方法就是<strong>在<code>non-const</code>函数中调用<code>const</code>函数</strong>。注意以上这段话不能反过来，我们不能够在<code>const</code>函数中调用<code>non-const</code>函数。然而要想完成这次调用我们需要有两次转型。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;assert.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class CTextBook</span><br><span class="line">&#123;</span><br><span class="line">friend ostream&amp; operator&lt;&lt;(ostream &amp;cout, const CTextBook&amp; text);</span><br><span class="line">public:</span><br><span class="line">    CTextBook(const char* str)</span><br><span class="line">        :_text(nullptr)</span><br><span class="line">        ,_len(0)</span><br><span class="line">        ,_lengthIsValid(false)</span><br><span class="line">    &#123;</span><br><span class="line">        int capacity = strlen(str) + 1;</span><br><span class="line">        _text = new char[capacity];</span><br><span class="line">        strcpy(_text, str);</span><br><span class="line">    &#125;</span><br><span class="line">    ~CTextBook()</span><br><span class="line">    &#123;</span><br><span class="line">        if(_text != nullptr)</span><br><span class="line">        &#123;</span><br><span class="line">            delete[] _text;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    //const函数</span><br><span class="line">    const char&amp; operator[](size_t position) const</span><br><span class="line">    &#123;</span><br><span class="line">        //在这里加上检查，我们先少些点代码，假设这之前有更多的代码</span><br><span class="line">        //......</span><br><span class="line">        assert(position &lt; length());</span><br><span class="line">        return _text[position];</span><br><span class="line">    &#125;</span><br><span class="line">    //non-const函数</span><br><span class="line">    char&amp; operator[](size_t position)</span><br><span class="line">    &#123;</span><br><span class="line">        //这里只需要调用const版本的函数即可，但是为了调用要先进行类型转换</span><br><span class="line">        //这里用到了将本身的对象转换为常对象来调用常成员函数</span><br><span class="line">        const char&amp; a = static_cast&lt;const CTextBook&amp;&gt;(*this)[position];</span><br><span class="line">        //这里将返回值的const限定去掉</span><br><span class="line">        return const_cast&lt;char&amp;&gt;(a);</span><br><span class="line">    &#125;</span><br><span class="line">    size_t length() const</span><br><span class="line">    &#123;</span><br><span class="line">        if(!_lengthIsValid)</span><br><span class="line">        &#123;</span><br><span class="line">            //这里明显是编译不过的，因为其不是bitwiss constness的</span><br><span class="line">            _len = strlen(_text);</span><br><span class="line">            _lengthIsValid = true;</span><br><span class="line">        &#125;</span><br><span class="line">        return _len;</span><br><span class="line">    &#125;</span><br><span class="line">private:</span><br><span class="line">    char* _text;</span><br><span class="line">    mutable int _len;</span><br><span class="line">    mutable bool _lengthIsValid;</span><br><span class="line">&#125;;</span><br><span class="line">ostream&amp; operator&lt;&lt;(ostream &amp;cout, const CTextBook&amp; text)</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; text._text &lt;&lt; endl;</span><br><span class="line">    return cout;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    CTextBook text(&quot;Hello&quot;);</span><br><span class="line">    const CTextBook con_text(&quot;Hello&quot;);</span><br><span class="line">    //con_text[0] = &apos;J&apos;;//常量成员调用常成员函数，无法更改</span><br><span class="line">    text[0] = &apos;J&apos;;</span><br><span class="line">    cout &lt;&lt; text;</span><br><span class="line">    cout &lt;&lt; text.length() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Jello</span><br><span class="line">5</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;但是要注意这其中进行了两次转型，这是十分不安全的尽量还是少使用，但是尽管如此我们还是达成了我们避免数据冗余的问题。</p>
<h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p>&emsp;&emsp;1、将某些东西声明为<code>const</code>可帮助编译器侦测出错误用法。<code>const</code>可被施加于任何作用域内的对象、函数参数、函数返回类型、成员函数本体。<br>&emsp;&emsp;2、扁你其前置实施<code>bitwise constness</code>，但你编写程序时应该使用<code>logical constness</code>。<br>&emsp;&emsp;3、<code>const</code>与<code>non-const</code>成员函数有着实质等价时，令<code>non-const</code>版本调用<code>const</code>版本可避免代码重复。</p>
<h2 id="确定对象被使用前已先被初始化"><a href="#确定对象被使用前已先被初始化" class="headerlink" title="确定对象被使用前已先被初始化"></a>确定对象被使用前已先被初始化</h2><p>&emsp;&emsp;<strong>Make sure that objects are initialized before they`re used.</strong></p>
<h3 id="C-part-of-C"><a href="#C-part-of-C" class="headerlink" title="C part of C++"></a>C part of C++</h3><p>&emsp;&emsp;在Cpp中是存在不会被初始化的变量的，无论这些变量是成员变量来自类中，还是内置类型的变量都有可能编译器不会帮助我们初始化，这是十分危险的，因为会导致不明确的行为。如果我们在使用<code>C part of C++</code>时变量往往并不会进行初始化例如数组往往需要我们手动给一个初值，而我们在使用Cpp中的<code>vector</code>时编译器却可以保证即使我们不给初值这个数组也会被初始化，如果熟悉STL库的话，你会知道<code>vecotr</code>此时会将内部的三个成员变量全部初始化为空，长度和容量都为0。所以在使用<code>C part of C++</code>时我们最好手动为每一个变量赋予初值，这是很好的编程习惯。</p>
<h3 id="自定义类型"><a href="#自定义类型" class="headerlink" title="自定义类型"></a>自定义类型</h3><p>&emsp;&emsp;对于自定义类型以外的所有类型，他们的初始化都落在了构造函数的身上，我们所要作的就是确保每一个构造函数都将对象的每一个成员初始化。<br>&emsp;&emsp;但是这里要搞清楚赋值和初始化的概念。这里就牵扯到了构造函数的使用。我们都知道我们可以在构造函数中对成员<strong>赋值</strong>，而是用初始化列表才可以对成员进行初始化。所以经常可以看到有些对Cpp不是很了解的程序员写出这样的构造函数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class PhoneNumber</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    PhoneNumber()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; &quot;PhoneNumber()&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    PhoneNumber(string theNumber)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; &quot;PhoneNumber(string theNumber)&quot; &lt;&lt; endl;</span><br><span class="line">        string _theNumber;</span><br><span class="line">    &#125;</span><br><span class="line">    PhoneNumber operator=(const PhoneNumber&amp; phoneNumber)</span><br><span class="line">    &#123;</span><br><span class="line">        _theNumber = phoneNumber._theNumber;</span><br><span class="line">        cout &lt;&lt; &quot;PhoneNumber operator=(const PhoneNumber&amp; phoneNumber))&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">private:</span><br><span class="line">    string _theNumber;</span><br><span class="line">&#125;;</span><br><span class="line">class ABEntry</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    ABEntry(const string&amp; theName, const string&amp; theAddress, const PhoneNumber&amp; theNumber)</span><br><span class="line">    &#123;</span><br><span class="line">        //这里的构造函数写法并不是直接对成员进行初始化，更应该说是在初始化后进行了一次赋值</span><br><span class="line">        _theName = theName;</span><br><span class="line">        _theAddress = theAddress;</span><br><span class="line">        //所以这里会调用赋值函数</span><br><span class="line">        _theNumber = theNumber;</span><br><span class="line">    &#125;</span><br><span class="line">private:</span><br><span class="line">    string _theName;</span><br><span class="line">    string _theAddress;</span><br><span class="line">    PhoneNumber _theNumber;</span><br><span class="line">&#125;;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    ABEntry abEntry(&quot;Misaki&quot;, &quot;China&quot;, PhoneNumber(&quot;181********&quot;));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">PhoneNumber(string theNumber)</span><br><span class="line">PhoneNumber()</span><br><span class="line">PhoneNumber operator=(const PhoneNumber&amp; phoneNumber))</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;这种构造函数的写法并不能为成员变量进行初始化，而是将变量先初始化后再进行赋值，在过程中产生了一次无参构造，一次有参构造，以及一次赋值，这会消耗更多的性能。而最佳的处理手段是将成员变量的初始化放进初始化列表中。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class PhoneNumber</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    PhoneNumber()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; &quot;PhoneNumber()&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    PhoneNumber(string theNumber)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; &quot;PhoneNumber(string theNumber)&quot; &lt;&lt; endl;</span><br><span class="line">        string _theNumber;</span><br><span class="line">    &#125;</span><br><span class="line">    PhoneNumber(const PhoneNumber&amp; phoneNumber)</span><br><span class="line">    &#123;</span><br><span class="line">        _theNumber = phoneNumber._theNumber;</span><br><span class="line">        cout &lt;&lt; &quot;PhoneNumber(const PhoneNumber&amp; phoneNumber)&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    PhoneNumber operator=(const PhoneNumber&amp; phoneNumber)</span><br><span class="line">    &#123;</span><br><span class="line">        _theNumber = phoneNumber._theNumber;</span><br><span class="line">        cout &lt;&lt; &quot;PhoneNumber operator=(const PhoneNumber&amp; phoneNumber))&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">private:</span><br><span class="line">    string _theNumber;</span><br><span class="line">&#125;;</span><br><span class="line">class ABEntry</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    //这样才能对成员进行初始化，从结果也可以看出这里少了一次无参的默认构造</span><br><span class="line">    ABEntry(const string&amp; theName, const string&amp; theAddress, const PhoneNumber&amp; theNumber)</span><br><span class="line">        :_theName(theName)</span><br><span class="line">        ,_theAddress(theAddress)</span><br><span class="line">        ,_theNumber(theNumber)</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">private:</span><br><span class="line">    string _theName;</span><br><span class="line">    string _theAddress;</span><br><span class="line">    PhoneNumber _theNumber;</span><br><span class="line">&#125;;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    ABEntry abEntry(&quot;Misaki&quot;, &quot;China&quot;, PhoneNumber(&quot;181********&quot;));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">PhoneNumber(string theNumber)</span><br><span class="line">PhoneNumber(const PhoneNumber&amp; phoneNumber)</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;建议再初始化列表中对成员变量进行初始化，并且建议在初始化列表中对所有的成员包括基类都能进行手动初始化，无论是自定义类型还是内置类型，这样就不用考虑哪些成员是可以不初始化的成员，这样的编程习惯也是极好的。<br>&emsp;&emsp;对于成员变量的初始化顺序，其顺序并不由初始化列表而决定，基类总是优先于派生类进行初始化，而成员变量是以其声明次序进行初始化的，因此如果你如果定义了一个变量并决定把它作为数组的大小来初始化数组，那么你要保证在声明数组前那个代表大小的变量应该现有值。因此为了方便理解，增强可读性我们在构造函数中书写初始化列表时最好是按照声明顺序对其进行初始化。</p>
<h3 id="不同编译单元内定义之non-local-static对象的初始化"><a href="#不同编译单元内定义之non-local-static对象的初始化" class="headerlink" title="不同编译单元内定义之non-local static对象的初始化"></a>不同编译单元内定义之non-local static对象的初始化</h3><p>&emsp;&emsp;这一句话很长，很难理解，我们大概可以理解为在不同文件中的静态(<code>static</code>)变量的初始化顺序。我们想要在一个源文件中使用另一个源文件中定义的全局变量，但是这连个源文件中的变量初始化的先后顺序是并没有明确规定的，因此可能会出现问题。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">FileSystem.h</span><br><span class="line"></span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class FileSystem</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    size_t numDisks() const</span><br><span class="line">    &#123;</span><br><span class="line">        return _disks;</span><br><span class="line">    &#125;</span><br><span class="line">private:</span><br><span class="line">    size_t _disks = 5;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">第一个.cpp</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &quot;FileSystem.h&quot;</span><br><span class="line">using namespace std;</span><br><span class="line">FileSystem tfs;//其中定义一个全局变量</span><br><span class="line"></span><br><span class="line">第二个.cpp</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &quot;FileSystem.h&quot;</span><br><span class="line">using namespace std;</span><br><span class="line">extern FileSystem tfs;</span><br><span class="line">class Directory</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    Directory()</span><br><span class="line">    &#123;</span><br><span class="line">        _disks = tfs.numDisks();</span><br><span class="line">    &#125;</span><br><span class="line">    size_t _disks;</span><br><span class="line">&#125;;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    Directory dir;</span><br><span class="line">    cout &lt;&lt; dir._disks &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;以上这段代码中我们在一个源码文件中定义了一个成员变量，而在另一个源文件中声明外部变量并且使用了这个变量对我们的成员变量进行了初始化，但是我们并无法确定这个外部变量编译器在处理时是否会先对其进行初始化，如果没有初始化而我们又用它对我们的成员进行初始化此时就会无法进行指定的初始化。因此我们要使用一种间接的方式设计它，来保证外部成员一定会先进行初始化。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">FileSystem.h</span><br><span class="line"></span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class FileSystem</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    size_t numDisks() const</span><br><span class="line">    &#123;</span><br><span class="line">        return _disks;</span><br><span class="line">    &#125;</span><br><span class="line">private:</span><br><span class="line">    size_t _disks = 5;</span><br><span class="line">&#125;;</span><br><span class="line">FileSystem&amp; tfs();</span><br><span class="line"></span><br><span class="line">第一个.cpp</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &quot;FileSystem.h&quot;</span><br><span class="line">using namespace std;</span><br><span class="line">//这里的设计模式十分类似于单例模式</span><br><span class="line">//在函数内部定义静态变量，这样保证在调用函数时一定会先对变量进行初始化</span><br><span class="line">//保证初始化顺序</span><br><span class="line">FileSystem&amp; tfs()</span><br><span class="line">&#123;</span><br><span class="line">    static FileSystem fs;</span><br><span class="line">    return fs;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">第二个.cpp</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &quot;FileSystem.h&quot;</span><br><span class="line">using namespace std;</span><br><span class="line">class Directory</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    Directory()</span><br><span class="line">    &#123;</span><br><span class="line">        _disks = tfs().numDisks();</span><br><span class="line">    &#125;</span><br><span class="line">    size_t _disks;</span><br><span class="line">&#125;;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    Directory dir;</span><br><span class="line">    cout &lt;&lt; dir._disks &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;这样的设计模式更加安全可靠。</p>
<h3 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h3><p>&emsp;&emsp;1、为内置类型进行手动初始化，Cpp并不保证会对其进行初始化。<br>&emsp;&emsp;2、构造函数最好使用初始化列表对成员进行初始化，而不是使用赋值操作，并且初始化时最好按照声明次序进行初始化，增强可读性。<br>&emsp;&emsp;3、为免除“跨编译单元之初始化次序”问题，最好书写接口，利用<code>local static</code>对象代替<code>non-local static</code>对象。</p>

          
        
      
    </div>
    
    
    

    

    <div>
    
    </div>

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/08/22/【Cpp】第十一章-继承/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="MisakiFx">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/blog-logo.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Misaki`s blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/08/22/【Cpp】第十一章-继承/" itemprop="url">【Cpp】第十一章-继承</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-08-22T17:30:48+08:00">
                2019-08-22
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Cpp/" itemprop="url" rel="index">
                    <span itemprop="name">Cpp</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  7.6k
                </span>
              

              

              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h1><h2 id="什么是继承"><a href="#什么是继承" class="headerlink" title="什么是继承"></a>什么是继承</h2><p>&emsp;&emsp;继承是为了更好的使代码得以复用而产生的，同时呈现了面向对象程序设计中的层次结构，继承会使得我们写好的类可以得到扩展。简单来说继承可以增强我们的代码复用，包括可以复用类的层次结构，同时使程序复用层次和条理。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class Person</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    //如果我们设计一个类考虑到它会被继承那么最好用protected成员取代private成员</span><br><span class="line">    //protected成员在类外部仍然是无法使用的，但是在派生类中它是可见的也就是可以使用的</span><br><span class="line">    Person()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; &quot;im a Person&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    void Print()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; &quot;age = &quot; &lt;&lt; _age &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; &quot;name = &quot; &lt;&lt; _name &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">protected:</span><br><span class="line">    int _age = 20;</span><br><span class="line">    string _name = &quot;Misaki&quot;; </span><br><span class="line">&#125;;</span><br><span class="line">//Programer类，这里让其公有继承Person类</span><br><span class="line">//这时继承产生的新类被称为子类，也叫派生类</span><br><span class="line">//被继承的旧类被称为父类，也叫基类</span><br><span class="line">//继承方式为公有(public)，其会让基类中的public成员成为派生类中的public成员</span><br><span class="line">//基类中的protected成员成为派生类中的protected成员，基类中的private成员在派生类中不可见</span><br><span class="line">//关于继承方式也在下文讲解</span><br><span class="line">class Programer: public Person</span><br><span class="line">&#123;</span><br><span class="line">    //这里我们不再重写几个默认生成的成员函数，他们默认会完成他们应有的功能</span><br><span class="line">    //具体派生类的默认成员函数会在下文讲解</span><br><span class="line">protected:</span><br><span class="line">    int _workyear;</span><br><span class="line">&#125;;</span><br><span class="line">class Teacher: public Person</span><br><span class="line">&#123;</span><br><span class="line">protected:</span><br><span class="line">    int _teachyear;</span><br><span class="line">&#125;;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    Person person;//基类对象</span><br><span class="line">    Programer programer;//派生类对象</span><br><span class="line">    Teacher teacher;//派生类对象</span><br><span class="line">    person.Print();</span><br><span class="line">    programer.Print();</span><br><span class="line">    teacher.Print();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">im a Person</span><br><span class="line">im a Person</span><br><span class="line">im a Person</span><br><span class="line">age = 20</span><br><span class="line">name = Misaki</span><br><span class="line">age = 20</span><br><span class="line">name = Misaki</span><br><span class="line">age = 20</span><br><span class="line">name = Misaki</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;以上这个例子就是简单的利用继承进行了类的扩展扩展出了两个派生类，可以看出派生类中拥有积累的成员函数和成员变量，并且还可以添加新的成员函数和变量。</p>
<h2 id="继承方式"><a href="#继承方式" class="headerlink" title="继承方式"></a>继承方式</h2><h3 id="三种继承方式"><a href="#三种继承方式" class="headerlink" title="三种继承方式"></a>三种继承方式</h3><p>&emsp;&emsp;继承方式一共有三种：<code>public</code>, <code>protected</code>,<code>private</code>，这三种继承方式都可以将基类中的成员继承到派生类中，但是继承方式的不同也决定着在派生类中继承过来的成员的访问权限的不同，具体关于各个继承方式中对访问权限的改变可以参考下图。<br><br><img src="/2019/08/22/【Cpp】第十一章-继承/1.png" alt="继承"><br><br>&emsp;&emsp;这里提到基类中的<code>private</code>成员无论何种继承方式在派生类中都是<strong>不可见</strong>的，所谓不可见指成员依然已经继承了过来并且作为了私有成员，但是在派生类中限制这些成员无论在类外还是类内都是无法访问的。<br>&emsp;&emsp;因此为了让一个成员在派生类中依然可以访问便出现了<code>protected</code>访问权限，所以才说如果一个类为了方便继承最好将其<code>private</code>访问权限用<code>protected</code>来替代，这样即使继承产生派生类也依然可以在派生类中访问该成员。<br>&emsp;&emsp;如果我们在继承时不写出继承方式，则<code>class</code>默认使用<code>private</code>继承，<code>struct</code>默认使用<code>public</code>继承，不过为了可读性最好还是显示的写出继承方式。<br>&emsp;&emsp;最为经常使用的继承方式是<code>public</code>继承，它可以让派生类中各个访问权限下的成员在派生类中还为相应的访问权限，是最为方便便于理解的继承方式，并且其他继承方式的扩展和维护性也并不强，因此除非特殊情况也不建议使用除<code>public</code>外的其他继承方式。</p>
<h2 id="切割"><a href="#切割" class="headerlink" title="切割"></a>切割</h2><p>&emsp;&emsp;在C++中允许将派生类对象隐式类型转换为父类。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">//基类</span><br><span class="line">class Person</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    Person()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; &quot;im a Person&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    void Print()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; &quot;age = &quot; &lt;&lt; _age &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; &quot;name = &quot; &lt;&lt; _name &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">protected:</span><br><span class="line">    int _age = 20;</span><br><span class="line">    string _name = &quot;Misaki&quot;; </span><br><span class="line">&#125;;</span><br><span class="line">//派生类</span><br><span class="line">class Programer: public Person</span><br><span class="line">&#123;</span><br><span class="line">protected:</span><br><span class="line">    int _workyear;</span><br><span class="line">&#125;;</span><br><span class="line">//派生类</span><br><span class="line">class Teacher: public Person</span><br><span class="line">&#123;</span><br><span class="line">protected:</span><br><span class="line">    int _teachyear;</span><br><span class="line">&#125;;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    Person person;</span><br><span class="line">    //Programer programer;</span><br><span class="line">    Teacher teacher;</span><br><span class="line">    //person.Print();</span><br><span class="line">    //programer.Print();</span><br><span class="line">    //teacher.Print();</span><br><span class="line">    //teacher是派生类对象，person是基类对象，这样的隐式类型转换是允许的</span><br><span class="line">    person = teacher;</span><br><span class="line">    //也可以用派生类对象来拷贝构造基类对象</span><br><span class="line">    Person person2 = teacher;</span><br><span class="line">    person.Print();</span><br><span class="line">    person2.Print();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">im a Person</span><br><span class="line">im a Person</span><br><span class="line">age = 20</span><br><span class="line">name = Misaki</span><br><span class="line">age = 20</span><br><span class="line">name = Misaki</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;以上这段代码我们将派生类对象赋值给了基类对象，并且用派生类对象拷贝构造了基类对象，在这其中得以隐式转换最重要的原因就是编译器进行了<strong>切割</strong>处理，即将派生类对象中属于基类的那一部分成员保留，而将属于派生类的成员舍弃，由此才能完成类型转换。<br><br><img src="/2019/08/22/【Cpp】第十一章-继承/2.png" alt="切割"><br><br>&emsp;&emsp;上图过程即为切割的过程，在派生类的对象/指针/引用赋值给父类的对象/指针/引用时都会发生隐式类型转换，过程中都会发生切割。但是<strong>基类对象/指针引用不可以赋值给派生类对象/指针/引用</strong>。当然也有例外，基类指针可以通过强制类型转换也可以赋值给派生类指针，当然只有在基类指针指向了派生类对象时才是安全的。如果基类构成多态也可以用RTTI(运行时类型识别)的<code>dynamic_cast</code>类型识别后进行类型转换，是最为安全的。</p>
<h2 id="继承中的作用域"><a href="#继承中的作用域" class="headerlink" title="继承中的作用域"></a>继承中的作用域</h2><p>&emsp;&emsp;在继承体系中，基类和派生类都有属于自己的作用域，那么如果在派生类中定义了和基类同名的成员编译器会怎样处理呢？</p>
<h3 id="重定义-隐藏"><a href="#重定义-隐藏" class="headerlink" title="重定义/隐藏"></a>重定义/隐藏</h3><p>&emsp;&emsp;派生类和基类有各自独立的作用域，在派生类中如果出现和基类同名成员，则会优先调用派生类的同名成员，即<strong>隐藏</strong>基类成员，这个过程叫做被称为<strong>隐藏</strong>也叫做<strong>重定义</strong>。<br>&emsp;&emsp;但是我们也可以在派生类中加上域限定符显示调用基类的成员。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class Person</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    void Print()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; &quot;Person::Print()&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">protected:</span><br><span class="line">    int _age = 20;</span><br><span class="line">    string _name = &quot;Misaki&quot;; </span><br><span class="line">&#125;;</span><br><span class="line">//派生类</span><br><span class="line">class Teacher: public Person</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    void Print()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; &quot;Teacher::Print()&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    void PrintAge()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; &quot;Teacher::_age:&quot; &lt;&lt; _age &lt;&lt; endl;//重名成员构成隐藏</span><br><span class="line">        cout &lt;&lt; &quot;Person::_age:&quot; &lt;&lt; Person::_age &lt;&lt; endl;//显示调用基类成员</span><br><span class="line">    &#125;</span><br><span class="line">protected:</span><br><span class="line">    int _age = 19;</span><br><span class="line">&#125;;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    Person person;</span><br><span class="line">    person.Print();//Person::Print()</span><br><span class="line">    Teacher teacher;</span><br><span class="line">    teacher.Print();//Teacher::Print()，派生类重名成员构成隐藏</span><br><span class="line">    teacher.PrintAge();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Person::Print()</span><br><span class="line">Teacher::Print()</span><br><span class="line">Teacher::_age:19</span><br><span class="line">Person::_age:20</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;值得注意的是，关于函数，函数重载指的是在相同作用域内函数名相同参数不同构成重载，而<strong>重定义/隐藏是指在基类和派生类的作用域内函数名相同就会构成隐藏</strong>。所以我们最好还是不要在派生类中定义和基类同名的成员，避免隐藏和重定义的发生。</p>
<h2 id="派生类的默认成员函数"><a href="#派生类的默认成员函数" class="headerlink" title="派生类的默认成员函数"></a>派生类的默认成员函数</h2><p>&emsp;&emsp;派生类也有6个默认成员函数，但是着6个默认成员函数既要兼顾到基类也需要兼顾到派生类，因此在写法上与常规的并不相同。</p>
<h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><p>&emsp;&emsp;在派生类的构造函数中我们需要先显示调用基类的构造函数对基类成员进行初始化然后才能对派生类成员进行初始化。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">//基类</span><br><span class="line">class Person</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    //这里构造函数就不选择传参了方便起见我都初始化为定值</span><br><span class="line">    Person()</span><br><span class="line">        :_age(20)</span><br><span class="line">        ,_name(&quot;Misaki&quot;)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; &quot;Person()&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    void Print()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; &quot;age = &quot; &lt;&lt; _age &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; &quot;name = &quot; &lt;&lt; _name &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">protected:</span><br><span class="line">    int _age;</span><br><span class="line">    string _name;</span><br><span class="line">&#125;;</span><br><span class="line">//派生类</span><br><span class="line">class Teacher: public Person</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    //派生类构造函数，先调用基类构造函数，在初始化派生类成员</span><br><span class="line">    //默认生成的构造函数也是这样实现的</span><br><span class="line">    Teacher()</span><br><span class="line">        :Person()</span><br><span class="line">        ,_teachyear(3)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; &quot;Teacher()&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    void Print()</span><br><span class="line">    &#123;</span><br><span class="line">        Person::Print();</span><br><span class="line">        cout &lt;&lt; &quot;teachyear = &quot; &lt;&lt; _teachyear &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    static int _count;</span><br><span class="line">protected:</span><br><span class="line">    int _teachyear;</span><br><span class="line">&#125;;</span><br><span class="line">int Teacher::_count = 2;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    Teacher teacher;</span><br><span class="line">    teacher.Print();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Person()</span><br><span class="line">Teacher()</span><br><span class="line">age = 20</span><br><span class="line">name = Misaki</span><br><span class="line">teachyear = 3</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;从以上代码可以得出<strong>派生类对象初始化会调用派生类构造函数，而在派生类构造函数中会先调用基类的构造函数对基类成员进行初始化然后才会对派生类成员进行初始化</strong>。这样我们就成功的完成了派生类构造函数，并且实现了成员初始化。</p>
<h3 id="拷贝构造函数"><a href="#拷贝构造函数" class="headerlink" title="拷贝构造函数"></a>拷贝构造函数</h3><p>&emsp;&emsp;拷贝构造函数与构造函数类似，我们在派生类的拷贝构造函数中也需要先调用基类拷贝构造函数先拷贝构造基类成员再将派生类成员拷贝构造。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">//基类</span><br><span class="line">class Person</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    //这里构造函数就不选择传参了方便起见我都初始化为定值</span><br><span class="line">    Person()</span><br><span class="line">        :_age(20)</span><br><span class="line">        ,_name(&quot;Misaki&quot;)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; &quot;Person()&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    Person(const Person&amp; person)</span><br><span class="line">        :_age(person._age)</span><br><span class="line">        ,_name(person._name)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; &quot;Person(const Person&amp;)&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    void Print()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; &quot;age = &quot; &lt;&lt; _age &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; &quot;name = &quot; &lt;&lt; _name &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">protected:</span><br><span class="line">    int _age;</span><br><span class="line">    string _name;</span><br><span class="line">&#125;;</span><br><span class="line">//派生类</span><br><span class="line">class Teacher: public Person</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    //派生类构造函数，先调用基类构造函数，在初始化派生类成员</span><br><span class="line">    //默认生成的构造函数也是这样实现的</span><br><span class="line">    Teacher()</span><br><span class="line">        :Person()</span><br><span class="line">        ,_teachyear(3)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; &quot;Teacher()&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    //拷贝构造函数，先调用基类构造函数对基类成拷贝构造，再拷贝构造派生类成员</span><br><span class="line">    //默认生成的拷贝构造也是这样的实现方法</span><br><span class="line">    Teacher(const Teacher&amp; teacher)</span><br><span class="line">        :Person(teacher)//这里利用派生类对象可以隐式转换为基类对象来调用基类拷贝构造</span><br><span class="line">        ,_teachyear(3)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; &quot;Teacher(const Teacher&amp;)&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    void Print()</span><br><span class="line">    &#123;</span><br><span class="line">        Person::Print();</span><br><span class="line">        cout &lt;&lt; &quot;teachyear = &quot; &lt;&lt; _teachyear &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    static int _count;</span><br><span class="line">protected:</span><br><span class="line">    int _teachyear;</span><br><span class="line">&#125;;</span><br><span class="line">int Teacher::_count = 2;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    Teacher teacher1;</span><br><span class="line">    Teacher teacher2 = teacher1;</span><br><span class="line">    teacher2.Print();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Person()</span><br><span class="line">Teacher()</span><br><span class="line">Person(const Person&amp;)</span><br><span class="line">Teacher(const Teacher&amp;)</span><br><span class="line">age = 20</span><br><span class="line">name = Misaki</span><br><span class="line">teachyear = 3</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;从结果可以看出<strong>派生类对象在进行拷贝构造的时候调用了派生类拷贝构造函数，而派生类拷贝构造函数中会先调用基类拷贝构造函数对基类成员进行初始化然后才会对派生类成员进行初始化</strong>。</p>
<h3 id="赋值运算符重载"><a href="#赋值运算符重载" class="headerlink" title="赋值运算符重载"></a>赋值运算符重载</h3><p>&emsp;&emsp;赋值运算符也同样类似，需要先调用基类的赋值运算符重载，然后再进行派生类成员的赋值。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">//基类</span><br><span class="line">class Person</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    //这里构造函数就不选择传参了方便起见我都初始化为定值</span><br><span class="line">    Person()</span><br><span class="line">        :_age(20)</span><br><span class="line">        ,_name(&quot;Misaki&quot;)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; &quot;Person()&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    Person(const Person&amp; person)</span><br><span class="line">        :_age(person._age)</span><br><span class="line">        ,_name(person._name)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; &quot;Person(const Person&amp;)&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    Person&amp; operator=(const Person&amp; person)</span><br><span class="line">    &#123;</span><br><span class="line">        if(&amp;person != this)</span><br><span class="line">        &#123;</span><br><span class="line">            _age = person._age;</span><br><span class="line">            _name = person._name;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; &quot;Person::operator=(const Person&amp;)&quot; &lt;&lt; endl;</span><br><span class="line">        return *this;</span><br><span class="line">    &#125;</span><br><span class="line">    void Print()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; &quot;age = &quot; &lt;&lt; _age &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; &quot;name = &quot; &lt;&lt; _name &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">protected:</span><br><span class="line">    int _age;</span><br><span class="line">    string _name;</span><br><span class="line">&#125;;</span><br><span class="line">//派生类</span><br><span class="line">class Teacher: public Person</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    //派生类构造函数，先调用基类构造函数，在初始化派生类成员</span><br><span class="line">    //默认生成的构造函数也是这样实现的</span><br><span class="line">    Teacher()</span><br><span class="line">        :Person()</span><br><span class="line">        ,_teachyear(3)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; &quot;Teacher()&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    //拷贝构造函数，先调用基类构造函数对基类成拷贝构造，再拷贝构造派生类成员</span><br><span class="line">    //默认生成的拷贝构造也是这样的实现方法</span><br><span class="line">    Teacher(const Teacher&amp; teacher)</span><br><span class="line">        :Person(teacher)//这里利用派生类对象可以隐式转换为基类对象来调用基类拷贝构造</span><br><span class="line">        ,_teachyear(3)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; &quot;Teacher(const Teacher&amp;)&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    //赋值运算符重载，先调用基类的赋值运算符重载对基类成员进行赋值，再赋值派生类成员</span><br><span class="line">    //默认生成的赋值运算符重载也是这样的实现方法</span><br><span class="line">    Teacher&amp; operator=(const Teacher&amp; teacher)</span><br><span class="line">    &#123;</span><br><span class="line">        if(&amp;teacher != this)</span><br><span class="line">        &#123;</span><br><span class="line">            Person::operator=(teacher);//调用基类的赋值运算符重载，并且用隐式类型转换传参</span><br><span class="line">            _teachyear = teacher._teachyear;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; &quot;Teacher::operator=(const Teacher&amp;)&quot; &lt;&lt; endl;</span><br><span class="line">        return *this;</span><br><span class="line">    &#125;</span><br><span class="line">    void Print()</span><br><span class="line">    &#123;</span><br><span class="line">        Person::Print();</span><br><span class="line">        cout &lt;&lt; &quot;teachyear = &quot; &lt;&lt; _teachyear &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    static int _count;</span><br><span class="line">protected:</span><br><span class="line">    int _teachyear;</span><br><span class="line">&#125;;</span><br><span class="line">int Teacher::_count = 2;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    Teacher teacher1;</span><br><span class="line">    Teacher teacher2;</span><br><span class="line">    teacher2 = teacher1;</span><br><span class="line">    teacher2.Print();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Person()</span><br><span class="line">Teacher()</span><br><span class="line">Person()</span><br><span class="line">Teacher()</span><br><span class="line">Person::operator=(const Person&amp;)</span><br><span class="line">Teacher::operator=(const Teacher&amp;)</span><br><span class="line">age = 20</span><br><span class="line">name = Misaki</span><br><span class="line">teachyear = 3</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;从以上代码可以看出<strong>派生类在赋值时会先调用派生类赋值运算符重载，而在派生类赋值运算符重载中会首先调用积累的赋值运算符重载对基类成员进行赋值，然后才会赋值派生类成员</strong>。</p>
<h3 id="析构函数"><a href="#析构函数" class="headerlink" title="析构函数"></a>析构函数</h3><p>&emsp;&emsp;析构函数与其他的默认成员函数有所不同，因为派生类在构造时是先初始化基类成员再初始化派生类成员，因此在析构时是先释放派生类成员再释放基类成员。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">//基类</span><br><span class="line">class Person</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    //这里构造函数就不选择传参了方便起见我都初始化为定值</span><br><span class="line">    Person()</span><br><span class="line">        :_age(20)</span><br><span class="line">        ,_name(&quot;Misaki&quot;)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; &quot;Person()&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    Person(const Person&amp; person)</span><br><span class="line">        :_age(person._age)</span><br><span class="line">        ,_name(person._name)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; &quot;Person(const Person&amp;)&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    Person&amp; operator=(const Person&amp; person)</span><br><span class="line">    &#123;</span><br><span class="line">        if(&amp;person != this)</span><br><span class="line">        &#123;</span><br><span class="line">            _age = person._age;</span><br><span class="line">            _name = person._name;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; &quot;Person::operator=(const Person&amp;)&quot; &lt;&lt; endl;</span><br><span class="line">        return *this;</span><br><span class="line">    &#125;</span><br><span class="line">    ~Person()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; &quot;~Person()&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    void Print()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; &quot;age = &quot; &lt;&lt; _age &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; &quot;name = &quot; &lt;&lt; _name &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">protected:</span><br><span class="line">    int _age;</span><br><span class="line">    string _name;</span><br><span class="line">&#125;;</span><br><span class="line">//派生类</span><br><span class="line">class Teacher: public Person</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    //派生类构造函数，先调用基类构造函数，在初始化派生类成员</span><br><span class="line">    //默认生成的构造函数也是这样实现的</span><br><span class="line">    Teacher()</span><br><span class="line">        :Person()</span><br><span class="line">        ,_teachyear(3)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; &quot;Teacher()&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    //拷贝构造函数，先调用基类构造函数对基类成拷贝构造，再拷贝构造派生类成员</span><br><span class="line">    //默认生成的拷贝构造也是这样的实现方法</span><br><span class="line">    Teacher(const Teacher&amp; teacher)</span><br><span class="line">        :Person(teacher)//这里利用派生类对象可以隐式转换为基类对象来调用基类拷贝构造</span><br><span class="line">        ,_teachyear(3)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; &quot;Teacher(const Teacher&amp;)&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    //赋值运算符重载，先调用基类的赋值运算符重载对基类成员进行赋值，再赋值派生类成员</span><br><span class="line">    //默认生成的赋值运算符重载也是这样的实现方法</span><br><span class="line">    Teacher&amp; operator=(const Teacher&amp; teacher)</span><br><span class="line">    &#123;</span><br><span class="line">        if(&amp;teacher != this)</span><br><span class="line">        &#123;</span><br><span class="line">            Person::operator=(teacher);//调用基类的赋值运算符重载，并且用隐式类型转换传参</span><br><span class="line">            _teachyear = teacher._teachyear;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; &quot;Teacher::operator=(const Teacher&amp;)&quot; &lt;&lt; endl;</span><br><span class="line">        return *this;</span><br><span class="line">    &#125;</span><br><span class="line">    //要注意派生类析构函数不需要显示调用基类的析构函数，在调用派生类析构函数释放派生类成员后</span><br><span class="line">    //会自动调用基类的析构函数，来满足先释放派生类成员再释放基类成员的顺序</span><br><span class="line">    ~Teacher()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; &quot;~Teacher()&quot; &lt;&lt; endl;</span><br><span class="line">        //Person::~Person();这样调用会报错</span><br><span class="line">    &#125;</span><br><span class="line">    void Print()</span><br><span class="line">    &#123;</span><br><span class="line">        Person::Print();</span><br><span class="line">        cout &lt;&lt; &quot;teachyear = &quot; &lt;&lt; _teachyear &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    static int _count;</span><br><span class="line">protected:</span><br><span class="line">    int _teachyear;</span><br><span class="line">&#125;;</span><br><span class="line">int Teacher::_count = 2;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    Teacher teacher;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Person()</span><br><span class="line">Teacher()</span><br><span class="line">~Teacher()</span><br><span class="line">~Person()</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;派生类析构函数执行时会先释放派生类成员再释放基类成员，并且要注意<strong>派生类析构函数会自动调用基类析构函数进行清理，无需手动调用</strong>。从执行结果上也可以看出编译器是先释放派生类成员再释放基类成员。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>&emsp;&emsp;对派生类默认成员函数进行总结。<br>&emsp;&emsp;1、派生类构造函数必须首先调用基类构造函数构造基类成员，之后再构造派生类成员才能成立。<br>&emsp;&emsp;2、派生类拷贝构造函数必须先调用基类拷贝构造函数拷贝构造基类成员，之后再拷贝构造派生类成员才能成立。<br>&emsp;&emsp;3、派生类赋值运算符重载必须先调用基类赋值运算符重载函数对基类成员进行赋值，再对派生类成员进行赋值才能成立。<br>&emsp;&emsp;4、派生类析构函数会在调用后自动调用基类析构函数无需显式调用基类析构函数。<br>&emsp;&emsp;5、派生类对象构造会先构造基类成员再构造派生类成员。<br>&emsp;&emsp;6、派生类对象析构会先释放派生类成员再释放基类成员。</p>
<h2 id="继承与友元"><a href="#继承与友元" class="headerlink" title="继承与友元"></a>继承与友元</h2><p>&emsp;&emsp;在C++类和对象中有介绍<strong>友元</strong>这一概念，即允许在友元类或友元函数中打破类的封装从而使用类的保护和私有成员。那么如果涉及继承，编译器会如何处理呢？<br>&emsp;&emsp;<strong>友元关系不能继承</strong>，即<strong>基类的友元不能访问派生类的私有和保护成员，但其依然可以访问派生类中从基类继承而来的私有和保护成员</strong>。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class Test;</span><br><span class="line">//基类</span><br><span class="line">class Person</span><br><span class="line">&#123;</span><br><span class="line">    friend class Test;</span><br><span class="line">public:</span><br><span class="line">    void Print()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; &quot;age = &quot; &lt;&lt; _age &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; &quot;name = &quot; &lt;&lt; _name &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">protected:</span><br><span class="line">    int _age = 20;</span><br><span class="line">    string _name = &quot;Misaki&quot;;</span><br><span class="line">&#125;;</span><br><span class="line">//派生类</span><br><span class="line">class Teacher: public Person</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    void Print()</span><br><span class="line">    &#123;</span><br><span class="line">        Person::Print();</span><br><span class="line">        cout &lt;&lt; &quot;teachyear = &quot; &lt;&lt; _teachyear &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">protected:</span><br><span class="line">    int _teachyear = 3;</span><br><span class="line">&#125;;</span><br><span class="line">class Test</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    void Print()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; &quot;age = &quot; &lt;&lt; person._age &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; &quot;name = &quot; &lt;&lt; person._name &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    void Print2()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; &quot;age = &quot; &lt;&lt; teacher._age &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; &quot;name = &quot; &lt;&lt; teacher._name &lt;&lt; endl;</span><br><span class="line">        //cout &lt;&lt; &quot;teachyear = &quot; &lt;&lt; teacher._teachyear &lt;&lt; endl;//无法访问</span><br><span class="line">    &#125;</span><br><span class="line">private:</span><br><span class="line">    Person person;</span><br><span class="line">    Teacher teacher;</span><br><span class="line">&#125;;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    Test test;</span><br><span class="line">    test.Print2();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">age = 20</span><br><span class="line">name = Misaki</span><br></pre></td></tr></table></figure></p>
<h2 id="继承和静态成员"><a href="#继承和静态成员" class="headerlink" title="继承和静态成员"></a>继承和静态成员</h2><p>&emsp;&emsp;关于继承和静态成员，我们所要记住的只有一句话，<strong>在整个继承体系中，无论发生多少次继承，静态成员在继承体系中只存在一份</strong>。</p>
<h3 id="静态成员函数"><a href="#静态成员函数" class="headerlink" title="静态成员函数"></a>静态成员函数</h3><p>&emsp;&emsp;关于静态成员函数，这句话将更好理解，在不发生隐藏的情况下我们调用的依然是基类的静态函数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">//基类</span><br><span class="line">class Person</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    static void Print()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; &quot;Person::_count = &quot; &lt;&lt; _count &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">protected:</span><br><span class="line">    int _age = 20;</span><br><span class="line">    string _name = &quot;Misaki&quot;; </span><br><span class="line">    static int _count;</span><br><span class="line">&#125;;</span><br><span class="line">int Person::_count = 1;</span><br><span class="line">//派生类</span><br><span class="line">class Teacher: public Person</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    //static void Print()</span><br><span class="line">    //&#123;</span><br><span class="line">    //    cout &lt;&lt; &quot;Teacher::_count = &quot; &lt;&lt; _count &lt;&lt; endl;</span><br><span class="line">    //&#125;</span><br><span class="line">protected:</span><br><span class="line">    int _age = 19;</span><br><span class="line">&#125;;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    Person::Print();</span><br><span class="line">    Teacher::Print();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Person::_count = 1</span><br><span class="line">Person::_count = 1</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;在发生隐藏的情况下，就会调用派生类的静态函数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">//基类</span><br><span class="line">class Person</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    static void Print()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; &quot;Person::_count = &quot; &lt;&lt; _count &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">protected:</span><br><span class="line">    int _age = 20;</span><br><span class="line">    string _name = &quot;Misaki&quot;; </span><br><span class="line">    static int _count;</span><br><span class="line">&#125;;</span><br><span class="line">int Person::_count = 1;</span><br><span class="line">//派生类</span><br><span class="line">class Teacher: public Person</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    static void Print()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; &quot;Teacher::_count = &quot; &lt;&lt; _count &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">protected:</span><br><span class="line">    int _age = 19;</span><br><span class="line">&#125;;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    Person::Print();</span><br><span class="line">    Teacher::Print();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Person::_count = 1</span><br><span class="line">Teacher::_count = 1</span><br></pre></td></tr></table></figure></p>
<h3 id="静态成员变量"><a href="#静态成员变量" class="headerlink" title="静态成员变量"></a>静态成员变量</h3><p>&emsp;&emsp;关于静态成员变量，我们要理解其在整个继承体系中有且只有一份，我们在基类中将其改变，派生类的也会跟着改变。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">//基类</span><br><span class="line">class Person</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    static void Print()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; &quot;Person::_count = &quot; &lt;&lt; _count &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    static int _count;</span><br><span class="line">protected:</span><br><span class="line">    int _age = 20;</span><br><span class="line">    string _name = &quot;Misaki&quot;; </span><br><span class="line">&#125;;</span><br><span class="line">int Person::_count = 1;</span><br><span class="line">//派生类</span><br><span class="line">class Teacher: public Person</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    static void Print()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; &quot;Teacher::_count = &quot; &lt;&lt; _count &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">protected:</span><br><span class="line">    int _age = 19;</span><br><span class="line">&#125;;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    Person::_count = 3;</span><br><span class="line">    Person::Print();</span><br><span class="line">    Teacher::Print();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Person::_count = 3</span><br><span class="line">Teacher::_count = 3</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;但是如果我们在派生类中定义同名静态成员变量构成隐藏的话，则会产生新的变量，并且隐藏掉基类的同名静态成员，当然我们也可以通过显示调用的方式再去调用它。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">//基类</span><br><span class="line">class Person</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    static void Print()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; &quot;Person::_count = &quot; &lt;&lt; _count &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    static int _count;</span><br><span class="line">protected:</span><br><span class="line">    int _age = 20;</span><br><span class="line">    string _name = &quot;Misaki&quot;; </span><br><span class="line">&#125;;</span><br><span class="line">int Person::_count = 1;</span><br><span class="line">//派生类</span><br><span class="line">class Teacher: public Person</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    static void Print()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; &quot;Teacher::_count = &quot; &lt;&lt; _count &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; &quot;Person::_count = &quot; &lt;&lt; Person::_count &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">protected:</span><br><span class="line">    int _age = 19;</span><br><span class="line">    static int _count;</span><br><span class="line">&#125;;</span><br><span class="line">int Teacher::_count = 5;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    Person::_count = 3;</span><br><span class="line">    Person::Print();</span><br><span class="line">    Teacher::Print();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Person::_count = 3</span><br><span class="line">Teacher::_count = 5</span><br><span class="line">Person::_count = 3</span><br></pre></td></tr></table></figure></p>
<h3 id="继承中隐藏-重定义的权限及生命周期"><a href="#继承中隐藏-重定义的权限及生命周期" class="headerlink" title="继承中隐藏/重定义的权限及生命周期"></a>继承中隐藏/重定义的权限及生命周期</h3><p>&emsp;&emsp;我们知道了静态成员发生隐藏时才会产生新的一份空间进行存储，如果我们将原本在基类中是静态成员的变量在派生类中定义同名成员为非静态的成员编译器会怎么判定呢？<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">//基类</span><br><span class="line">class Person</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    static void Print()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; &quot;Person::_count = &quot; &lt;&lt; _count &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    static int _count;</span><br><span class="line">protected:</span><br><span class="line">    int _age = 20;</span><br><span class="line">    string _name = &quot;Misaki&quot;; </span><br><span class="line">&#125;;</span><br><span class="line">int Person::_count = 1;</span><br><span class="line">//派生类</span><br><span class="line">class Teacher: public Person</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    static void Print()</span><br><span class="line">    &#123;</span><br><span class="line">        //cout &lt;&lt; &quot;Teacher::_count = &quot; &lt;&lt; _count &lt;&lt; endl;//编不过了，因为静态函数中只能调用静态成员，而此时_count隐藏已经不是静态成员</span><br><span class="line">        cout &lt;&lt; &quot;Person::_count = &quot; &lt;&lt; Person::_count &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    int _count = 5;</span><br><span class="line">protected:</span><br><span class="line">    int _age = 19;</span><br><span class="line">&#125;;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    Person::_count = 3;</span><br><span class="line">    Person::Print();</span><br><span class="line">    Teacher::Print();</span><br><span class="line">    Teacher teacher;</span><br><span class="line">    cout &lt;&lt; teacher._count &lt;&lt; endl;//可以访问了</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Person::_count = 3</span><br><span class="line">Person::_count = 3</span><br><span class="line">5</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;由此我们可以判断一点，如果在派生类中发生隐藏和重定义那么在派生类中该<strong>同名成员的生命周期及访问权限将根据在派生类中重定义的情况而决定</strong>，因此在基类中即使是静态的成员如果在派生类中重定义为非静态变量进行使用也是可以的，可见重定义和隐藏是十分恐怖的，因此我们最好是尽量防止在派生类中定义和基类重名的成员，避免发生隐藏和重定义。</p>
<h2 id="菱形继承和虚继承"><a href="#菱形继承和虚继承" class="headerlink" title="菱形继承和虚继承"></a>菱形继承和虚继承</h2><p>&emsp;&emsp;Cpp语法复杂这一特点可以从继承中体现出来，因为其支持多继承，而多继承就有可能会产生<strong>菱形继承</strong>的情况。</p>
<h3 id="菱形继承"><a href="#菱形继承" class="headerlink" title="菱形继承"></a>菱形继承</h3><p>&emsp;&emsp;什么是菱形继承呢？其产生原因就要“归功于”Cpp支持多继承这一特点，多继承就是允许一个类继承于多个基类，当派生类多继承于多个基类时，这些基类也有可能继承于更上层的同一个基类，由此就会产生菱形继承的情况。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class A</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    char _a = &apos;A&apos;;</span><br><span class="line">&#125;;</span><br><span class="line">//B继承于A</span><br><span class="line">class B: public A</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    char _b = &apos;B&apos;;</span><br><span class="line">&#125;;</span><br><span class="line">//C也继承于A</span><br><span class="line">class C: public A</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    char _c = &apos;C&apos;;</span><br><span class="line">&#125;;</span><br><span class="line">//D继承于B,C</span><br><span class="line">class D: public B, public C</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    char _d = &apos;D&apos;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;以上这种结构就会产生菱形继承，我们用画图的方式具现化表示一下。<br><br><img src="/2019/08/22/【Cpp】第十一章-继承/3.png" alt="菱形继承"><br><br>&emsp;&emsp;这种继承体系就是菱形继承，也是非常直观的可以体现出来的。</p>
<h3 id="菱形继承带来的问题"><a href="#菱形继承带来的问题" class="headerlink" title="菱形继承带来的问题"></a>菱形继承带来的问题</h3><p>&emsp;&emsp;菱形继承是Cpp多继承所带来的主要问题之一，一旦发生菱形继承，首当其冲的我们就应该考虑到菱形继承带来的<strong>数据冗余</strong>及<strong>数据二义性</strong>的问题。<br>&emsp;&emsp;还用上面的例子，因为D同时继承了B,C类，而B,C类又都分别继承了A类这就意味着D中存在着两份A类，一份是从B那里继承来的，另一份是从C继承来的，这就造成了数据冗余，并且当我们通过D想要直接访问A类成员时编译器会报错，因为编译器不知道你要访问的时B中的A类成员还是C中的A类成员，我们必须加上域限定符才能访问，这就造成了数据二义性，但是我们通过域限定符姑且可以解决数据二义性的问题，但是数据冗余却无法解决。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class A</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    char _a = &apos;A&apos;;</span><br><span class="line">&#125;;</span><br><span class="line">//B继承于A</span><br><span class="line">class B: public A</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    char _b = &apos;B&apos;;</span><br><span class="line">&#125;;</span><br><span class="line">//C也继承于A</span><br><span class="line">class C: public A</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    char _c = &apos;C&apos;;</span><br><span class="line">&#125;;</span><br><span class="line">//D继承于B,C</span><br><span class="line">class D: public B, public C</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    char _d = &apos;D&apos;;</span><br><span class="line">&#125;;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    D d;</span><br><span class="line">    //cout &lt;&lt; d._a &lt;&lt; endl;//报错</span><br><span class="line">    d.B::_a = &apos;E&apos;;</span><br><span class="line">    d.C::_a = &apos;F&apos;;</span><br><span class="line">    cout &lt;&lt; d.B::_a &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; d.C::_a &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">E</span><br><span class="line">F</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;从以上结果中可以看出d中有着两份A类的成员，因此在我们日常程序设计中应该极力避免菱形继承的产生，因为会浪费空间也会产生不必要的错误。</p>
<h3 id="虚拟继承"><a href="#虚拟继承" class="headerlink" title="虚拟继承"></a>虚拟继承</h3><p>&emsp;&emsp;但是如果在某些场景下一定要产生菱形继承，我们也有办法避免数据冗余及数据二义性的发生，这就要牵扯到<strong>虚拟继承</strong>。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class A</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    char _a = &apos;A&apos;;</span><br><span class="line">&#125;;</span><br><span class="line">//使用虚拟继承使B继承于A</span><br><span class="line">class B: virtual public A</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    char _b = &apos;B&apos;;</span><br><span class="line">&#125;;</span><br><span class="line">//使用虚拟继承使C继承于A</span><br><span class="line">class C: virtual public A</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    char _c = &apos;C&apos;;</span><br><span class="line">&#125;;</span><br><span class="line">//D继承于B,C</span><br><span class="line">class D: public B, public C</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    char _d = &apos;D&apos;;</span><br><span class="line">&#125;;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    //一旦使用虚拟继承那么D类中就只存在一份A的成员变量</span><br><span class="line">    D d;</span><br><span class="line">    //无论用什么作用域进行访问都只能访问到同一份</span><br><span class="line">    d.B::_a = &apos;E&apos;;</span><br><span class="line">    cout &lt;&lt; d._a &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; d.B::_a &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; d.C::_a &lt;&lt; endl;</span><br><span class="line">    d.C::_a = &apos;F&apos;;</span><br><span class="line">    cout &lt;&lt; d._a &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; d.B::_a &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; d.C::_a &lt;&lt; endl;</span><br><span class="line">    //我们甚至还可以这样访问，一旦使用虚拟继承我们可以视d间接继承了A，因此也有了A的作用域</span><br><span class="line">    //这在不使用虚拟继承的情况下是无法完成的</span><br><span class="line">    cout &lt;&lt; d.A::_a &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">E</span><br><span class="line">E</span><br><span class="line">E</span><br><span class="line">F</span><br><span class="line">F</span><br><span class="line">F</span><br><span class="line">F</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;那么虚拟继承是如何做到的这一切呢？在不适用虚拟继承的情况下类D中可以这样表示。<br><br><img src="/2019/08/22/【Cpp】第十一章-继承/4.png" alt="虚拟继承"><br><br>&emsp;&emsp;但是引入虚拟继承后，编译器就会生成一张<strong>虚基表</strong>，这张表中存放着这个类与其虚拟继承的基类之间的地址偏移量，而在这个类中也会多生成一个指针被称为<strong>虚基表指针</strong>指向这张虚基表。因此此时D类中由于所继承的两个基类都是虚拟继承自A类，因此B,C类都会有属于自己的虚基表及指向这张表的虚基表指针，而他们的虚基表中都会存储与同一个A类之间的地址偏移量，因此就可以做到D类中就有唯一的一份A类成员。<br>&emsp;&emsp;使用虚拟继承D中可以如下表示。<br><br><img src="/2019/08/22/【Cpp】第十一章-继承/5.png" alt="虚拟继承"><br><br>&emsp;&emsp;但是要注意虚基表中存放的并不是直接指向类A的指针，而是与A的地址偏移量，由此可以找到A。这样就确保了D中只有唯一的一份A的成员，解决了数据冗余以及数据二义性的问题。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; sizeof(B) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">8</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;我们取一个虚拟继承的类的大小也可以发现其大小变成了8，这是因为多了一个虚基表指针占了4个字节，加上3个字节的补齐成了8。不过这样我们知道了虚基表指针是存储在对象中的，那么虚基表存储在哪里呢？这个根据每个编译器的不同都有不同的处理，vs是存储在寄存器中的。</p>
<h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><p>&emsp;&emsp;在继承这一章，我们透彻的学习了继承的各种知识点，并且还解析了菱形继承以及虚拟继承底层的实现原理，我们不由得产生了一个问题，我什么时候使用继承什么时候使用组合呢？<br>&emsp;&emsp;继承：是一种<strong>is a</strong>的关系。<br>&emsp;&emsp;组合：是一种<strong>has a</strong>的关系。<br>&emsp;&emsp;这一点并不难理解，但是实际开发中，我们尽量优先使用组合，因为组合耦合度低，易于开发和维护，我们可以不用过多的考虑基类的实现，而继承不同。但是有一些情况下确实是继承更为符合情景呢么就是用继承，但要小心多继承。继承的使用也是十分广泛的，比如之后要学习的多态，都多亏于继承的语法，当然如果继承和组合都可以使用的话还是使用组合更好。</p>

          
        
      
    </div>
    
    
    

    

    <div>
    
    </div>

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/08/12/【Cpp】第十章-模板进阶/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="MisakiFx">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/blog-logo.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Misaki`s blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/08/12/【Cpp】第十章-模板进阶/" itemprop="url">【Cpp】第十章-模板进阶</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-08-12T16:35:22+08:00">
                2019-08-12
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Cpp/" itemprop="url" rel="index">
                    <span itemprop="name">Cpp</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  2.9k
                </span>
              

              

              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="模板进阶"><a href="#模板进阶" class="headerlink" title="模板进阶"></a>模板进阶</h1><p>&emsp;&emsp;之前的博客已经介绍过模板的概念，这是Cpp在实现泛型编程中不可缺少的一环，在模板进阶的讨论中会着重于模板的更为高级的使用。</p>
<h2 id="非类型模板参数"><a href="#非类型模板参数" class="headerlink" title="非类型模板参数"></a>非类型模板参数</h2><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>&emsp;&emsp;在模板中我们通常都是定义一个类型模板参数，在进行实例化的时候通过传入类型来实例化模板，但是模板中也可以定义非类型的模板参数。用一个封装的定长顺序表进行举例。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;assert.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">template&lt;class T, size_t L&gt;</span><br><span class="line">class Array</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    Array()</span><br><span class="line">    :_arr(&#123;0&#125;)</span><br><span class="line">    ,_size(0)</span><br><span class="line">    &#123;&#125;</span><br><span class="line">    size_t Size() const</span><br><span class="line">    &#123;</span><br><span class="line">        return _size;</span><br><span class="line">    &#125;</span><br><span class="line">    T&amp; operator[](size_t pos)</span><br><span class="line">    &#123;</span><br><span class="line">        assert(pos &lt; _size);</span><br><span class="line">        return _arr[pos];</span><br><span class="line">    &#125;</span><br><span class="line">    void Push_Back(T data)</span><br><span class="line">    &#123;</span><br><span class="line">        if(_size &lt; L)</span><br><span class="line">        &#123;</span><br><span class="line">            _arr[_size] = data;</span><br><span class="line">            _size++;</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; &quot;Array is full&quot; &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    void Pop_Back()</span><br><span class="line">    &#123;</span><br><span class="line">        if(!Empty())</span><br><span class="line">        &#123;</span><br><span class="line">            _size--;</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; &quot;Array is empty&quot; &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    bool Empty() const</span><br><span class="line">    &#123;</span><br><span class="line">        return _size == 0;</span><br><span class="line">    &#125;</span><br><span class="line">private:</span><br><span class="line">    T _arr[L];</span><br><span class="line">    size_t _size;</span><br><span class="line">&#125;;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    Array&lt;int, 20&gt; arr;</span><br><span class="line">    arr.Push_Back(1);</span><br><span class="line">    arr.Push_Back(2);</span><br><span class="line">    arr.Push_Back(2);</span><br><span class="line">    arr.Push_Back(5);</span><br><span class="line">    arr.Push_Back(7);</span><br><span class="line">    arr.Push_Back(5);</span><br><span class="line">    arr.Pop_Back();</span><br><span class="line">    arr.Pop_Back();</span><br><span class="line">    arr.Pop_Back();</span><br><span class="line">    for(int i = 0; i &lt; arr.Size(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; arr[i] &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><p>&emsp;&emsp;非类型模板参数在使用中有很严格的要求，它必须遵循以下规则，其实这块的要求在网上大部分博客中都说的十分模糊并且在我的实验下发现过于片面和局限，因此我给出我的总结和理解。<br>&emsp;&emsp;1、非类型模板参数可以是整形，指针和引用。<br>&emsp;&emsp;2、再给模板参数传参时要求其必须是一个常量表达式。<br>&emsp;&emsp;3、如果模板参数是一个整形，那么在传参的时候可以传入字面值常量，也可以是全局/局部常量，可以是外部/内部链接（关于链接属性参考其他博客）。<br>&emsp;&emsp;4、如果模板参数是一个指针或者引用，那么传参时要求，如果传入变量，变量必须是全局的，如果是常量常量必须是外部链接属性的，并且不能把动态对象的指针或引用传入。也就是说局部变量和内部链接属性的常量是不可以当作模板参数构造模板的，并且指针和引用还不能是动态对象的。<br>&emsp;&emsp;以上是我个人在环境下多次实验得出的理解和总结，环境是gcc 6.3.0，如果有误区还请指出。</p>
<h2 id="模板的特化"><a href="#模板的特化" class="headerlink" title="模板的特化"></a>模板的特化</h2><p>&emsp;&emsp;模板可以封装不同的类型做相同的操作，然而有这么一种情况，我想要根据不同的类型做出不同于原来模板的操作，这就需要用到模板的特化这个语法。特化就是在原模版的基础上，根据特殊类型进行特殊化的实现方式。</p>
<h3 id="函数模板的特化"><a href="#函数模板的特化" class="headerlink" title="函数模板的特化"></a>函数模板的特化</h3><p>&emsp;&emsp;函数模板特化要求当然要有基本的函数模板，在特化时格式要求<code>template</code>后跟一对尖括号，并且函数名后尖括号内写特化的模板参数。参数及函数体中的模板参数必须全部替换为特化的模板实参，不然会报错。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">//为了验证函数模板与类模板</span><br><span class="line">//先写一个函数模板</span><br><span class="line">template&lt;class T&gt;</span><br><span class="line">T Add(T a, T b)</span><br><span class="line">&#123;</span><br><span class="line">    return a + b;</span><br><span class="line">&#125;</span><br><span class="line">//特化处理</span><br><span class="line">template&lt;&gt;</span><br><span class="line">int Add&lt;int&gt;(int a, int b)</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; &quot;specialization&quot; &lt;&lt; endl;</span><br><span class="line">    return a + b;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; Add(1, 2) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">specialization</span><br><span class="line">3</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;这样的特化写法是最为规范的写法，就像是函数模板的显示实例化一样，当然我们也可以将<code>&lt;int&gt;</code>不要，只要能让模板知道你再特化哪一种情况即可，但是要与模板完全符合，不然是编不过的。<br>&emsp;&emsp;还有一种更为简单的方式，及利用我在模板初阶中提到的<strong>模板匹配规则</strong>。模板匹配是在所有同名函数都不符合调用的情况下才会进行实例化，因此我们可以用类似重载的情况写同名函数来进行处理，在调用时会优先调用非模板函数。这种情况并不能算是模板的特化处理，但是可以用来处理一些模板无法匹配的情况。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">template&lt;class T&gt;</span><br><span class="line">T Add(T&amp; a, T&amp; b)</span><br><span class="line">&#123;</span><br><span class="line">    return a + b;</span><br><span class="line">&#125;</span><br><span class="line">template&lt;&gt;</span><br><span class="line">int Add(int&amp; a, int&amp; b)</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; &quot;specialization&quot; &lt;&lt; endl;</span><br><span class="line">    return a + b;</span><br><span class="line">&#125;</span><br><span class="line">int Add(int a, int b)</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; &quot;overload&quot; &lt;&lt; endl;</span><br><span class="line">    return a + b;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int a = 1;</span><br><span class="line">    int b = 2;</span><br><span class="line">    cout &lt;&lt; Add(a, b) &lt;&lt; endl;//调用重载的Add</span><br><span class="line">    cout &lt;&lt; Add&lt;int&gt;(a, b) &lt;&lt; endl;//调用特化的Add</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">overload</span><br><span class="line">3</span><br><span class="line">specialization</span><br><span class="line">3</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;在这个例子中可以看出根据模板匹配规则确实优先调用了我们重载的函数，我们只有显示实例化才会调用模板。</p>
<h3 id="类模板的特化"><a href="#类模板的特化" class="headerlink" title="类模板的特化"></a>类模板的特化</h3><p>&emsp;&emsp;类模板特化与函数模板类似，但是由于类模板是无法通过其他方式识别模板参数的类型的，因此我们必须通过<code>&lt;&gt;</code>来显示实例化才能进行特化。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">//类模板</span><br><span class="line">template&lt;class T1, class T2&gt;</span><br><span class="line">class Data</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    Data()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; &quot;Data&lt;T1, T2&gt;&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">private:</span><br><span class="line">    T1 _data1;</span><br><span class="line">    T2 _data2;</span><br><span class="line">&#125;;</span><br><span class="line">//特化处理</span><br><span class="line">template&lt;&gt;</span><br><span class="line">class Data&lt;int, char&gt;</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    Data()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; &quot;Data&lt;int, char&gt;&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">private:</span><br><span class="line">    int _data1;</span><br><span class="line">    char _data2;</span><br><span class="line">&#125;;</span><br><span class="line">int main()</span><br><span class="line">&#123;    </span><br><span class="line">    Data&lt;int, int&gt; data1;</span><br><span class="line">    Data&lt;int, char&gt; data2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Data&lt;T1, T2&gt;</span><br><span class="line">Data&lt;int, char&gt;</span><br></pre></td></tr></table></figure></p>
<h3 id="特化的种类"><a href="#特化的种类" class="headerlink" title="特化的种类"></a>特化的种类</h3><h4 id="全特化"><a href="#全特化" class="headerlink" title="全特化"></a>全特化</h4><p>&emsp;&emsp;全特化就是将模板参数全部进行实例特化的情况。这里用类模板举例。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">template&lt;class T1, class T2&gt;</span><br><span class="line">class Data</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    Data()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; &quot;Data&lt;T1, T2&gt;&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">private:</span><br><span class="line">    T1 _data1;</span><br><span class="line">    T2 _data2;</span><br><span class="line">&#125;;</span><br><span class="line">//这样的把所有的模板参数都进行实例特化的就叫全特化</span><br><span class="line">template&lt;&gt;</span><br><span class="line">class Data&lt;int, char&gt;</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    Data()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; &quot;Data&lt;int, char&gt;&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">private:</span><br><span class="line">    int _data1;</span><br><span class="line">    char _data2;</span><br><span class="line">&#125;;</span><br><span class="line">int main()</span><br><span class="line">&#123;    </span><br><span class="line">    Data&lt;int, int&gt; data1;</span><br><span class="line">    Data&lt;int, char&gt; data2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Data&lt;T1, T2&gt;</span><br><span class="line">Data&lt;int, char&gt;</span><br></pre></td></tr></table></figure></p>
<h4 id="偏特化"><a href="#偏特化" class="headerlink" title="偏特化"></a>偏特化</h4><p>&emsp;&emsp;偏特化就是全特化以外的情况，并没有将所有的模板参数全部都实例化为某一特殊情况。偏特化又有两种情况。<br>&emsp;&emsp;<strong>1、部分特化</strong>：部分特化是将模板参数中一部分模板参数进行实例化特化的情况。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">template&lt;class T1, class T2&gt;</span><br><span class="line">class Data</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    Data()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; &quot;Data&lt;T1, T2&gt;&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">private:</span><br><span class="line">    T1 _data1;</span><br><span class="line">    T2 _data2;</span><br><span class="line">&#125;;</span><br><span class="line">//这样的把所有的模板参数都进行实例特化的就叫全特化</span><br><span class="line">template&lt;&gt;</span><br><span class="line">class Data&lt;int, char&gt;</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    Data()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; &quot;Data&lt;int, char&gt;&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">private:</span><br><span class="line">    int _data1;</span><br><span class="line">    char _data2;</span><br><span class="line">&#125;;</span><br><span class="line">//这里就是一个部分特化，只将第一个参数进行实例化的情况</span><br><span class="line">template&lt;class T&gt;</span><br><span class="line">class Data&lt;int, T&gt;</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    Data()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; &quot;Data&lt;int, T&gt;&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    Data&lt;int, int&gt; data1;//这里会调用部分特化</span><br><span class="line">    Data&lt;int, char&gt; data2;//这里调用全特化</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Data&lt;int, T&gt;</span><br><span class="line">Data&lt;int, char&gt;</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;通过这个例子还可以证实如果实例化同时符合全特化和部分特化的特化情况，则会优先调用全特化，之后才会考虑部分特化的情况。<br>&emsp;&emsp;<strong>2、将参数进一步限制的特化</strong>：<br>&emsp;&emsp;这个类型的特化是将参数进行了进一步的限制，我们可以将参数限制为指针类型或者引用，在这种情况下才会调用这种类型的特化<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">template&lt;class T1, class T2&gt;</span><br><span class="line">class Data</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    Data()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; &quot;Data&lt;T1, T2&gt;&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">private:</span><br><span class="line">    T1 _data1;</span><br><span class="line">    T2 _data2;</span><br><span class="line">&#125;;</span><br><span class="line">//这样的把所有的模板参数都进行实例特化的就叫全特化</span><br><span class="line">template&lt;&gt;</span><br><span class="line">class Data&lt;int, char&gt;</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    Data()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; &quot;Data&lt;int, char&gt;&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">private:</span><br><span class="line">    int _data1;</span><br><span class="line">    char _data2;</span><br><span class="line">&#125;;</span><br><span class="line">//这里就是一个部分特化，只将第一个参数进行实例化的情况</span><br><span class="line">template&lt;class T&gt;</span><br><span class="line">class Data&lt;int, T&gt;</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    Data()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; &quot;Data&lt;int, T&gt;&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">//将两个参数类型限制为指针类型，如果两个参数都是指针类型则调用这个特化</span><br><span class="line">template&lt;class T1, class T2&gt;</span><br><span class="line">class Data&lt;T1*, T2*&gt;</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    Data()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; &quot;Data&lt;T1*, T2*&gt;&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    Data&lt;int, int&gt; data1;//这里会调用部分特化</span><br><span class="line">    Data&lt;int, char&gt; data2;//这里调用全特化</span><br><span class="line">    Data&lt;int*, char*&gt; data3;//这里调用类型限制的特化</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="类型萃取"><a href="#类型萃取" class="headerlink" title="类型萃取"></a>类型萃取</h2><p>&emsp;&emsp;类型萃取是通过特化的方式使模板可以识别不同的类型从而使用不同的处理方法。比如说我们要写一个拷贝函数，对于内置类型我们直接调用<code>memcpy()</code>函数拷贝内存，而对于自定义类型我们可能需要使用自定义的其他拷贝方法进行深拷贝，这时候就可以使用类型萃取的方式来区别内置类型和自定义类型达到不同处理方式的结果。<br>&emsp;&emsp;这并不是一种新的语法，更像是一种设计模式，在STL中就有所体现。</p>
<h2 id="模板的分离编译"><a href="#模板的分离编译" class="headerlink" title="模板的分离编译"></a>模板的分离编译</h2><p>&emsp;&emsp;什么是分离编译模式？分离编译模式就是我们通常在写项目是方便项目管理时所使用的将函数和类的声明放进<code>.h</code>文件中而在<code>.cpp</code>文件中写类定义和类成员函数定义的模式。这种方法可行就是应为我们将声明写入<code>.h</code>而在需要使用的地方引入头文件，在链接过程中编译器会根据声明找到具体实现定义的地址完成链接。</p>
<h3 id="模板不支持分离编译"><a href="#模板不支持分离编译" class="headerlink" title="模板不支持分离编译"></a>模板不支持分离编译</h3><p>&emsp;&emsp;但是这里要说的是，无论是函数模板还是类模板在没有实例化之前都是没有具体代码的，那么也就没有具体定义的地址，我们根据声明也就无法链接到定义的地方。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// a.h</span><br><span class="line">template&lt;class T&gt;</span><br><span class="line">T Add(const T&amp; left, const T&amp; right);</span><br><span class="line">// a.cpp</span><br><span class="line">template&lt;class T&gt;</span><br><span class="line">T Add(const T&amp; left, const T&amp; right)</span><br><span class="line">&#123;</span><br><span class="line">    return left + right;</span><br><span class="line">&#125;</span><br><span class="line">// main.cpp</span><br><span class="line">#include&quot;a.h&quot;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    Add(1, 2);</span><br><span class="line">    Add(1.0, 2.0);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;以上这个例子中的代码时编不过的，原因就是模板不支持分离编译，无法连接。</p>
<h3 id="如何解决？"><a href="#如何解决？" class="headerlink" title="如何解决？"></a>如何解决？</h3><p>&emsp;&emsp;解决方法也很简单，最简单的就是将定义和声明都写到头文件中可以了，这样就省去了链接这个步骤，也就不存在错误了。</p>

          
        
      
    </div>
    
    
    

    

    <div>
    
    </div>

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/08/05/【Cpp】第九章-STL-stack类和queue类/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="MisakiFx">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/blog-logo.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Misaki`s blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/08/05/【Cpp】第九章-STL-stack类和queue类/" itemprop="url">【Cpp】第九章-STL_stack类和queue类</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-08-05T18:04:20+08:00">
                2019-08-05
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Cpp/" itemprop="url" rel="index">
                    <span itemprop="name">Cpp</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  3.8k
                </span>
              

              

              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="stack类和queue类"><a href="#stack类和queue类" class="headerlink" title="stack类和queue类"></a>stack类和queue类</h1><p>&emsp;&emsp;<code>stack</code>和<code>queue</code>以及<code>priority_queue</code>(优先级队列)是STL中三大容器适配器，将其称为容器适配器是因为其在底层只是对现有容器进行的了封装而并没有重新实现。因此在容器适配器中都有让传入容器的模板参数。</p>
<h2 id="容器适配器"><a href="#容器适配器" class="headerlink" title="容器适配器"></a>容器适配器</h2><p>&emsp;&emsp;适配器是一种设计模式，在GOF的《设计模式：可复用面向对象软件的基础》中是这样说的：将一个类的接口转换成客户希望的另外一个接口。适配器模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。而容器适配器就是将常见容器的接口进行封装，使之成为我们需要的结构。因此在容器适配的模板参数中我们可以传入我们想要使用的容器作为模板参数进行封装，但是作为适配器的实现容器它们也需要满足一定的要求才可以作为模板参数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//Container就是底层实现的容器的模板参数</span><br><span class="line">template &lt;class T, class Container = deque&lt;T&gt; &gt; class queue;</span><br><span class="line">template &lt;class T, class Container = deque&lt;T&gt; &gt; class stack;</span><br><span class="line">template &lt;class T, class Container = vector&lt;T&gt;,</span><br><span class="line">  class Compare = less&lt;typename Container::value_type&gt; &gt; class priority_queue;</span><br></pre></td></tr></table></figure></p>
<h2 id="stack类"><a href="#stack类" class="headerlink" title="stack类"></a>stack类</h2><p>&emsp;&emsp;<code>stack</code>和我们数据结构中的栈实现了同样的功能，<strong>后进先出</strong>是其最大的特点。它只能从容器的一端进行元素的插入和提取，来满足栈的相关功能。<br>&emsp;&emsp;它底层的容器可以是标准中的容器类也可以是其他的容器类，但是无论如何这些容器类必须满足以下要求。<br>&emsp;&emsp;1、<code>empty()</code>，判空操作。<br>&emsp;&emsp;2、<code>back()</code>，获取尾部元素。<br>&emsp;&emsp;3、<code>push_back()</code>，尾插。<br>&emsp;&emsp;4、<code>pop_back()</code>，尾删。<br>&emsp;&emsp;满足这些要求的容器类才可以被传入，如果没有传入容器的话则默认使用<code>deque</code>。</p>
<h3 id="常用接口"><a href="#常用接口" class="headerlink" title="常用接口"></a>常用接口</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">stack(const container_type &amp;ctnr = container_type()); //构造空的栈</span><br><span class="line">bool empty() const;                                   //检测stack是否为空</span><br><span class="line">size_type size();                                     //const 返回stack中元素的个数</span><br><span class="line">value_type &amp;top();                                    //返回栈顶元素的引用</span><br><span class="line">const value_type &amp;top() const;                        //返回栈顶元素的const引用</span><br><span class="line">void push(const value_type &amp;val);                     //将元素val压入stack中</span><br><span class="line">void pop();                                           //将stack中尾部的元素弹出</span><br><span class="line">template &lt;class... Args&gt;</span><br><span class="line">void emplace(Args &amp;&amp;... args);                        //(C++11) 在stack的栈顶构造元素</span><br><span class="line">void swap(stack &amp;x);                                  //(C++11) 交换两个栈中的元素</span><br></pre></td></tr></table></figure>
<h3 id="栈的应用"><a href="#栈的应用" class="headerlink" title="栈的应用"></a>栈的应用</h3><h4 id="最小栈"><a href="#最小栈" class="headerlink" title="最小栈"></a>最小栈</h4><p>&emsp;&emsp;力扣：<br><a href="https://leetcode-cn.com/problems/min-stack/submissions/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/min-stack/submissions/</a><br>&emsp;&emsp;这道题就是用栈区实现一个可以返回当前栈中最小值的栈，方法有很多种，这里只提供一种方法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">class MinStack &#123;</span><br><span class="line">public:</span><br><span class="line">    /** initialize your data structure here. */</span><br><span class="line">    MinStack()</span><br><span class="line">        :_min(INT_MAX)</span><br><span class="line">    &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    void push(int x) &#123;</span><br><span class="line">        if(x &lt; _min)</span><br><span class="line">        &#123;</span><br><span class="line">            _min = x;</span><br><span class="line">        &#125;</span><br><span class="line">        _elem.push_back(x);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    void pop() &#123;</span><br><span class="line">        if(top() == _min)</span><br><span class="line">        &#123;</span><br><span class="line">            _min = INT_MAX;</span><br><span class="line">            for(int i = 0; i &lt; _elem.size() - 1; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                if(_elem[i] &lt; _min)</span><br><span class="line">                &#123;</span><br><span class="line">                    _min = _elem[i];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        _elem.pop_back();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    int top() &#123;</span><br><span class="line">        return _elem[_elem.size() - 1];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    int getMin() &#123;</span><br><span class="line">        return _min;</span><br><span class="line">    &#125;</span><br><span class="line">private:</span><br><span class="line">    std::vector&lt;int&gt; _elem;</span><br><span class="line">    int _min;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Your MinStack object will be instantiated and called as such:</span><br><span class="line"> * MinStack* obj = new MinStack();</span><br><span class="line"> * obj-&gt;push(x);</span><br><span class="line"> * obj-&gt;pop();</span><br><span class="line"> * int param_3 = obj-&gt;top();</span><br><span class="line"> * int param_4 = obj-&gt;getMin();</span><br><span class="line"> */</span><br></pre></td></tr></table></figure></p>
<h4 id="栈的压入、弹出序列"><a href="#栈的压入、弹出序列" class="headerlink" title="栈的压入、弹出序列"></a>栈的压入、弹出序列</h4><p>&emsp;&emsp;牛客网：<br><a href="https://www.nowcoder.com/practice/d77d11405cc7470d82554cb392585106?tpId=13&amp;&amp;tqId=11174&amp;rp=1&amp;ru=/activity/oj&amp;qru=/ta/coding-interviews/question-ranking" target="_blank" rel="noopener">https://www.nowcoder.com/practice/d77d11405cc7470d82554cb392585106?tpId=13&amp;&amp;tqId=11174&amp;rp=1&amp;ru=/activity/oj&amp;qru=/ta/coding-interviews/question-ranking</a><br>&emsp;&emsp;这道题用到了栈的弹出序列是否匹配压入序列的算法，大致思路是用一个栈进行模拟，并且设立用于分别遍历弹出和压入序列的下标，只要栈顶元素不等于当前遍历到的弹出序列的元素，就将压入序列当前元素压入栈，并且遍历压入序列的下一个元素，如果相等，则将栈顶元素弹出，并且遍历弹出序列的下一个元素。如果当弹出序列还没有遍历完毕而压入序列也始终找不到下一个可以和弹出序列进行匹配的元素则不匹配，返回false，如果弹出序列遍历完毕，则表示匹配，返回true。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool IsPopOrder(vector&lt;int&gt; pushV,vector&lt;int&gt; popV) &#123;</span><br><span class="line">        int pushIndex = 0;</span><br><span class="line">        int popIndex = 0;</span><br><span class="line">        //用栈进行模拟</span><br><span class="line">        stack&lt;int&gt; s;</span><br><span class="line">        //遍历弹出序列</span><br><span class="line">        while(popIndex &lt; popV.size())</span><br><span class="line">        &#123;</span><br><span class="line">            //栈为空或者栈顶元素不等于当天弹出序列遍历到的元素</span><br><span class="line">            while(s.empty() || s.top() != popV[popIndex])</span><br><span class="line">            &#123;</span><br><span class="line">                //压入序列还有元素则压入</span><br><span class="line">                if(pushIndex &lt; pushV.size())</span><br><span class="line">                &#123;</span><br><span class="line">                    s.push(pushV[pushIndex]);</span><br><span class="line">                    pushIndex++;</span><br><span class="line">                &#125;</span><br><span class="line">                //压入序列全部压入无法完成匹配</span><br><span class="line">                else</span><br><span class="line">                &#123;</span><br><span class="line">                    return false;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            //栈顶元素和弹出序列当前元素相同则往后继续遍历</span><br><span class="line">            s.pop();</span><br><span class="line">            popIndex++;</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h4 id="逆波兰表达式求值"><a href="#逆波兰表达式求值" class="headerlink" title="逆波兰表达式求值"></a>逆波兰表达式求值</h4><p>&emsp;&emsp;力扣：<br><a href="https://leetcode-cn.com/problems/evaluate-reverse-polish-notation/submissions/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/evaluate-reverse-polish-notation/submissions/</a><br>&emsp;&emsp;逆波兰表达式也成为后缀表达式，这里的逆波兰表达式求值由于不涉及括号所以比较简单，我们只需要将遇到的操作数放入栈，遇到操作符则取出栈顶两个元素进行计算，然后将结果再次放入栈最后取出栈中最后一个元素就是答案。不过这里要注意负数的处理，以及从栈中取出的两个操作数哪个是前操作数哪个是后操作数的问题。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int evalRPN(vector&lt;string&gt;&amp; tokens) &#123;</span><br><span class="line">        stack&lt;int&gt; s;</span><br><span class="line">        for(int i = 0; i &lt; tokens.size(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            if(tokens[i][0] &lt;= &apos;9&apos; &amp;&amp; tokens[i][0] &gt;= &apos;0&apos;)</span><br><span class="line">            &#123;</span><br><span class="line">                s.push(atoi(tokens[i].c_str()));</span><br><span class="line">            &#125;</span><br><span class="line">            //要处理负数</span><br><span class="line">            else if(tokens[i][0] == &apos;-&apos; &amp;&amp; tokens[i][1] != &apos;\0&apos;)</span><br><span class="line">            &#123;</span><br><span class="line">                string str = tokens[i].substr(1);</span><br><span class="line">                int temp = -1 * atoi(str.c_str());</span><br><span class="line">                s.push(temp);</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">            &#123;</span><br><span class="line">                int num1 = s.top();</span><br><span class="line">                s.pop();</span><br><span class="line">                int num2 = s.top();</span><br><span class="line">                s.pop();</span><br><span class="line">                switch(tokens[i][0])</span><br><span class="line">                &#123;</span><br><span class="line">                    case &apos;+&apos;:</span><br><span class="line">                        s.push(num2 + num1);</span><br><span class="line">                        break;</span><br><span class="line">                    case &apos;-&apos;:</span><br><span class="line">                        s.push(num2 - num1);</span><br><span class="line">                        break;</span><br><span class="line">                    case &apos;*&apos;:</span><br><span class="line">                        s.push(num2 * num1);</span><br><span class="line">                        break;</span><br><span class="line">                    case &apos;/&apos;:</span><br><span class="line">                        s.push(num2 / num1);</span><br><span class="line">                        break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return s.top();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h2 id="queue类"><a href="#queue类" class="headerlink" title="queue类"></a>queue类</h2><p>&emsp;&emsp;和<code>stack</code>相反，<code>queue</code>有着先进先出的特性，这使得他能够按照顺序完成某一功能。它从容器的一端插入另一端删除，因此它的模板参数中的容器要求有以下功能：<br>&emsp;&emsp;1、<code>empty()</code>，判空<br>&emsp;&emsp;2、<code>size()</code>，长度<br>&emsp;&emsp;3、<code>back()</code>，获取尾部元素<br>&emsp;&emsp;4、<code>front()</code>，获取头部元素<br>&emsp;&emsp;5、<code>push_back()</code>，尾插<br>&emsp;&emsp;6、<code>pop_front()</code>，头删<br>&emsp;&emsp;如果没有传入容器的话则默认使用<code>deque</code>。</p>
<h3 id="常用接口-1"><a href="#常用接口-1" class="headerlink" title="常用接口"></a>常用接口</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">queue(const container_type &amp;ctnr = container_type()); //构造空的队列</span><br><span class="line">bool empty() const;                                   //检测队列是否为空，是返回true，否则返回false</span><br><span class="line">size_type size() const;                               //返回队列中有效元素的个数</span><br><span class="line">value_type &amp;front();                                  //返回队头元素的引用</span><br><span class="line">const value_type &amp;front() const;                      //返回队头元素的const引用</span><br><span class="line">value_type &amp;back();                                   //返回队尾元素的引用</span><br><span class="line">const value_type &amp;back() const;                       //返回队尾元素的cosnt引用</span><br><span class="line">void push(value_type &amp; val);                          //在队尾将元素val入队列</span><br><span class="line">void pop();                                           //将队头元素出队列</span><br><span class="line">template &lt;class... Args&gt;</span><br><span class="line">void emplace(Args &amp;&amp; ... args)(C++ 11);               //在队尾构造元素</span><br><span class="line">void swap(queue &amp; x);                                 //交换两个队列中的元素</span><br></pre></td></tr></table></figure>
<h3 id="队列的应用"><a href="#队列的应用" class="headerlink" title="队列的应用"></a>队列的应用</h3><h4 id="用队列实现栈"><a href="#用队列实现栈" class="headerlink" title="用队列实现栈"></a>用队列实现栈</h4><p>&emsp;&emsp;力扣：<br><a href="https://leetcode-cn.com/problems/implement-stack-using-queues/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/implement-stack-using-queues/</a><br>&emsp;&emsp;利用栈进行层序遍历类似于bfs，即广度优先搜索，我们在进行遍历时需要将每一个结点的儿子都压入栈，只要栈不为空就一直遍历下去。但是这个题要求要区分每一层，则我们需要在遍历每一层前都拿到当前队列中结点的个数，则是这一层要遍历的结点数，我们这一层就只遍历这些结点即可。我们甚至由此可以得出N叉树的层序遍历，都可以用类似的思路。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for a binary tree node.</span><br><span class="line"> * struct TreeNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeNode *left;</span><br><span class="line"> *     TreeNode *right;</span><br><span class="line"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><br><span class="line"> * &#125;;</span><br><span class="line"> */</span><br><span class="line">class Solution &#123;</span><br><span class="line">    public:</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; levelOrder(TreeNode* root) &#123;</span><br><span class="line">        vector&lt;vector&lt;int&gt;&gt; res;</span><br><span class="line">        queue&lt;TreeNode*&gt; q;</span><br><span class="line">        //根结点为空直接返回</span><br><span class="line">        if(root == nullptr)</span><br><span class="line">        &#123;</span><br><span class="line">            return res;</span><br><span class="line">        &#125;</span><br><span class="line">        q.push(root);</span><br><span class="line">        while(!q.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            vector&lt;int&gt; line;</span><br><span class="line">            int size = q.size();</span><br><span class="line">            for(int i = 0; i &lt; size; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                TreeNode* node = q.front();</span><br><span class="line">                if(node-&gt;left != nullptr)</span><br><span class="line">                &#123;</span><br><span class="line">                    q.push(node-&gt;left);</span><br><span class="line">                &#125;</span><br><span class="line">                if(node-&gt;right != nullptr)</span><br><span class="line">                &#123;</span><br><span class="line">                    q.push(node-&gt;right);</span><br><span class="line">                &#125;</span><br><span class="line">                q.pop();</span><br><span class="line">                line.push_back(node-&gt;val);</span><br><span class="line">            &#125;</span><br><span class="line">            res.push_back(line);</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h2 id="priority-queue类"><a href="#priority-queue类" class="headerlink" title="priority_queue类"></a>priority_queue类</h2><p>&emsp;&emsp;<code>priority_queue</code>称为优先级队列，它的出队元素永远是队列中优先级最高的那一个，它的底层是用一个堆来完成的，堆顶就是优先级最高的元素。<br>&emsp;&emsp;优先级队列在每次插入删除元素后都会分别调用算法<code>push_heap()</code>和<code>pop_heap()</code>重新建堆，并且还会和容器中的<code>push_back()</code>和<code>pop_back()</code>结合。同时优先级队列中有一个<code>Compare</code>的模板参数，用于传入一个仿函数，建堆会用这个仿函数按照严格弱序进行建堆。<br>&emsp;&emsp;所谓仿函数则是一个类中重载了<code>operator()</code>使其实例化的对象可以像函数一样进行调用，它的特点是可以使类作为模板参数一部分传入模板内，并且使其实例化出的对象可以当作函数使用。标准中给了两个类提供了仿函数的功能，<code>less</code>和<code>greater</code>。<br>&emsp;&emsp;如果在优先级队列中存放自定义类型的数据，要求自定义类型必须重载<code>operator&lt;</code>或<code>operator&gt;</code>取决于<code>Compare</code>的类型，这两个重载在仿函数中将会进行调用用于判断和比较。<br>&emsp;&emsp;同样的优先级队列中的容器也必须满足一些要求才能完成功能：<br>&emsp;&emsp;1、<code>empty()</code>，判空<br>&emsp;&emsp;2、<code>size()</code>，长度<br>&emsp;&emsp;3、<code>front()</code>，获取头部元素<br>&emsp;&emsp;4、<code>push_back()</code>，尾插<br>&emsp;&emsp;5、<code>pop_back()</code>，尾删<br>&emsp;&emsp;容器还需要支持随机访问迭代器，以便始终在内部保持堆结构。<br>&emsp;&emsp;为什么是这些接口？<code>front()</code>用于在建堆和堆调整后可以获得堆顶元素，即优先级最高的元素，即<code>top()</code>；<code>push()</code>在给堆插入元素时是从容器的尾部插入，因此需要<code>push_back()</code>进行尾插，尾插后再用<code>push_heap()</code>调整堆；<code>pop()</code>在出队时要先调用<code>pop_heap()</code>，这个接口会将堆顶元素与堆的最后一个元素交换位置，并且对堆的除最后一个元素进行调整，这个过程类似于堆排序。之后再调用容器的<code>pop_back()</code>即可将原本堆顶优先级最高的元素出队。</p>
<h3 id="常用接口-2"><a href="#常用接口-2" class="headerlink" title="常用接口"></a>常用接口</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">priority_queue(const Compare &amp;x = Compare(),</span><br><span class="line">                   const Container &amp;y = Container());   //构造一个空的优先级队列</span><br><span class="line">template &lt;class InputIterator&gt;</span><br><span class="line">priority_queue(InputIterator first, InputIterator last,</span><br><span class="line">               const Compare &amp;comp = Compare(),</span><br><span class="line">               const Container &amp;ctnr = Container()); //用[first, last)区间中的元素构造优先级队列</span><br><span class="line">bool empty() const;                                  //检测优先级队列是否为空，是返回true，否则返回false</span><br><span class="line">const value_type &amp;top() const;                       //返回优先级队列中最大(最小元素)，即堆顶元素</span><br><span class="line">void push(const T &amp;x);                               //在优先级队列中插入元素x</span><br><span class="line">void pop();                                          //删除优先级队列中最大(最小)元素，即堆顶元素</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;默认情况下，类模板中<code>Compare</code>的类型为<code>less</code>，实例化出来的对象重载时判断的为是否小于，因此会创建大堆，队列出队返回的值也是队中优先级最高的。</p>
<h3 id="优先级队列的应用"><a href="#优先级队列的应用" class="headerlink" title="优先级队列的应用"></a>优先级队列的应用</h3><p>&emsp;&emsp;优先级队列底层是堆的实现，因此优先级队列擅长于结局堆能够解决的问题，例如TopK问题。</p>
<h4 id="数组中的第K个最大的元素"><a href="#数组中的第K个最大的元素" class="headerlink" title="数组中的第K个最大的元素"></a>数组中的第K个最大的元素</h4><p>&emsp;&emsp;力扣：<br><a href="https://leetcode-cn.com/problems/kth-largest-element-in-an-array/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/kth-largest-element-in-an-array/</a><br>&emsp;&emsp;这道题就利用优先级队列找到第k个大的元素即可，也可以先排序后再找。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int findKthLargest(vector&lt;int&gt;&amp; nums, int k) &#123;</span><br><span class="line">        priority_queue&lt;int&gt; que(nums.begin(), nums.end());</span><br><span class="line">        for(int i = 0; i &lt; k - 1; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            que.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        return que.top();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h4 id="前K个高频元素"><a href="#前K个高频元素" class="headerlink" title="前K个高频元素"></a>前K个高频元素</h4><p>力扣：<br><a href="https://leetcode-cn.com/problems/top-k-frequent-elements/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/top-k-frequent-elements/</a><br>&emsp;&emsp;这道题做起来不难，但是是对优先级队列较为综合的运用，我们要考虑到TOPK问题中找前K大要用小根堆，还要考虑到要将出现次数与元素本身联系起来要在优先级队列中存储<code>pair</code>。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; topKFrequent(vector&lt;int&gt;&amp; nums, int k) &#123;</span><br><span class="line">        map&lt;int, int&gt; m;</span><br><span class="line">        for(int i = 0; i &lt; nums.size(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            m[nums[i]]++;</span><br><span class="line">        &#125;</span><br><span class="line">        //topK问题求前K大一定要用小根堆，维护K个数据</span><br><span class="line">        //用大根堆要放入全部数据费时费空间</span><br><span class="line">        priority_queue&lt;pair&lt;int, int&gt;, vector&lt;pair&lt;int, int&gt;&gt;, greater&lt;pair&lt;int, int&gt;&gt;&gt; que;</span><br><span class="line">        for(auto e : m)</span><br><span class="line">        &#123;</span><br><span class="line">            if(que.size() &gt;= k)</span><br><span class="line">            &#123;</span><br><span class="line">                if(e.second &gt; que.top().first)</span><br><span class="line">                &#123;</span><br><span class="line">                    que.pop();</span><br><span class="line">                    que.push(make_pair(e.second, e.first));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">            &#123;</span><br><span class="line">                que.push(make_pair(e.second, e.first)); </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        vector&lt;int&gt; res(k);</span><br><span class="line">        while(!que.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            res[que.size() - 1] = que.top().second;</span><br><span class="line">            que.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>&emsp;&emsp;依旧是实现常用接口，了解底层原理。</p>
<h3 id="stack类的实现"><a href="#stack类的实现" class="headerlink" title="stack类的实现"></a>stack类的实现</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">#pragma once</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;deque&gt;</span><br><span class="line">template&lt;class T, class Container = std::deque&lt;T&gt;&gt;</span><br><span class="line">class Stack</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    void Push(const T&amp; data)</span><br><span class="line">    &#123;</span><br><span class="line">        _con.push_back(data);</span><br><span class="line">    &#125;</span><br><span class="line">    void Pop()</span><br><span class="line">    &#123;</span><br><span class="line">        _con.pop_back();</span><br><span class="line">    &#125;</span><br><span class="line">    bool Empty()</span><br><span class="line">    &#123;</span><br><span class="line">        return _con.empty();</span><br><span class="line">    &#125;</span><br><span class="line">    size_t Size()</span><br><span class="line">    &#123;</span><br><span class="line">        return _con.size();</span><br><span class="line">    &#125;</span><br><span class="line">    T&amp; Top()</span><br><span class="line">    &#123;</span><br><span class="line">        return _con.back();</span><br><span class="line">    &#125;</span><br><span class="line">    const T&amp; Top() const</span><br><span class="line">    &#123;</span><br><span class="line">        return _con.back();</span><br><span class="line">    &#125;</span><br><span class="line">private:</span><br><span class="line">    Container _con;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="queue的实现"><a href="#queue的实现" class="headerlink" title="queue的实现"></a>queue的实现</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">#pragma once</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;deque&gt;</span><br><span class="line">template&lt;class T, class Container = std::deque&lt;T&gt;&gt;</span><br><span class="line">class Queue</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    void Push(const T&amp; data)</span><br><span class="line">    &#123;</span><br><span class="line">        _con.push_back(data);</span><br><span class="line">    &#125;</span><br><span class="line">    void Pop()</span><br><span class="line">    &#123;</span><br><span class="line">        _con.pop_front();</span><br><span class="line">    &#125;</span><br><span class="line">    size_t Size()</span><br><span class="line">    &#123;</span><br><span class="line">        return _con.size();</span><br><span class="line">    &#125;</span><br><span class="line">    bool Empty()</span><br><span class="line">    &#123;</span><br><span class="line">        return _con.empty();</span><br><span class="line">    &#125;</span><br><span class="line">    T&amp; Back()</span><br><span class="line">    &#123;</span><br><span class="line">        return _con.back();</span><br><span class="line">    &#125;</span><br><span class="line">    const T&amp; Back() const</span><br><span class="line">    &#123;</span><br><span class="line">        return _con.back();</span><br><span class="line">    &#125;</span><br><span class="line">    T&amp; Front()</span><br><span class="line">    &#123;</span><br><span class="line">        return _con.front();</span><br><span class="line">    &#125;</span><br><span class="line">    const T&amp; Front() const</span><br><span class="line">    &#123;</span><br><span class="line">        return _con.front();</span><br><span class="line">    &#125;</span><br><span class="line">private:</span><br><span class="line">    Container _con;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="priority-queue的实现"><a href="#priority-queue的实现" class="headerlink" title="priority_queue的实现"></a>priority_queue的实现</h3><p>&emsp;&emsp;在SGI版本的<code>priority_queue</code>中建堆以及调整堆都是调用的<code>algorithm</code>中的算法函数完成的，但是在模拟实现中我们完全自己实现。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line">#pragma once</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;functional&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">template&lt;class T&gt;</span><br><span class="line">struct Less</span><br><span class="line">&#123;</span><br><span class="line">    bool operator()(const T&amp; obj1, const T&amp; obj2)</span><br><span class="line">    &#123;</span><br><span class="line">        return obj1 &lt; obj2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">template&lt;class T&gt;</span><br><span class="line">struct Greater</span><br><span class="line">&#123;</span><br><span class="line">    bool operator()(const T&amp; obj1, const T&amp; obj2)</span><br><span class="line">    &#123;</span><br><span class="line">        return obj1 &gt; obj2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">template&lt;class T, class Container = std::vector&lt;T&gt;, class Compare = Less&lt;T&gt;&gt;</span><br><span class="line">class Priority_queue</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    //向下调整</span><br><span class="line">    void AdjustDown(size_t parent)</span><br><span class="line">    &#123;</span><br><span class="line">        size_t child = parent * 2 + 1;</span><br><span class="line">        Compare com;</span><br><span class="line">        while(child &lt; _con.size())</span><br><span class="line">        &#123;</span><br><span class="line">            if(child + 1 &lt; _con.size() &amp;&amp; com(_con[child], _con[child + 1]))</span><br><span class="line">            &#123;</span><br><span class="line">                child++;    </span><br><span class="line">            &#125;</span><br><span class="line">            if(com(_con[parent], _con[child]))</span><br><span class="line">            &#123;</span><br><span class="line">                std::swap(_con[parent], _con[child]);</span><br><span class="line">                parent = child;</span><br><span class="line">                child = parent * 2 + 1;    </span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">            &#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    //向上调整</span><br><span class="line">    void AdjustUp(size_t child)</span><br><span class="line">    &#123;</span><br><span class="line">        size_t parent = (child - 1) / 2;</span><br><span class="line">        Compare com;</span><br><span class="line">        while(child &gt; 0)</span><br><span class="line">        &#123;</span><br><span class="line">            if(com(_con[parent], _con[child]))</span><br><span class="line">            &#123;</span><br><span class="line">                std::swap(_con[parent], _con[child]);</span><br><span class="line">                child = parent;</span><br><span class="line">                parent = (child - 1) / 2;</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">            &#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    void Push(const T&amp; data)</span><br><span class="line">    &#123;</span><br><span class="line">        _con.push_back(data);</span><br><span class="line">        //模拟push_heap()的功能</span><br><span class="line">        AdjustUp(_con.size() - 1);</span><br><span class="line">    &#125;</span><br><span class="line">    void Pop()</span><br><span class="line">    &#123;</span><br><span class="line">        //模拟pop_heap()的功能</span><br><span class="line">        std::swap(_con[0], _con[_con.size() - 1]);</span><br><span class="line">        _con.pop_back();</span><br><span class="line">        AdjustDown(0);</span><br><span class="line">    &#125;</span><br><span class="line">    size_t Size()</span><br><span class="line">    &#123;</span><br><span class="line">        return _con.size();</span><br><span class="line">    &#125;</span><br><span class="line">    bool Empty()</span><br><span class="line">    &#123;</span><br><span class="line">        return _con.empty();</span><br><span class="line">    &#125;</span><br><span class="line">    T&amp; Top()</span><br><span class="line">    &#123;</span><br><span class="line">        return _con.front();</span><br><span class="line">    &#125;</span><br><span class="line">    const T&amp; Top() const</span><br><span class="line">    &#123;</span><br><span class="line">        return _con.front();</span><br><span class="line">    &#125;</span><br><span class="line">//private:</span><br><span class="line">    Container _con;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>

          
        
      
    </div>
    
    
    

    

    <div>
    
    </div>

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/07/30/【Cpp】第八章-STL-deque类/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="MisakiFx">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/blog-logo.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Misaki`s blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/07/30/【Cpp】第八章-STL-deque类/" itemprop="url">【Cpp】第八章-STL_deque类</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-07-30T16:39:49+08:00">
                2019-07-30
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Cpp/" itemprop="url" rel="index">
                    <span itemprop="name">Cpp</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  1.4k
                </span>
              

              

              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="deque类"><a href="#deque类" class="headerlink" title="deque类"></a>deque类</h1><h2 id="基础介绍"><a href="#基础介绍" class="headerlink" title="基础介绍"></a>基础介绍</h2><p>&emsp;&emsp;<code>deque</code>是双端队列，它提供了和<code>vector</code>类似的接口但是底层的实现与<code>vector</code>完全不同，<code>vector</code>底层用三个指针指向数组的起点，尾部和总容量的尾部，并且所有元素都是连续的，但是在<code>deque</code>中所有元素并不一定都是在连续的内存空间上的。<code>deque</code>在底层实现上是将一个连续的空间分段进行管理，并将它们的首地址用一个指针数组进行管理，这样特殊的存储结构使得它在头部和尾部增加元素比<code>vector</code>更加高效，但是底层实现更为复杂，存储了很多额外信息。如果抛去在头部和尾部增加元素，在中间任意位置添加元素，它的效率比vector更高，但是比list要低。</p>
<h2 id="常用接口"><a href="#常用接口" class="headerlink" title="常用接口"></a>常用接口</h2><h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">deque();                                                  //构造空的双端队列</span><br><span class="line">deque(size_type n, const value_type &amp;val = value_type()); //用n个值为val的元素构造双端队列</span><br><span class="line">deque(InputIterator first, InputIterator last);           //用[first, last)的区间构造双端队列</span><br><span class="line">deque(const deque &amp;x);                                    //双端队列的拷贝构造函数</span><br></pre></td></tr></table></figure>
<h3 id="迭代器相关"><a href="#迭代器相关" class="headerlink" title="迭代器相关"></a>迭代器相关</h3><p>&emsp;&emsp;由于<code>deque</code>在内存上并不完全是连续的因此想要保持deque的连续性，这个任务就落到了迭代器身上。在底层实现上，<code>deque</code>将一段一段连续的内存称为一个缓冲区(buffer)，并将这些缓冲区的首尾地址存储在一个map中用以映射，map中一个存储缓冲区的地址对应一个结点(node)信息用于标记这个键值对，这样就构建好了基础架构。在迭代器中存储了4个信息，分别是当前结点(cur)，当前缓冲区的头(first)，当前缓冲区的尾(last)以及在map中用以标记当前缓冲区的地址的结点(node)信息。并且在<code>deque</code>内部已经存储好了两个迭代器<code>start</code>和<code>finish</code>用于标记<code>deque</code>的头和尾元素。这样即可完成将一段一段连续的空间在逻辑结构上构成一段连续空间的目的。<br>&emsp;&emsp;当从头遍历<code>deque</code>时，<code>start</code>迭代器中<code>first</code>和<code>last</code>已经从map中找到了第一个结点的缓冲区首尾信息并进行了保存，于是<code>cur</code>就从<code>first</code>开始遍历这个缓冲区，当遍历到<code>last</code>时就重新到map中寻找写一个结点的缓冲区收尾地址并且替换掉原来<code>first</code>和<code>last</code>值，继续遍历，这样即可完成遍历直到最后一个结点也遍历完。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">iterator begin();                       //返回deque起始位置迭代器</span><br><span class="line">iterator end();                         //返回deque最后一个元素下一个位置的迭代器</span><br><span class="line">reverse_iterator rbegin();              //返回deque起始位置的反向迭代器(即end())</span><br><span class="line">reverse_iterator rend();                //返回deque最后一个元素下一个位置的反向迭代器(begin())</span><br><span class="line">const_iterator cbegin() const;          //返回deque起始位置的const迭代器</span><br><span class="line">const_iterator cend() const;            //返回deque最后一个元素下一个位置的const迭代器</span><br><span class="line">const_reverse_iterator crbegin() const; //返回deque起始位置的const反向迭代器(即crend())</span><br><span class="line">const_reverse_iterator crend() const;   //返回deque最后一个元素下一个位置的const反向迭代器(crbegin())</span><br></pre></td></tr></table></figure></p>
<h3 id="容量相关"><a href="#容量相关" class="headerlink" title="容量相关"></a>容量相关</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">size_type size() const;               //返回deque中有效元素个数</span><br><span class="line">bool empty() const;                   //检测deque是否为空，是返回true，否则返回false</span><br><span class="line">void resize(size_type sz, T c = T()); //将deque中的元素改变到sz，多出的空间用c填充</span><br></pre></td></tr></table></figure>
<h3 id="增删改查"><a href="#增删改查" class="headerlink" title="增删改查"></a>增删改查</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">reference operator[](size_type n);                         //返回deque中n位置上元素的引用</span><br><span class="line">const_reference operator[](size_type n) const;             //返回deque中n位置上元素的const 引用</span><br><span class="line">reference front();                                         //返回deque中首元素的引用</span><br><span class="line">const_reference front() const;                             //返回deque中首元素的const引用</span><br><span class="line">reference back();                                          //返回deque中最后一个元素的引用</span><br><span class="line">const_reference back() const;                              //返回deque中最后一个元素的const引用</span><br><span class="line">void push_back(const value_type &amp;val);                     //deque尾部插入元素val</span><br><span class="line">void pop_back();                                           //删除deque尾部元素</span><br><span class="line">void push_front(const value_type &amp;val);                    //deque头部插入元素val</span><br><span class="line">void pop_front();                                          //删除deque头部元素</span><br><span class="line">iterator insert(iterator position, const value_type &amp;val); //在deque的position位置插入值为val的元素</span><br><span class="line">void insert(iterator position, size_type n,</span><br><span class="line">            const value_type &amp;val);                                      //在deque的position位置插入n个值为val的元素</span><br><span class="line">void insert(iterator position, InputIterator first, InputIterator last); //在deque的position位置插入[first, last)区间中的元素</span><br><span class="line">iterator erase(iterator position);                                       //删除deque中position位置的元素，并返回该位置的下一个位置</span><br><span class="line">iterator erase(iterator first, iterator last);                           //删除deque中[first, last)区间中的元素，并返回last位置</span><br><span class="line">void swap(deque &amp; x);                                                    //交换两个deque中的内容</span><br><span class="line">void clear();                                                            //将deque中的元素清空</span><br><span class="line">iterator emplace(const_iterator position, Args &amp;&amp; ... args);             //在deque的position位置构造元素，将元素所需内容通过参数类表传入</span><br><span class="line">void emplace_front(Args &amp;&amp; ... args);                                    //在deque的头部构造元素，元素的参数通过参数列表传入</span><br><span class="line">void emplace_back(Args &amp;&amp; ... args);                                     //在deque的尾部构造元素，元素的参数通过参数列表传入</span><br></pre></td></tr></table></figure>
<h3 id="综合运用"><a href="#综合运用" class="headerlink" title="综合运用"></a>综合运用</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;deque&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    deque&lt;int&gt; deq;</span><br><span class="line">    deq.push_front(1);</span><br><span class="line">    deq.push_back(2);</span><br><span class="line">    deque&lt;int&gt;::iterator it = deq.begin();</span><br><span class="line">    it = deq.insert(it, 0);</span><br><span class="line">    while(it != deq.end())</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; *it &lt;&lt; endl;</span><br><span class="line">        it++;</span><br><span class="line">    &#125;</span><br><span class="line">    it = deq.erase(--it);</span><br><span class="line">    it = deq.begin();</span><br><span class="line">    while(it != deq.end())</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; *it &lt;&lt; endl;</span><br><span class="line">        it++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>&emsp;&emsp;双端队列<code>deque</code>是一个设计并不算成功的容器，如果要随机访问单纯的查询多一点可以用<code>vector</code>而且更加方便，如果需要频繁插入那么<code>list</code>效率又会跟高，因此<code>deque</code>并不常用，其最常用的地方就是在作为适配器<code>stack</code>和<code>queue</code>的底层存储容器。</p>

          
        
      
    </div>
    
    
    

    

    <div>
    
    </div>

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/07/29/【Cpp】第七章-STL-list类/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="MisakiFx">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/blog-logo.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Misaki`s blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/07/29/【Cpp】第七章-STL-list类/" itemprop="url">【Cpp】第七章-STL_list类</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-07-29T23:12:49+08:00">
                2019-07-29
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Cpp/" itemprop="url" rel="index">
                    <span itemprop="name">Cpp</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  2.2k
                </span>
              

              

              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="list类"><a href="#list类" class="headerlink" title="list类"></a>list类</h1><h2 id="基础介绍"><a href="#基础介绍" class="headerlink" title="基础介绍"></a>基础介绍</h2><p>&emsp;&emsp;<code>list类</code>是STL中封装的链表模板类，并且底层实现是以双向链表作为基础进行封装的。在数据结构中，线性存储结构中主要分为顺序表和链表，前者在物理结构上拥有连续的内存空间和地址，在STL中<code>vector</code>和<code>string</code>都是使用了这种结构，其最大的特点就是方便进行随机访问并且尾插和尾删都能达到O1的时间复杂度并且使用方便，而链表作为物理结构上内存空间不连续的数据结构，其最大的特点就是方便在任何位置就行插入删除，<code>list</code>就是建立在此数据结构上封装出的模板类。</p>
<h2 id="常用接口"><a href="#常用接口" class="headerlink" title="常用接口"></a>常用接口</h2><h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">list();                                                  //构造空的list</span><br><span class="line">list(size_type n, const value_type &amp;val = value_type()); //构造的list中包含n个值为val的元素</span><br><span class="line">list(const list &amp;x);                                     //拷贝构造函数</span><br><span class="line">list(InputIterator first, InputIterator last);           //用[first, last)区间中的元素构造list</span><br></pre></td></tr></table></figure>
<h3 id="迭代器相关"><a href="#迭代器相关" class="headerlink" title="迭代器相关"></a>迭代器相关</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">begin();   //返回第一个元素的迭代器</span><br><span class="line">end();     //返回最后一个元素下一个位置的迭代器</span><br><span class="line">rbegin();  //返回第一个元素的reverse_iterator,即end位置</span><br><span class="line">rend();    //返回最后一个元素下一个位置的reverse_iterator,即begin位置</span><br><span class="line">cbegin();  //(C++11) 返回第一个元素的cosnt_iterator</span><br><span class="line">cend();    //(C++11) 返回最后一个元素下一个位置的const_iterator</span><br><span class="line">crbegin(); //(C++11) 即crend()位置</span><br><span class="line">crend();   //(C++11) 即crbegin()位置</span><br></pre></td></tr></table></figure>
<h3 id="容量相关"><a href="#容量相关" class="headerlink" title="容量相关"></a>容量相关</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">bool empty() const;  //检测list是否为空，是返回true，否则返回false</span><br><span class="line">size_t size() const; //返回list中有效节点的个数</span><br></pre></td></tr></table></figure>
<h3 id="增删查改"><a href="#增删查改" class="headerlink" title="增删查改"></a>增删查改</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">reference front();                      //返回list的第一个节点中值的引用</span><br><span class="line">const_reference front() const;          //返回list的第一个节点中值的const引用</span><br><span class="line">reference back();                       //返回list的最后一个节点中值的引用</span><br><span class="line">const_reference back() const;           //返回list的最后一个节点中值的const引用</span><br><span class="line">void push_front(const value_type &amp;val); //在list首元素前插入值为val的元素</span><br><span class="line">void pop_front();                       //删除list中第一个元素</span><br><span class="line">void push_back;                         //(const value_type&amp; val)在list尾部插入值为val的元素</span><br><span class="line">void pop_back();                        //删除list中最后一个元素</span><br><span class="line">template &lt;class... Args&gt;</span><br><span class="line">void emplace_front(Args &amp;&amp; ... args); //（C++11）在list第一个元素前根据参数直接构造元素</span><br><span class="line">template &lt;class... Args&gt;</span><br><span class="line">void emplace_back(Args &amp;&amp; ... args); //（C++11）在list最后一个元素后根据参数直接构造元素</span><br><span class="line">template &lt;class... Args&gt;</span><br><span class="line">iterator emplace(const_iterator position, Args &amp;&amp; ... args);             //（C++11）在链表的任意位置根据参数直接构造元素</span><br><span class="line">iterator insert(iterator position, const value_type &amp;val);               //在list position 位置中插入值为val的元素</span><br><span class="line">void insert(iterator position, size_type n, const value_type &amp;val);      //在list position位置插入n个值为val的元素</span><br><span class="line">void insert(iterator position, InputIterator first, InputIterator last); //在list position位置插入[first, last)区间中元素</span><br><span class="line">iterator erase(iterator position);                                       //删除list position位置的元素</span><br><span class="line">iterator erase(iterator first, iterator last);                           //删除list中[first, last)区间中的元素</span><br><span class="line">void swap(list &amp; x);                                                     //交换两个list中的元素</span><br><span class="line">void resize(size_type n, value_type val = value_type());                 //将list中有效元素个数改变到n个，多出的元素用val填充</span><br><span class="line">void clear();                                                            //清空list中的有效元素</span><br></pre></td></tr></table></figure>
<h2 id="emplace与insert"><a href="#emplace与insert" class="headerlink" title="emplace与insert"></a>emplace与insert</h2><p>&emsp;&emsp;在STL很多接口中我们都发现有一个<code>emplace()</code>的接口也是用来进行插入的，那么它与<code>insert()</code>和<code>push_back()</code>有什么区别呢？以下用<code>vector</code>举个例子，从接口调用上就能看出区别。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    struct Foo </span><br><span class="line">    &#123;</span><br><span class="line">        Foo(int n, double x)</span><br><span class="line">            :_n(n)</span><br><span class="line">            ,_x(x)</span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        int _n;</span><br><span class="line">        double _x;</span><br><span class="line">    &#125;;</span><br><span class="line">    vector&lt;Foo&gt; v;</span><br><span class="line">    v.emplace(v.begin(), 42, 3.1416);     // 没有临时变量产生</span><br><span class="line">    v.insert(v.begin(), Foo(42, 3.1416)); // 需要产生一个临时变量</span><br><span class="line">    v.insert(v.begin(), &#123;42, 3.1416&#125;);    // 需要产生一个临时变量</span><br><span class="line">    for(int i = 0; i &lt; v.size(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; v[i]._n &lt;&lt; &quot; &quot; &lt;&lt; v[i]._x &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">42 3.1416</span><br><span class="line">42 3.1416</span><br><span class="line">42 3.1416</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;在进行内置类型和拥有单参构造函数的类型的插入时我们只传入一个参数往往很难发现区别，但在我们必须传入多个参数才能进行插入时我们就会发现在使用<code>insert()</code>这些接口时我们必须插入与容器中元素类型相同的<strong>元素</strong>才能完成接口调用，这让我们不得不构造一个临时匿名对象，而<code>emplace</code>则不需要，我们只要按照构造一个对象那样给构造元素的参数即可省去了构造匿名对象的过程。而这其中需要用到<code>C++11</code>中的新标准<strong>变参模板</strong>和<strong>完美转发</strong>，因此<code>emplace</code>使用的时候要求编译器支持<code>C++11</code>标准。<br>&emsp;&emsp;<code>emplace</code>不光是调用接口上有所不同，在有的时候也可以提高我们的效率。例如在<code>list</code>中如果利用<code>insert</code>传入一个元素的时候我们就需要先调用元素的构造函数构造元素，然后再调用<code>Node</code>的构造函数以及该元素的拷贝构造函数构造一个拥有该元素值的结点，才能进行插入，而<code>emplace</code>则可以在创建结点时直接利用原本要构造临时元素对象的参数来直接构造结点，并且直接构造结点中的元素对象，<strong>相当于少了一次元素的拷贝构造，并且省去了构造临时对象，效率更高</strong>。</p>
<h2 id="list迭代器失效"><a href="#list迭代器失效" class="headerlink" title="list迭代器失效"></a>list迭代器失效</h2><p>&emsp;&emsp;对于<code>list</code>这种链式结构，在插入后是不会迭代器失效的，因为原先位置的迭代器依旧指向原来的结点，不会因为添加结点导致指向位置的变动。而在删除后迭代器原本指向的结点内存被释放，因此删除后删除结点的迭代器失效，但是其他结点迭代器指向不变因此不会发生迭代器失效。<br>&emsp;&emsp;总结：<strong>list只有在删除节点后才会发生迭代器失效，并且之后删除结点的迭代器失效</strong>。</p>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>&emsp;&emsp;<code>list</code>采用链式结构存储，因此实现起来要稍微麻烦一些，迭代器也需要额外进行封装。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;assert.h&gt;</span><br><span class="line">//定义结点类</span><br><span class="line">template&lt;class T&gt;</span><br><span class="line">struct ListNode</span><br><span class="line">&#123;</span><br><span class="line">    ListNode&lt;T&gt;* _prev;</span><br><span class="line">    ListNode&lt;T&gt;* _next;</span><br><span class="line">    T _data;</span><br><span class="line">    ListNode(const T&amp; data = T())</span><br><span class="line">        :_prev(nullptr)</span><br><span class="line">        ,_next(nullptr)</span><br><span class="line">        ,_data(data)</span><br><span class="line">    &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line">//由于const_iterator与iterator除了在迭代器返回值上不一样外其他要求完全一样</span><br><span class="line">//因此这里要进行实现时可以考虑定义两个类</span><br><span class="line">//但是这里使用一种取巧的方法我们将返回值类型当作模板参数传入模板中</span><br><span class="line">template&lt;class T, class Ref, class Ptr&gt;</span><br><span class="line">struct ListIterator</span><br><span class="line">&#123;</span><br><span class="line">    typedef ListNode&lt;T&gt; Node;</span><br><span class="line">    typedef ListIterator&lt;T, Ref, Ptr&gt; Self;</span><br><span class="line">    //构造函数</span><br><span class="line">    ListIterator(Node* node)</span><br><span class="line">        :_node(node)</span><br><span class="line">    &#123;&#125;</span><br><span class="line">    //operator* 为了让其可以和指针一样使用，返回引用</span><br><span class="line">    Ref operator*()</span><br><span class="line">    &#123;</span><br><span class="line">        return _node-&gt;_data;</span><br><span class="line">    &#125;</span><br><span class="line">    //operator-&gt; 为了让其可以和指针一样使用，返回指针</span><br><span class="line">    //这里实际调用it-&gt;只能取到数据的指针，所以正常来说得写成it-&gt;-&gt;</span><br><span class="line">    //但是经过编译器优化，只用写it-&gt;就可以取到值了</span><br><span class="line">    Ptr operator-&gt;()</span><br><span class="line">    &#123;</span><br><span class="line">        return &amp;(_node-&gt;_data);</span><br><span class="line">    &#125;</span><br><span class="line">    Self operator++()</span><br><span class="line">    &#123;</span><br><span class="line">        _node = _node-&gt;_next;</span><br><span class="line">        return _node;    </span><br><span class="line">    &#125;</span><br><span class="line">    Self operator++(int)</span><br><span class="line">    &#123;</span><br><span class="line">        Self temp(_node);</span><br><span class="line">        _node = _node-&gt;_next;</span><br><span class="line">        return temp;</span><br><span class="line">    &#125; </span><br><span class="line">    Self operator--()</span><br><span class="line">    &#123;</span><br><span class="line">        _node = _node-&gt;_prev;</span><br><span class="line">        return _node;    </span><br><span class="line">    &#125;</span><br><span class="line">    Self operator--(int)</span><br><span class="line">    &#123;</span><br><span class="line">        Self temp(_node);</span><br><span class="line">        _node = _node-&gt;_prev;</span><br><span class="line">        return temp;</span><br><span class="line">    &#125; </span><br><span class="line">    bool operator!=(Self it)</span><br><span class="line">    &#123;</span><br><span class="line">        return _node != it._node;</span><br><span class="line">    &#125;</span><br><span class="line">    Node* _node;</span><br><span class="line">&#125;;</span><br><span class="line">//构建一个带头结点双向循环链表来模拟实现list</span><br><span class="line">template&lt;class T&gt;</span><br><span class="line">class List</span><br><span class="line">&#123;</span><br><span class="line">    typedef ListNode&lt;T&gt; Node;</span><br><span class="line">public:</span><br><span class="line">    typedef ListIterator&lt;T, T&amp;, T*&gt; iterator;</span><br><span class="line">    typedef ListIterator&lt;T, const T&amp;, const T*&gt; const_iterator;</span><br><span class="line">    //构造函数j</span><br><span class="line">    List()</span><br><span class="line">    &#123;</span><br><span class="line">        _head = new Node;</span><br><span class="line">        _head-&gt;_next = _head;</span><br><span class="line">        _head-&gt;_prev = _head;</span><br><span class="line">    &#125;</span><br><span class="line">    //拷贝构造</span><br><span class="line">    List(const List&amp; list)</span><br><span class="line">        :_head(new Node)</span><br><span class="line">    &#123;</span><br><span class="line">        _head-&gt;_next = _head;</span><br><span class="line">        _head-&gt;_prev = _head;</span><br><span class="line">        const_iterator it = list.begin();</span><br><span class="line">        while(it != list.end())</span><br><span class="line">        &#123;</span><br><span class="line">            Push_back(*it);</span><br><span class="line">            it++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    //operator=重载</span><br><span class="line">    List&amp; operator=(const List&amp; list)</span><br><span class="line">    &#123;</span><br><span class="line">        List listTemp = list;</span><br><span class="line">        Swap(listTemp);</span><br><span class="line">    &#125;</span><br><span class="line">    //交换</span><br><span class="line">    void Swap(List&amp; list)</span><br><span class="line">    &#123;</span><br><span class="line">        std::swap(_head, list._head);</span><br><span class="line">    &#125;</span><br><span class="line">    //析构函数</span><br><span class="line">    ~List()</span><br><span class="line">    &#123;</span><br><span class="line">        </span><br><span class="line">        while(_head-&gt;_next != _head)</span><br><span class="line">        &#123;</span><br><span class="line">            Pop_back();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    iterator begin()</span><br><span class="line">    &#123;</span><br><span class="line">        return _head-&gt;_next;</span><br><span class="line">    &#125;</span><br><span class="line">    const_iterator begin() const</span><br><span class="line">    &#123;</span><br><span class="line">        return _head-&gt;_next;</span><br><span class="line">    &#125;</span><br><span class="line">    iterator end()</span><br><span class="line">    &#123;</span><br><span class="line">        return _head;</span><br><span class="line">    &#125;</span><br><span class="line">    const_iterator end() const</span><br><span class="line">    &#123;</span><br><span class="line">        return _head;</span><br><span class="line">    &#125;</span><br><span class="line">    iterator Erase(iterator&amp; it)</span><br><span class="line">    &#123;</span><br><span class="line">        assert(it._node != nullptr);</span><br><span class="line">        Node* pTemp = it._node;</span><br><span class="line">        Node* pNew = pTemp-&gt;_next;</span><br><span class="line">        //it-&gt;_node = pTemp-&gt;_next;</span><br><span class="line">        pTemp-&gt;_prev-&gt;_next = pTemp-&gt;_next;</span><br><span class="line">        pTemp-&gt;_next-&gt;_prev = pTemp-&gt;_prev;</span><br><span class="line">        delete pTemp;</span><br><span class="line">        return pNew;</span><br><span class="line">    &#125;</span><br><span class="line">    //插入</span><br><span class="line">    iterator Insert(iterator&amp; it, const T&amp; data = T())</span><br><span class="line">    &#123;</span><br><span class="line">        assert(it._node != nullptr);</span><br><span class="line">        Node* newNode = new Node(data);</span><br><span class="line">        newNode-&gt;_next = it._node;</span><br><span class="line">        newNode-&gt;_prev = it._node-&gt;_prev;</span><br><span class="line">        it._node-&gt;_prev-&gt;_next = newNode;</span><br><span class="line">        it._node-&gt;_prev  = newNode;</span><br><span class="line">        return newNode;</span><br><span class="line">    &#125;</span><br><span class="line">    //尾插</span><br><span class="line">    void Push_back(const T&amp; data)</span><br><span class="line">    &#123;</span><br><span class="line">        assert(_head != nullptr);</span><br><span class="line">        Node* tail = _head-&gt;_prev;</span><br><span class="line">        Node* newNode = new Node(data);</span><br><span class="line">        newNode-&gt;_next = _head;</span><br><span class="line">        newNode-&gt;_prev = tail;</span><br><span class="line">        tail-&gt;_next = newNode;</span><br><span class="line">        _head-&gt;_prev = newNode;</span><br><span class="line">    &#125;</span><br><span class="line">    //尾删</span><br><span class="line">    void Pop_back()</span><br><span class="line">    &#123;</span><br><span class="line">        assert(_head != nullptr);</span><br><span class="line">        if(_head-&gt;_next == _head)</span><br><span class="line">        &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        Node* tail = _head-&gt;_prev;</span><br><span class="line">        tail-&gt;_prev-&gt;_next = _head;</span><br><span class="line">        _head-&gt;_prev = tail-&gt;_prev;</span><br><span class="line">        delete tail;</span><br><span class="line">    &#125;</span><br><span class="line">private:</span><br><span class="line">    Node* _head;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>

          
        
      
    </div>
    
    
    

    

    <div>
    
    </div>

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/07/27/【算法】第二章-搜索/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="MisakiFx">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/blog-logo.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Misaki`s blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/07/27/【算法】第二章-搜索/" itemprop="url">【算法】第二章-搜索</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-07-27T17:46:48+08:00">
                2019-07-27
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/算法/" itemprop="url" rel="index">
                    <span itemprop="name">算法</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  2.2k
                </span>
              

              

              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="搜索"><a href="#搜索" class="headerlink" title="搜索"></a>搜索</h1><h2 id="深度优先搜索-DFS"><a href="#深度优先搜索-DFS" class="headerlink" title="深度优先搜索(DFS)"></a>深度优先搜索(DFS)</h2><p>&emsp;&emsp;深度优先搜索是使用递归的方式以深度为主逐个探索遍历每种情况，在排列组合，迷宫问题中十分常用。深度优先搜索思想简单，但是由于使用递归，要求我们遍历时探索的必须深度有限。不然有可能会使栈溢出。还要注意有时我们在使用深度优先搜索时情况过多，而大部分是无用解时就需要套入<strong>剪枝</strong>。<br>&emsp;&emsp;模型：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">DFS()</span><br><span class="line">&#123;</span><br><span class="line">    //1.判断边界，如果已经到达搜索的最深，则回退尝试其他可能</span><br><span class="line">    //2.尝试当下的每一种可能</span><br><span class="line">    //3.确定一种可能后，继续下一步</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="例1-员工的重要度"><a href="#例1-员工的重要度" class="headerlink" title="例1 员工的重要度"></a>例1 员工的重要度</h3><p>&emsp;&emsp;力扣：<br><a href="https://leetcode-cn.com/problems/employee-importance/submissions/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/employee-importance/submissions/</a></p>
<h4 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h4><p>&emsp;&emsp;抽象模型。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">DFS(id)</span><br><span class="line">&#123;</span><br><span class="line">    //1.获取当前员工的重要度</span><br><span class="line">    //2.累加每一个下属(for)的重要度,DFS(下属id)</span><br><span class="line">    //3.return累加的重要度</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int DFS(unordered_map&lt;int, Employee*&gt; em, int id)</span><br><span class="line">    &#123;</span><br><span class="line">        int curRet = em[id]-&gt;importance;</span><br><span class="line">        for(auto&amp; e : em[id]-&gt;subordinates)</span><br><span class="line">        &#123;</span><br><span class="line">            curRet += DFS(em, e);</span><br><span class="line">        &#125;</span><br><span class="line">        return curRet;</span><br><span class="line">    &#125;</span><br><span class="line">    int getImportance(vector&lt;Employee*&gt; employees, int id) &#123;</span><br><span class="line">        if(employees.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        unordered_map&lt;int, Employee*&gt; em;</span><br><span class="line">        for(auto&amp; e: employees)</span><br><span class="line">        &#123;</span><br><span class="line">            em[e-&gt;id] = e;</span><br><span class="line">        &#125;</span><br><span class="line">        return DFS(em, id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="例2-图像渲染"><a href="#例2-图像渲染" class="headerlink" title="例2 图像渲染"></a>例2 图像渲染</h3><p>&emsp;&emsp;力扣：<br><a href="https://leetcode-cn.com/problems/flood-fill/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/flood-fill/</a></p>
<h4 id="解析-1"><a href="#解析-1" class="headerlink" title="解析"></a>解析</h4><p>&emsp;&emsp;抽象模型。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">DFS()</span><br><span class="line">&#123;</span><br><span class="line">    //1.nx,ny染色</span><br><span class="line">    //2.处理上，下，左，右4个点</span><br><span class="line">    &#123;</span><br><span class="line">        //以深度优先逐个方向遍历周边4个点</span><br><span class="line">        //新位置颜色符合，且没有越界，且没有染过色</span><br><span class="line">        //符合条件处理新位置</span><br><span class="line">        DFS(新的位置)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">static int nextP[4][2] = &#123;&#123;0, 1&#125;, &#123;1, 0&#125;, &#123;0, -1&#125;, &#123;-1, 0&#125;&#125;;</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    void DFS(vector&lt;vector&lt;int&gt;&gt;&amp; image, int row, int col, int nx, int ny, vector&lt;vector&lt;int&gt;&gt; book, int newColor, int oldColor)</span><br><span class="line">    &#123;</span><br><span class="line">        image[nx][ny] = newColor;</span><br><span class="line">        book[nx][ny] = 1;</span><br><span class="line">        //上下左右遍历</span><br><span class="line">        for(int i = 0; i &lt; 4; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            int newx = nx + nextP[i][0];</span><br><span class="line">            int newy = ny + nextP[i][1];</span><br><span class="line">            if(newx &gt;= row || newx &lt; 0 || newy &gt;= col || newy &lt; 0)</span><br><span class="line">            &#123;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">            if(image[newx][newy] == oldColor &amp;&amp; book[newx][newy] == 0)</span><br><span class="line">            &#123;</span><br><span class="line">                DFS(image, row, col, newx, newy, book, newColor, oldColor);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; floodFill(vector&lt;vector&lt;int&gt;&gt;&amp; image, int sr, int sc, int newColor) &#123;</span><br><span class="line">        if(image.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            return image;</span><br><span class="line">        &#125;</span><br><span class="line">        int row = image.size();</span><br><span class="line">        int col = image[0].size();</span><br><span class="line">        int oldColor = image[sr][sc];</span><br><span class="line">        vector&lt;vector&lt;int&gt;&gt; book(row, vector&lt;int&gt;(col, 0));</span><br><span class="line">        DFS(image, row, col, sr, sc, book, newColor, oldColor);</span><br><span class="line">        return image;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="例3-走迷宫"><a href="#例3-走迷宫" class="headerlink" title="例3 走迷宫"></a>例3 走迷宫</h3><p>&emsp;&emsp;牛客：<br><a href="https://www.nowcoder.com/questionTerminal/6276dbbda7094978b0e9ebb183ba37b9" target="_blank" rel="noopener">https://www.nowcoder.com/questionTerminal/6276dbbda7094978b0e9ebb183ba37b9</a></p>
<h4 id="解析-2"><a href="#解析-2" class="headerlink" title="解析"></a>解析</h4><p>&emsp;&emsp;模型：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">DFS()</span><br><span class="line">&#123;</span><br><span class="line">    //1.当前位置已走，路径长度+1，并且置为墙表示走过了</span><br><span class="line">    //2.走到终点，和最短路径长度比较取最优</span><br><span class="line">    //3.遍历四周，如果不是墙且不越界则遍历</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;但是，这种模型在一张只有极少障碍物的迷宫中要消耗很多的时间，因为我们要让每一个结点都被遍历近10次，这其中会消耗大量时间，并且很多是无用的解。因此我们在其中可以加入动态规划的思想。<br>&emsp;&emsp;模型：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">DFS()</span><br><span class="line">&#123;</span><br><span class="line">    //1.遍历四周，如果不是墙且不越界则进行二次判断</span><br><span class="line">    //2.如果本次路径到达这个位置的路径数要小于以往在表中记录的路径数，则将表中最优解进行修改，否则不再遍历此位置。</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="实现-2"><a href="#实现-2" class="headerlink" title="实现"></a>实现</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">//这类迷宫问题不能纯粹使用深度优先搜索，因为要完全遍历一遍很慢，还要加上动态规划算法（剪枝）</span><br><span class="line">//记录到达每个点上的最少步数，如果大于这个步数则不再走这个点，可以剪掉大量冗余无效的走法</span><br><span class="line">using namespace std;</span><br><span class="line">int res[10][10] = &#123; 0 &#125;;</span><br><span class="line">vector&lt;string&gt; mess(10, string(10, 0));</span><br><span class="line">int nextP[4][2] = &#123;&#123;0, 1&#125;, &#123;1, 0&#125;, &#123;0, -1&#125;, &#123;-1, 0&#125;&#125;;</span><br><span class="line">void dfs(int i, int j)</span><br><span class="line">&#123;</span><br><span class="line">    //继续向四周遍历</span><br><span class="line">    for(int m = 0; m &lt; 4; m++)</span><br><span class="line">    &#123;</span><br><span class="line">        int newi = i + nextP[m][0];</span><br><span class="line">        int newj = j + nextP[m][1];</span><br><span class="line">        if(newi &lt; 10 &amp;&amp; newi &gt;= 0 &amp;&amp; newj &lt; 10 &amp;&amp; newj &gt;= 0 &amp;&amp; mess[newi][newj] != &apos;#&apos;)</span><br><span class="line">        &#123;</span><br><span class="line">            if(res[newi][newj] == 0 || res[newi][newj] &gt; res[i][j] + 1)</span><br><span class="line">            &#123;</span><br><span class="line">                res[newi][newj] = res[i][j] + 1;</span><br><span class="line">                dfs(newi, newj);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    while(cin &gt;&gt; mess[0])</span><br><span class="line">    &#123;</span><br><span class="line">        for(int i = 1; i &lt; 10; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            cin &gt;&gt; mess[i];</span><br><span class="line">        &#125;</span><br><span class="line">        dfs(0, 1);</span><br><span class="line">        cout &lt;&lt; res[9][8] &lt;&lt; endl;</span><br><span class="line">        memset(res, 0, sizeof(res));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="广度优先搜索-BFS"><a href="#广度优先搜索-BFS" class="headerlink" title="广度优先搜索(BFS)"></a>广度优先搜索(BFS)</h2><p>&emsp;&emsp;广度优先搜索是以广度为主逐层往外一次遍历，不同于深度优先逐条解进行排列组合，广度优先搜索只会遍历一次所有结点，并且会最先拿到最优解，因此某些情况下广度优先搜索效率优于深度优先搜索。广度优先搜索在迷宫问题的解上效率会更高，在寻找最优解时会更快，因为其不需要列出所有组合的情况。<br>&emsp;&emsp;广度优先搜索在实现时需要借助队列，每一次将下一层要遍历的结点入队，上一层出队。</p>
<h3 id="例1-员工的重要性"><a href="#例1-员工的重要性" class="headerlink" title="例1 员工的重要性"></a>例1 员工的重要性</h3><p>&emsp;&emsp;力扣：<br><a href="https://leetcode-cn.com/problems/employee-importance/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/employee-importance/</a></p>
<h4 id="解析-3"><a href="#解析-3" class="headerlink" title="解析"></a>解析</h4><p>&emsp;&emsp;将要查找的第一个员工入队，之后每次遍历队中元素将其重要度相加，并且将其下属入队。</p>
<h4 id="实现-3"><a href="#实现-3" class="headerlink" title="实现"></a>实现</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">// Employee info</span><br><span class="line">class Employee &#123;</span><br><span class="line">public:</span><br><span class="line">    // It&apos;s the unique ID of each node.</span><br><span class="line">    // unique id of this employee</span><br><span class="line">    int id;</span><br><span class="line">    // the importance value of this employee</span><br><span class="line">    int importance;</span><br><span class="line">    // the id of direct subordinates</span><br><span class="line">    vector&lt;int&gt; subordinates;</span><br><span class="line">&#125;;</span><br><span class="line">*/</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int getImportance(vector&lt;Employee*&gt; employees, int id) &#123;</span><br><span class="line">        unordered_map&lt;int, Employee*&gt; info;</span><br><span class="line">        for(auto&amp; e : employees)</span><br><span class="line">        &#123;</span><br><span class="line">            info[e-&gt;id] = e;</span><br><span class="line">        &#125;</span><br><span class="line">        queue&lt;int&gt; q;</span><br><span class="line">        //将这个员工入队</span><br><span class="line">        q.push(id);</span><br><span class="line">        int ret = 0;</span><br><span class="line">        //广度优先遍历</span><br><span class="line">        while(!q.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            //依次加上队中所有员工的重要度</span><br><span class="line">            int curId = q.front();</span><br><span class="line">            q.pop();</span><br><span class="line">            ret += info[curId]-&gt;importance;</span><br><span class="line">            //将其下属入队</span><br><span class="line">            for(auto&amp; e : info[curId]-&gt;subordinates)</span><br><span class="line">            &#123;</span><br><span class="line">                q.push(e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="例2-N叉树层序遍历"><a href="#例2-N叉树层序遍历" class="headerlink" title="例2 N叉树层序遍历"></a>例2 N叉树层序遍历</h3><p>&emsp;&emsp;力扣：<br><a href="https://leetcode-cn.com/problems/n-ary-tree-level-order-traversal/submissions/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/n-ary-tree-level-order-traversal/submissions/</a></p>
<h4 id="解析-4"><a href="#解析-4" class="headerlink" title="解析"></a>解析</h4><p>&emsp;&emsp;建立队列，将根节点入队，创造循环遍历队中每个结点将其孩子入队，但这题要注意要分树的每一行进行遍历，先遍历这一行的结点将其放到结果数组中，再以此遍历下一行的结点。</p>
<h4 id="实现-4"><a href="#实现-4" class="headerlink" title="实现"></a>实现</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">// Definition for a Node.</span><br><span class="line">class Node &#123;</span><br><span class="line">public:</span><br><span class="line">    int val;</span><br><span class="line">    vector&lt;Node*&gt; children;</span><br><span class="line"></span><br><span class="line">    Node() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    Node(int _val, vector&lt;Node*&gt; _children) &#123;</span><br><span class="line">        val = _val;</span><br><span class="line">        children = _children;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">*/</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; levelOrder(Node* root) &#123;</span><br><span class="line">        //创造队列</span><br><span class="line">        queue&lt;Node*&gt; q;</span><br><span class="line">        vector&lt;vector&lt;int&gt;&gt; treeVec;</span><br><span class="line">        if(root == nullptr)</span><br><span class="line">        &#123;</span><br><span class="line">            return treeVec;</span><br><span class="line">        &#125;</span><br><span class="line">        //放入根结点</span><br><span class="line">        q.push(root);</span><br><span class="line">        //遍历队中结点</span><br><span class="line">        while(!q.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            //得到这一行的长度</span><br><span class="line">            int sz = q.size();</span><br><span class="line">            vector&lt;int&gt; rowNode;</span><br><span class="line">            //遍历这一行</span><br><span class="line">            while(sz--)</span><br><span class="line">            &#123;</span><br><span class="line">                Node* curNode = q.front();</span><br><span class="line">                q.pop();</span><br><span class="line">                //将这一行结点的值放到rowNode中</span><br><span class="line">                rowNode.push_back(curNode-&gt;val);</span><br><span class="line">                //将这一行中每个结点的孩子入队</span><br><span class="line">                for(auto&amp; chd : curNode-&gt;children)</span><br><span class="line">                &#123;</span><br><span class="line">                    q.push(chd);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            treeVec.push_back(rowNode);</span><br><span class="line">        &#125;</span><br><span class="line">        return treeVec;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="例3-腐烂的橘子"><a href="#例3-腐烂的橘子" class="headerlink" title="例3 腐烂的橘子"></a>例3 腐烂的橘子</h3><p>&emsp;&emsp;力扣：<br><a href="https://leetcode-cn.com/problems/rotting-oranges/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/rotting-oranges/</a></p>
<h4 id="解析-5"><a href="#解析-5" class="headerlink" title="解析"></a>解析</h4><p>&emsp;&emsp;类似于N叉树的遍历。每一分钟腐烂一层，遍历每一层即可，最后搜索结束后判断是否还有新鲜橘子。</p>
<h4 id="实现-5"><a href="#实现-5" class="headerlink" title="实现"></a>实现</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">int nextP[4][2] = &#123;&#123;0, 1&#125;, &#123;1, 0&#125;, &#123;-1, 0&#125;, &#123;0, -1&#125;&#125;;</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int orangesRotting(vector&lt;vector&lt;int&gt;&gt;&amp; grid) &#123;</span><br><span class="line">        queue&lt;pair&lt;int, int&gt;&gt; q;</span><br><span class="line">        int row = grid.size();</span><br><span class="line">        int col = grid[0].size();</span><br><span class="line">        //找出第一批已经坏掉的橘子，入队</span><br><span class="line">        for(int i = 0; i &lt; row; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            for(int j = 0; j &lt; col; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                if(grid[i][j] == 2)</span><br><span class="line">                &#123;</span><br><span class="line">                    q.push(make_pair(i, j));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        //初始状态</span><br><span class="line">        int minRet = 0;</span><br><span class="line">        while(!q.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            //跟N叉树遍历一样，这里遍历一层代表要消耗一分钟</span><br><span class="line">            int flag = 0;</span><br><span class="line">            int sz = q.size();</span><br><span class="line">            //遍历这一层</span><br><span class="line">            while(sz--)</span><br><span class="line">            &#123;</span><br><span class="line">                pair&lt;int, int&gt; curPos = q.front();</span><br><span class="line">                q.pop();</span><br><span class="line">                for(int i = 0; i &lt; 4; i++)</span><br><span class="line">                &#123;</span><br><span class="line">                    int nx = curPos.first + nextP[i][0];</span><br><span class="line">                    int ny = curPos.second + nextP[i][1];</span><br><span class="line">                    if(nx &gt;= row || nx &lt; 0 || ny &gt;= col || ny &lt; 0)</span><br><span class="line">                    &#123;</span><br><span class="line">                        continue;</span><br><span class="line">                    &#125;</span><br><span class="line">                    if(grid[nx][ny] == 1)</span><br><span class="line">                    &#123;</span><br><span class="line">                        flag = 1;</span><br><span class="line">                        grid[nx][ny] = 2;</span><br><span class="line">                        q.push(make_pair(nx, ny));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            if(flag)</span><br><span class="line">            &#123;</span><br><span class="line">                ++minRet;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        for(int i = 0; i &lt; row; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            for(int j = 0; j &lt; col; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                if(grid[i][j] == 1)</span><br><span class="line">                &#123;</span><br><span class="line">                    return -1;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return minRet;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
          
        
      
    </div>
    
    
    

    

    <div>
    
    </div>

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/07/24/【Cpp】第六章-STL-vector类/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="MisakiFx">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/blog-logo.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Misaki`s blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/07/24/【Cpp】第六章-STL-vector类/" itemprop="url">【Cpp】第六章-STL_vector类</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-07-24T22:32:14+08:00">
                2019-07-24
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Cpp/" itemprop="url" rel="index">
                    <span itemprop="name">Cpp</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  1.7k
                </span>
              

              

              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="vector类"><a href="#vector类" class="headerlink" title="vector类"></a>vector类</h1><h2 id="基础介绍"><a href="#基础介绍" class="headerlink" title="基础介绍"></a>基础介绍</h2><p>&emsp;&emsp;vector类是STL中另一大容器，它十分类似于一个顺序表，不过经过封装它已经变成了一个可变长度并且拥有各种功能的顺序表，在其内部我们可以通过利用数组进行实现。vector是很常用的容器，因为它支持随机访问，并且尾插和尾删拥有O1的时间复杂度。但是在中间插入时要更高的时间复杂度，最差情况下需要遍历整个数组才能进行插入。它与string的物理与逻辑结构上十分相似，不过它是一个模板类，我们可以在其中存放任意类型的数据。</p>
<h2 id="常用接口"><a href="#常用接口" class="headerlink" title="常用接口"></a>常用接口</h2><h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">vector();                                                  //无参构造</span><br><span class="line">vector(size_type n, const value_type &amp;val = value_type()); //构造并初始化n个val</span><br><span class="line">vector(const vector &amp;x);                                   //拷贝构造</span><br><span class="line">vector(InputIterator first, InputIterator last);           //使用迭代器进行初始化构造</span><br></pre></td></tr></table></figure>
<h3 id="容量相关"><a href="#容量相关" class="headerlink" title="容量相关"></a>容量相关</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">size();     //获取数据个数</span><br><span class="line">capacity(); //获取容量大小</span><br><span class="line">empty();    //判断是否为空</span><br><span class="line">void resize(size_type n, value_type val = value_type());//改变空间大小，如果大于原有空间用val填充</span><br><span class="line">改变vector的size void reserve(size_type n); //改变vector放入capacity</span><br></pre></td></tr></table></figure>
<h3 id="增删查改"><a href="#增删查改" class="headerlink" title="增删查改"></a>增删查改</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">void push_back(const value_type &amp;val);                     //尾插</span><br><span class="line">void pop_back();                                           //尾删</span><br><span class="line">iterator insert(iterator position, constvalue_type &amp; val); //在position之前插入val</span><br><span class="line">iterator erase(iterator position);                         //删除position位置的数据</span><br><span class="line">void swap(vector &amp; x);                                     //交换两个vector的数据空间</span><br><span class="line">reference operator[](size_type n);                         //像数组一样访问</span><br></pre></td></tr></table></figure>
<h3 id="迭代器相关"><a href="#迭代器相关" class="headerlink" title="迭代器相关"></a>迭代器相关</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">begin();  //获取第一个数据位置的iterator</span><br><span class="line">end();    //获取最后一个数据的下一个位置的iterator</span><br><span class="line">rbegin(); //获取最后一个数据位置的reverse_iterator</span><br><span class="line">rend();   //获取第一个数据前一个位置的reverse_iterator</span><br><span class="line">cbegin(); //获取第一个数据位置的const_iterator</span><br><span class="line">cend();   //获取最后一个数据的下一个位置的const_iterator</span><br></pre></td></tr></table></figure>
<h2 id="迭代器失效问题"><a href="#迭代器失效问题" class="headerlink" title="迭代器失效问题"></a>迭代器失效问题</h2><p>&emsp;&emsp;在容器使用中我们经常会要操作迭代器，很多容器接口中也有提供使用迭代器进行增加删除修改的操作。但是迭代器本身是一个指针，在我们使用接口进行增加或是删除的时候这个迭代器的指向的内容会发生改变甚至是指向非法内存，原因是原来的内存已经被释放，称之为<strong>迭代器失效</strong>，迭代器失效会导致指向内容改变，从而引起bug甚至是内存越界访问导致程序崩溃。</p>
<h3 id="常见场景"><a href="#常见场景" class="headerlink" title="常见场景"></a>常见场景</h3><p>&emsp;&emsp;最为常见的是<code>erase</code>和<code>insert</code>导致的迭代器失效。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int a[] = &#123;1, 2, 3, 4&#125;;</span><br><span class="line">    vector&lt;int&gt; v(a, a + sizeof(a) / sizeof(int));</span><br><span class="line">    vector&lt;int&gt;::iterator it = v.begin();</span><br><span class="line">    while (it != v.end())</span><br><span class="line">    &#123;</span><br><span class="line">        if (*it % 2 == 0)</span><br><span class="line">            v.erase(it);</span><br><span class="line">        ++it;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;以上这段程序就会引起迭代器失效，在删除最后一个元素是甚至导致内存越界访问，程序崩溃。因此可以总结在<strong>利用迭代器删除元素后，删除位置及其之后的所有迭代器都会失效</strong>，原因是，之后的所有元素都会前移，之前的迭代器所指向的内容都会发生改变，甚至是指向非法内存。<br>&emsp;&emsp;同理我们在<code>insert</code>之后由于删除位置及其以后的元素会后移进行变动，因此<strong>插入位置及其之后所有的迭代器也都会失效</strong>，并且如果有扩容发生还可能发生内存越界访问。<br>&emsp;&emsp;对于迭代器失效我们要如何避免呢？我们注意看<code>erase</code>的接口可以发现<code>erase</code>返回的是一个迭代器。说明：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">An iterator pointing to the new location of the element that followed the last element erased by the function call. </span><br><span class="line">This is the container end if the operation erased the last element in the sequence.</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;它的返回值是返回在删除位置之后紧接着它的元素的迭代器，这个迭代器保证是有效的，<code>insert</code>的返回值也是一个迭代器，并且是插入位置插入后的元素的迭代器，因此它们的返回值都是保证有效的，所以我们的代码可以改成以下这样就可以避免迭代器失效。</p>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>&emsp;&emsp;我们模拟实现一个Vector类，并且实现常用接口，让其达到和vector相同的功能。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br></pre></td><td class="code"><pre><span class="line">#pragma once</span><br><span class="line">#include &lt;assert.h&gt;</span><br><span class="line">#include &lt;memory.h&gt;</span><br><span class="line">template &lt;class T&gt;</span><br><span class="line">class Vector</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    typedef T* iterator;</span><br><span class="line">    typedef const T* const_iterator;</span><br><span class="line">    //构造函数</span><br><span class="line">    Vector()</span><br><span class="line">        :_start(nullptr)</span><br><span class="line">        ,_finish(nullptr)</span><br><span class="line">        ,_endOfStorge(nullptr)</span><br><span class="line">    &#123;&#125;        </span><br><span class="line">    Vector(size_t n, T val)</span><br><span class="line">        :_start(nullptr)</span><br><span class="line">        ,_finish(nullptr)</span><br><span class="line">        ,_endOfStorge(nullptr)</span><br><span class="line">    &#123;</span><br><span class="line">        Reserve(n);</span><br><span class="line">        for(int i = 0; i &lt; n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            *_finish = val;</span><br><span class="line">            _finish++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    //拷贝构造</span><br><span class="line">    Vector(const Vector&lt;T&gt;&amp; vec)</span><br><span class="line">        :_start(nullptr)</span><br><span class="line">        ,_finish(nullptr)</span><br><span class="line">        ,_endOfStorge(nullptr)</span><br><span class="line">    &#123;</span><br><span class="line">        Resize(vec.Size());</span><br><span class="line">        memcpy(_start, vec._start, vec.Size() * sizeof(T));</span><br><span class="line">        _finish = _start + vec.Size();</span><br><span class="line">    &#125;</span><br><span class="line">    //operator=重载</span><br><span class="line">    Vector&amp; operator=(Vector&lt;T&gt; vec)</span><br><span class="line">    &#123;</span><br><span class="line">        Swap(vec);</span><br><span class="line">        return *this;</span><br><span class="line">    &#125;</span><br><span class="line">    //交换</span><br><span class="line">    void Swap(Vector&lt;T&gt;&amp; vec)</span><br><span class="line">    &#123;</span><br><span class="line">        std::swap(_start, vec._start);</span><br><span class="line">        std::swap(_finish, vec._finish);</span><br><span class="line">        std::swap(_endOfStorge, vec._endOfStorge);</span><br><span class="line">    &#125;</span><br><span class="line">    //析构函数</span><br><span class="line">    ~Vector()</span><br><span class="line">    &#123;</span><br><span class="line">        delete[] _start;</span><br><span class="line">        _start = nullptr;</span><br><span class="line">        _finish = nullptr;</span><br><span class="line">        _endOfStorge = nullptr;</span><br><span class="line">    &#125;</span><br><span class="line">    //迭代器相关</span><br><span class="line">    iterator begin()</span><br><span class="line">    &#123;</span><br><span class="line">        return _start;</span><br><span class="line">    &#125;</span><br><span class="line">    iterator end()</span><br><span class="line">    &#123;</span><br><span class="line">        return _finish;</span><br><span class="line">    &#125;</span><br><span class="line">    const_iterator begin() const</span><br><span class="line">    &#123;</span><br><span class="line">        return _start;</span><br><span class="line">    &#125;</span><br><span class="line">    const_iterator end() const</span><br><span class="line">    &#123;</span><br><span class="line">        return _finish;</span><br><span class="line">    &#125;</span><br><span class="line">    //插入</span><br><span class="line">    iterator Insert(iterator pos, const T&amp; val)</span><br><span class="line">    &#123;</span><br><span class="line">        assert(pos &gt;= _start &amp;&amp; pos &lt;= _finish);</span><br><span class="line">        //扩容，扩容会导致pos要重新指定位置，因为内存地址变更</span><br><span class="line">        if(_finish == _endOfStorge)</span><br><span class="line">        &#123;</span><br><span class="line">            size_t n = pos - _start;</span><br><span class="line">            size_t size = Capacity() == 0 ? 4 : 2 * Capacity();</span><br><span class="line">            Reserve(size);</span><br><span class="line">            pos = _start + n;</span><br><span class="line">        &#125;</span><br><span class="line">        iterator it = _finish;</span><br><span class="line">        while(it != pos)</span><br><span class="line">        &#123;</span><br><span class="line">            *it = *(it - 1);</span><br><span class="line">            it--;</span><br><span class="line">        &#125;</span><br><span class="line">        *pos = val;</span><br><span class="line">        _finish++;</span><br><span class="line">        return pos;</span><br><span class="line">    &#125;</span><br><span class="line">    //删除</span><br><span class="line">    iterator Erase(iterator pos)</span><br><span class="line">    &#123;</span><br><span class="line">        assert(pos &gt;= _start &amp;&amp; pos &lt;= _finish);</span><br><span class="line">        iterator it = pos + 1;</span><br><span class="line">        while(it != _finish)</span><br><span class="line">        &#123;</span><br><span class="line">            *(it - 1) = *it;</span><br><span class="line">            it++;</span><br><span class="line">        &#125;</span><br><span class="line">        _finish--;</span><br><span class="line">        return pos;</span><br><span class="line">    &#125;</span><br><span class="line">    //尾插</span><br><span class="line">    void Push_back(const T&amp; val)</span><br><span class="line">    &#123;</span><br><span class="line">        //扩容</span><br><span class="line">        if(_endOfStorge == _finish)</span><br><span class="line">        &#123;</span><br><span class="line">            size_t capacity = Capacity() == 0 ? 4 : 2 * Capacity();</span><br><span class="line">            Reserve(capacity);</span><br><span class="line">        &#125;</span><br><span class="line">        *_finish = val;</span><br><span class="line">        _finish++;</span><br><span class="line">    &#125;</span><br><span class="line">    //尾删</span><br><span class="line">    void Pop_back()</span><br><span class="line">    &#123;</span><br><span class="line">        assert(_finish &gt; _start);</span><br><span class="line">        _finish--;</span><br><span class="line">    &#125;</span><br><span class="line">    //operator[]重载</span><br><span class="line">    T&amp; operator[](size_t pos)</span><br><span class="line">    &#123;</span><br><span class="line">        return _start[pos];</span><br><span class="line">    &#125;</span><br><span class="line">    const T&amp; operator[](size_t pos) const</span><br><span class="line">    &#123;</span><br><span class="line">        return _start[pos];</span><br><span class="line">    &#125;</span><br><span class="line">    //长度</span><br><span class="line">    size_t Size() const</span><br><span class="line">    &#123;</span><br><span class="line">        return _finish - _start;</span><br><span class="line">    &#125;</span><br><span class="line">    //容量</span><br><span class="line">    size_t Capacity() const</span><br><span class="line">    &#123;</span><br><span class="line">        return _endOfStorge - _start;</span><br><span class="line">    &#125;</span><br><span class="line">    //重新给容量</span><br><span class="line">    void Reserve(size_t capacity)</span><br><span class="line">    &#123;</span><br><span class="line">        if(capacity &gt; Capacity())</span><br><span class="line">        &#123;</span><br><span class="line">            size_t size = Size();</span><br><span class="line">            //分配新的内存空间</span><br><span class="line">            T* newArr = new T[capacity];</span><br><span class="line">            if(_start)</span><br><span class="line">            &#123;</span><br><span class="line">                memcpy(newArr, _start, size * sizeof(T));</span><br><span class="line">            &#125;</span><br><span class="line">            //销毁原有内存空间</span><br><span class="line">            delete[] _start;</span><br><span class="line">            //注意这里更新三个指针都要进行更新，因为三个指针都还指向原来的内存空间</span><br><span class="line">            _start = newArr;</span><br><span class="line">            _finish = _start + size;</span><br><span class="line">            _endOfStorge = _start + capacity;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    //重新给长度,空白部分val填充</span><br><span class="line">    void Resize(size_t size, T val = T())</span><br><span class="line">    &#123;</span><br><span class="line">        Reserve(size);</span><br><span class="line">        if(Size() &lt; size)</span><br><span class="line">        &#123;</span><br><span class="line">            T* ptr = _finish;</span><br><span class="line">            while(ptr != _start + size)</span><br><span class="line">            &#123;</span><br><span class="line">                *ptr = val;</span><br><span class="line">                ptr++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        _finish = _start + size;</span><br><span class="line">    &#125;</span><br><span class="line">private:</span><br><span class="line">    //vecotor的实现与string有所不同</span><br><span class="line">    //其底层使用三个迭代器（指针）用来标记头部，尾部和总容量尾部</span><br><span class="line">    iterator _start;</span><br><span class="line">    iterator _finish;</span><br><span class="line">    iterator _endOfStorge;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>

          
        
      
    </div>
    
    
    

    

    <div>
    
    </div>

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/07/22/【Cpp】第五章-STL-string类/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="MisakiFx">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/blog-logo.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Misaki`s blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/07/22/【Cpp】第五章-STL-string类/" itemprop="url">【Cpp】第五章-STL_string类</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-07-22T20:51:53+08:00">
                2019-07-22
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Cpp/" itemprop="url" rel="index">
                    <span itemprop="name">Cpp</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  2.9k
                </span>
              

              

              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="string类"><a href="#string类" class="headerlink" title="string类"></a>string类</h1><h2 id="STL"><a href="#STL" class="headerlink" title="STL"></a>STL</h2><p>&emsp;&emsp;<strong>STL</strong>是<code>Standard Template Library</code>的简称，中文名为是<strong>标准模板库</strong>，在Cpp中模板是构成泛型编程的基础，我们利用模板可以极大程度地提高我们的代码复用率，但是如果模板要我们现写也有点过于繁琐，不过好在Cpp中为我们写代码方便为我们制作了一套标准地模板库，供我们直接使用十分方便。</p>
<h3 id="STL的版本"><a href="#STL的版本" class="headerlink" title="STL的版本"></a>STL的版本</h3><p>&emsp;&emsp;STL发展至今也不是一气呵成的，随着发展和进化，STL一共出现了四大版本。</p>
<h4 id="HP版本"><a href="#HP版本" class="headerlink" title="HP版本"></a>HP版本</h4><p>&emsp;&emsp;这个版本是STL的原始版本，由Alexander Stepanov、Meng Lee在惠普实验室完成，是所有STL版本的始祖。并且此版本秉承开源精神，允许任何人免费运用，拷贝，商用，传播，修改这些代码，唯一的条件也只是要求需要像原始版本一样开源使用。</p>
<h4 id="P-J-版本"><a href="#P-J-版本" class="headerlink" title="P.J.版本"></a>P.J.版本</h4><p>&emsp;&emsp;这个版本由P. J. Plauger开发，继承自HP版本，被Windows Visual C++采用，不可公开或修改，可读性较差。</p>
<h4 id="RW版本"><a href="#RW版本" class="headerlink" title="RW版本"></a>RW版本</h4><p>&emsp;&emsp;这个版本由Rouge Wage公司开发，继承自HP版本，被C++ Builder采用，不能公开或修改，可读性一般。</p>
<h4 id="SGI版本"><a href="#SGI版本" class="headerlink" title="SGI版本"></a>SGI版本</h4><p>&emsp;&emsp;这个版本由Silicon Graphics Computer Systems，Inc公司开发，继承自HP版本，被GCC采用，可移植性较好，可公开，修改，贩卖，可读性很高。也是我们学习主要参考的版本。</p>
<h3 id="STL六大组件"><a href="#STL六大组件" class="headerlink" title="STL六大组件"></a>STL六大组件</h3><p>&emsp;&emsp;STL中包含六大组件，他们共同组成STL互相协同工作。</p>
<h4 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h4><p>&emsp;&emsp;<code>string, vector, list, deque, map, set, multimap, multiset</code>。</p>
<h4 id="配接器"><a href="#配接器" class="headerlink" title="配接器"></a>配接器</h4><p>&emsp;&emsp;<code>stack, queue, priority_queue</code></p>
<h4 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h4><p>&emsp;&emsp;<code>find, swap, reverse, sort, merge...</code></p>
<h4 id="空间适配器"><a href="#空间适配器" class="headerlink" title="空间适配器"></a>空间适配器</h4><p>&emsp;&emsp;<code>allocator</code></p>
<h4 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h4><p>&emsp;&emsp;<code>iterator, const_iterator, reverse_iterator, const_reverse_iterator</code></p>
<h4 id="仿函数"><a href="#仿函数" class="headerlink" title="仿函数"></a>仿函数</h4><p>&emsp;&emsp;<code>greater, less...</code><br><br>&emsp;&emsp;STL在日常编程中无论是笔试还是项目都十分常用，必须多用多练，并且自己实现一遍才能熟练掌握。STL(包扩Cpp绝大部分库)学习可分为三个层次：<br><br>&emsp;&emsp;1、熟用STL<br>&emsp;&emsp;2、了解泛型技术d的内涵与STL的学理乃至实作<br>&emsp;&emsp;3、扩充STL<br>&emsp;&emsp;总结就是能用，明理，能扩展。</p>
<h2 id="string类-1"><a href="#string类-1" class="headerlink" title="string类"></a>string类</h2><p>&emsp;&emsp;<code>string</code>类时STL中专门用于字符串处理的容器。在C语言中我们利用字符数组或字符指针来构成字符串，所有字符串使用十分不方便，库中为字符串提供的接口也并不便于使用，于是在Cpp中有了<code>string</code>模板类，这个容器可以帮助我们更加方便的使用字符串，并且帮助我们封装了很多字符串相关的常用接口。</p>
<h3 id="常用接口"><a href="#常用接口" class="headerlink" title="常用接口"></a>常用接口</h3><h4 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h4><p>&emsp;&emsp;<code>string</code>中提供了各种构造函数帮助我们构造字符串。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">string(); //构造空的string类对象，即空字符串</span><br><span class="line">string(const char *s);// 用C-string来构造string类对象</span><br><span class="line">string(size_t n, char c);//string类对象中包含n个字符c</span><br><span class="line">string(const string &amp;s);//拷贝构造函数</span><br><span class="line">string(const string &amp;s, size_t n);//用s中的前n个字符构造新的string类对象 return 0;</span><br></pre></td></tr></table></figure></p>
<h4 id="容量相关接口"><a href="#容量相关接口" class="headerlink" title="容量相关接口"></a>容量相关接口</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">size_t size() const;			  // 返回字符串有效字符长度</span><br><span class="line">size_t length() const;			  // 返回字符串有效字符长度</span><br><span class="line">size_t capacity() const;		  // 返回空间总大小</span><br><span class="line">bool empty() const;				  // 检测字符串释放为空串，是返回true，否则返回false</span><br><span class="line">void clear();					  //清空有效字符</span><br><span class="line">void resize(size_t n, char c);	// 将有效字符的个数该成n个，多出的空间用字符c填充</span><br><span class="line">void resize(size_t n);			  // 将有效字符的个数改成n个，多出的空间用0填充</span><br><span class="line">void reserve(size_t res_arg = 0); // 为字符串预留空间</span><br></pre></td></tr></table></figure>
<h4 id="访问相关接口"><a href="#访问相关接口" class="headerlink" title="访问相关接口"></a>访问相关接口</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">char&amp; operator[] (size_t pos); 	  	    //返回pos位置的字符,非const string类对象调用</span><br><span class="line">const char&amp; operator[] (size_t pos);	//const返回pos位置的字符，const string类对象调用</span><br></pre></td></tr></table></figure>
<h4 id="修改相关接口"><a href="#修改相关接口" class="headerlink" title="修改相关接口"></a>修改相关接口</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">void push_back(char c);							//在字符串后尾插字符c</span><br><span class="line">string&amp; append (const char* s); 				//在字符串后追加一个字符串</span><br><span class="line">string&amp; operator+=(const string&amp; str);			//在字符串后追加字符串str</span><br><span class="line">string&amp; operator+=(const char* s);				//在字符串后追加字符串</span><br><span class="line">string&amp; operator+=(char c);						//在字符串后追加字符c</span><br><span class="line">const char* c_str()const;						//返回C格式字符串</span><br><span class="line">size_t find (char c, size_t pos = 0) const;		//从字符串pos位置开始往后找字符c，返回该字符在字符串中的位置</span><br><span class="line">size_t rfind(char c, size_t pos = npos);		//从字符串pos位置开始往前找字符c，返回该字符在字符串中的位置</span><br><span class="line">string substr(size_t pos = 0, size_t n= npos); 	//const在str中从pos位置开始，截取n个字符，然后将其返回</span><br><span class="line">string&amp; erase (size_t pos = 0, size_t len = npos); //从pos位置起删除串中npos个字符</span><br></pre></td></tr></table></figure>
<h4 id="迭代器相关"><a href="#迭代器相关" class="headerlink" title="迭代器相关"></a>迭代器相关</h4><p>&emsp;&emsp;迭代器十分类似于指针，我们可以将其等同于一个自定义类型的指针，用它我们可以完成容器内的遍历，增加，删除等操作，STL中容器的很多功能也为迭代器设计了很多接口，其中最为常用的还是取到一个容器的迭代器。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">iterator begin();					//取到头部迭代器</span><br><span class="line">const_iterator begin() const;		//取到头部常迭代器</span><br><span class="line">iterator end();						//取到尾部迭代器</span><br><span class="line">const_iterator end() const;			//取到尾部常迭代器</span><br></pre></td></tr></table></figure></p>
<h4 id="其他接口"><a href="#其他接口" class="headerlink" title="其他接口"></a>其他接口</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">string operator+ (const string&amp; lhs, const string&amp; rhs); 	//在lhs串后拼接rhs串</span><br><span class="line">istream&amp; operator&gt;&gt; (istream&amp; is, string&amp; str);				//输入运算符重载</span><br><span class="line">istream&amp; getline (istream&amp; is, string&amp; str);				//获取一行字符串</span><br><span class="line">relational operators 										//大小比较</span><br></pre></td></tr></table></figure>
<h4 id="综合运用"><a href="#综合运用" class="headerlink" title="综合运用"></a>综合运用</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	string str = &quot;123456&quot;;//单参构造的隐式类型转换 + 拷贝构造</span><br><span class="line">	for(int i = 0; i &lt; str.size(); i++)//size()取出长度</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; str[i] &lt;&lt; &quot; &quot;;//operator[]重载的运用</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">	str.append(&quot;abc&quot;);//append()接口</span><br><span class="line">	str.push_back(&apos;d&apos;);//push_back接口使用</span><br><span class="line">	str += &quot;efg&quot;;//operator += 重载使用</span><br><span class="line">	//迭代器的应用</span><br><span class="line">	string::iterator it = str.begin();</span><br><span class="line">	while(it != str.end())</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; * it &lt;&lt; &quot; &quot;;</span><br><span class="line">		it++;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1 2 3 4 5 6</span><br><span class="line">1 2 3 4 5 6 a b c d e f g</span><br></pre></td></tr></table></figure>
<h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>&emsp;&emsp;学习STL要熟用，明理，能扩展，那么第二部明理我们就要自己实现封装一个<code>string</code>类。根据库中<code>string</code>常用接口我们也实现其基本功能。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;assert.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">class String</span><br><span class="line">&#123;</span><br><span class="line">    friend std::ostream &amp;operator&lt;&lt;(std::ostream &amp;os, String str);</span><br><span class="line">public:</span><br><span class="line">    //迭代器</span><br><span class="line">    typedef char* iterator;</span><br><span class="line">    typedef const char* const_iterator;</span><br><span class="line">    iterator begin()</span><br><span class="line">    &#123;</span><br><span class="line">        return _str;</span><br><span class="line">    &#125;</span><br><span class="line">    const_iterator begin() const</span><br><span class="line">    &#123;</span><br><span class="line">        return _str;</span><br><span class="line">    &#125;</span><br><span class="line">    iterator end()</span><br><span class="line">    &#123;</span><br><span class="line">        return _str+_size;</span><br><span class="line">    &#125;</span><br><span class="line">    const_iterator end() const</span><br><span class="line">    &#123;</span><br><span class="line">        return _str+_size;</span><br><span class="line">    &#125;</span><br><span class="line">    static size_t npos;</span><br><span class="line">    //构造函数</span><br><span class="line">    String(const char* str = &quot;&quot;)//要进行深拷贝</span><br><span class="line">        :_str(nullptr)</span><br><span class="line">        ,_capacity(0)</span><br><span class="line">    &#123;</span><br><span class="line">        _size = strlen(str);</span><br><span class="line">        //重新给容量Reserve()</span><br><span class="line">        Reserve(_size);</span><br><span class="line">        //strcpy()拷贝给成员变量</span><br><span class="line">        strcpy(_str, str);</span><br><span class="line">    &#125;</span><br><span class="line">    //拷贝构造，要使用深拷贝</span><br><span class="line">    //所谓深拷贝就是创立独立的内存空间并将目标对象中的值拷贝过来</span><br><span class="line">    //而不是单纯的让指针等于目标拷贝对象中的指针</span><br><span class="line">    //注意：拷贝构造和operator=重载都是不拷贝容量大小的</span><br><span class="line">    //传统写法：创建新的独立内存，销毁原来的内存空间，更新_size, _capacity的值</span><br><span class="line">    //String(const String&amp; str)</span><br><span class="line">    //    :_str(nullptr)</span><br><span class="line">    //    ,_size(0)</span><br><span class="line">    //    ,_capacity(0)</span><br><span class="line">    //&#123;</span><br><span class="line">    //    Resize(str.Size());</span><br><span class="line">    //    strcpy(_str, str._str);</span><br><span class="line">    //&#125;</span><br><span class="line">    ////operator=重载和拷贝构造类似，先用传统写法实现</span><br><span class="line">    //String&amp; operator=(const String&amp; str)</span><br><span class="line">    //&#123;</span><br><span class="line">    //    if(this != &amp;str)</span><br><span class="line">    //    &#123;</span><br><span class="line">    //        Resize(str.Size());</span><br><span class="line">    //        strcpy(_str, str._str);</span><br><span class="line">    //    &#125;</span><br><span class="line">    //&#125;</span><br><span class="line">    //现代写法，另外创建对象让其等于要拷贝的对象，交换两个对象即可</span><br><span class="line">    String(const String&amp; str)</span><br><span class="line">        :_str(nullptr)</span><br><span class="line">        ,_size(0)</span><br><span class="line">        ,_capacity(0)</span><br><span class="line">    &#123;</span><br><span class="line">        String temp(str._str);</span><br><span class="line">        Swap(temp);</span><br><span class="line">    &#125;</span><br><span class="line">    //现代写法，利用拷贝构造函数创建临时对象，交换两个对象，临时对象在函数结束时也会自动释放</span><br><span class="line">    String&amp; operator=(String str)</span><br><span class="line">    &#123;</span><br><span class="line">        Swap(str);</span><br><span class="line">    &#125;</span><br><span class="line">    //交换两个字符串，浅拷贝，不另申请内存空间</span><br><span class="line">    void Swap(String&amp; str)</span><br><span class="line">    &#123;</span><br><span class="line">        std::swap(_str, str._str);</span><br><span class="line">        std::swap(_size, str._size);</span><br><span class="line">        std::swap(_capacity, str._capacity);</span><br><span class="line">    &#125;</span><br><span class="line">    //析构函数</span><br><span class="line">    ~String()</span><br><span class="line">    &#123;</span><br><span class="line">        if(_str)</span><br><span class="line">        &#123;</span><br><span class="line">            delete[] _str;</span><br><span class="line">            _str = nullptr;</span><br><span class="line">            _size = _capacity = 0;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    //返回_size</span><br><span class="line">    size_t Size() const</span><br><span class="line">    &#123;</span><br><span class="line">        return _size;</span><br><span class="line">    &#125;</span><br><span class="line">    //返回_capacity</span><br><span class="line">    size_t Capacity() const</span><br><span class="line">    &#123;</span><br><span class="line">        return _capacity;</span><br><span class="line">    &#125;</span><br><span class="line">    //在某个下标插入一个字符</span><br><span class="line">    void Insert(size_t pos, char ch)</span><br><span class="line">    &#123;</span><br><span class="line">        assert(pos &lt;= _size);</span><br><span class="line">        //容量满了，扩容</span><br><span class="line">        if(_size == _capacity)</span><br><span class="line">        &#123;</span><br><span class="line">            Reserve(2 * _capacity);</span><br><span class="line">        &#125;</span><br><span class="line">        for(int i = _size; i &gt; pos; i--)</span><br><span class="line">        &#123;</span><br><span class="line">            _str[i] = _str[i - 1];</span><br><span class="line">        &#125;</span><br><span class="line">        _str[pos] = ch;</span><br><span class="line">        _size++;</span><br><span class="line">        _str[_size] = &apos;\0&apos;;</span><br><span class="line">    &#125;</span><br><span class="line">    //在某个下标处插入一个字符串</span><br><span class="line">    void Insert(size_t pos, const char* str)</span><br><span class="line">    &#123;</span><br><span class="line">        assert(pos &lt;= _size);</span><br><span class="line">        int len = strlen(str);</span><br><span class="line">        //容量不够扩容</span><br><span class="line">        if(_size + len &gt; _capacity)</span><br><span class="line">        &#123;</span><br><span class="line">            Reserve(len + _size);</span><br><span class="line">        &#125;</span><br><span class="line">        for(int i = len + _size - 1; i &gt; pos + len - 1; i--)</span><br><span class="line">        &#123;</span><br><span class="line">            _str[i] = _str[i - len];        </span><br><span class="line">        &#125;</span><br><span class="line">        for(int i = pos; i &lt; pos + len; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            _str[i] = str[i - pos];</span><br><span class="line">        &#125;</span><br><span class="line">        _size += len;</span><br><span class="line">    &#125;</span><br><span class="line">    //+=运算符重载</span><br><span class="line">    String&amp; operator+=(char ch)</span><br><span class="line">    &#123;</span><br><span class="line">        Push_back(ch);</span><br><span class="line">    &#125;</span><br><span class="line">    String&amp; operator+=(const char* str)</span><br><span class="line">    &#123;</span><br><span class="line">        Append(str);</span><br><span class="line">    &#125;</span><br><span class="line">    //删除pos下标开始的npos个字符</span><br><span class="line">    void Erase(size_t pos, size_t npos)</span><br><span class="line">    &#123;</span><br><span class="line">        assert(pos &lt; _size);</span><br><span class="line">        for(int i = pos; i &lt; _size - npos; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            _str[i] = _str[i + npos];</span><br><span class="line">        &#125;</span><br><span class="line">        _size -= npos;</span><br><span class="line">        _str[_size] = &apos;\0&apos;;</span><br><span class="line">    &#125;</span><br><span class="line">    //从pos开始找第一个字符为ch返回其下标</span><br><span class="line">    size_t Find(const char ch, size_t pos = 0)</span><br><span class="line">    &#123;</span><br><span class="line">        assert(pos &lt; _size);</span><br><span class="line">        for(size_t i = pos; i &lt; _size; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            if(_str[i] == ch)</span><br><span class="line">            &#123;</span><br><span class="line">                return i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return npos;</span><br><span class="line">    &#125;</span><br><span class="line">    //从pos开始找第一个子串为str返回其下标</span><br><span class="line">    size_t Find(const char* str, size_t pos = 0)</span><br><span class="line">    &#123;</span><br><span class="line">        assert(pos &lt; _size);</span><br><span class="line">        for(size_t i = pos; i &lt; _size; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            if(_str[i] == str[0])</span><br><span class="line">            &#123;</span><br><span class="line">                int j = i;</span><br><span class="line">                while (j &lt; i + strlen(str) &amp;&amp; _str[j] != &apos;\0&apos;)</span><br><span class="line">                &#123;</span><br><span class="line">                    if (_str[j] != str[j - i])</span><br><span class="line">                    &#123;</span><br><span class="line">                        break;</span><br><span class="line">                    &#125;</span><br><span class="line">                    j++;</span><br><span class="line">                &#125;</span><br><span class="line">                //子串遍历完毕,子串与要查找的串完全匹配</span><br><span class="line">                if (j == i + strlen(str))</span><br><span class="line">                &#123;</span><br><span class="line">                    return i;</span><br><span class="line">                &#125;</span><br><span class="line">                //主串遇到结尾，长度不够不用继续查找了</span><br><span class="line">                else if(_str[j] == &apos;\0&apos;)</span><br><span class="line">                &#123;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">                //其他情况本次子串与要查找的串匹配不上，继续下一次子串查找</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return npos;</span><br><span class="line">    &#125;</span><br><span class="line">    //在尾部插入字符</span><br><span class="line">    void Push_back(char ch)</span><br><span class="line">    &#123;</span><br><span class="line">        Insert(_size, ch);</span><br><span class="line">    &#125;</span><br><span class="line">    //字符串拼接</span><br><span class="line">    void Append(const char* str)</span><br><span class="line">    &#123;</span><br><span class="line">        Insert(_size, str);</span><br><span class="line">    &#125;</span><br><span class="line">    //重新给容量，并且要求容量永远为8的整数倍</span><br><span class="line">    void Reserve(size_t n)</span><br><span class="line">    &#123;</span><br><span class="line">        if(n &gt; _capacity || (n == 0 &amp;&amp; _capacity == 0))</span><br><span class="line">        &#123;</span><br><span class="line">            size_t newCapacity = n;</span><br><span class="line">            if(newCapacity % 8 != 0)</span><br><span class="line">            &#123;</span><br><span class="line">                newCapacity = (((newCapacity / 8) + 1) * 8);</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">            &#123;</span><br><span class="line">                newCapacity += 8;</span><br><span class="line">            &#125;</span><br><span class="line">            char* newStr = new char[newCapacity];</span><br><span class="line">            if(newStr &amp;&amp; _str)</span><br><span class="line">            &#123;</span><br><span class="line">                strcpy(newStr, _str);</span><br><span class="line">            &#125;</span><br><span class="line">            //释放旧空间</span><br><span class="line">            delete[] _str;</span><br><span class="line">            _str = newStr;</span><br><span class="line">            _capacity = newCapacity - 1;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    void Resize(size_t size, char ch = &apos;\0&apos;)</span><br><span class="line">    &#123;</span><br><span class="line">        if(size &lt; _size)</span><br><span class="line">        &#123;</span><br><span class="line">            _size = size;</span><br><span class="line">            _str[_size] = &apos;\0&apos;;</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            Reserve(size);</span><br><span class="line">            for(size_t i = _size; i &lt; size; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                _str[i] = ch;</span><br><span class="line">            &#125;</span><br><span class="line">            _size = size;</span><br><span class="line">            _str[_size] = &apos;\0&apos;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    //&gt;运算符重载</span><br><span class="line">    bool operator&gt;(const String&amp; str)</span><br><span class="line">    &#123;</span><br><span class="line">        if(strcmp(_str, str._str) &gt; 0)</span><br><span class="line">        &#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    bool operator==(const String&amp; str)</span><br><span class="line">    &#123;</span><br><span class="line">        if(strcmp(_str, str._str) == 0)</span><br><span class="line">        &#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    bool operator&gt;=(const String&amp; str)</span><br><span class="line">    &#123;</span><br><span class="line">        if(*this &gt; str || *this == str)</span><br><span class="line">        &#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    bool operator&lt;(const String&amp; str)</span><br><span class="line">    &#123;</span><br><span class="line">        if(*this &gt;= str)</span><br><span class="line">        &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    bool operator&lt;=(const String&amp; str)</span><br><span class="line">    &#123;</span><br><span class="line">        if(*this &lt; str || *this == str)</span><br><span class="line">        &#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    bool operator!=(const String&amp; str)</span><br><span class="line">    &#123;</span><br><span class="line">        if(*this == str)</span><br><span class="line">        &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    //+运算符重载</span><br><span class="line">    String operator+(char ch)</span><br><span class="line">    &#123;</span><br><span class="line">        String temp(*this);</span><br><span class="line">        temp.Push_back(ch);</span><br><span class="line">        return temp;</span><br><span class="line">    &#125;</span><br><span class="line">    String operator+(const char* str)</span><br><span class="line">    &#123;</span><br><span class="line">        String temp(*this);</span><br><span class="line">        temp.Append(str);</span><br><span class="line">        return temp;</span><br><span class="line">    &#125;</span><br><span class="line">    //取类中的字符串</span><br><span class="line">    char* c_str()</span><br><span class="line">    &#123;</span><br><span class="line">        return _str;    </span><br><span class="line">    &#125;</span><br><span class="line">    //operator[]重载</span><br><span class="line">    char&amp; operator[](size_t pos)</span><br><span class="line">    &#123;</span><br><span class="line">        assert(pos &lt; _size);</span><br><span class="line">        return _str[pos];</span><br><span class="line">    &#125;</span><br><span class="line">    //operator[]重载</span><br><span class="line">    const char&amp; operator[](size_t pos) const</span><br><span class="line">    &#123;</span><br><span class="line">        assert(pos &lt; _size);</span><br><span class="line">        return _str[pos];</span><br><span class="line">    &#125;</span><br><span class="line">private:</span><br><span class="line">    char* _str;</span><br><span class="line">    size_t _size;</span><br><span class="line">    size_t _capacity;</span><br><span class="line">&#125;;</span><br><span class="line">std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, String str)</span><br><span class="line">&#123;</span><br><span class="line">	os &lt;&lt; str._str;</span><br><span class="line">	return os;</span><br><span class="line">&#125;</span><br><span class="line">size_t String::npos = -1;</span><br></pre></td></tr></table></figure></p>

          
        
      
    </div>
    
    
    

    

    <div>
    
    </div>

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/2/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><span class="space">&hellip;</span><a class="page-number" href="/page/8/">8</a><a class="extend next" rel="next" href="/page/4/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/blog-logo.jpg"
                alt="MisakiFx" />
            
              <p class="site-author-name" itemprop="name">MisakiFx</p>
              <p class="site-description motion-element" itemprop="description">Hard working or giving up!!!</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">79</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">9</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">56</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/MisakiFx" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="mailto:1761607418@qq.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope-open"></i>E-Mail</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://music.163.com/#/user/home?id=432551242" target="_blank" title="网易云音乐">
                      
                        <i class="fa fa-fw fa-music"></i>网易云音乐</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://blog.csdn.net/qq_41669298" target="_blank" title="CSDN">
                      
                        <i class="fa fa-fw fa-crosshairs"></i>CSDN</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        ﻿<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js">
</script>
<div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">MisakiFx</span>

  
</div>


<div class="powered-by">
  <i class="fa fa-user-md"></i>
  <span id="busuanzi_container_site_uv">
    我的网站的访客数:<span id="busuanzi_value_site_uv"></span>
  </span>
</div>



<span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.4</div>




<div class="theme-info">
  <div class="powered-by"></div>
  <span class="post-count">博客全站共240k字</span>
</div>

        ﻿







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  


  











  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  

  
  
    <script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

  <!-- 页面点击小红心 -->
        <script type="text/javascript" src="/js/src/love.js"></script>
<script src="/live2dw/lib/L2Dwidget.min.js?0c58a1486de42ac6cc1c59c7d98ae887"></script><script>L2Dwidget.init({"pluginModelPath":"assets/","model":{"jsonPath":"/live2dw/assets/z16.model.json"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":false},"log":false,"pluginJsPath":"lib/","pluginRootPath":"live2dw/","tagMode":false});</script></body>
</html>
