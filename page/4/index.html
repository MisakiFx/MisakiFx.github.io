<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.ico?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon_16.ico?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta name="description" content="Hard working or giving up!!!">
<meta property="og:type" content="website">
<meta property="og:title" content="Misaki`s blog">
<meta property="og:url" content="http://yoursite.com/page/4/index.html">
<meta property="og:site_name" content="Misaki`s blog">
<meta property="og:description" content="Hard working or giving up!!!">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Misaki`s blog">
<meta name="twitter:description" content="Hard working or giving up!!!">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/page/4/"/>





  <title>Misaki`s blog</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

<a href="https://github.com/MisakiFx" class="github-corner" aria-label="View source on GitHub"><svg width="80" height="80" viewBox="0 0 250 250" style="fill:#64CEAA; color:#fff; position: absolute; top: 0; border: 0; left: 0; transform: scale(-1, 1);" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Misaki`s blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">学习是一种态度</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/07/22/【Cpp】第五章-STL-string类/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="MisakiFx">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/blog-logo.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Misaki`s blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/07/22/【Cpp】第五章-STL-string类/" itemprop="url">【Cpp】第五章-STL_string类</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-07-22T20:51:53+08:00">
                2019-07-22
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Cpp/" itemprop="url" rel="index">
                    <span itemprop="name">Cpp</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  2.9k
                </span>
              

              

              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="string类"><a href="#string类" class="headerlink" title="string类"></a>string类</h1><h2 id="STL"><a href="#STL" class="headerlink" title="STL"></a>STL</h2><p>&emsp;&emsp;<strong>STL</strong>是<code>Standard Template Library</code>的简称，中文名为是<strong>标准模板库</strong>，在Cpp中模板是构成泛型编程的基础，我们利用模板可以极大程度地提高我们的代码复用率，但是如果模板要我们现写也有点过于繁琐，不过好在Cpp中为我们写代码方便为我们制作了一套标准地模板库，供我们直接使用十分方便。</p>
<h3 id="STL的版本"><a href="#STL的版本" class="headerlink" title="STL的版本"></a>STL的版本</h3><p>&emsp;&emsp;STL发展至今也不是一气呵成的，随着发展和进化，STL一共出现了四大版本。</p>
<h4 id="HP版本"><a href="#HP版本" class="headerlink" title="HP版本"></a>HP版本</h4><p>&emsp;&emsp;这个版本是STL的原始版本，由Alexander Stepanov、Meng Lee在惠普实验室完成，是所有STL版本的始祖。并且此版本秉承开源精神，允许任何人免费运用，拷贝，商用，传播，修改这些代码，唯一的条件也只是要求需要像原始版本一样开源使用。</p>
<h4 id="P-J-版本"><a href="#P-J-版本" class="headerlink" title="P.J.版本"></a>P.J.版本</h4><p>&emsp;&emsp;这个版本由P. J. Plauger开发，继承自HP版本，被Windows Visual C++采用，不可公开或修改，可读性较差。</p>
<h4 id="RW版本"><a href="#RW版本" class="headerlink" title="RW版本"></a>RW版本</h4><p>&emsp;&emsp;这个版本由Rouge Wage公司开发，继承自HP版本，被C++ Builder采用，不能公开或修改，可读性一般。</p>
<h4 id="SGI版本"><a href="#SGI版本" class="headerlink" title="SGI版本"></a>SGI版本</h4><p>&emsp;&emsp;这个版本由Silicon Graphics Computer Systems，Inc公司开发，继承自HP版本，被GCC采用，可移植性较好，可公开，修改，贩卖，可读性很高。也是我们学习主要参考的版本。</p>
<h3 id="STL六大组件"><a href="#STL六大组件" class="headerlink" title="STL六大组件"></a>STL六大组件</h3><p>&emsp;&emsp;STL中包含六大组件，他们共同组成STL互相协同工作。</p>
<h4 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h4><p>&emsp;&emsp;<code>string, vector, list, deque, map, set, multimap, multiset</code>。</p>
<h4 id="配接器"><a href="#配接器" class="headerlink" title="配接器"></a>配接器</h4><p>&emsp;&emsp;<code>stack, queue, priority_queue</code></p>
<h4 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h4><p>&emsp;&emsp;<code>find, swap, reverse, sort, merge...</code></p>
<h4 id="空间适配器"><a href="#空间适配器" class="headerlink" title="空间适配器"></a>空间适配器</h4><p>&emsp;&emsp;<code>allocator</code></p>
<h4 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h4><p>&emsp;&emsp;<code>iterator, const_iterator, reverse_iterator, const_reverse_iterator</code></p>
<h4 id="仿函数"><a href="#仿函数" class="headerlink" title="仿函数"></a>仿函数</h4><p>&emsp;&emsp;<code>greater, less...</code><br><br>&emsp;&emsp;STL在日常编程中无论是笔试还是项目都十分常用，必须多用多练，并且自己实现一遍才能熟练掌握。STL(包扩Cpp绝大部分库)学习可分为三个层次：<br><br>&emsp;&emsp;1、熟用STL<br>&emsp;&emsp;2、了解泛型技术d的内涵与STL的学理乃至实作<br>&emsp;&emsp;3、扩充STL<br>&emsp;&emsp;总结就是能用，明理，能扩展。</p>
<h2 id="string类-1"><a href="#string类-1" class="headerlink" title="string类"></a>string类</h2><p>&emsp;&emsp;<code>string</code>类时STL中专门用于字符串处理的容器。在C语言中我们利用字符数组或字符指针来构成字符串，所有字符串使用十分不方便，库中为字符串提供的接口也并不便于使用，于是在Cpp中有了<code>string</code>模板类，这个容器可以帮助我们更加方便的使用字符串，并且帮助我们封装了很多字符串相关的常用接口。</p>
<h3 id="常用接口"><a href="#常用接口" class="headerlink" title="常用接口"></a>常用接口</h3><h4 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h4><p>&emsp;&emsp;<code>string</code>中提供了各种构造函数帮助我们构造字符串。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">string(); //构造空的string类对象，即空字符串</span><br><span class="line">string(const char *s);// 用C-string来构造string类对象</span><br><span class="line">string(size_t n, char c);//string类对象中包含n个字符c</span><br><span class="line">string(const string &amp;s);//拷贝构造函数</span><br><span class="line">string(const string &amp;s, size_t n);//用s中的前n个字符构造新的string类对象 return 0;</span><br></pre></td></tr></table></figure></p>
<h4 id="容量相关接口"><a href="#容量相关接口" class="headerlink" title="容量相关接口"></a>容量相关接口</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">size_t size() const;			  // 返回字符串有效字符长度</span><br><span class="line">size_t length() const;			  // 返回字符串有效字符长度</span><br><span class="line">size_t capacity() const;		  // 返回空间总大小</span><br><span class="line">bool empty() const;				  // 检测字符串释放为空串，是返回true，否则返回false</span><br><span class="line">void clear();					  //清空有效字符</span><br><span class="line">void resize(size_t n, char c);	// 将有效字符的个数该成n个，多出的空间用字符c填充</span><br><span class="line">void resize(size_t n);			  // 将有效字符的个数改成n个，多出的空间用0填充</span><br><span class="line">void reserve(size_t res_arg = 0); // 为字符串预留空间</span><br></pre></td></tr></table></figure>
<h4 id="访问相关接口"><a href="#访问相关接口" class="headerlink" title="访问相关接口"></a>访问相关接口</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">char&amp; operator[] (size_t pos); 	  	    //返回pos位置的字符,非const string类对象调用</span><br><span class="line">const char&amp; operator[] (size_t pos);	//const返回pos位置的字符，const string类对象调用</span><br></pre></td></tr></table></figure>
<h4 id="修改相关接口"><a href="#修改相关接口" class="headerlink" title="修改相关接口"></a>修改相关接口</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">void push_back(char c);							//在字符串后尾插字符c</span><br><span class="line">string&amp; append (const char* s); 				//在字符串后追加一个字符串</span><br><span class="line">string&amp; operator+=(const string&amp; str);			//在字符串后追加字符串str</span><br><span class="line">string&amp; operator+=(const char* s);				//在字符串后追加字符串</span><br><span class="line">string&amp; operator+=(char c);						//在字符串后追加字符c</span><br><span class="line">const char* c_str()const;						//返回C格式字符串</span><br><span class="line">size_t find (char c, size_t pos = 0) const;		//从字符串pos位置开始往后找字符c，返回该字符在字符串中的位置</span><br><span class="line">size_t rfind(char c, size_t pos = npos);		//从字符串pos位置开始往前找字符c，返回该字符在字符串中的位置</span><br><span class="line">string substr(size_t pos = 0, size_t n= npos); 	//const在str中从pos位置开始，截取n个字符，然后将其返回</span><br><span class="line">string&amp; erase (size_t pos = 0, size_t len = npos); //从pos位置起删除串中npos个字符</span><br></pre></td></tr></table></figure>
<h4 id="迭代器相关"><a href="#迭代器相关" class="headerlink" title="迭代器相关"></a>迭代器相关</h4><p>&emsp;&emsp;迭代器十分类似于指针，我们可以将其等同于一个自定义类型的指针，用它我们可以完成容器内的遍历，增加，删除等操作，STL中容器的很多功能也为迭代器设计了很多接口，其中最为常用的还是取到一个容器的迭代器。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">iterator begin();					//取到头部迭代器</span><br><span class="line">const_iterator begin() const;		//取到头部常迭代器</span><br><span class="line">iterator end();						//取到尾部迭代器</span><br><span class="line">const_iterator end() const;			//取到尾部常迭代器</span><br></pre></td></tr></table></figure></p>
<h4 id="其他接口"><a href="#其他接口" class="headerlink" title="其他接口"></a>其他接口</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">string operator+ (const string&amp; lhs, const string&amp; rhs); 	//在lhs串后拼接rhs串</span><br><span class="line">istream&amp; operator&gt;&gt; (istream&amp; is, string&amp; str);				//输入运算符重载</span><br><span class="line">istream&amp; getline (istream&amp; is, string&amp; str);				//获取一行字符串</span><br><span class="line">relational operators 										//大小比较</span><br></pre></td></tr></table></figure>
<h4 id="综合运用"><a href="#综合运用" class="headerlink" title="综合运用"></a>综合运用</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	string str = &quot;123456&quot;;//单参构造的隐式类型转换 + 拷贝构造</span><br><span class="line">	for(int i = 0; i &lt; str.size(); i++)//size()取出长度</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; str[i] &lt;&lt; &quot; &quot;;//operator[]重载的运用</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">	str.append(&quot;abc&quot;);//append()接口</span><br><span class="line">	str.push_back(&apos;d&apos;);//push_back接口使用</span><br><span class="line">	str += &quot;efg&quot;;//operator += 重载使用</span><br><span class="line">	//迭代器的应用</span><br><span class="line">	string::iterator it = str.begin();</span><br><span class="line">	while(it != str.end())</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; * it &lt;&lt; &quot; &quot;;</span><br><span class="line">		it++;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1 2 3 4 5 6</span><br><span class="line">1 2 3 4 5 6 a b c d e f g</span><br></pre></td></tr></table></figure>
<h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>&emsp;&emsp;学习STL要熟用，明理，能扩展，那么第二部明理我们就要自己实现封装一个<code>string</code>类。根据库中<code>string</code>常用接口我们也实现其基本功能。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;assert.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">class String</span><br><span class="line">&#123;</span><br><span class="line">    friend std::ostream &amp;operator&lt;&lt;(std::ostream &amp;os, String str);</span><br><span class="line">public:</span><br><span class="line">    //迭代器</span><br><span class="line">    typedef char* iterator;</span><br><span class="line">    typedef const char* const_iterator;</span><br><span class="line">    iterator begin()</span><br><span class="line">    &#123;</span><br><span class="line">        return _str;</span><br><span class="line">    &#125;</span><br><span class="line">    const_iterator begin() const</span><br><span class="line">    &#123;</span><br><span class="line">        return _str;</span><br><span class="line">    &#125;</span><br><span class="line">    iterator end()</span><br><span class="line">    &#123;</span><br><span class="line">        return _str+_size;</span><br><span class="line">    &#125;</span><br><span class="line">    const_iterator end() const</span><br><span class="line">    &#123;</span><br><span class="line">        return _str+_size;</span><br><span class="line">    &#125;</span><br><span class="line">    static size_t npos;</span><br><span class="line">    //构造函数</span><br><span class="line">    String(const char* str = &quot;&quot;)//要进行深拷贝</span><br><span class="line">        :_str(nullptr)</span><br><span class="line">        ,_capacity(0)</span><br><span class="line">    &#123;</span><br><span class="line">        _size = strlen(str);</span><br><span class="line">        //重新给容量Reserve()</span><br><span class="line">        Reserve(_size);</span><br><span class="line">        //strcpy()拷贝给成员变量</span><br><span class="line">        strcpy(_str, str);</span><br><span class="line">    &#125;</span><br><span class="line">    //拷贝构造，要使用深拷贝</span><br><span class="line">    //所谓深拷贝就是创立独立的内存空间并将目标对象中的值拷贝过来</span><br><span class="line">    //而不是单纯的让指针等于目标拷贝对象中的指针</span><br><span class="line">    //注意：拷贝构造和operator=重载都是不拷贝容量大小的</span><br><span class="line">    //传统写法：创建新的独立内存，销毁原来的内存空间，更新_size, _capacity的值</span><br><span class="line">    //String(const String&amp; str)</span><br><span class="line">    //    :_str(nullptr)</span><br><span class="line">    //    ,_size(0)</span><br><span class="line">    //    ,_capacity(0)</span><br><span class="line">    //&#123;</span><br><span class="line">    //    Resize(str.Size());</span><br><span class="line">    //    strcpy(_str, str._str);</span><br><span class="line">    //&#125;</span><br><span class="line">    ////operator=重载和拷贝构造类似，先用传统写法实现</span><br><span class="line">    //String&amp; operator=(const String&amp; str)</span><br><span class="line">    //&#123;</span><br><span class="line">    //    if(this != &amp;str)</span><br><span class="line">    //    &#123;</span><br><span class="line">    //        Resize(str.Size());</span><br><span class="line">    //        strcpy(_str, str._str);</span><br><span class="line">    //    &#125;</span><br><span class="line">    //&#125;</span><br><span class="line">    //现代写法，另外创建对象让其等于要拷贝的对象，交换两个对象即可</span><br><span class="line">    String(const String&amp; str)</span><br><span class="line">        :_str(nullptr)</span><br><span class="line">        ,_size(0)</span><br><span class="line">        ,_capacity(0)</span><br><span class="line">    &#123;</span><br><span class="line">        String temp(str._str);</span><br><span class="line">        Swap(temp);</span><br><span class="line">    &#125;</span><br><span class="line">    //现代写法，利用拷贝构造函数创建临时对象，交换两个对象，临时对象在函数结束时也会自动释放</span><br><span class="line">    String&amp; operator=(String str)</span><br><span class="line">    &#123;</span><br><span class="line">        Swap(str);</span><br><span class="line">    &#125;</span><br><span class="line">    //交换两个字符串，浅拷贝，不另申请内存空间</span><br><span class="line">    void Swap(String&amp; str)</span><br><span class="line">    &#123;</span><br><span class="line">        std::swap(_str, str._str);</span><br><span class="line">        std::swap(_size, str._size);</span><br><span class="line">        std::swap(_capacity, str._capacity);</span><br><span class="line">    &#125;</span><br><span class="line">    //析构函数</span><br><span class="line">    ~String()</span><br><span class="line">    &#123;</span><br><span class="line">        if(_str)</span><br><span class="line">        &#123;</span><br><span class="line">            delete[] _str;</span><br><span class="line">            _str = nullptr;</span><br><span class="line">            _size = _capacity = 0;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    //返回_size</span><br><span class="line">    size_t Size() const</span><br><span class="line">    &#123;</span><br><span class="line">        return _size;</span><br><span class="line">    &#125;</span><br><span class="line">    //返回_capacity</span><br><span class="line">    size_t Capacity() const</span><br><span class="line">    &#123;</span><br><span class="line">        return _capacity;</span><br><span class="line">    &#125;</span><br><span class="line">    //在某个下标插入一个字符</span><br><span class="line">    void Insert(size_t pos, char ch)</span><br><span class="line">    &#123;</span><br><span class="line">        assert(pos &lt;= _size);</span><br><span class="line">        //容量满了，扩容</span><br><span class="line">        if(_size == _capacity)</span><br><span class="line">        &#123;</span><br><span class="line">            Reserve(2 * _capacity);</span><br><span class="line">        &#125;</span><br><span class="line">        for(int i = _size; i &gt; pos; i--)</span><br><span class="line">        &#123;</span><br><span class="line">            _str[i] = _str[i - 1];</span><br><span class="line">        &#125;</span><br><span class="line">        _str[pos] = ch;</span><br><span class="line">        _size++;</span><br><span class="line">        _str[_size] = &apos;\0&apos;;</span><br><span class="line">    &#125;</span><br><span class="line">    //在某个下标处插入一个字符串</span><br><span class="line">    void Insert(size_t pos, const char* str)</span><br><span class="line">    &#123;</span><br><span class="line">        assert(pos &lt;= _size);</span><br><span class="line">        int len = strlen(str);</span><br><span class="line">        //容量不够扩容</span><br><span class="line">        if(_size + len &gt; _capacity)</span><br><span class="line">        &#123;</span><br><span class="line">            Reserve(len + _size);</span><br><span class="line">        &#125;</span><br><span class="line">        for(int i = len + _size - 1; i &gt; pos + len - 1; i--)</span><br><span class="line">        &#123;</span><br><span class="line">            _str[i] = _str[i - len];        </span><br><span class="line">        &#125;</span><br><span class="line">        for(int i = pos; i &lt; pos + len; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            _str[i] = str[i - pos];</span><br><span class="line">        &#125;</span><br><span class="line">        _size += len;</span><br><span class="line">    &#125;</span><br><span class="line">    //+=运算符重载</span><br><span class="line">    String&amp; operator+=(char ch)</span><br><span class="line">    &#123;</span><br><span class="line">        Push_back(ch);</span><br><span class="line">    &#125;</span><br><span class="line">    String&amp; operator+=(const char* str)</span><br><span class="line">    &#123;</span><br><span class="line">        Append(str);</span><br><span class="line">    &#125;</span><br><span class="line">    //删除pos下标开始的npos个字符</span><br><span class="line">    void Erase(size_t pos, size_t npos)</span><br><span class="line">    &#123;</span><br><span class="line">        assert(pos &lt; _size);</span><br><span class="line">        for(int i = pos; i &lt; _size - npos; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            _str[i] = _str[i + npos];</span><br><span class="line">        &#125;</span><br><span class="line">        _size -= npos;</span><br><span class="line">        _str[_size] = &apos;\0&apos;;</span><br><span class="line">    &#125;</span><br><span class="line">    //从pos开始找第一个字符为ch返回其下标</span><br><span class="line">    size_t Find(const char ch, size_t pos = 0)</span><br><span class="line">    &#123;</span><br><span class="line">        assert(pos &lt; _size);</span><br><span class="line">        for(size_t i = pos; i &lt; _size; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            if(_str[i] == ch)</span><br><span class="line">            &#123;</span><br><span class="line">                return i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return npos;</span><br><span class="line">    &#125;</span><br><span class="line">    //从pos开始找第一个子串为str返回其下标</span><br><span class="line">    size_t Find(const char* str, size_t pos = 0)</span><br><span class="line">    &#123;</span><br><span class="line">        assert(pos &lt; _size);</span><br><span class="line">        for(size_t i = pos; i &lt; _size; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            if(_str[i] == str[0])</span><br><span class="line">            &#123;</span><br><span class="line">                int j = i;</span><br><span class="line">                while (j &lt; i + strlen(str) &amp;&amp; _str[j] != &apos;\0&apos;)</span><br><span class="line">                &#123;</span><br><span class="line">                    if (_str[j] != str[j - i])</span><br><span class="line">                    &#123;</span><br><span class="line">                        break;</span><br><span class="line">                    &#125;</span><br><span class="line">                    j++;</span><br><span class="line">                &#125;</span><br><span class="line">                //子串遍历完毕,子串与要查找的串完全匹配</span><br><span class="line">                if (j == i + strlen(str))</span><br><span class="line">                &#123;</span><br><span class="line">                    return i;</span><br><span class="line">                &#125;</span><br><span class="line">                //主串遇到结尾，长度不够不用继续查找了</span><br><span class="line">                else if(_str[j] == &apos;\0&apos;)</span><br><span class="line">                &#123;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">                //其他情况本次子串与要查找的串匹配不上，继续下一次子串查找</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return npos;</span><br><span class="line">    &#125;</span><br><span class="line">    //在尾部插入字符</span><br><span class="line">    void Push_back(char ch)</span><br><span class="line">    &#123;</span><br><span class="line">        Insert(_size, ch);</span><br><span class="line">    &#125;</span><br><span class="line">    //字符串拼接</span><br><span class="line">    void Append(const char* str)</span><br><span class="line">    &#123;</span><br><span class="line">        Insert(_size, str);</span><br><span class="line">    &#125;</span><br><span class="line">    //重新给容量，并且要求容量永远为8的整数倍</span><br><span class="line">    void Reserve(size_t n)</span><br><span class="line">    &#123;</span><br><span class="line">        if(n &gt; _capacity || (n == 0 &amp;&amp; _capacity == 0))</span><br><span class="line">        &#123;</span><br><span class="line">            size_t newCapacity = n;</span><br><span class="line">            if(newCapacity % 8 != 0)</span><br><span class="line">            &#123;</span><br><span class="line">                newCapacity = (((newCapacity / 8) + 1) * 8);</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">            &#123;</span><br><span class="line">                newCapacity += 8;</span><br><span class="line">            &#125;</span><br><span class="line">            char* newStr = new char[newCapacity];</span><br><span class="line">            if(newStr &amp;&amp; _str)</span><br><span class="line">            &#123;</span><br><span class="line">                strcpy(newStr, _str);</span><br><span class="line">            &#125;</span><br><span class="line">            //释放旧空间</span><br><span class="line">            delete[] _str;</span><br><span class="line">            _str = newStr;</span><br><span class="line">            _capacity = newCapacity - 1;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    void Resize(size_t size, char ch = &apos;\0&apos;)</span><br><span class="line">    &#123;</span><br><span class="line">        if(size &lt; _size)</span><br><span class="line">        &#123;</span><br><span class="line">            _size = size;</span><br><span class="line">            _str[_size] = &apos;\0&apos;;</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            Reserve(size);</span><br><span class="line">            for(size_t i = _size; i &lt; size; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                _str[i] = ch;</span><br><span class="line">            &#125;</span><br><span class="line">            _size = size;</span><br><span class="line">            _str[_size] = &apos;\0&apos;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    //&gt;运算符重载</span><br><span class="line">    bool operator&gt;(const String&amp; str)</span><br><span class="line">    &#123;</span><br><span class="line">        if(strcmp(_str, str._str) &gt; 0)</span><br><span class="line">        &#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    bool operator==(const String&amp; str)</span><br><span class="line">    &#123;</span><br><span class="line">        if(strcmp(_str, str._str) == 0)</span><br><span class="line">        &#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    bool operator&gt;=(const String&amp; str)</span><br><span class="line">    &#123;</span><br><span class="line">        if(*this &gt; str || *this == str)</span><br><span class="line">        &#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    bool operator&lt;(const String&amp; str)</span><br><span class="line">    &#123;</span><br><span class="line">        if(*this &gt;= str)</span><br><span class="line">        &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    bool operator&lt;=(const String&amp; str)</span><br><span class="line">    &#123;</span><br><span class="line">        if(*this &lt; str || *this == str)</span><br><span class="line">        &#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    bool operator!=(const String&amp; str)</span><br><span class="line">    &#123;</span><br><span class="line">        if(*this == str)</span><br><span class="line">        &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    //+运算符重载</span><br><span class="line">    String operator+(char ch)</span><br><span class="line">    &#123;</span><br><span class="line">        String temp(*this);</span><br><span class="line">        temp.Push_back(ch);</span><br><span class="line">        return temp;</span><br><span class="line">    &#125;</span><br><span class="line">    String operator+(const char* str)</span><br><span class="line">    &#123;</span><br><span class="line">        String temp(*this);</span><br><span class="line">        temp.Append(str);</span><br><span class="line">        return temp;</span><br><span class="line">    &#125;</span><br><span class="line">    //取类中的字符串</span><br><span class="line">    char* c_str()</span><br><span class="line">    &#123;</span><br><span class="line">        return _str;    </span><br><span class="line">    &#125;</span><br><span class="line">    //operator[]重载</span><br><span class="line">    char&amp; operator[](size_t pos)</span><br><span class="line">    &#123;</span><br><span class="line">        assert(pos &lt; _size);</span><br><span class="line">        return _str[pos];</span><br><span class="line">    &#125;</span><br><span class="line">    //operator[]重载</span><br><span class="line">    const char&amp; operator[](size_t pos) const</span><br><span class="line">    &#123;</span><br><span class="line">        assert(pos &lt; _size);</span><br><span class="line">        return _str[pos];</span><br><span class="line">    &#125;</span><br><span class="line">private:</span><br><span class="line">    char* _str;</span><br><span class="line">    size_t _size;</span><br><span class="line">    size_t _capacity;</span><br><span class="line">&#125;;</span><br><span class="line">std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, String str)</span><br><span class="line">&#123;</span><br><span class="line">	os &lt;&lt; str._str;</span><br><span class="line">	return os;</span><br><span class="line">&#125;</span><br><span class="line">size_t String::npos = -1;</span><br></pre></td></tr></table></figure></p>

          
        
      
    </div>
    
    
    

    

    <div>
    
    </div>

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/07/20/【算法】第一章-动态规划/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="MisakiFx">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/blog-logo.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Misaki`s blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/07/20/【算法】第一章-动态规划/" itemprop="url">【算法】第一章-动态规划</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-07-20T18:25:03+08:00">
                2019-07-20
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/算法/" itemprop="url" rel="index">
                    <span itemprop="name">算法</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  2.2k
                </span>
              

              

              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="第一章-动态规划"><a href="#第一章-动态规划" class="headerlink" title="第一章-动态规划"></a>第一章-动态规划</h1><h2 id="动态规划求解模式"><a href="#动态规划求解模式" class="headerlink" title="动态规划求解模式"></a>动态规划求解模式</h2><p>&emsp;&emsp;动态规划具备了一下三个特点：<br>&emsp;&emsp;1、把原来的问题分解成了几个相似子问题<br>&emsp;&emsp;2、所有的子问题只需要解决一次<br>&emsp;&emsp;3、储存子问题的解<br>&emsp;&emsp;从以下四个角度考虑：<br>&emsp;&emsp;1、初始状态定义<br>&emsp;&emsp;2、状态间转移方程<br>&emsp;&emsp;3、状态的初始化<br>&emsp;&emsp;4、返回结果<br>&emsp;&emsp;解决问题主要适用于：查找最优解，最大值/最小值，可不可行，是不是，方案个数</p>
<h2 id="例1-斐波那契数列"><a href="#例1-斐波那契数列" class="headerlink" title="例1 斐波那契数列"></a>例1 斐波那契数列</h2><p>&emsp;&emsp;牛客网:<br><a href="https://www.nowcoder.com/questionTerminal/c6c7742f5ba7442aada113136ddea0c3" target="_blank" rel="noopener">https://www.nowcoder.com/questionTerminal/c6c7742f5ba7442aada113136ddea0c3</a><br><br>&emsp;&emsp;动态规划解法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int Fibonacci(int n) &#123;</span><br><span class="line">        vector&lt;int&gt; ret(n + 1, 0);</span><br><span class="line">        //初始状态</span><br><span class="line">        ret[1] = ret[2] = 1;</span><br><span class="line">        //递推公式</span><br><span class="line">        //ret[i] = ret [i - 1] + ret[i - 2];</span><br><span class="line">        for(int i = 3; i &lt;= n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            ret[i] = ret[i - 1] + ret[i - 2];</span><br><span class="line">        &#125;</span><br><span class="line">        return ret[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h2 id="例2-变态青蛙跳台阶"><a href="#例2-变态青蛙跳台阶" class="headerlink" title="例2 变态青蛙跳台阶"></a>例2 变态青蛙跳台阶</h2><p>&emsp;&emsp;牛客网：<br><a href="https://www.nowcoder.com/questionTerminal/22243d016f6b47f2a6928b4313c85387" target="_blank" rel="noopener">https://www.nowcoder.com/questionTerminal/22243d016f6b47f2a6928b4313c85387</a><br></p>
<h3 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h3><h4 id="定义状态"><a href="#定义状态" class="headerlink" title="定义状态"></a>定义状态</h4><p>&emsp;&emsp;跳上i级台阶的方法数</p>
<h4 id="状态转移方程"><a href="#状态转移方程" class="headerlink" title="状态转移方程"></a>状态转移方程</h4><p>&emsp;&emsp;分解：<br>&emsp;&emsp;一次跳1级台阶：1， F(i - 1)<br>&emsp;&emsp;一次跳2级台阶：2， F(i - 2)<br>&emsp;&emsp;……<br>&emsp;&emsp;推得状态转移方程：<br>&emsp;&emsp;F(i) = F(i - 1) + F(i - 2) + … + F(1)<br>&emsp;&emsp;F(i - 1) = F(i - 2) + F(i - 3) + … + F(1)<br>&emsp;&emsp;F(i) = F(i - 1) + F(i - 1) = 2 * F(i - 1);</p>
<h4 id="初始状态和最终状态"><a href="#初始状态和最终状态" class="headerlink" title="初始状态和最终状态"></a>初始状态和最终状态</h4><p>&emsp;&emsp;F(1) = 1,求F(n)。</p>
<h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int jumpFloorII(int number) &#123;</span><br><span class="line">        //初始状态</span><br><span class="line">        int f1 = 1;</span><br><span class="line">        //状态转移方程：F(i) = 2 * F(i - 1)</span><br><span class="line">        for(int i = 2; i &lt;= number; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            f1 = 2 * f1;</span><br><span class="line">        &#125;</span><br><span class="line">        return f1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h3><p>&emsp;&emsp;根据状态转移方程我们可以得知，<code>F(n) = 2 ^ (n - 1)</code>;所以可以得到优化：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int jumpFloorII(int number) &#123;</span><br><span class="line">        return (1 &lt;&lt; (number - 1));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h2 id="例3-求连续最大子数组的和"><a href="#例3-求连续最大子数组的和" class="headerlink" title="例3 求连续最大子数组的和"></a>例3 求连续最大子数组的和</h2><p>&emsp;&emsp;牛客网：</p>
<p><a href="https://www.nowcoder.com/questionTerminal/459bd355da1549fa8a49e350bf3df484" target="_blank" rel="noopener">https://www.nowcoder.com/questionTerminal/459bd355da1549fa8a49e350bf3df484</a></p>
<h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><h4 id="定义状态-1"><a href="#定义状态-1" class="headerlink" title="定义状态"></a>定义状态</h4><p>&emsp;&emsp;到此项为止前i项的连续子序列的最大和</p>
<h4 id="状态转移方程-1"><a href="#状态转移方程-1" class="headerlink" title="状态转移方程"></a>状态转移方程</h4><p>&emsp;&emsp;F(i) = max(F(i - 1) + a[i], a[i]);</p>
<h4 id="初始状态和最终状态-1"><a href="#初始状态和最终状态-1" class="headerlink" title="初始状态和最终状态"></a>初始状态和最终状态</h4><p>&emsp;&emsp;初始状态F[0] = a[0]。<br>&emsp;&emsp;最终结果max(F[i])。</p>
<h3 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int FindGreatestSumOfSubArray(vector&lt;int&gt; array) &#123;</span><br><span class="line">        if(array.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        vector&lt;int&gt; ret(array.size(), 0);</span><br><span class="line">        //初始状态</span><br><span class="line">        ret[0] = array[0];</span><br><span class="line">        //状态转移</span><br><span class="line">        for(int i = 1; i &lt; array.size(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            ret[i] = max(array[i] + ret[i - 1], array[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        //求max(F[i])</span><br><span class="line">        int maxNum = ret[0];</span><br><span class="line">        for(int i = 0; i &lt; ret.size(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            maxNum = max(maxNum, ret[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        return maxNum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="例4-word-break-字符串分割"><a href="#例4-word-break-字符串分割" class="headerlink" title="例4 word-break(字符串分割)"></a>例4 word-break(字符串分割)</h2><p>&emsp;&emsp;牛客网：<br><a href="https://www.nowcoder.com/questionTerminal/5f3b7bf611764c8ba7868f3ed40d6b2c" target="_blank" rel="noopener">https://www.nowcoder.com/questionTerminal/5f3b7bf611764c8ba7868f3ed40d6b2c</a></p>
<h3 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h3><h4 id="定义状态-2"><a href="#定义状态-2" class="headerlink" title="定义状态"></a>定义状态</h4><p>&emsp;&emsp;F(i)：前i个字符能否被分割。</p>
<h4 id="状态转移方程-2"><a href="#状态转移方程-2" class="headerlink" title="状态转移方程"></a>状态转移方程</h4><p>&emsp;&emsp;F(i): F(i)能否被分割取决于前j项能否被分割和j + 1到第i项能否被分割。（此处j取0 ~ i - 1）<br>&emsp;&emsp;得递推方程F(i) : F(j) &amp;&amp; (j + 1 ~ i)能否被分割</p>
<h4 id="初始状态和最终状态-2"><a href="#初始状态和最终状态-2" class="headerlink" title="初始状态和最终状态"></a>初始状态和最终状态</h4><p>&emsp;&emsp;初始状态：F(0) = true。<br>&emsp;&emsp;最终状态F(n)。</p>
<h3 id="实现-2"><a href="#实现-2" class="headerlink" title="实现"></a>实现</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool wordBreak(string s, unordered_set&lt;string&gt; &amp;dict) &#123;</span><br><span class="line">        if(s.empty() || dict.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        vector&lt;bool&gt; Fn(s.size() + 1, false);</span><br><span class="line">        //初始状态</span><br><span class="line">        Fn[0] = true;</span><br><span class="line">        for(int i = 1; i &lt;= s.size(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            //状态转移</span><br><span class="line">            //F(i) = F(j) &amp;&amp; (j + 1 ~ i), (0 &lt;= j &lt; i)能否被分割</span><br><span class="line">            for(int j = i - 1; j &gt;= 0; j--)</span><br><span class="line">            &#123;</span><br><span class="line">                if(Fn[j] &amp;&amp; dict.find(s.substr(j, i - j)) != dict.end())</span><br><span class="line">                &#123;</span><br><span class="line">                    Fn[i] = true;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        //最终状态</span><br><span class="line">        return Fn[s.size()];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="例5-triangle-三角矩阵最短路"><a href="#例5-triangle-三角矩阵最短路" class="headerlink" title="例5 triangle(三角矩阵最短路)"></a>例5 triangle(三角矩阵最短路)</h2><p>&emsp;&emsp;牛客网：<br><a href="https://www.nowcoder.com/questionTerminal/2b7995aa4f7949d99674d975489cb7da" target="_blank" rel="noopener">https://www.nowcoder.com/questionTerminal/2b7995aa4f7949d99674d975489cb7da</a></p>
<h3 id="分析-2"><a href="#分析-2" class="headerlink" title="分析"></a>分析</h3><h4 id="定义状态-3"><a href="#定义状态-3" class="headerlink" title="定义状态"></a>定义状态</h4><p>&emsp;&emsp;F[i][j]: 从(0, 0)到(i, j)的最短路径和。</p>
<h4 id="状态转移方程-3"><a href="#状态转移方程-3" class="headerlink" title="状态转移方程"></a>状态转移方程</h4><p>&emsp;&emsp;一般情况下，走到每个位置的最短路径都可以看作是上一行相邻两个位置的最短路径+这个位置的路径长度，数学描述：F[i][j]:min(F[i - 1][j], F[i - 1][j - 1]) + a[i][j]。<br>&emsp;&emsp;但要考虑边界状态：当在矩阵边缘时只有一种选择的情况，即F[i][0] = F[i - 1][0];F[i][i] = F[i - 1][i - 1]。</p>
<h4 id="初始状态和最终状态-3"><a href="#初始状态和最终状态-3" class="headerlink" title="初始状态和最终状态"></a>初始状态和最终状态</h4><p>&emsp;&emsp;初始状态：F[0][0] = a[0][0]。<br>&emsp;&emsp;最终状态：min(F[n - 1][j])，即最后一行中的最小值。</p>
<h3 id="实现-3"><a href="#实现-3" class="headerlink" title="实现"></a>实现</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int minimumTotal(vector&lt;vector&lt;int&gt; &gt; &amp;triangle) &#123;</span><br><span class="line">        if(triangle.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        //初始状态</span><br><span class="line">        vector&lt;vector&lt;int&gt;&gt; ret(triangle);</span><br><span class="line">        //状态转移</span><br><span class="line">        int row = ret.size();</span><br><span class="line">        for(int i = 1; i &lt; row; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            ret[i][0] = ret[i - 1][0] + triangle[i][0];</span><br><span class="line">        &#125;</span><br><span class="line">        for(int i = 1; i &lt; row; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            ret[i][i] = ret[i - 1][i - 1] + triangle[i][i];</span><br><span class="line">        &#125;</span><br><span class="line">        for(int i = 1; i &lt; row; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            for(int j = 1; j &lt; i; ++j)</span><br><span class="line">            &#123;</span><br><span class="line">                ret[i][j] = min(ret[i - 1][j], ret[i - 1][j - 1]) + triangle[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        //最终状态</span><br><span class="line">        int minSum = ret[row - 1][0];</span><br><span class="line">        for(int i = 1; i &lt; row; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            minSum = min(minSum, ret[row - 1][i]);</span><br><span class="line">        &#125;</span><br><span class="line">        return minSum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="例6-求路径数量"><a href="#例6-求路径数量" class="headerlink" title="例6 求路径数量"></a>例6 求路径数量</h2><p>牛客网：<br><a href="https://www.nowcoder.com/questionTerminal/3cdf08dd4e974260921b712f0a5c8752" target="_blank" rel="noopener">https://www.nowcoder.com/questionTerminal/3cdf08dd4e974260921b712f0a5c8752</a></p>
<h3 id="分析-3"><a href="#分析-3" class="headerlink" title="分析"></a>分析</h3><h4 id="状态定义"><a href="#状态定义" class="headerlink" title="状态定义"></a>状态定义</h4><p>&emsp;&emsp;F[i][j]：从左上角到达下标(i, j)的路径总数</p>
<h4 id="状态转移方程-4"><a href="#状态转移方程-4" class="headerlink" title="状态转移方程"></a>状态转移方程</h4><p>&emsp;&emsp;if(a[i][j] == 1) F[i][j] = 0;<br>&emsp;&emsp;if(a[i][j] == 0) F[i][j] = F[i][j - 1] + F[i - 1][j]。</p>
<h4 id="初始状态和最终状态-4"><a href="#初始状态和最终状态-4" class="headerlink" title="初始状态和最终状态"></a>初始状态和最终状态</h4><p>&emsp;&emsp;初始状态：如果第一行第一列有障碍物表示这条路走不通则路径数置0，否则只有一条路径，置一if(a[0][j]) == 1) F[0][j] = 0，if(a[i][0] == 1) F[i][0] = 0，这种情况下这条路走不通。<br>&emsp;&emsp;最终状态：F[i][j]。</p>
<h3 id="实现-4"><a href="#实现-4" class="headerlink" title="实现"></a>实现</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int uniquePathsWithObstacles(vector&lt;vector&lt;int&gt; &gt; &amp;obstacleGrid) &#123;</span><br><span class="line">        if(obstacleGrid.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        if(obstacleGrid[0][0] == 1)</span><br><span class="line">        &#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        int row = obstacleGrid.size();</span><br><span class="line">        int col = obstacleGrid[0].size();</span><br><span class="line">        vector&lt;vector&lt;int&gt;&gt; pathNum(row, vector&lt;int&gt;(col, 0));</span><br><span class="line">        for(int i = 0; i &lt; row; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            if(obstacleGrid[i][0] == 1)</span><br><span class="line">            &#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">            &#123;</span><br><span class="line">                pathNum[i][0] = 1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        for(int i = 0; i &lt; col; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            if(obstacleGrid[0][i] == 1)</span><br><span class="line">            &#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            else </span><br><span class="line">            &#123;</span><br><span class="line">                pathNum[0][i] = 1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        for(int i = 1; i &lt; row; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            for(int j = 1; j &lt; col; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                if(obstacleGrid[i][j] == 1)</span><br><span class="line">                &#123;</span><br><span class="line">                    pathNum[i][j] = 0;</span><br><span class="line">                &#125;</span><br><span class="line">                else</span><br><span class="line">                &#123;</span><br><span class="line">                    pathNum[i][j] = pathNum[i][j - 1] + pathNum[i - 1][j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return pathNum[row - 1][col - 1];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="例7-背包问题"><a href="#例7-背包问题" class="headerlink" title="例7 背包问题"></a>例7 背包问题</h2><p>&emsp;&emsp;lintcode：<br><a href="https://www.lintcode.com/problem/backpack-ii/description" target="_blank" rel="noopener">https://www.lintcode.com/problem/backpack-ii/description</a></p>
<h3 id="分析-4"><a href="#分析-4" class="headerlink" title="分析"></a>分析</h3><p>&emsp;&emsp;背包问题是一类问题，主要是求解约束条件下的最优解问题。</p>
<h4 id="状态定义-1"><a href="#状态定义-1" class="headerlink" title="状态定义"></a>状态定义</h4><p>&emsp;&emsp;F[i][j]：前i个商品，包的重量为j的最大价值。定义二维数组遍历所有商品，和到当前商品情况下背包容量从0 - max的所有情况下的最大值求解，遍历到最后则可得到n个全部商品情况下背包最大容量max下背包可拿的最大价值F[n][max]。</p>
<h4 id="状态转移方程-5"><a href="#状态转移方程-5" class="headerlink" title="状态转移方程"></a>状态转移方程</h4><p>&emsp;&emsp;当前商品空间大于包能承受的总空间，放不下直接跳过。数学描述：if(w[i] &gt; j) F[i][j] = F[i - 1][j]。<br>&emsp;&emsp;当前商品空间小于等于包能承受总空间，可以选择放可以选择不放，如果不放入，则F[i][j] = F[i - 1][j]；如果放入，则当前重量等于遍历到的上一个商品并且空间还有w[i]这么大的时候的价值+本商品的价值，最大价值F[i][j] = F[i - 1][j - w[i]] + v[i]，选择放入或不放入商品情况中的最大值作为最优解。数学描述：if(w[i] &lt;= j) max(F[i - 1][j], F[i - 1][j - w[i]] + v[i]);</p>
<h4 id="初始状态和最终状态-5"><a href="#初始状态和最终状态-5" class="headerlink" title="初始状态和最终状态"></a>初始状态和最终状态</h4><p>&emsp;&emsp;初始状态：没有商品时，F[0][j] = 0,最大容量为0时F[i][0] = 0。<br>&emsp;&emsp;最终状态：遍历完全部n个商品，并且背包总容量为最大值m时得到最大价值F[n][m]。</p>
<h3 id="实现-5"><a href="#实现-5" class="headerlink" title="实现"></a>实现</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    /**</span><br><span class="line">     * @param m: An integer m denotes the size of a backpack</span><br><span class="line">     * @param A: Given n items with size A[i]</span><br><span class="line">     * @param V: Given n items with value V[i]</span><br><span class="line">     * @return: The maximum value</span><br><span class="line">     */</span><br><span class="line">    int backPackII(int m, vector&lt;int&gt; &amp;A, vector&lt;int&gt; &amp;V) &#123;</span><br><span class="line">        if(A.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        int row = A.size();</span><br><span class="line">        vector&lt;vector&lt;int&gt;&gt; maxValue(row + 1, vector&lt;int&gt;(m + 1, 0));</span><br><span class="line">        for(int i = 1; i &lt;= row; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            for(int j = 1; j &lt;= m; ++j)</span><br><span class="line">            &#123;</span><br><span class="line">                if(A[i - 1] &gt; j)</span><br><span class="line">                &#123;</span><br><span class="line">                    maxValue[i][j] = maxValue[i - 1][j];</span><br><span class="line">                &#125;</span><br><span class="line">                else</span><br><span class="line">                &#123;</span><br><span class="line">                    maxValue[i][j] = max(maxValue[i - 1][j], maxValue[i - 1][j - A[i - 1]] + V[i - 1]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return maxValue[row][m];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
          
        
      
    </div>
    
    
    

    

    <div>
    
    </div>

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/07/15/【Cpp】第四章-模板初阶/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="MisakiFx">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/blog-logo.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Misaki`s blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/07/15/【Cpp】第四章-模板初阶/" itemprop="url">【Cpp】第四章-模板初阶</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-07-15T20:10:18+08:00">
                2019-07-15
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Cpp/" itemprop="url" rel="index">
                    <span itemprop="name">Cpp</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  1.7k
                </span>
              

              

              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="模板初阶"><a href="#模板初阶" class="headerlink" title="模板初阶"></a>模板初阶</h1><h2 id="泛型编程"><a href="#泛型编程" class="headerlink" title="泛型编程"></a>泛型编程</h2><p>&emsp;&emsp;在我们进行大型程序的编写时往往会遇到一类问题，同一个函数或类我们希望多种类型数据传入时都能完成类似或者相同的功能，但是在C语言中我们很难做到这一点因为我们往往在换了一个数据类型后就要重新写一遍函数，这样耽误我们大量的时间，呢么有没有一种语法在Cpp中能够使让我们的代码成为一种模板，不同的数据类型传入也依然能够执行类似的功能呢？<br><br>&emsp;&emsp;正所谓世界是由懒人创造的，于是在C++中引入了模板这一概念，同时也正得益与此使我们可以做到<strong>泛型编程</strong>，是我们的代码极大程度的可以复用。</p>
<h2 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h2><p>&emsp;&emsp;模板是实现泛型编程的基础，其中又可细分为<strong>函数模板</strong>和<strong>类模板</strong>。</p>
<h3 id="函数模板"><a href="#函数模板" class="headerlink" title="函数模板"></a>函数模板</h3><p>&emsp;&emsp;函数模板是生成一个家族的函数，其中我们可以使用任意类型的参数进行传入。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">//定义函数模板,T为任意类型</span><br><span class="line">//class 也可替换为 typename</span><br><span class="line">template&lt;class T&gt;</span><br><span class="line">void Swap(T&amp; a, T&amp; b)</span><br><span class="line">&#123;</span><br><span class="line">    T t = a;</span><br><span class="line">    a = b;</span><br><span class="line">    b = t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int a = 4, b = 5;</span><br><span class="line">    double c = 6, d = 7;</span><br><span class="line">    Swap(a, b);</span><br><span class="line">    Swap(c, d);</span><br><span class="line">    cout &lt;&lt; a &lt;&lt; &quot; &quot; &lt;&lt; b &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; c &lt;&lt; &quot; &quot; &lt;&lt; d &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">5 4</span><br><span class="line">7 6</span><br></pre></td></tr></table></figure></p>
<h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><p>&emsp;&emsp;函数模板在定义完之后并不会直接生成函数，而是在调用时会根据传参类型进行推演，在上面的例子中我们传入了<code>int</code>类型的参数因此在推演时会将<code>T</code>转换为<code>int</code>再进行调用，但有时我们的调用如果出现了让编译器无法推演的情况就会导致报错。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">template&lt;class T&gt;</span><br><span class="line">void Swap(T&amp; a, T&amp; b)</span><br><span class="line">&#123;</span><br><span class="line">    T t = a;</span><br><span class="line">    a = b;</span><br><span class="line">    b = t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int a = 4, b = 5;</span><br><span class="line">    double c = 6, d = 7;</span><br><span class="line">    Swap(a, d);</span><br><span class="line">    Swap(c, b);</span><br><span class="line">    cout &lt;&lt; a &lt;&lt; &quot; &quot; &lt;&lt; b &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; c &lt;&lt; &quot; &quot; &lt;&lt; d &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">.\test.cpp: In function &apos;int main()&apos;:</span><br><span class="line">.\test.cpp:15:14: error: no matching function for call to &apos;Swap(int&amp;, double&amp;)&apos;</span><br><span class="line">     Swap(a, d);</span><br><span class="line">              ^</span><br><span class="line">.\test.cpp:4:6: note: candidate: template&lt;class T&gt; void Swap(T&amp;, T&amp;)</span><br><span class="line"> void Swap(T&amp; a, T&amp; b)</span><br><span class="line">      ^~~~</span><br><span class="line">.\test.cpp:4:6: note:   template argument deduction/substitution failed:</span><br><span class="line">.\test.cpp:15:14: note:   deduced conflicting types for parameter &apos;T&apos; (&apos;int&apos; and &apos;double&apos;)</span><br><span class="line">     Swap(a, d);</span><br><span class="line">              ^</span><br><span class="line">.\test.cpp:16:14: error: no matching function for call to &apos;Swap(double&amp;, int&amp;)&apos;</span><br><span class="line">     Swap(c, b);</span><br><span class="line">              ^</span><br><span class="line">.\test.cpp:4:6: note: candidate: template&lt;class T&gt; void Swap(T&amp;, T&amp;)</span><br><span class="line"> void Swap(T&amp; a, T&amp; b)</span><br><span class="line">      ^~~~</span><br><span class="line">.\test.cpp:4:6: note:   template argument deduction/substitution failed:</span><br><span class="line">.\test.cpp:16:14: note:   deduced conflicting types for parameter &apos;T&apos; (&apos;double&apos; and &apos;int&apos;)</span><br><span class="line">     Swap(c, b);</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;我们会发现在这样只有一个模板参数<code>T</code>进行多类型传入就会混淆编译器，导致报错，因此我们可以定义多个模板参数，也可以进行强转使参数类型唯一，不过这里要提到另一种可以让编译器推演出我们想要的函数的方式，<strong>显示实例化</strong>。</p>
<h4 id="显示实例化"><a href="#显示实例化" class="headerlink" title="显示实例化"></a>显示实例化</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">template&lt;class T&gt;</span><br><span class="line">T Add(T a, T b)</span><br><span class="line">&#123;</span><br><span class="line">    return a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int ret = Add&lt;int&gt;(1, 2);</span><br><span class="line">    cout &lt;&lt; ret &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">3</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;像是这样的情况我们就利用显示实例化给我们的函数模板制定了实例化类型，同时如果类型不匹配，编译器会进行隐式类型转换，如果转换不成功则会报错。</p>
<h4 id="函数模板匹配原则"><a href="#函数模板匹配原则" class="headerlink" title="函数模板匹配原则"></a>函数模板匹配原则</h4><p>&emsp;&emsp;函数模板可以与非模板函数重名，此时会构成类似于函数重载的情况，并且在函数调用时如果出现重名的函数模板和非模板函数都可以构成匹配则会优先调用非模板函数，而不会对函数模板进行实例化，除非我们利用显示实例化指定必须调用模板函数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">template&lt;class T&gt;</span><br><span class="line">T Add(T a, T b)</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; &quot;template function&quot; &lt;&lt; endl;</span><br><span class="line">    return a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int Add(int a, int b)</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; &quot;simple function&quot; &lt;&lt; endl;</span><br><span class="line">    return a + b;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int ret = Add(1, 2);//调用普通函数</span><br><span class="line">    ret = Add&lt;int&gt;(1, 2);//调用模板函数</span><br><span class="line">    cout &lt;&lt; ret &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">simple function</span><br><span class="line">template function</span><br><span class="line">3</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;但是如果模板函数此时可以提供更好的适配性，则会优先调用模板函数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">template&lt;class T1, class T2&gt;</span><br><span class="line">T1 Add(T1 a, T2 b)</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; &quot;template function&quot; &lt;&lt; endl;</span><br><span class="line">    return a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int Add(int a, int b)</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; &quot;simple function&quot; &lt;&lt; endl;</span><br><span class="line">    return a + b;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int ret = Add(1, 2.0);//优先调用函数模板</span><br><span class="line">    ret = Add&lt;int, double&gt;(1, 2.0);</span><br><span class="line">    cout &lt;&lt; ret &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">template function</span><br><span class="line">template function</span><br><span class="line">3</span><br></pre></td></tr></table></figure></p>
<h3 id="类模板"><a href="#类模板" class="headerlink" title="类模板"></a>类模板</h3><p>&emsp;&emsp;类模板与函数模板类似，是使用一个模板参数来构造整个类，并且原理也与函数模板类似，只有在类构造对象时才会推演模板参数进行实例化，实例化出我们想要的类。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;assert.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">template&lt;class T&gt;</span><br><span class="line">class Vector</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    Vector(size_t capacity = 10)</span><br><span class="line">        :_pData(new T[capacity])</span><br><span class="line">        ,_size(0)</span><br><span class="line">        ,_capacity(capacity)</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    ~Vector();</span><br><span class="line">    //返回size</span><br><span class="line">    size_t Size()</span><br><span class="line">    &#123;</span><br><span class="line">        return _size;</span><br><span class="line">    &#125;</span><br><span class="line">    //尾插</span><br><span class="line">    void Push_back(const T&amp; data)</span><br><span class="line">    &#123;</span><br><span class="line">        //检查扩容</span><br><span class="line">        if(_size &gt;= _capacity)</span><br><span class="line">        &#123;//扩容</span><br><span class="line">            Reserve(2 * _capacity);</span><br><span class="line">        &#125;</span><br><span class="line">        _pData[_size] = data;</span><br><span class="line">        _size++;</span><br><span class="line">    &#125;</span><br><span class="line">    //尾删</span><br><span class="line">    void Pop_back()</span><br><span class="line">    &#123;</span><br><span class="line">        _size--;</span><br><span class="line">    &#125;</span><br><span class="line">    //改变容量</span><br><span class="line">    void Reserve(int capacity)</span><br><span class="line">    &#123;</span><br><span class="line">        if(capacity &lt;= _capacity)</span><br><span class="line">        &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        T* newPData = new T[capacity];</span><br><span class="line">        for(int i = 0; i &lt; _size; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            newPData[i] = _pData[i];</span><br><span class="line">        &#125;</span><br><span class="line">        _pData = newPData;</span><br><span class="line">        _capacity = capacity;</span><br><span class="line">    &#125;</span><br><span class="line">    T operator[](size_t pos)</span><br><span class="line">    &#123;</span><br><span class="line">        assert(pos &lt; _size);</span><br><span class="line">        return _pData[pos];</span><br><span class="line">    &#125;</span><br><span class="line">private:</span><br><span class="line">    T* _pData;</span><br><span class="line">    size_t _size;</span><br><span class="line">    size_t _capacity;</span><br><span class="line">&#125;;</span><br><span class="line">//在类外进行函数声明时要加上模板参数</span><br><span class="line">//同时要注意Vector不是一个类，实例化后Vector&lt;T&gt;才是一个类</span><br><span class="line">template&lt;class T&gt;</span><br><span class="line">Vector&lt;T&gt;::~Vector()</span><br><span class="line">&#123;</span><br><span class="line">    if(_pData)</span><br><span class="line">    &#123;</span><br><span class="line">        delete[] _pData;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    Vector&lt;int&gt; arr;</span><br><span class="line">    arr.Push_back(1);</span><br><span class="line">    arr.Push_back(2);</span><br><span class="line">    for(int i = 0; i &lt; arr.Size(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; arr[i] &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1</span><br><span class="line">2</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;这个例子我们模拟简单实现了一个<code>vector</code>模板类，并且使用实例化进行使用，类模板与函数模板不同的是类模板往往无法推演出模板参数类型因此需要我们显示实例化使其实例化为一个具体的类才可以进行使用。</p>

          
        
      
    </div>
    
    
    

    

    <div>
    
    </div>

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/06/11/【Cpp】第三章-内存管理/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="MisakiFx">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/blog-logo.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Misaki`s blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/06/11/【Cpp】第三章-内存管理/" itemprop="url">【Cpp】第三章-内存管理</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-06-11T01:34:08+08:00">
                2019-06-11
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Cpp/" itemprop="url" rel="index">
                    <span itemprop="name">Cpp</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  2.6k
                </span>
              

              

              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h1><h2 id="C-内存管理"><a href="#C-内存管理" class="headerlink" title="C++内存管理"></a>C++内存管理</h2><p>&emsp;&emsp;在C语言中，我们想要动态分配内存空间需要使用到<code>malloc,calloc,realloc</code>函数，在C++中我们同样有动态进行内存管理的方式，并且与C语言中的内存管理有着一些区别。</p>
<h3 id="new-delete"><a href="#new-delete" class="headerlink" title="new/delete"></a>new/delete</h3><p>&emsp;&emsp;在C++中我们使用<code>new</code>进行内存的申请，用<code>delete</code>进行内存的释放。他们的使用比<code>malloc</code>和<code>free</code>更加简单方便。</p>
<h4 id="内置类型的内存分配与释放"><a href="#内置类型的内存分配与释放" class="headerlink" title="内置类型的内存分配与释放"></a>内置类型的内存分配与释放</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">  int* a = new int;</span><br><span class="line">  //等同于int* a = (int*)malloc(sizeof(int));</span><br><span class="line">  int* b = new int[10];</span><br><span class="line">  //等同于int* b = (int*)malloc(sizeof(int) * 10);</span><br><span class="line">  int* c = new int(10);</span><br><span class="line">  //new还可以进行内置类型的初始化</span><br><span class="line">  cout &lt;&lt; *c &lt;&lt; endl;</span><br><span class="line">  delete a;</span><br><span class="line">  //等同于free(a);</span><br><span class="line">  delete[] b;//对于多个变量的空间释放要用delete[]</span><br><span class="line">  //等同于free(b);</span><br><span class="line">  delete c;</span><br><span class="line">  //等同于free(c);                                </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[misaki@localhost 第三章-内存管理]$ ./New</span><br><span class="line">10</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;<code>new</code>和<code>malloc</code>一样会在堆上开辟空间同时需要我们手动进行内存的释放，但是<code>new</code>的写法更加简单易于理解同时我们还可以对单个申请的变量进行初始化。</p>
<h4 id="自定义类型的内存分配与释放"><a href="#自定义类型的内存分配与释放" class="headerlink" title="自定义类型的内存分配与释放"></a>自定义类型的内存分配与释放</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;                                 </span><br><span class="line">#include &lt;stdlib.h&gt;  </span><br><span class="line">using namespace std;                           </span><br><span class="line">class Stu                </span><br><span class="line">&#123;                                                   </span><br><span class="line">  public:                </span><br><span class="line">    Stu()                          </span><br><span class="line">    &#123;                  </span><br><span class="line">      cout &lt;&lt; &quot;default building&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;;              </span><br><span class="line">    Stu(int num, string name):_num(num), _name(name)</span><br><span class="line">    &#123;               </span><br><span class="line">      cout &lt;&lt; &quot;custom building&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;               </span><br><span class="line">    ~Stu()                  </span><br><span class="line">    &#123;                                </span><br><span class="line">      cout &lt;&lt; &quot;destroying&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;                         </span><br><span class="line">  private:                  </span><br><span class="line">    int _num;                            </span><br><span class="line">    string _name;        </span><br><span class="line">&#125;;                    </span><br><span class="line">int main()</span><br><span class="line">&#123;         </span><br><span class="line">  cout &lt;&lt; &quot;malloc:&quot; &lt;&lt; endl;</span><br><span class="line">  Stu* a = (Stu*)malloc(sizeof(Stu));</span><br><span class="line">  cout &lt;&lt; &quot;new:&quot; &lt;&lt; endl;</span><br><span class="line">  Stu* b = new Stu(1, &quot;张三&quot;);</span><br><span class="line">  cout &lt;&lt; &quot;malloc:&quot; &lt;&lt; endl;</span><br><span class="line">  Stu* c = (Stu*)malloc(sizeof(Stu) * 5);</span><br><span class="line">  cout &lt;&lt; &quot;new:&quot; &lt;&lt; endl;</span><br><span class="line">  Stu* d = new Stu[5];</span><br><span class="line">  cout &lt;&lt; &quot;free:&quot; &lt;&lt; endl;</span><br><span class="line">  free(a);</span><br><span class="line">  cout &lt;&lt; &quot;delete:&quot; &lt;&lt; endl;</span><br><span class="line">  delete b;</span><br><span class="line">  cout &lt;&lt; &quot;free:&quot; &lt;&lt; endl;</span><br><span class="line">  free(c);</span><br><span class="line">  cout &lt;&lt; &quot;delete:&quot; &lt;&lt; endl;</span><br><span class="line">  delete[] d;</span><br><span class="line">&#125;              </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[misaki@localhost 第三章-内存管理]$ ./New </span><br><span class="line">malloc:</span><br><span class="line">new:</span><br><span class="line">custom building</span><br><span class="line">malloc:</span><br><span class="line">new:</span><br><span class="line">default building</span><br><span class="line">default building</span><br><span class="line">default building</span><br><span class="line">default building</span><br><span class="line">default building</span><br><span class="line">free:</span><br><span class="line">delete:</span><br><span class="line">destroying</span><br><span class="line">free:</span><br><span class="line">delete:</span><br><span class="line">destroying</span><br><span class="line">destroying</span><br><span class="line">destroying</span><br><span class="line">destroying</span><br><span class="line">destroying</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;以上这段代码我分别使用<code>malloc</code>和<code>new</code>对自定义类型进行内存分配和释放，我们可以发现<code>new</code>不但可以在分配内存的时候手动调用指定的构造函数还会在分配多个对象的空间时自动调用默认构造函数，<code>delete</code>也会自动调用析构函数，而<code>malloc</code>和<code>free</code>却做不到这一点。因此可以理解<strong>为<code>malloc</code>和<code>free</code>分配出来的只不过是一个和类一样大小的空间，并不能称作是一个对象，而<code>new</code>和<code>delete</code>分配出来的才能被成为对象</strong>。</p>
<h2 id="new和delete实现原理"><a href="#new和delete实现原理" class="headerlink" title="new和delete实现原理"></a>new和delete实现原理</h2><p>&emsp;&emsp;<code>new</code>和<code>delete</code>在C++中其实被定义为两个运算符，我们在使用这两个运算符的时候它会在底层调用全局函数<code>operator new</code>和<code>operator delete</code>。</p>
<h3 id="operator-new-operator-delete"><a href="#operator-new-operator-delete" class="headerlink" title="operator new/operator delete"></a>operator new/operator delete</h3><p>&emsp;&emsp;我们首先看下这两个函数在底层的实现源码。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">void *__CRTDECL operator new(size_t size) _THROW1(_STD bad_alloc)</span><br><span class="line">&#123;</span><br><span class="line"> // try to allocate size bytes</span><br><span class="line"> void *p;</span><br><span class="line"> while ((p = malloc(size)) == 0)</span><br><span class="line"> if (_callnewh(size) == 0)</span><br><span class="line"> &#123;</span><br><span class="line"> // report no memory</span><br><span class="line"> // 如果申请内存失败了，这里会抛出bad_alloc 类型异常</span><br><span class="line"> static const std::bad_alloc nomem;</span><br><span class="line"> _RAISE(nomem);</span><br><span class="line"> &#125;</span><br><span class="line"> return (p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">void operator delete(void *pUserData)</span><br><span class="line">&#123;</span><br><span class="line"> _CrtMemBlockHeader * pHead;</span><br><span class="line"> RTCCALLBACK(_RTC_Free_hook, (pUserData, 0));</span><br><span class="line"> if (pUserData == NULL)</span><br><span class="line"> return;</span><br><span class="line">  _mlock(_HEAP_LOCK); /* block other threads */</span><br><span class="line"> __TRY</span><br><span class="line"> /* get a pointer to memory block header */</span><br><span class="line"> pHead = pHdr(pUserData);</span><br><span class="line"> /* verify block type */</span><br><span class="line"> _ASSERTE(_BLOCK_TYPE_IS_VALID(pHead-&gt;nBlockUse));</span><br><span class="line"> _free_dbg( pUserData, pHead-&gt;nBlockUse );</span><br><span class="line"> __FINALLY</span><br><span class="line"> _munlock(_HEAP_LOCK); /* release other threads */</span><br><span class="line"> __END_TRY_FINALLY</span><br><span class="line"> return;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;从源码中能看出的是<code>operator new</code>和<code>operator delete</code>在底层也是利用<code>malloc</code>和<code>free</code>分配内存的，因此可以说<code>new</code>和<code>delete</code>不过是<code>malloc</code>和<code>free</code>的一层封装。因此在某些情况下，我们想要用独特的方式给一个类分配内存空间的时候我们就可以重新重载这两个运算符来达到我们的目的。基于这个原理如果有某些类需要特殊的内存分配方式我们可以对其进行运算符的重载。</p>
<h3 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h3><h4 id="内置类型"><a href="#内置类型" class="headerlink" title="内置类型"></a>内置类型</h4><p>&emsp;&emsp;对于内置类型来说<code>new</code>和<code>malloc</code>,<code>delete</code>和<code>free</code>的功能一致，不同的是<code>new[]</code>和<code>delete[]</code>才能分配多个连续的空间。</p>
<h4 id="自定义类型"><a href="#自定义类型" class="headerlink" title="自定义类型"></a>自定义类型</h4><h5 id="单个元素空间分配"><a href="#单个元素空间分配" class="headerlink" title="单个元素空间分配"></a>单个元素空间分配</h5><p>&emsp;&emsp;1、<strong>new</strong>:<br><br>&emsp;&emsp;&emsp;&emsp;1)首先调用<code>operator new</code>为对象分配空间。<br><br>&emsp;&emsp;&emsp;&emsp;2)调用对象的构造函数对对象进行初始化。<br><br>&emsp;&emsp;2、<strong>delete</strong>:<br><br>&emsp;&emsp;&emsp;&emsp;1)调用对象的析构函数进行对象中资源的空间清理。<br><br>&emsp;&emsp;&emsp;&emsp;2)调用<code>operator delete</code>释放对象的空间。</p>
<h5 id="多个元素空间分配"><a href="#多个元素空间分配" class="headerlink" title="多个元素空间分配"></a>多个元素空间分配</h5><p>&emsp;&emsp;1、<strong>new[]</strong>:<br><br>&emsp;&emsp;&emsp;&emsp;1)调用<code>operator new[]</code>，在<code>operator new[]</code>中调用<code>operator new</code>完成N个对象的空间的分配。<br><br>&emsp;&emsp;&emsp;&emsp;2)调用构造函数N次完成N个对象的初始化。<br><br>&emsp;&emsp;2、<strong>delete[]</strong>:<br><br>&emsp;&emsp;&emsp;&emsp;1)调用析构函数N次完成N个对象资源的清理。<br><br>&emsp;&emsp;&emsp;&emsp;2)调用<code>operator delete[]</code>,在<code>operator delete[]</code>中调用<code>operator delete</code>完成N个对象的空间的释放。</p>
<h2 id="定位new表达式"><a href="#定位new表达式" class="headerlink" title="定位new表达式"></a>定位new表达式</h2><p>&emsp;&emsp;当我们用<code>malloc</code>或者其他方式分配了一块和某个类一样大小的空间给，并用某个指针去指向这块空间。但是问题在于这块空间并未执行构造函数因此并不能称为对象。因此定位new表达式就是为了帮助我们对一块已经分配好的空间执行构造函数使之成为对象的一个方式。</p>
<h3 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h3><p>&emsp;&emsp;<code>new (place_address) type(initializer-list)。</code><br><br>&emsp;&emsp;<code>place_address</code>为指向某一块空间的指针，<code>type</code>为自定义类型，<code>initializer-list</code>为参数列表。</p>
<h3 id="例"><a href="#例" class="headerlink" title="例"></a>例</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;                                 </span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class Stu                                          </span><br><span class="line">&#123;                   </span><br><span class="line">  public:    </span><br><span class="line">    Stu()           </span><br><span class="line">    &#123;                         </span><br><span class="line">      cout &lt;&lt; &quot;default building&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;;                     </span><br><span class="line">    Stu(int num, string name):_num(num), _name(name)</span><br><span class="line">    &#123;                         </span><br><span class="line">      cout &lt;&lt; &quot;custom building&quot; &lt;&lt; endl;   </span><br><span class="line">    &#125;                      </span><br><span class="line">    ~Stu()              </span><br><span class="line">    &#123;                       </span><br><span class="line">      cout &lt;&lt; &quot;destroying&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;                         </span><br><span class="line">  private:   </span><br><span class="line">    int _num;               </span><br><span class="line">    string _name;</span><br><span class="line">&#125;;                            </span><br><span class="line">int main()     </span><br><span class="line">&#123;                                    </span><br><span class="line">  Stu* p = (Stu*)malloc(sizeof(Stu));</span><br><span class="line">  cout &lt;&lt; &quot;定位new表达式：&quot; &lt;&lt; endl;</span><br><span class="line">  new(p) Stu(1,&quot;张三&quot;);              </span><br><span class="line">  delete p;              </span><br><span class="line">&#125;                                    </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[misaki@localhost 第三章-内存管理]$ ./New</span><br><span class="line">定位new表达式：</span><br><span class="line">custom building</span><br><span class="line">destroying</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;这样我们就用定位new表达式给已经分配好的空间调用了构造函数。</p>
<h2 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h2><h3 id="new和malloc的异同"><a href="#new和malloc的异同" class="headerlink" title="new和malloc的异同"></a>new和malloc的异同</h3><h4 id="相同"><a href="#相同" class="headerlink" title="相同"></a>相同</h4><p>&emsp;&emsp;1、<code>new</code>和<code>delete</code>都在堆上进行空间的申请。<br><br>&emsp;&emsp;2、都需要手动释放空间。</p>
<h4 id="不同"><a href="#不同" class="headerlink" title="不同"></a>不同</h4><p>&emsp;&emsp;1、<code>malloc</code>和<code>free</code>是函数而<code>new</code>和<code>delete</code>是运算符。<br><br>&emsp;&emsp;2、<code>new</code>可以在分配空间的时候进行初始化。<br><br>&emsp;&emsp;3、<code>malloc</code>返回值是<code>void*</code>需要强转，<code>new</code>会直接返回与分配空间类型一样的类型指针。<br><br>&emsp;&emsp;4、<code>malloc</code>需要手动计算分配空间大小在进行传入，而<code>new</code>只需要类型和元素个数，空间大小会自动计算。<br><br>&emsp;&emsp;5、<code>new</code>在给自定义类型分配空间的时候会自动调用其构造函数，<code>delete</code>会自动调用其析构函数。<br><br>&emsp;&emsp;6、<code>malloc</code>申请空间失败会返回<code>NULL</code>，<code>new</code>会抛异常。<br><br>&emsp;&emsp;7、<code>new</code>和<code>delete</code>是<code>malloc</code>和<code>free</code>的一层封装，因此效率会低一些。</p>
<h3 id="写一个只能在堆上创建对象的类"><a href="#写一个只能在堆上创建对象的类" class="headerlink" title="写一个只能在堆上创建对象的类"></a>写一个只能在堆上创建对象的类</h3><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>&emsp;&emsp;1、将构造函数，赋值构造函数全部封装为私有，不允许外部直接调用构造。<br><br>&emsp;&emsp;2、单独写一个静态函数提供在堆上创建对象的接口。</p>
<h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class HeapOnly</span><br><span class="line">&#123;</span><br><span class="line">  public:</span><br><span class="line">    //开放构造接口                        </span><br><span class="line">    static HeapOnly* Create()</span><br><span class="line">    &#123;</span><br><span class="line">      cout &lt;&lt; &quot;create int heap&quot; &lt;&lt; endl;</span><br><span class="line">      return new HeapOnly();</span><br><span class="line">    &#125;</span><br><span class="line">    ~HeapOnly()</span><br><span class="line">    &#123;</span><br><span class="line">      cout &lt;&lt; &quot;destorying&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">  private:</span><br><span class="line">    //构造函数私有化</span><br><span class="line">    HeapOnly()&#123;&#125;</span><br><span class="line">    HeapOnly(const HeapOnly&amp;)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">  HeapOnly* heapOnly = HeapOnly::Create();</span><br><span class="line">  delete heapOnly;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[misaki@localhost 第三章-内存管理]$ ./HeapOnlyClass</span><br><span class="line">create int heap</span><br><span class="line">destorying</span><br></pre></td></tr></table></figure>
<h3 id="写一个只能在栈上创建对象的类"><a href="#写一个只能在栈上创建对象的类" class="headerlink" title="写一个只能在栈上创建对象的类"></a>写一个只能在栈上创建对象的类</h3><h4 id="思路一"><a href="#思路一" class="headerlink" title="思路一"></a>思路一</h4><p>&emsp;&emsp;1、将构造函数，赋值构造函数全部封装为私有，不允许外部直接调用构造。<br><br>&emsp;&emsp;2、单独写一个静态函数提供在栈上创建对象的接口。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class StackOnly</span><br><span class="line">&#123;</span><br><span class="line">  public:</span><br><span class="line">    static StackOnly Create()</span><br><span class="line">    &#123;</span><br><span class="line">      //创建匿名对象</span><br><span class="line">      return StackOnly();</span><br><span class="line">    &#125;</span><br><span class="line">    static StackOnly a;</span><br><span class="line">    ~StackOnly()</span><br><span class="line">    &#123;</span><br><span class="line">      cout &lt;&lt; &quot;destorying&quot; &lt;&lt; endl;      </span><br><span class="line">    &#125;</span><br><span class="line">  private:</span><br><span class="line">    StackOnly()</span><br><span class="line">    &#123;</span><br><span class="line">      cout &lt;&lt; &quot;create in stack&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    StackOnly(const StackOnly&amp;)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">  StackOnly::a = StackOnly::Create();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[misaki@localhost 第三章-内存管理]$ ./StackOnlyClass </span><br><span class="line">create in stack</span><br><span class="line">destorying</span><br></pre></td></tr></table></figure></p>
<h4 id="思路二"><a href="#思路二" class="headerlink" title="思路二"></a>思路二</h4><p>&emsp;&emsp;1、直接将<code>operator new</code>和<code>operator delete</code>重载并定义为私有。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;                     </span><br><span class="line">using namespace std;               </span><br><span class="line">class StackOnly                  </span><br><span class="line">&#123;</span><br><span class="line">  public:      </span><br><span class="line">    StackOnly()</span><br><span class="line">    &#123;    </span><br><span class="line">      cout &lt;&lt; &quot;create in stack&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    ~StackOnly()    </span><br><span class="line">    &#123;                    </span><br><span class="line">      cout &lt;&lt; &quot;destorying&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;                  </span><br><span class="line">  private:      </span><br><span class="line">    void* operator new(size_t size)&#123;&#125;</span><br><span class="line">    void operator delete(void* p)&#123;&#125;</span><br><span class="line">&#125;;   </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;                   </span><br><span class="line">  StackOnly p;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="实现单例模式"><a href="#实现单例模式" class="headerlink" title="实现单例模式"></a>实现单例模式</h3><p>&emsp;&emsp;单例模式是一种设计模式，在实战中经常会用到。其意思是创建一个类这个类只能唯一的创建一个对象，如果之后还想用这个类创建新对象的时候都会返回最开始创建的呢个对象。<br><br>&emsp;&emsp;要实现这一点有两种思路，分别成为<strong>懒汉模式</strong>和<strong>饿汉模式</strong>。</p>
<h4 id="饿汉模式"><a href="#饿汉模式" class="headerlink" title="饿汉模式"></a>饿汉模式</h4><p>&emsp;&emsp;饿汉模式是在程序启动时就夹在所有需要资源的设计模式，用这种思想实现单例模式时需要在程序一开始就直接声明对象，需要适用对象就返回对象即可。但是坏处是程序启动时会消耗时间可能会造成程序启动缓慢。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">class Singleton1</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    //外留接口</span><br><span class="line">    static Singleton1* GetInstence()</span><br><span class="line">    &#123;</span><br><span class="line">        return &amp;_singleton;</span><br><span class="line">    &#125;</span><br><span class="line">private:</span><br><span class="line">    //防拷贝，禁用构造，拷贝构造和赋值</span><br><span class="line">    Singleton1()</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    Singleton1(const Singleton1&amp;);</span><br><span class="line">    Singleton1&amp; operator=(const Singleton1&amp;);</span><br><span class="line">    static Singleton1 _singleton;</span><br><span class="line">&#125;;</span><br><span class="line">Singleton1 Singleton1::_singleton;</span><br></pre></td></tr></table></figure></p>
<h4 id="懒汉模式"><a href="#懒汉模式" class="headerlink" title="懒汉模式"></a>懒汉模式</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">class Singleton2</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    static Singleton2* GetInstence()</span><br><span class="line">    &#123;</span><br><span class="line">        //双重判断避免不必要的锁竞争</span><br><span class="line">        if(_pSingleton == nullptr)</span><br><span class="line">        &#123;</span><br><span class="line">            //为了线程安全需要加锁</span><br><span class="line">            _mtx.lock();</span><br><span class="line">            if (_pSingleton == nullptr)</span><br><span class="line">            &#123;</span><br><span class="line">                _pSingleton = new Singleton2;</span><br><span class="line">            &#125;</span><br><span class="line">            _mtx.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">        return _pSingleton;</span><br><span class="line">    &#125;</span><br><span class="line">private:</span><br><span class="line">    Singleton2()&#123;&#125;</span><br><span class="line">    Singleton2(const Singleton2&amp;);</span><br><span class="line">    Singleton2&amp; operator=(const Singleton2&amp;);</span><br><span class="line">    static std::mutex _mtx;</span><br><span class="line">    static Singleton2* _pSingleton;</span><br><span class="line">&#125;;</span><br><span class="line">std::mutex Singleton2::_mtx;</span><br><span class="line">Singleton2* Singleton2::_pSingleton = nullptr;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;懒汉模式就是在第一次使用时才会创建对象，因此我们需要对变量进行判断考虑到线程安全我们需要对其加锁。懒汉模式的坏处是可能造成程序运行卡顿。</p>

          
        
      
    </div>
    
    
    

    

    <div>
    
    </div>

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/05/28/【Cpp】第二章-类和对象-下/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="MisakiFx">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/blog-logo.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Misaki`s blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/05/28/【Cpp】第二章-类和对象-下/" itemprop="url">【Cpp】第二章-类和对象-下</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-05-28T15:09:14+08:00">
                2019-05-28
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Cpp/" itemprop="url" rel="index">
                    <span itemprop="name">Cpp</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  2.3k
                </span>
              

              

              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="类和对象"><a href="#类和对象" class="headerlink" title="类和对象"></a>类和对象</h1><h2 id="初始化列表"><a href="#初始化列表" class="headerlink" title="初始化列表"></a>初始化列表</h2><p>&emsp;&emsp;我们之前想要在类创建时就对类进行初始化时使用构造函数直接在构造函数中对成员变量进行赋值。但是这种方法并非是最好的方法，并且有一些情况比如说常成员函数我们就无法在构造函数中初始化，因此有了新的对成员进行初始化的方法——<strong>初始化列表</strong>。</p>
<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>&emsp;&emsp;初始化列表是和构造函数写在一起的，会在执行成员函数函数体之前优先利用初始化列表对成员变量赋予初值。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using std::cout;</span><br><span class="line">using std::endl;</span><br><span class="line">class A</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">  A(int x = 4, int y = 5):_x(x), _y(y)                                                      </span><br><span class="line">  &#123;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">  int GetX()</span><br><span class="line">  &#123;</span><br><span class="line">    return _x;</span><br><span class="line">  &#125;</span><br><span class="line">  int GetY()</span><br><span class="line">  &#123;</span><br><span class="line">    return _y;</span><br><span class="line">  &#125;</span><br><span class="line">private:</span><br><span class="line">  int _x;</span><br><span class="line">  int _y;</span><br><span class="line">&#125;;</span><br><span class="line">class Test</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">  Test(int a, int&amp; b, int c, A d):_a(a), _b(b), _c(c), _d(d)</span><br><span class="line">  &#123;</span><br><span class="line">    cout &lt;&lt; _a &lt;&lt; &quot;\t&quot; &lt;&lt; _b &lt;&lt; &quot;\t&quot; &lt;&lt; _c &lt;&lt; &quot;\t&quot; &lt;&lt; _d.GetX() &lt;&lt; &quot;\t&quot; &lt;&lt; d.GetY() &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; &quot;building seccess&quot; &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">private:</span><br><span class="line">  const int _a;</span><br><span class="line">  int&amp; _b;</span><br><span class="line">  int _c;</span><br><span class="line">  A _d;</span><br><span class="line">  </span><br><span class="line">&#125;;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">  int b = 2;</span><br><span class="line">  A d;</span><br><span class="line">  Test(1, b, 3, d);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;在初始化列表中进行成员的初始化是最优的，因为对于自定义的类一定会先用初始化列表进行初始化。</p>
<h3 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h3><p>&emsp;&emsp;1、有几种一定需要在初始化列表中才能进行初始化的成员变量：<strong>常成员，引用，没有默认构造函数的自定义类类型成员</strong>。<br><br>&emsp;&emsp;2、类类型成员不论是否在初始化列表中是否显示初始化都会自动在初始化列表中进行构造函数的调用。<br><br>&emsp;&emsp;3、每个成员在初始化列表中只能出现一次。<br><br>&emsp;&emsp;4、初始化顺序与初始化列表无关，只与成员在类中声明先后有关。<br><br>&emsp;&emsp;5、优先在初始化列表中初始化所有成员，尤其是类类型成员。</p>
<h2 id="explicit关键字"><a href="#explicit关键字" class="headerlink" title="explicit关键字"></a>explicit关键字</h2><p>&emsp;&emsp;我们在对对象进行初始化的时候可以进行这样的构造。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;               </span><br><span class="line">using std::cout;</span><br><span class="line">using std::endl;</span><br><span class="line">class A</span><br><span class="line">&#123;       </span><br><span class="line">public:  </span><br><span class="line">  A(int x, int y = 5):_x(x), _y(y)</span><br><span class="line">  &#123;</span><br><span class="line">            </span><br><span class="line">  &#125;</span><br><span class="line">  int GetX()</span><br><span class="line">  &#123;                               </span><br><span class="line">    return _x;</span><br><span class="line">  &#125;                               </span><br><span class="line">  int GetY()                      </span><br><span class="line">  &#123;  </span><br><span class="line">    return _y;</span><br><span class="line">  &#125;              </span><br><span class="line">private:    </span><br><span class="line">  int _x;  </span><br><span class="line">  int _y;</span><br><span class="line">&#125;;  </span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">  A a = 4;//等同A a(4);</span><br><span class="line">  cout &lt;&lt; a.GetX() &lt;&lt; &quot;\t&quot; &lt;&lt; a.GetY() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;这种构造函数的调用仅适用于调用只有一个参数的构造函数，这种情况下可以达到隐式转换的效果。但是如果我们不想支持这种隐式转换呢？我们就可以在构造函数前加上<code>explicit</code>关键字，这样就可以仅用构造函数的隐式转换。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">explicit A(int x, int y = 5):_x(x), _y(y)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[misaki@localhost 第二章-类和对象]$ make</span><br><span class="line">g++ -g Init.cpp -o Init</span><br><span class="line">Init.cpp: 在函数‘int main()’中:</span><br><span class="line">Init.cpp:40:9: 错误：请求从‘int’转换到非标量类型‘A’</span><br><span class="line">   A a = 4;</span><br><span class="line">         ^</span><br><span class="line">make: *** [Init] 错误 1</span><br></pre></td></tr></table></figure></p>
<h2 id="static静态成员"><a href="#static静态成员" class="headerlink" title="static静态成员"></a>static静态成员</h2><h3 id="静态成员变量和静态成员函数"><a href="#静态成员变量和静态成员函数" class="headerlink" title="静态成员变量和静态成员函数"></a>静态成员变量和静态成员函数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class Test</span><br><span class="line">&#123;</span><br><span class="line">  public:</span><br><span class="line">    Test()</span><br><span class="line">    &#123;</span><br><span class="line">      _num++;</span><br><span class="line">    &#125;</span><br><span class="line">    static int GetNum()</span><br><span class="line">    &#123;</span><br><span class="line">      return _num;</span><br><span class="line">    &#125;</span><br><span class="line">  private:</span><br><span class="line">    static int _num;//静态成员变量</span><br><span class="line">&#125;;</span><br><span class="line">int Test::_num = 0;//在类外进行初始化</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">  Test test[4];</span><br><span class="line">  cout &lt;&lt; Test::GetNum() &lt;&lt; endl;//用类+域限定符调用静态成员函数</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[misaki@localhost 第二章-类和对象]$ ./static</span><br><span class="line">4</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;静态成员是属于整个类的成员，同时也是属于所有类的实例化对象的成员，它们在类被定义后即被初始化，静态成员可以被所有的实例化对象操作。<br><br>&emsp;&emsp;以上这个代码我们用静态成计算类的构造函数调用次数。</p>
<h3 id="特性-1"><a href="#特性-1" class="headerlink" title="特性"></a>特性</h3><p>&emsp;&emsp;1、静态成员变量必须在类外进行初始化。<br><br>&emsp;&emsp;2、静态成员函数中不含<code>this</code>指针因此不可以使用非静态成员。<br><br>&emsp;&emsp;3、静态成员属于这个类和所有实例对象因此用类或者对象都可以调用静态成员，前提其是公有。<br><br>&emsp;&emsp;4、非静态成员函数也可以调用静态成员。</p>
<h3 id="static作用"><a href="#static作用" class="headerlink" title="static作用"></a>static作用</h3><p>&emsp;&emsp;这里我们又了解了<code>static</code>的新的作用，我们总结一下<code>static</code>一共有哪些作用。<br>&emsp;&emsp;1、修饰局部变量，改变生命周期。<br><br>&emsp;&emsp;2、修饰全局变量，改变链接属性，使其只在当前文件可见。<br><br>&emsp;&emsp;3、修饰成员函数，将其变为静态，无<code>this</code>指针。<br><br>&emsp;&emsp;4、修饰成员变量，将其变为静态成员变量。</p>
<h2 id="为成员变量设置默认值（C-11）"><a href="#为成员变量设置默认值（C-11）" class="headerlink" title="为成员变量设置默认值（C++11）"></a>为成员变量设置默认值（C++11）</h2><p>&emsp;&emsp;这个语法只有在支持11版本的编译器上才可以使用，这种语法相当于给成员变量设定了默认值，十分类似于参数缺省。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class Test</span><br><span class="line">&#123;</span><br><span class="line">  public:</span><br><span class="line">    Test()&#123;&#125;</span><br><span class="line">    int _a = 1;</span><br><span class="line">    int _b = 2;</span><br><span class="line">&#125;;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">  Test t;</span><br><span class="line">  cout &lt;&lt; t._a &lt;&lt; &quot;\t&quot; &lt;&lt; t._b &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[misaki@localhost 第二章-类和对象]$ ./default</span><br><span class="line">1	2</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;这种设置默认值的语法如果我们并没有在构造函数中给成员变量赋值则会将其赋为这里的默认值。</p>
<h2 id="友元"><a href="#友元" class="headerlink" title="友元"></a>友元</h2><p>&emsp;&emsp;有的时候我们想要在外部使用一个对象的成员变量但是又不想破坏其封装的时候就需要借助友元的语法，如果一个函数或者类是另一个类的友元，则这个函数或者类就可以自由使用另一个类中的私有成员。</p>
<h3 id="友元函数"><a href="#友元函数" class="headerlink" title="友元函数"></a>友元函数</h3><p>&emsp;&emsp;例如我们要书写一个<code>&lt;&lt;</code>的重载函数让其可以按照我们的规则打印类中的成员，这个函数如果写在类中则左操作数永远被我们的类本身占据我们想要让<code>ostream</code>的对象作为左操作数的时候就只能定义在类外，看这样以来就无法访问类中的私有成员，这是我们就可以借助友元。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class Test</span><br><span class="line">&#123;</span><br><span class="line">  //将其声明为友元函数                                         </span><br><span class="line">  friend ostream&amp; operator&lt;&lt;(ostream&amp; _cout, const Test&amp; test);</span><br><span class="line">  private:         </span><br><span class="line">    int _a;        </span><br><span class="line">    int _b;        </span><br><span class="line">  public:                                  </span><br><span class="line">    Test(int a = 1, int b = 2):_a(a), _b(b)</span><br><span class="line">    &#123;              </span><br><span class="line">                   </span><br><span class="line">    &#125;              </span><br><span class="line">&#125;;                                                   </span><br><span class="line">ostream&amp; operator&lt;&lt;(ostream&amp; _cout, const Test&amp; test)</span><br><span class="line">&#123;                                             </span><br><span class="line">  _cout &lt;&lt; test._a &lt;&lt; &quot;\t&quot; &lt;&lt; test._b &lt;&lt; endl;</span><br><span class="line">  return _cout;    </span><br><span class="line">&#125;                  </span><br><span class="line">int main()         </span><br><span class="line">&#123;                  </span><br><span class="line">  Test test;       </span><br><span class="line">  cout &lt;&lt; test;    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[misaki@localhost 第二章-类和对象]$ ./friend</span><br><span class="line">1	2</span><br></pre></td></tr></table></figure></p>
<h3 id="友元类"><a href="#友元类" class="headerlink" title="友元类"></a>友元类</h3><p>&emsp;&emsp;友元类和友元函数一样，一旦一个类是另一个类的友元，他就可以访问其的私有成员。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;                                           </span><br><span class="line">using namespace std;                         </span><br><span class="line">class B;//前置声明                           </span><br><span class="line">class A                                      </span><br><span class="line">&#123;                                            </span><br><span class="line">  //将其声明为友元类                                          </span><br><span class="line">  friend class B;                            </span><br><span class="line">  //将其声明为友元函数                       </span><br><span class="line"> friend  ostream&amp; operator&lt;&lt;(ostream&amp; _cout, const B&amp; test);</span><br><span class="line">  private:                                   </span><br><span class="line">    int _a;                                  </span><br><span class="line">    int _b;                                  </span><br><span class="line">  public:                                    </span><br><span class="line">    A(int a = 1, int b = 2):_a(a), _b(b)     </span><br><span class="line">    &#123;                                        </span><br><span class="line">                                             </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">class B                                           </span><br><span class="line">&#123;</span><br><span class="line">  friend ostream&amp; operator&lt;&lt;(ostream&amp; _cout, const B&amp; test);</span><br><span class="line">  private:                                                    </span><br><span class="line">    int _a;    </span><br><span class="line">    int _b;</span><br><span class="line">    A _classA;</span><br><span class="line">  public:</span><br><span class="line">    B(int a = 3, int b = 4):_a(a), _b(b)</span><br><span class="line">    &#123;       </span><br><span class="line">      //直接访问A类的私有成员</span><br><span class="line">      _classA._a = a;</span><br><span class="line">      _classA._b = b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">ostream&amp; operator&lt;&lt;(ostream&amp; _cout, const B&amp; test)</span><br><span class="line">&#123;</span><br><span class="line">  _cout &lt;&lt; test._a &lt;&lt; &quot;\t&quot; &lt;&lt; test._b &lt;&lt; endl;</span><br><span class="line">  _cout &lt;&lt; test._classA._a &lt;&lt; &quot;\t&quot; &lt;&lt; test._classA._b &lt;&lt; endl;</span><br><span class="line">  return _cout;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">  B b;</span><br><span class="line">  cout &lt;&lt; b;</span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[misaki@localhost 第二章-类和对象]$ ./friend</span><br><span class="line">3	4</span><br><span class="line">3	4</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;以上这个例子综合使用了友元类和友元函数，友元类让B可以随意访问A的成员，但是要注意友元的关系是单向的，B是A的友元，但是A并不是B的友元，因此A不能访问B的成员。</p>
<h2 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h2><p>&emsp;&emsp;内部类是在一个类内部所定义的类。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;                                         </span><br><span class="line">using namespace std;</span><br><span class="line">class A            </span><br><span class="line">&#123;        </span><br><span class="line">  private:                              </span><br><span class="line">    int _a;</span><br><span class="line">    int _b; </span><br><span class="line">    static int num;</span><br><span class="line">  public:   </span><br><span class="line">    A(int a = 1, int b = 2):_a(a), _b(b)</span><br><span class="line">    &#123;</span><br><span class="line">      num++;  </span><br><span class="line">    &#125;          </span><br><span class="line">    //内部类   </span><br><span class="line">    class B  </span><br><span class="line">    &#123;                                       </span><br><span class="line">      private:</span><br><span class="line">        int _a;</span><br><span class="line">        int _b;</span><br><span class="line">      public:              </span><br><span class="line">        B(int a = 3, int b = 4):_a(a), _b(b)</span><br><span class="line">        &#123;                                                </span><br><span class="line"></span><br><span class="line">        &#125;                     </span><br><span class="line">        void Test(A classA)</span><br><span class="line">        &#123;</span><br><span class="line">          cout &lt;&lt; classA._a &lt;&lt; &quot;\t&quot; &lt;&lt; classA._b &lt;&lt; endl;</span><br><span class="line">          cout &lt;&lt; _a &lt;&lt; &quot;\t&quot; &lt;&lt; _b &lt;&lt; endl;</span><br><span class="line">          cout &lt;&lt; num &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br><span class="line">int A::num = 0;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">  A::B b;//内部类的实例化</span><br><span class="line">  A a;</span><br><span class="line">  b.Test(a);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">[misaki@localhost 第二章-类和对象]$ ./insideclass</span><br><span class="line">1	2</span><br><span class="line">3	4</span><br><span class="line">1</span><br></pre></td></tr></table></figure></p>
<h3 id="特性-2"><a href="#特性-2" class="headerlink" title="特性"></a>特性</h3><p>&emsp;&emsp;1、内部类是外部类的友元类。<br><br>&emsp;&emsp;2、外部类与内部类独立，不能用外部类访问内部类。<br><br>&emsp;&emsp;3、对外部类取大小与内部类无关<br><br>&emsp;&emsp;4、内部类可以不用加访问限定符就可以访问外部类的静态、枚举成员。# 类和对象</p>

          
        
      
    </div>
    
    
    

    

    <div>
    
    </div>

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/05/19/【Linux】第八章-多线程/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="MisakiFx">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/blog-logo.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Misaki`s blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/05/19/【Linux】第八章-多线程/" itemprop="url">【Linux】第八章-多线程</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-05-19T15:13:07+08:00">
                2019-05-19
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Linux/" itemprop="url" rel="index">
                    <span itemprop="name">Linux</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  17.8k
                </span>
              

              

              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="第八章-多线程"><a href="#第八章-多线程" class="headerlink" title="第八章 多线程"></a>第八章 多线程</h1><h2 id="线程概念"><a href="#线程概念" class="headerlink" title="线程概念"></a>线程概念</h2><p>&emsp;&emsp;多进程任务处理是同时通过多个进程进行任务，多个pcb拥有多个虚拟地址空间，分别执行不同的代码，之间互不关联。而多线程是通过多个pcb共用一个虚拟地址空间，分别执行虚拟地址空间上所对应的多个不同的物理内存中的代码。即一个虚拟地址空间对应多个物理内存。<br>&emsp;&emsp;之前我们说linux下pcb是一个进程，但其实linux下线程以进程pcb模拟实现线程，因此linux下pcb是线程；因此linux线程也叫轻量级进程。一个进程可能拥有多个线程，而每个进程势必有一个主线程，我们在主线程中创建其他线程。那么一个进程可以理解为一堆线程的集合，我们称其为线程组，而进程的pid为了不冲突则规定是主线程的pid。<br>&emsp;&emsp;因为linux线程是pcb——因此线程是cpu的基本单位。因为进程是线程组，程序运行起来，资源是分配给整个线程组的，因此进程是资源分配的基本单位。</p>
<h3 id="进程与线程的对比"><a href="#进程与线程的对比" class="headerlink" title="进程与线程的对比"></a>进程与线程的对比</h3><p>&emsp;&emsp;一个进程中的线程共用同一个虚拟地址空间，因此线程间通信更加方便；线程的创建/销毁成本更低；线程间切换调度成本更低；线程的执行粒度更细。<br>&emsp;&emsp;线程之间缺乏访问控制——系统调用，异常针对的是整个进程，健壮性低。<br>&emsp;&emsp;<code>vfork</code>创建一个子进程共用同一个虚拟地址空间，怕出现调用栈混乱，因此子进程运行完毕或程序替换后父进程才开始运行。而线程也共用同一个虚拟地址空间却不会发生调用栈混乱的情况，因为每个线程都会有一些独立的信息，会为每个线程在虚拟地址空间中单独分配一块内存用来存储这些独立的信息：<strong>栈，寄存器，errno，信号屏蔽字，调度优先级</strong>。同时线程间也有共享的数据：<strong>代码段，数据段，文件描述符表，信号处理方式，用户和组，当前工作目录</strong>。<br>&emsp;&emsp;多线程相比多进程的优点：<br>&emsp;&emsp;1、通信更加方便，灵活。<br>&emsp;&emsp;2、创建/销毁成本更低。<br>&emsp;&emsp;3、切换调度成本更低。<br>&emsp;&emsp;多线程相比多进程的缺点：<br>&emsp;&emsp;1、缺乏访问控制并且一些系统调用以及错误针对整个进程，健壮性/稳定性更低。</p>
<h3 id="多进程-多线程进行多任务处理的优势"><a href="#多进程-多线程进行多任务处理的优势" class="headerlink" title="多进程/多线程进行多任务处理的优势"></a>多进程/多线程进行多任务处理的优势</h3><h4 id="cpu密集型程序"><a href="#cpu密集型程序" class="headerlink" title="cpu密集型程序"></a>cpu密集型程序</h4><p>&emsp;&emsp;对于读写操作比较少，更多的则是计算方面的操作，这类程序尽量少用多线程/进程，因为cpu调度线程/进程会浪费cpu资源。</p>
<h4 id="io密集型程序"><a href="#io密集型程序" class="headerlink" title="io密集型程序"></a>io密集型程序</h4><p>&emsp;&emsp;对于读写操作较多，cpu计算操作较少的程序则应该多使用多进程/线程进行io操作，由此来并行执行程序，减少执行时间。</p>
<h2 id="线程控制"><a href="#线程控制" class="headerlink" title="线程控制"></a>线程控制</h2><h3 id="线程创建"><a href="#线程创建" class="headerlink" title="线程创建"></a>线程创建</h3><p>&emsp;&emsp;操作系统并没有为用户提供直接创建线程的系统调用接口，但是有人自己封装了一套线程库实现线程控制。</p>
<h4 id="pthread-create"><a href="#pthread-create" class="headerlink" title="pthread_create"></a>pthread_create</h4><p>&emsp;&emsp;由于<code>pthread_create</code>所在的库<code>pthread</code>并不在gcc默认的链接库中，因此我们在编译时要加参数<code>-pthread</code>或者<code>-lpthread</code>让其连接到这个库中。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 线程创建</span><br><span class="line"> **/</span><br><span class="line">/**</span><br><span class="line"> * int pthread_create(pthread_t *thread, const pthread_attr_t *attr,</span><br><span class="line"> *        void *(*start_routine) (void *), void *arg);</span><br><span class="line"> * thread:输出型参数，获取新创建的线程id</span><br><span class="line"> * attr:  设置线程属性，通常置空</span><br><span class="line"> * start_routine:  线程入口函数</span><br><span class="line"> * arg:通过线程入口函数传递给线程的参数</span><br><span class="line"> **/</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;errno.h&gt;</span><br><span class="line">#include &lt;pthread.h&gt;</span><br><span class="line">void* thr_start(void* arg)</span><br><span class="line">&#123;</span><br><span class="line">  while(1)</span><br><span class="line">  &#123;</span><br><span class="line">    //pthread_self查看此线程的tid</span><br><span class="line">    printf(&quot;i am child---%d\n&quot;,pthread_self());                           </span><br><span class="line">    sleep(1);</span><br><span class="line">  &#125;</span><br><span class="line">  return NULL;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">  pthread_t tid;</span><br><span class="line">  int ret = pthread_create(&amp;tid, NULL, thr_start, (void*)&quot;Misaki&quot;);</span><br><span class="line">  printf(&quot;%d\n&quot;,tid);</span><br><span class="line">  if(ret != 0)//0为成功</span><br><span class="line">  &#123;</span><br><span class="line">    printf(&quot;thread vreate errno!\n&quot;);</span><br><span class="line">    return -1;</span><br><span class="line">  &#125;</span><br><span class="line">  while(1)</span><br><span class="line">  &#123;</span><br><span class="line">    //thread_self查看自己的线程id</span><br><span class="line">    printf(&quot;Misaki!%d\n&quot;,getpid());</span><br><span class="line">    sleep(1);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">[misaki@localhost 第八章-多线程]$ ./create</span><br><span class="line">-1544186112</span><br><span class="line">Misaki!5429</span><br><span class="line">i am child----1544186112</span><br><span class="line">i am child----1544186112</span><br><span class="line">Misaki!5429</span><br><span class="line">i am child----1544186112</span><br><span class="line">Misaki!5429</span><br><span class="line">i am child----1544186112</span><br><span class="line">Misaki!5429</span><br><span class="line">i am child----1544186112</span><br><span class="line">Misaki!5429</span><br><span class="line">i am child----1544186112</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;这个创建线程的函数中的返回值<code>tid</code>为线程在虚拟地址空间上所分配的属于自己的独立空间的首地址，我们以后要靠这个参数来控制线程。一个<code>tid</code>唯一的表示一个线程。<br></p>
<h3 id="线程终止"><a href="#线程终止" class="headerlink" title="线程终止"></a>线程终止</h3><h4 id="在线程入口函数中return"><a href="#在线程入口函数中return" class="headerlink" title="在线程入口函数中return"></a>在线程入口函数中return</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;errno.h&gt;</span><br><span class="line">#include &lt;pthread.h&gt;</span><br><span class="line">void* thr_start(void* arg)</span><br><span class="line">&#123;</span><br><span class="line">  while(1)</span><br><span class="line">  &#123;</span><br><span class="line">      printf(&quot;i am child\n&quot;);</span><br><span class="line">      reutrn NULL;</span><br><span class="line">  &#125;</span><br><span class="line">  return NULL;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">  pthread_t tid;</span><br><span class="line">  int ret = pthread_create(&amp;tid, NULL, thr_start, (void*)&quot;Misaki&quot;);</span><br><span class="line">  printf(&quot;%d\n&quot;,tid);</span><br><span class="line">  if(ret != 0)</span><br><span class="line">  &#123;</span><br><span class="line">    printf(&quot;thread vreate errno!\n&quot;);</span><br><span class="line">    return -1;</span><br><span class="line">  &#125;</span><br><span class="line">  while(1)</span><br><span class="line">  &#123;</span><br><span class="line">    //thread_self查看自己的线程id</span><br><span class="line">    printf(&quot;Misaki!%d\n&quot;,getpid());</span><br><span class="line">    sleep(1);</span><br><span class="line">    return 0;                                                      </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">[misaki@localhost 第八章-多线程]$ ./exit</span><br><span class="line">2052687616</span><br><span class="line">Misaki!5710</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;在线程入口函数中<code>return</code>会让线程退出。当在主函数中使用<code>return</code>退出主函数的时候这时会导致进程终止，由此进程中的所有线程都会终止。<br></p>
<h4 id="pthread-exit"><a href="#pthread-exit" class="headerlink" title="pthread_exit()"></a>pthread_exit()</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;pthread.h&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line"></span><br><span class="line">void* thr_start(void* arg)</span><br><span class="line">&#123;</span><br><span class="line">  while(1)</span><br><span class="line">  &#123;</span><br><span class="line">    printf(&quot;i am child---%s\n&quot;, arg);</span><br><span class="line">    sleep(1);</span><br><span class="line">    //退出调用这个函数的线程         </span><br><span class="line">    pthread_exit(0);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return NULL;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">  pthread_t tid;</span><br><span class="line">  int ret = pthread_create(&amp;tid, NULL, thr_start, (void*)&quot;Misaki&quot;);</span><br><span class="line">  while(1)</span><br><span class="line">  &#123;</span><br><span class="line">    printf(&quot;i am main!\n&quot;);</span><br><span class="line">    sleep(1);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[misaki@localhost 第八章-多线程]$ ./exit</span><br><span class="line">i am main!</span><br><span class="line">i am child---Misaki</span><br><span class="line">i am main!</span><br><span class="line">i am main!</span><br><span class="line">i am main!</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;可以看出我们自己创建的线程在执行<code>pthread_exit()</code>后退出了。如果我们的主线程调用这个函数会怎样呢？<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;pthread.h&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line"></span><br><span class="line">void* thr_start(void* arg)</span><br><span class="line">&#123;</span><br><span class="line">  while(1)</span><br><span class="line">  &#123;</span><br><span class="line">    printf(&quot;i am child---%s\n&quot;, arg);</span><br><span class="line">    sleep(1);</span><br><span class="line">  &#125;</span><br><span class="line">  return NULL;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">  pthread_t tid;</span><br><span class="line">  int ret = pthread_create(&amp;tid, NULL, thr_start, (void*)&quot;Misaki&quot;);</span><br><span class="line">  if(ret != 0)                      </span><br><span class="line">  &#123;             </span><br><span class="line">    printf(&quot;thread create error\n&quot;);</span><br><span class="line">    return -1;</span><br><span class="line">  &#125;</span><br><span class="line">  while(1)</span><br><span class="line">  &#123;</span><br><span class="line">    printf(&quot;i am main!\n&quot;);</span><br><span class="line">    sleep(1);</span><br><span class="line">    //退出调用这个函数的线程                                       </span><br><span class="line">    pthread_exit(0);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[misaki@localhost 第八章-多线程]$ ./exit</span><br><span class="line">i am main!</span><br><span class="line">i am child---Misaki</span><br><span class="line">i am child---Misaki</span><br><span class="line">i am child---Misaki</span><br><span class="line">i am child---Misaki</span><br><span class="line">i am child---Misaki</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;可以看出我们虽然在主线程中调用了退出函数，主线程也确实退出了，但是进程却并没有退出，这说明，<strong>主线程终止并不会让进程终止</strong>。但是我们要注意线程退出也会成为僵尸线程，但是普通线程退出并不会有过于明显大的影响。</p>
<h4 id="pthread-cancel"><a href="#pthread-cancel" class="headerlink" title="pthread_cancel"></a>pthread_cancel</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;pthread.h&gt;                                               </span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line"></span><br><span class="line">void* thr_start(void* arg)</span><br><span class="line">&#123;</span><br><span class="line">  while(1)</span><br><span class="line">  &#123;</span><br><span class="line">    printf(&quot;i am child---%s\n&quot;, arg);</span><br><span class="line">    sleep(1);</span><br><span class="line">  &#125;</span><br><span class="line">  return NULL;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">  pthread_t tid;</span><br><span class="line">  int ret = pthread_create(&amp;tid, NULL, thr_start, (void*)&quot;Misaki&quot;);</span><br><span class="line">  if(ret != 0)</span><br><span class="line">  &#123;</span><br><span class="line">    printf(&quot;thread create error\n&quot;);</span><br><span class="line">    return -1;</span><br><span class="line">  &#125;</span><br><span class="line">  while(1)</span><br><span class="line">  &#123;</span><br><span class="line">    printf(&quot;i am main!\n&quot;);</span><br><span class="line">    sleep(1);</span><br><span class="line">    //退出id = tid的线程</span><br><span class="line">    pthread_cancel(tid);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;                       </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[misaki@localhost 第八章-多线程]$ ./exit</span><br><span class="line">i am main!</span><br><span class="line">i am child---Misaki</span><br><span class="line">i am child---Misaki</span><br><span class="line">i am main!</span><br><span class="line">i am main!</span><br><span class="line">i am main!</span><br></pre></td></tr></table></figure>
<h3 id="线程等待"><a href="#线程等待" class="headerlink" title="线程等待"></a>线程等待</h3><p>&emsp;&emsp;线程等待是为了获取指定线程的返回值，和进程等待一样为了让系统可以释放资源，因为一个线程运行起来，默认有一个属性：<code>joinable</code>。这个属性决定了线程退出后，必须被等待，否则线程资源无法完全释放，成为僵尸线程，因此我们必须进行线程等待，获取线程返回值，允许系统释放资源。当然线程等待也有一个前提，线程能够被等待，即<code>joinable</code>属性。</p>
<h4 id="pthread-join"><a href="#pthread-join" class="headerlink" title="pthread_join()"></a>pthread_join()</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * int pthread_join(pthread_t thread, void **retval);</span><br><span class="line"> * 线程等待，获取线程退出返回值。</span><br><span class="line"> * thread:要等待的线程id</span><br><span class="line"> * retval:输出型参数，用于获取退出线程的返回值</span><br><span class="line"> **/</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;pthread.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">void* thr_start(void* arg)</span><br><span class="line">&#123;</span><br><span class="line">  sleep(3);</span><br><span class="line">  return (void*)&quot;Misaki&quot;;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">  pthread_t tid;</span><br><span class="line">  int ret = pthread_create(&amp;tid, NULL, thr_start, NULL);</span><br><span class="line">  if(ret != 0)</span><br><span class="line">  &#123;</span><br><span class="line">    printf(&quot;thread create error\n&quot;);</span><br><span class="line">    return -1;</span><br><span class="line">  &#125;</span><br><span class="line">  char* ptr;</span><br><span class="line">  pthread_join(tid, (void**)&amp;ptr);</span><br><span class="line">  printf(&quot;%s\n&quot;, ptr);                                </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[misaki@localhost 第八章-多线程]$ ./join</span><br><span class="line">Misaki</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;如果一个线程是被取消，则返回值是一个宏：<code>PTHREAD_CANCELED</code>，它的值是-1。线程等待<code>pthread_join</code>是阻塞函数，一个一个线程没有推出则会一直等待。</p>
<h3 id="线程分离"><a href="#线程分离" class="headerlink" title="线程分离"></a>线程分离</h3><p>&emsp;&emsp;将线程的一个属性从<code>joinable</code>设置为<code>detach</code>属性。属于<code>detach</code>属性的线程，退出后资源直接自动被回收，这类线程不能被等待。</p>
<h4 id="pthread-detach"><a href="#pthread-detach" class="headerlink" title="pthread_detach()"></a>pthread_detach()</h4><p>&emsp;&emsp;如果用户对一个线程的返回值不关心，则可以在线程入口函数对线程进行分离。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">/**                                                            </span><br><span class="line"> * int pthread_detach(pthread_t thread);</span><br><span class="line"> * 线程分离。</span><br><span class="line"> * thread:要分离的线程id</span><br><span class="line"> **/                </span><br><span class="line">#include &lt;stdio.h&gt;                                          </span><br><span class="line">#include &lt;stdlib.h&gt;                </span><br><span class="line">#include &lt;pthread.h&gt;     </span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;errno.h&gt;</span><br><span class="line">void* thr_start(void* arg)</span><br><span class="line">&#123;               </span><br><span class="line">                                                        </span><br><span class="line">  //分离自己这个线程</span><br><span class="line">  //线程的分离对于一个线程来说，任意线程在任意位置调用都可以</span><br><span class="line"> // pthread_detach(pthread_self());</span><br><span class="line">  return (void*)&quot;Misaki&quot;;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">  pthread_t tid;</span><br><span class="line">  int ret = pthread_create(&amp;tid, NULL, thr_start, NULL);</span><br><span class="line">  if(ret != 0)      </span><br><span class="line">  &#123;                                 </span><br><span class="line">    printf(&quot;thread create error\n&quot;);</span><br><span class="line">    return -1;      </span><br><span class="line">  &#125;</span><br><span class="line">  //分离这个线程</span><br><span class="line">  pthread_detach(tid);</span><br><span class="line">  char* ptr;</span><br><span class="line">  ret = pthread_join(tid, (void**)&amp;ptr);</span><br><span class="line">  //如果一个进程无法被等待则返回值为一个宏EINVAL</span><br><span class="line">  if(ret == EINVAL)</span><br><span class="line">  &#123;</span><br><span class="line">    printf(&quot;this thread can not be wait!!\n&quot;);</span><br><span class="line">    return -1;</span><br><span class="line">  &#125;</span><br><span class="line">  printf(&quot;%s\t%d\n&quot;, ptr, ret);</span><br><span class="line">&#125;                                               </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[misaki@localhost 第八章-多线程]$ ./join</span><br><span class="line">this thread can not be wait!!</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;会发现我们已经分离了我们自己创建的线程，这个线程已经无法被等待了，并且我们无法接收到线程的返回值。</p>
<h2 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h2><p>&emsp;&emsp;多个线程同时操作临界资源而不会出现数据二义性就说这个线程是安全的。如果在线程中进行了非原子性操作就可能会导致线程不安全，这些非原子性操作也叫做不可重入函数，即多个执行流中同时进入函数运行会出现问题的函数。<br><br>&emsp;&emsp;如何实现线程安全？这就要靠<strong>同步与互斥</strong>。同步指临界资源的合理访问，互斥指临界资源同一时间唯一访问。</p>
<h3 id="互斥"><a href="#互斥" class="headerlink" title="互斥"></a>互斥</h3><p>&emsp;&emsp;同步和互斥要如何实现呢？我们先从互斥开始讨论。为了保证操作的原子性，在C语言中<strong>互斥锁</strong>可以帮助我们保证互斥，使我们的函数变为可重入函数。</p>
<h4 id="互斥锁"><a href="#互斥锁" class="headerlink" title="互斥锁"></a>互斥锁</h4><p>&emsp;&emsp;互斥锁的值只能为0或1。1表示可以加锁，加锁后值-1，操作结束后就会解锁，解锁就会将值+1。如果一个操作已经加锁则值为0，因此当锁值为0时其他线程则不能加锁，不能加锁线程就会陷入等待。<br><br>&emsp;&emsp;互斥锁操作步骤：<br><br>&emsp;&emsp;1、定义互斥锁变量：<code>pthread_mutex_t</code>。<br><br>&emsp;&emsp;2、初始化互斥锁变量：<code>pthread_mutex_init</code>。<br><br>&emsp;&emsp;3、加锁：<code>pthread_mutex_lock</code>。<br><br>&emsp;&emsp;4、解锁：<code>pthread_mutex_unlock</code>。<br><br>&emsp;&emsp;5、删除锁：<code>pthread_mutex_destroy</code>。<br>&emsp;&emsp;接下来我用互斥锁将一个不可重入的函数使它可重入从而使多个线程同时运行函数时变得安全。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br></pre></td><td class="code"><pre><span class="line">/*实现互斥锁的基本使用以及线程安全的基本认识*/                                    </span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;errno.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;pthread.h&gt;</span><br><span class="line">int ticket = 100;</span><br><span class="line">//互斥锁变量不一定非要全局变量,使用的线程都能访问到就行     </span><br><span class="line">//互斥锁变量                                         </span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;pthread.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">int ticket = 100;</span><br><span class="line">pthread_mutex_t mutex;</span><br><span class="line">void* ticket_scalper(void* arg)</span><br><span class="line">&#123;</span><br><span class="line">  int id = (int)arg;</span><br><span class="line">  while(1)</span><br><span class="line">  &#123;</span><br><span class="line">    //加锁要在临界资源访问之前</span><br><span class="line">    //int pthread_mutex_lock(pthread_mutex_t* mutex);阻塞加锁</span><br><span class="line">    //int pthread_mutex_trylock(pthread_mutex_t* mutex);非阻塞加锁，加不上锁就返回</span><br><span class="line">    pthread_mutex_lock(&amp;mutex);</span><br><span class="line">    if(ticket &gt; 0)</span><br><span class="line">    &#123;</span><br><span class="line">      printf(&quot;scalper:%d--get a ticket:%d\n&quot;, id, ticket);</span><br><span class="line">      ticket--;</span><br><span class="line">      usleep(1000);</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">      //解锁</span><br><span class="line">      pthread_mutex_unlock(&amp;mutex);                                               </span><br><span class="line">      pthread_exit(0);</span><br><span class="line">    &#125;</span><br><span class="line">    //解锁</span><br><span class="line">    pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">  &#125;</span><br><span class="line">  return NULL;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">  int i = 0;</span><br><span class="line">  int ret;</span><br><span class="line">  pthread_t tid[4];</span><br><span class="line">  //初始化互斥锁</span><br><span class="line">  //int pthread_mutex_init(pthread_mutex_t *restrict mutex,</span><br><span class="line">  //         const pthread_mutexattr_t *restrict attr);</span><br><span class="line">  //             </span><br><span class="line">  pthread_mutex_init(&amp;mutex, NULL);</span><br><span class="line">  //创建线程</span><br><span class="line">  for(i = 0; i &lt; 4; i++)</span><br><span class="line">  &#123;</span><br><span class="line">    ret = pthread_create(&amp;tid[i], NULL, ticket_scalper, (void*)i);</span><br><span class="line">    if(ret != 0)</span><br><span class="line">    &#123;</span><br><span class="line">      perror(&quot;thread creat error:&quot;);</span><br><span class="line">      return -1;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  for(i = 0; i &lt; 4; i++)</span><br><span class="line">  &#123;</span><br><span class="line">    pthread_join(tid[i], NULL);</span><br><span class="line">  &#125;</span><br><span class="line">  //销毁互斥锁</span><br><span class="line">  //int pthread_mutex_destroy(pthread_mutex_t *mutex);</span><br><span class="line">  pthread_mutex_destroy(&amp;mutex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[misaki@localhost thread_2019_9_2_class45]$ ./main </span><br><span class="line">scalper:2--get a ticket:100</span><br><span class="line">scalper:2--get a ticket:99</span><br><span class="line">scalper:2--get a ticket:98</span><br><span class="line">scalper:2--get a ticket:97</span><br><span class="line">scalper:2--get a ticket:96</span><br><span class="line">scalper:2--get a ticket:95</span><br><span class="line">scalper:3--get a ticket:94</span><br><span class="line">scalper:3--get a ticket:93</span><br><span class="line">scalper:3--get a ticket:92</span><br><span class="line">scalper:3--get a ticket:91</span><br><span class="line">scalper:3--get a ticket:90</span><br><span class="line">scalper:3--get a ticket:89</span><br><span class="line">scalper:3--get a ticket:88</span><br><span class="line">scalper:3--get a ticket:87</span><br><span class="line">scalper:3--get a ticket:86</span><br><span class="line">scalper:3--get a ticket:85</span><br><span class="line">scalper:3--get a ticket:84</span><br><span class="line">scalper:3--get a ticket:83</span><br><span class="line">scalper:3--get a ticket:82</span><br><span class="line">scalper:3--get a ticket:81</span><br><span class="line">scalper:3--get a ticket:80</span><br><span class="line">scalper:3--get a ticket:79</span><br><span class="line">scalper:3--get a ticket:78</span><br><span class="line">scalper:3--get a ticket:77</span><br><span class="line">scalper:3--get a ticket:76</span><br><span class="line">scalper:3--get a ticket:75</span><br><span class="line">scalper:3--get a ticket:74</span><br><span class="line">scalper:3--get a ticket:73</span><br><span class="line">scalper:3--get a ticket:72</span><br><span class="line">scalper:3--get a ticket:71</span><br><span class="line">scalper:3--get a ticket:70</span><br><span class="line">scalper:3--get a ticket:69</span><br><span class="line">scalper:3--get a ticket:68</span><br><span class="line">scalper:3--get a ticket:67</span><br><span class="line">scalper:3--get a ticket:66</span><br><span class="line">scalper:3--get a ticket:65</span><br><span class="line">scalper:3--get a ticket:64</span><br><span class="line">scalper:3--get a ticket:63</span><br><span class="line">scalper:3--get a ticket:62</span><br><span class="line">scalper:3--get a ticket:61</span><br><span class="line">scalper:3--get a ticket:60</span><br><span class="line">scalper:3--get a ticket:59</span><br><span class="line">scalper:3--get a ticket:58</span><br><span class="line">scalper:3--get a ticket:57</span><br><span class="line">scalper:3--get a ticket:56</span><br><span class="line">scalper:3--get a ticket:55</span><br><span class="line">scalper:3--get a ticket:54</span><br><span class="line">scalper:3--get a ticket:53</span><br><span class="line">scalper:3--get a ticket:52</span><br><span class="line">scalper:3--get a ticket:51</span><br><span class="line">scalper:3--get a ticket:50</span><br><span class="line">scalper:3--get a ticket:49</span><br><span class="line">scalper:3--get a ticket:48</span><br><span class="line">scalper:3--get a ticket:47</span><br><span class="line">scalper:3--get a ticket:46</span><br><span class="line">scalper:3--get a ticket:45</span><br><span class="line">scalper:3--get a ticket:44</span><br><span class="line">scalper:3--get a ticket:43</span><br><span class="line">scalper:3--get a ticket:42</span><br><span class="line">scalper:3--get a ticket:41</span><br><span class="line">scalper:3--get a ticket:40</span><br><span class="line">scalper:3--get a ticket:39</span><br><span class="line">scalper:3--get a ticket:38</span><br><span class="line">scalper:3--get a ticket:37</span><br><span class="line">scalper:3--get a ticket:36</span><br><span class="line">scalper:3--get a ticket:35</span><br><span class="line">scalper:3--get a ticket:34</span><br><span class="line">scalper:3--get a ticket:33</span><br><span class="line">scalper:3--get a ticket:32</span><br><span class="line">scalper:3--get a ticket:31</span><br><span class="line">scalper:3--get a ticket:30</span><br><span class="line">scalper:3--get a ticket:29</span><br><span class="line">scalper:3--get a ticket:28</span><br><span class="line">scalper:3--get a ticket:27</span><br><span class="line">scalper:3--get a ticket:26</span><br><span class="line">scalper:3--get a ticket:25</span><br><span class="line">scalper:3--get a ticket:24</span><br><span class="line">scalper:3--get a ticket:23</span><br><span class="line">scalper:3--get a ticket:22</span><br><span class="line">scalper:3--get a ticket:21</span><br><span class="line">scalper:3--get a ticket:20</span><br><span class="line">scalper:3--get a ticket:19</span><br><span class="line">scalper:3--get a ticket:18</span><br><span class="line">scalper:3--get a ticket:17</span><br><span class="line">scalper:3--get a ticket:16</span><br><span class="line">scalper:3--get a ticket:15</span><br><span class="line">scalper:3--get a ticket:14</span><br><span class="line">scalper:3--get a ticket:13</span><br><span class="line">scalper:3--get a ticket:12</span><br><span class="line">scalper:3--get a ticket:11</span><br><span class="line">scalper:3--get a ticket:10</span><br><span class="line">scalper:3--get a ticket:9</span><br><span class="line">scalper:3--get a ticket:8</span><br><span class="line">scalper:3--get a ticket:7</span><br><span class="line">scalper:3--get a ticket:6</span><br><span class="line">scalper:3--get a ticket:5</span><br><span class="line">scalper:3--get a ticket:4</span><br><span class="line">scalper:3--get a ticket:3</span><br><span class="line">scalper:3--get a ticket:2</span><br><span class="line">scalper:3--get a ticket:1</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;这样就达成了互斥，在一个线程操作临界资源时，其他线程不会同时干涉。</p>
<h4 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h4><p>&emsp;&emsp;死锁是指因为对一些无法加锁的锁进行加锁操作而导致程序卡死。死锁是我们一定要在使用锁时要注意和避免的<br><br>&emsp;&emsp;死锁产生的四个必要条件：<br><br>&emsp;&emsp;1、互斥条件。一个线程操作时其他线程不能操作。<br><br>&emsp;&emsp;2、不可剥夺条件。一个线程加的锁别的线程不能释放。<br><br>&emsp;&emsp;3、请求与保持条件。一个线程已经有了锁却还在请求其他的锁，但是其他的锁请求不到第一个锁也不释放。<br><br>&emsp;&emsp;4、环路等待条件。<br><br>&emsp;&emsp;死锁产生往往是因为加锁解锁的顺序不同。要想避免死锁就要避免死锁产生的四个必要条件——死锁检测算法，银行家算法。<br></p>
<h3 id="同步"><a href="#同步" class="headerlink" title="同步"></a>同步</h3><p>&emsp;&emsp;通过对当前是否满足对临界资源的操作条件来判断线程是否该等待或唤醒这种方式实现对临界资源访问的合理性。资源产生后才能进行使用，没有资源则等待资源产生，生产资源后则唤醒等待，这样则达成同步。然而互斥锁虽然可以帮助我们完成等待但是无法判断何时将我们唤醒，不能在合适的事件唤醒，因此便要借助新的东西——条件变量。</p>
<h4 id="条件变量"><a href="#条件变量" class="headerlink" title="条件变量"></a>条件变量</h4><p>&emsp;&emsp;条件变量的使用流程：<br><br>&emsp;&emsp;1、定义条件变量：<code>pthread_cond_t</code>。<br><br>&emsp;&emsp;2、初始化条件变量：<code>pthread_cond_init</code>。<br><br>&emsp;&emsp;3、等待或者唤醒：<code>pthread_cond_wait/pthread_cond_signal</code>。<br><br>&emsp;&emsp;4、销毁条件变量：<code>pthread_cond_destroy</code>。<br><br>&emsp;&emsp;<code>pthread_cond_wait</code>中一共有三个操作，首先它要让让当前线程等待，但是此时有一点，此时的互斥量还处于加锁状态其他线程无法操作临界资源，呢又怎么做到让临界资源达到要求呢？因此他在让线程等待前要先解除了互斥量的加锁状态，并且这两部操作为<strong>原子操作</strong>。为什么要是原子操作？因为如果不是原子操作有可能在解锁后已经条件满足而此时线程还未进行等待可能会忽略唤醒。之后在线程被唤醒后<code>pthread_cond_wait</code>还会再加锁保证互斥。这就是三部操作：<code>解锁-&gt;等待-&gt;唤醒后加锁</code>。<br>&emsp;&emsp;在每一个条件变量内部都有一个等待队列，将所有等待的线程排列在上面，如果有其他线程唤醒则逐一唤醒。<br>&emsp;&emsp;接下来我们用互斥锁加条件变量模拟实现一个顾客去餐馆吃饭的情景，但是在这个情境中为了符合设计要注意两个顾客不能同时吃一碗饭，并且只有一个锅因此两个厨师不能同时做饭。如果没饭了2个厨师中其中一个做饭，又犯了2个顾客其中一个吃饭。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br></pre></td><td class="code"><pre><span class="line">/*实现条件变量的基本使用*/                                           </span><br><span class="line">/*吃面前提有人吃面，如果没有线程的面，等待老板做出来</span><br><span class="line"> * 老板做出来面就要唤醒顾客</span><br><span class="line"> * 老板不会做太多的面，老板只会提前做一碗面         </span><br><span class="line"> * 如果已经有面做出来，但是没人吃，不会再做（等待）</span><br><span class="line"> * 顾客吃完面后，老板再来一碗（唤醒老板的等待）*/</span><br><span class="line">#include &lt;stdio.h&gt;       </span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;errno.h&gt;</span><br><span class="line">#include &lt;pthread.h&gt;      </span><br><span class="line">//是否右面</span><br><span class="line">int have_noodle = 1;                                    </span><br><span class="line">//为了让客人与厨师间的不同的同步性，需要定义多个条件变量</span><br><span class="line">pthread_cond_t customer;</span><br><span class="line">pthread_cond_t boss;         </span><br><span class="line">pthread_mutex_t mutex;</span><br><span class="line">//老板做面</span><br><span class="line">void* thr_boss(void* arg)</span><br><span class="line">&#123;                        </span><br><span class="line">  while(1)               </span><br><span class="line">  &#123;           </span><br><span class="line">    pthread_mutex_lock(&amp;mutex);                  </span><br><span class="line">    //由于多个顾客，为了避免两个顾客吃一碗面的情况这里要循环判断</span><br><span class="line">    while(have_noodle == 1)//有面</span><br><span class="line">    &#123;    </span><br><span class="line">      //等待                  </span><br><span class="line">      //int pthread_cond_timedwait(pthread_cond_t *restrict cond,</span><br><span class="line">      //       pthread_mutex_t *restrict mutex,</span><br><span class="line">      //              const struct timespec *restrict abstime);</span><br><span class="line">      //限时等待</span><br><span class="line">      //cond:条件变量</span><br><span class="line">      //mutex:互斥锁</span><br><span class="line">      //abstime:限时等待时长</span><br><span class="line">      //时间到后返回时间超市，停止阻塞</span><br><span class="line">      //int pthread_cond_wait(pthread_cond_t *restrict cond,</span><br><span class="line">      //       pthread_mutex_t *restrict mutex);</span><br><span class="line">      //cond:条件变量</span><br><span class="line">      //mutex:互斥锁</span><br><span class="line">      //pthread_cond_wait 集合了解锁后挂起的操作（原子操作，不可被打断）</span><br><span class="line">      //有可能还没来得及挂起就已经有人唤醒，白唤醒，导致死等</span><br><span class="line">      //因此这里的wait将三个操作进行了原子性封装不让其中断</span><br><span class="line">      //解锁 -》 等待 -》 被唤醒后加锁</span><br><span class="line">      pthread_cond_wait(&amp;boss, &amp;mutex);</span><br><span class="line">    &#125;</span><br><span class="line">    //面没了，要再做</span><br><span class="line">    printf(&quot;拉面 + 1\n&quot;);</span><br><span class="line">    have_noodle = 1;</span><br><span class="line">    //面好了，唤醒顾客</span><br><span class="line">    pthread_cond_signal(&amp;customer);                                      </span><br><span class="line">    //解锁</span><br><span class="line">    pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">  &#125;</span><br><span class="line">    return NULL;</span><br><span class="line">&#125;</span><br><span class="line">//顾客吃面</span><br><span class="line">void* thr_customer(void* arg)</span><br><span class="line">&#123;</span><br><span class="line">  while(1)</span><br><span class="line">  &#123;</span><br><span class="line">    while(have_noodle == 0)</span><br><span class="line">    &#123;</span><br><span class="line">      //若没有现成的面等老板做好</span><br><span class="line">      //等待</span><br><span class="line">      pthread_cond_wait(&amp;customer, &amp;mutex);</span><br><span class="line">    &#125;</span><br><span class="line">    //有面了</span><br><span class="line">    printf(&quot;真好吃！\n&quot;);</span><br><span class="line">    have_noodle -= 1;                               </span><br><span class="line">    //唤醒厨师再做一碗</span><br><span class="line">    pthread_cond_signal(&amp;boss);</span><br><span class="line">    //解锁</span><br><span class="line">    pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">  &#125;</span><br><span class="line">  return NULL;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">  pthread_t tid1, tid2;</span><br><span class="line">  int ret;</span><br><span class="line">  //条件变量初始化</span><br><span class="line">  //int pthread_cond_init(pthread_cond_t *restrict cond,</span><br><span class="line">  //       const pthread_condattr_t *restrict attr);</span><br><span class="line">  pthread_cond_init(&amp;boss, NULL);</span><br><span class="line">  pthread_cond_init(&amp;customer, NULL);</span><br><span class="line">  pthread_mutex_init(&amp;mutex, NULL);</span><br><span class="line">  //各建立两个线程同时工作，相当于两个厨师两个客人</span><br><span class="line">  //客人间具有互斥性，厨师间也有互斥性，客人与厨师间有同步与互斥性</span><br><span class="line">  for(int i = 0; i &lt; 2; i++)</span><br><span class="line">  &#123;                                                                </span><br><span class="line">    ret = pthread_create(&amp;tid1, NULL, thr_boss, NULL);</span><br><span class="line">    if(ret != 0)</span><br><span class="line">    &#123;</span><br><span class="line">      printf(&quot;boss error&quot;);</span><br><span class="line">      return -1;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  for(int i = 0; i &lt; 2; i++)</span><br><span class="line">  &#123;</span><br><span class="line">    ret = pthread_create(&amp;tid2, NULL, thr_customer, NULL);</span><br><span class="line">    if(ret != 0)</span><br><span class="line">    &#123;</span><br><span class="line">      printf(&quot;customer error&quot;);</span><br><span class="line">      return -1;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  pthread_join(tid1, NULL);</span><br><span class="line">  pthread_join(tid2, NULL);</span><br><span class="line">  //销毁条件变量</span><br><span class="line">  //int pthread_cond_destroy(pthread_cond_t *cond);</span><br><span class="line">  pthread_cond_destroy(&amp;customer);                              </span><br><span class="line">  pthread_cond_destroy(&amp;boss);</span><br><span class="line">  //销毁锁</span><br><span class="line">  pthread_mutex_destroy(&amp;mutex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">真好吃！</span><br><span class="line">拉面 + 1</span><br><span class="line">真好吃！</span><br><span class="line">拉面 + 1</span><br><span class="line">真好吃！</span><br><span class="line">拉面 + 1</span><br><span class="line">真好吃！</span><br><span class="line">拉面 + 1</span><br><span class="line">真好吃！</span><br><span class="line">拉面 + 1</span><br><span class="line">真好吃！</span><br><span class="line">拉面 + 1</span><br><span class="line">真好吃！</span><br><span class="line">拉面 + 1</span><br><span class="line">^C真好吃！</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;在以上这个例子中要注意几个点：<br>&emsp;&emsp;1、用户对条件判断需要使用循环进行判断（防止角色不符合条件被唤醒之后因为不循环判断直接操作临界资源）。这个问题也被称为<strong>虚假唤醒</strong>问题。在多核处理器下，<code>pthread_cond_signal</code>可能会激活多于一个线程（阻塞在条件变量上的线程）。结果就是，当一个线程调用<code>pthread_cond_signal()</code>后，多个调用<code>pthread_cond_wait()</code>或其他等待在队列上的线程返回。这种效应就会造成<strong>虚假唤醒</strong>。<br>&emsp;&emsp;2、不同角色的线程因该等待在不同的条件变量上。（防止角色的误唤醒，导致程序阻塞）<br>&emsp;&emsp;但是要注意条件变量并不保证安全，因此往往使用条件变量的时候会与互斥锁共同使用。面生产一碗顾客吃一碗没有出现异常，因此实现是成功的。这种在多线程情况下有人生产数据有人消费数据利用同步与互斥达到合理与安全的模式十分经典，因此产生了一种固定的设计模型，这就是<strong>生产者消费者模型</strong>。</p>
<h3 id="生产者与消费者模型"><a href="#生产者与消费者模型" class="headerlink" title="生产者与消费者模型"></a>生产者与消费者模型</h3><p>&emsp;&emsp;生产者与消费者模型中有两种角色：生产者与消费者，同时包含三种关系：生产者与生产者之间互斥，消费者与消费者之间互斥，生产者与消费者之间同步与互斥。他们工作在一个场景中，这个场景通常是一个队列，用来保存数据。</p>
<h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br></pre></td><td class="code"><pre><span class="line">/**                                                   </span><br><span class="line"> * 基于互斥锁与条件变量实现一个线程安全的队列</span><br><span class="line"> * 实现生产者与消费者模型</span><br><span class="line"> **/                 </span><br><span class="line">#include &lt;iostream&gt;                                   </span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line">#include &lt;pthread.h&gt;</span><br><span class="line">#define MAXQ 10</span><br><span class="line">class BlockQueue</span><br><span class="line">&#123;</span><br><span class="line">public:                    </span><br><span class="line">  BlockQueue(int maxq = MAXQ)</span><br><span class="line">    :_capacity(maxq)</span><br><span class="line">  &#123;                   </span><br><span class="line">    pthread_mutex_init(&amp;_mutex, NULL);</span><br><span class="line">    pthread_cond_init(&amp;_cond_consumer, NULL);         </span><br><span class="line">    pthread_cond_init(&amp;_cond_productor, NULL);</span><br><span class="line">  &#125;</span><br><span class="line">  ~BlockQueue()                                     </span><br><span class="line">  &#123;</span><br><span class="line">    pthread_mutex_destroy(&amp;_mutex);</span><br><span class="line">    pthread_cond_destroy(&amp;_cond_consumer);</span><br><span class="line">    pthread_cond_destroy(&amp;_cond_productor);</span><br><span class="line">  &#125;                                                   </span><br><span class="line">  bool QueuePush(int data)</span><br><span class="line">  &#123;</span><br><span class="line">    pthread_mutex_lock(&amp;_mutex);                    </span><br><span class="line">    while(_queue.size() == _capacity)</span><br><span class="line">    &#123;</span><br><span class="line">      pthread_cond_wait(&amp;_cond_productor, &amp;_mutex);</span><br><span class="line">    &#125;</span><br><span class="line">    _queue.push(data);        </span><br><span class="line">    pthread_mutex_unlock(&amp;_mutex);</span><br><span class="line">    pthread_cond_signal(&amp;_cond_consumer);</span><br><span class="line">    return true;</span><br><span class="line">  &#125;</span><br><span class="line">  bool QueuePop(int &amp;data)</span><br><span class="line">  &#123;</span><br><span class="line">    pthread_mutex_lock(&amp;_mutex);</span><br><span class="line">    while(_queue.empty())</span><br><span class="line">    &#123;</span><br><span class="line">      pthread_cond_wait(&amp;_cond_consumer, &amp;_mutex);</span><br><span class="line">    &#125;</span><br><span class="line">    data = _queue.front();</span><br><span class="line">    _queue.pop();</span><br><span class="line">    pthread_mutex_unlock(&amp;_mutex);</span><br><span class="line">    pthread_cond_signal(&amp;_cond_productor);</span><br><span class="line">    return true;</span><br><span class="line">  &#125;</span><br><span class="line">private:</span><br><span class="line">  std::queue&lt;int&gt; _queue;</span><br><span class="line">  int _capacity;</span><br><span class="line">  pthread_mutex_t _mutex;</span><br><span class="line">  pthread_cond_t _cond_productor;</span><br><span class="line">  pthread_cond_t _cond_consumer;</span><br><span class="line">&#125;;</span><br><span class="line">void* thr_consumer(void* arg)</span><br><span class="line">&#123;</span><br><span class="line">  BlockQueue* q = (BlockQueue*)arg;</span><br><span class="line">  int data;</span><br><span class="line">  while(1)</span><br><span class="line">  &#123;</span><br><span class="line">    //消费者一直获取数据进行打印</span><br><span class="line">    q-&gt;QueuePop(data);                                                       </span><br><span class="line">    std::cout &lt;&lt; &quot;consumer gets a piece of data--&quot; &lt;&lt; data &lt;&lt; std::endl;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">void* thr_productor(void* arg)</span><br><span class="line">&#123;</span><br><span class="line">  BlockQueue* q = (BlockQueue*)arg;</span><br><span class="line">  int data = 0;</span><br><span class="line">  while(1)</span><br><span class="line">  &#123;</span><br><span class="line">    //生产者一直添加数据</span><br><span class="line">    q-&gt;QueuePush(data);</span><br><span class="line">    std::cout &lt;&lt; &quot;producer produces a data--&quot;  &lt;&lt; (data++) &lt;&lt; std::endl;</span><br><span class="line">  &#125;</span><br><span class="line">  return NULL;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">  pthread_t ctid[4], ptid[4];</span><br><span class="line">  int ret, i;</span><br><span class="line">  BlockQueue q;</span><br><span class="line">  for(i = 0; i &lt; 4; i++)</span><br><span class="line">  &#123;</span><br><span class="line">    ret = pthread_create(&amp;ctid[i], NULL, thr_consumer, (void*)&amp;q);</span><br><span class="line">    if(ret != 0)</span><br><span class="line">    &#123;</span><br><span class="line">      std::cerr &lt;&lt; &quot;create thread error&quot; &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  for(i = 0; i &lt; 4; i++)</span><br><span class="line">  &#123;</span><br><span class="line">    ret = pthread_create(&amp;ptid[i], NULL, thr_productor, (void*)&amp;q);</span><br><span class="line">    if(ret != 0)                                                         </span><br><span class="line">    &#123;</span><br><span class="line">      std::cerr &lt;&lt; &quot;create thread error&quot; &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  for(i = 0; i &lt; 4; i++)</span><br><span class="line">  &#123;</span><br><span class="line">    pthread_join(ctid[i], NULL);</span><br><span class="line">    pthread_join(ptid[i], NULL);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;                             </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">consumer gets a piece of data--2111</span><br><span class="line">consumer gets a piece of data--2112</span><br><span class="line">consumer gets a piece of data--2113</span><br><span class="line">consumer gets a piece of data--2114</span><br><span class="line">consumer gets a piece of data--2115</span><br><span class="line">consumer gets a piece of data--2116</span><br><span class="line">consumer gets a piece of data--2117</span><br><span class="line">consumer gets a piece of data--2118</span><br><span class="line">producer produces a data--2119</span><br><span class="line">producer produces a data--2120</span><br><span class="line">producer produces a data--2121</span><br><span class="line">producer produces a data--2122</span><br><span class="line">producer produces a data--2123</span><br><span class="line">producer produces a data--2124</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;这里打印之所以看上去乱是因为xshell的显示跟不上虚拟机计算的速度。</p>
<h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><p>&emsp;&emsp;生产者与消费者模型有三个优点：<br>&emsp;&emsp;1、解耦合<br>&emsp;&emsp;2、支持忙闲不均<br>&emsp;&emsp;3、支持并发<br>&emsp;&emsp;一个场所，两种角色，三种关系。</p>
<h3 id="posix标准信号量"><a href="#posix标准信号量" class="headerlink" title="posix标准信号量"></a>posix标准信号量</h3><p>&emsp;&emsp;<code>system V</code>是内核中的计数器，<code>posix</code>是线程间的全局计数器。它也有着实现进程/进程间同步与互斥的贡藕功能。</p>
<h4 id="与条件变量的区别"><a href="#与条件变量的区别" class="headerlink" title="与条件变量的区别"></a>与条件变量的区别</h4><p>&emsp;&emsp;条件变量是通过等待、唤醒操作来让线程等待在等待队列上来完成同步，这需要用户自己进行外部条件判断并且要搭配互斥锁一起使用。<br>&emsp;&emsp;信号量是通过自身内部技术实现条件的判断，不需要搭配互斥锁，自身已经保证了原子操作。</p>
<h4 id="信号量的工作原理"><a href="#信号量的工作原理" class="headerlink" title="信号量的工作原理"></a>信号量的工作原理</h4><p>&emsp;&emsp;信号量通过一个计数器实现对资源的计数，并且通过这个计数来判断当前线程/进程能否对临界资源进行访问，对临界资源进行访问之前先发起调用访问信号量进行判断是否能够访问。<br>&emsp;&emsp;信号量实现同步：首先资源计数-1，若此时资源计数<code>&gt;=0</code>，则可以直接进行访问，调用直接返回，若信号量内部计数器<code>&lt;0</code>表示没有资源无法访问，调用阻塞（挂起线程）；若其他线程生产了一个资源则发起调用，首先资源计数+1，如果此时计数器<code>&lt;=0</code>则唤醒等待队列上的线程，若此时计数器<code>&gt;0</code>则什么都不做。<br>&emsp;&emsp;信号量实现互斥：计数只有0/1，资源只有一个，同一时间只有 一个线程可以访问。首先信号量-1，若此时信号量<code>&lt;0</code>则调用阻塞，若<code>&gt;0</code>，则调用返回，对临界资源进行访问，访问完毕，进行计数+1，唤醒所有线程，所有线程继续进行抢夺。<br>&emsp;&emsp;同时如果信号量小于0则表示当前阻塞在等待队列上的线程/进程数，等于0表示资源刚好完全分配，大于0则表示多余资源数。</p>
<h4 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">sem_t//定义信号量。</span><br><span class="line">sem_init(sem_t* sem, int flag, int initval);//初始化，</span><br><span class="line">    //flag:0-线程间,!0-进程间</span><br><span class="line">    //initval:用于设置初值</span><br><span class="line">sem_wait(sem_t* sem);//，进行判断是否有资源，&lt;=0则阻塞，&gt;0则-1并调用返回并。</span><br><span class="line">sem_trywait(sem_t* sem);//非阻塞，没有资源直接报错返回。</span><br><span class="line">sem_timedwait(sem_t* sem);//限时阻塞，等待一段时间，若一直没有资源则超时报错返回</span><br><span class="line">sem_post(sem_t* sem);//计数+1，并且唤醒等待的线程</span><br><span class="line">sem_destroy(sem_t* sem);//销毁信号量</span><br></pre></td></tr></table></figure>
<h4 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h4><p>&emsp;&emsp;用信号量实现线程安全的环形队列。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 利用信号量完成线程安全的环形队列</span><br><span class="line"> **/</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;semaphore.h&gt;</span><br><span class="line">#include &lt;thread&gt;</span><br><span class="line">#define MAXQ 10</span><br><span class="line">class RingQueue</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">  RingQueue(int maxq = MAXQ)</span><br><span class="line">    :_capacity(maxq)</span><br><span class="line">    ,_queue(maxq)</span><br><span class="line">    ,_step_read(0)</span><br><span class="line">    ,_step_write(0)                                      </span><br><span class="line">  &#123;</span><br><span class="line">    sem_init(&amp;_lock, 0, 1);</span><br><span class="line">    sem_init(&amp;_idle_space, 0, maxq);</span><br><span class="line">    sem_init(&amp;_data_space, 0, 0);</span><br><span class="line">  &#125;</span><br><span class="line">  ~RingQueue()</span><br><span class="line">  &#123;</span><br><span class="line">    sem_destroy(&amp;_lock);</span><br><span class="line">    sem_destroy(&amp;_idle_space);</span><br><span class="line">    sem_destroy(&amp;_data_space);</span><br><span class="line">  &#125;</span><br><span class="line">  bool QueuePush(int data)</span><br><span class="line">  &#123;</span><br><span class="line">    //没有空闲空间则阻塞</span><br><span class="line">    sem_wait(&amp;_idle_space);</span><br><span class="line">    //加锁</span><br><span class="line">    sem_wait(&amp;_lock);</span><br><span class="line">    _queue[_step_write] = data;</span><br><span class="line">    _step_write = (_step_write + 1) % _capacity;</span><br><span class="line">    //解锁</span><br><span class="line">    sem_post(&amp;_lock);</span><br><span class="line">    //唤醒消费者</span><br><span class="line">    sem_post(&amp;_data_space);</span><br><span class="line">    return true;</span><br><span class="line">  &#125;</span><br><span class="line">  bool QueuePop(int&amp; data)</span><br><span class="line">  &#123;</span><br><span class="line">    sem_wait(&amp;_data_space);</span><br><span class="line">    sem_wait(&amp;_lock);</span><br><span class="line">    data = _queue[_step_read];</span><br><span class="line">    _step_read = (_step_read + 1) % _capacity;</span><br><span class="line">    sem_post(&amp;_lock);</span><br><span class="line">    sem_post(&amp;_idle_space);</span><br><span class="line">    return true;</span><br><span class="line">  &#125;</span><br><span class="line">private:</span><br><span class="line">  std::vector&lt;int&gt; _queue;//用vector实现环形队列</span><br><span class="line">  int _capacity;//容量</span><br><span class="line">  int _step_read;//读指针</span><br><span class="line">  int _step_write;//写指针</span><br><span class="line">  </span><br><span class="line">  sem_t _lock;//初始计数=1，负责完成互斥</span><br><span class="line"></span><br><span class="line">  //也需要有两个等待队列，分别完成两个角色间的同步</span><br><span class="line">  sem_t _idle_space;//空闲空间节点个数，生产者等待在这里，完成同步</span><br><span class="line">  sem_t _data_space;//数据节点个数，初始=0，消费者等待在这里，完成同步  </span><br><span class="line">&#125;;</span><br><span class="line">void thr_producer(RingQueue* q)</span><br><span class="line">&#123;</span><br><span class="line">  int data = 0;</span><br><span class="line">  while(1)</span><br><span class="line">  &#123;</span><br><span class="line">    q-&gt;QueuePush(data);</span><br><span class="line">    std::cout &lt;&lt; &quot;push data ----&quot; &lt;&lt; data++ &lt;&lt; std::endl;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">void thr_consumer(RingQueue* q)</span><br><span class="line">&#123;</span><br><span class="line">  int data = 0;</span><br><span class="line">  while(1)</span><br><span class="line">  &#123;</span><br><span class="line">    q-&gt;QueuePop(data);</span><br><span class="line">    std::cout &lt;&lt; &quot;get data ----&quot; &lt;&lt; data &lt;&lt; std::endl;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">  RingQueue q;</span><br><span class="line">  std::vector&lt;std::thread&gt; list_con(4);</span><br><span class="line">  std::vector&lt;std::thread&gt; list_pro(4);</span><br><span class="line">  for(int i = 0; i &lt; 4; i++)</span><br><span class="line">  &#123;</span><br><span class="line">    list_pro[i] = (std::thread(thr_producer, &amp;q));</span><br><span class="line">  &#125;</span><br><span class="line">  for(int i = 0; i &lt; 4; i++)</span><br><span class="line">  &#123;</span><br><span class="line">    list_con[i] = (std::thread(thr_consumer, &amp;q));        </span><br><span class="line">  &#125;</span><br><span class="line">  for(int i = 0; i &lt; 4; i++)</span><br><span class="line">  &#123;</span><br><span class="line">    list_con[i].join();</span><br><span class="line">    list_pro[i].join();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;       </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">push data ----4028</span><br><span class="line">get data ----push data ----4102</span><br><span class="line">41004029</span><br><span class="line">3996push data ----4030</span><br><span class="line">push data ----4031</span><br><span class="line">push data ----4032</span><br><span class="line">push data ----push data ----4033</span><br><span class="line">push data ----4034</span><br><span class="line">push data ----4101</span><br><span class="line">push data ----4102</span><br><span class="line">get data ----</span><br><span class="line">push data ----4103</span><br><span class="line">push data ----4104</span><br><span class="line">40974102</span><br><span class="line">get data ----4101</span><br><span class="line"></span><br><span class="line">push data ----4103</span><br><span class="line"></span><br><span class="line">push data ----get data ----4029</span><br><span class="line">4095</span><br><span class="line">get data ----4031</span><br><span class="line">get data ----4032</span><br><span class="line">get data ----4033</span><br><span class="line">get data ----4034</span><br><span class="line">get data ----4102</span><br><span class="line">get data ----get data ----40304103</span><br><span class="line">push data ----get data ----4104</span><br><span class="line">get data ----4103</span><br><span class="line">get data ----4105</span><br><span class="line">get data ----4104</span><br><span class="line">push data ----3997</span><br><span class="line">push data ----3998</span><br><span class="line">push data ----3999</span><br><span class="line">push data ----4000</span><br><span class="line">push data ----4001</span><br><span class="line">4104get data ----</span><br><span class="line">push data ----4105</span><br><span class="line">push data ----4106</span><br><span class="line">push data ----4107</span><br><span class="line">push data ----4108</span><br><span class="line">push data ----push data ----4035</span><br><span class="line">3997</span><br><span class="line">get data ----3999</span><br><span class="line">get data ----4000</span><br></pre></td></tr></table></figure></p>
<h3 id="读写锁"><a href="#读写锁" class="headerlink" title="读写锁"></a>读写锁</h3><p>&emsp;&emsp;读写锁在数据库中就有着极为重要的应用，这样才得以让数据得到共享修改得到合理的保存而不出现数据的二义性。</p>
<h4 id="特点，原理及应用"><a href="#特点，原理及应用" class="headerlink" title="特点，原理及应用"></a>特点，原理及应用</h4><p>&emsp;&emsp;读写锁有着自己的特点：<strong>写互斥，读共享</strong>，一个用户写时所有其他所有用户都不能读和写；一个用户读时其他所有用户都可以读但不能写，因此适用于多读少写的应用场景，保证数据不会出现二义性并且保证读取和写入的效率。<br>&emsp;&emsp;读写锁内部有两个计数器，读者计数与写者计数。加写锁时对两个技术进行判断如果任意一个计数器&gt;0，都无法加写锁需要等待。加读锁时对写者计数进行判断，若大于0，则无法加读锁需要进行等待。<br>&emsp;&emsp;读写锁通过<strong>自旋锁</strong>实现，不满足条件时自旋等待。自旋锁的特点是：等待中不停循环对条件进行判断，因此可以及时响应，但是cpu消耗较高。自旋锁一般应用在对于挂起等待被唤醒时间相较于数据处理时间可以忽略不记的情况下，这样更倾向于挂起。</p>
<h2 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h2><h3 id="为什么要有线程池"><a href="#为什么要有线程池" class="headerlink" title="为什么要有线程池"></a>为什么要有线程池</h3><p>&emsp;&emsp;假如在一个任务的处理时间中，若线程创建及销毁的时间占用任务处理的大量比例，则意味着大量任务处理中，资源被浪费在线程的创建与销毁中。因此产生线程池，创建大量线程，但并不推出线程并不断把任务交给这些线程处理，避免了大量创建线程/销毁带来的时间成本。<br>&emsp;&emsp;线程池中线程数量是有上限的，为了防止出现峰值压力导致资源瞬间耗尽程序崩溃。</p>
<h3 id="线程池的实现"><a href="#线程池的实现" class="headerlink" title="线程池的实现"></a>线程池的实现</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br></pre></td><td class="code"><pre><span class="line">/**                                                                             </span><br><span class="line"> * 线程池由两个部分构成一个是一个任务类</span><br><span class="line"> * 另一个部分是一个线程安全的队列，由此构成任务队列，</span><br><span class="line"> * 再用一组线程从任务队列中获取任务来执行</span><br><span class="line"> * 由此构成线程池        </span><br><span class="line"> **/</span><br><span class="line">#include &lt;iostream&gt;                                     </span><br><span class="line">#include &lt;unistd.h&gt;                        </span><br><span class="line">#include &lt;pthread.h&gt; </span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line">#include &lt;thread&gt;                        </span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">#include &lt;time.h&gt;             </span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;sstream&gt;</span><br><span class="line">#define MAX_THREAD 5</span><br><span class="line">#define MAX_QUEUE 10</span><br><span class="line">typedef void(*handler_t)(int val);</span><br><span class="line">//任务类</span><br><span class="line">//1、决定线程处理的任务，处理什么数据，怎么处理都由用户传入</span><br><span class="line">class Task              </span><br><span class="line">&#123;                      </span><br><span class="line">  private:                                                 </span><br><span class="line">    int _data;//数据                                        </span><br><span class="line">    handler_t _handler;//处理数据的方法，函数指针，用于传入线程中给线程下达命令</span><br><span class="line">  public:     </span><br><span class="line">    Task(int data, handler_t handler)</span><br><span class="line">      :_data(data)</span><br><span class="line">      ,_handler(handler)</span><br><span class="line">    &#123;</span><br><span class="line">                  </span><br><span class="line">    &#125;             </span><br><span class="line">    void SetTask(int data, handler_t handler)</span><br><span class="line">    &#123;</span><br><span class="line">      _data = data;  </span><br><span class="line">      _handler = handler;</span><br><span class="line">    &#125;</span><br><span class="line">    void Run()</span><br><span class="line">    &#123;</span><br><span class="line">      return _handler(_data);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line">//线程池类</span><br><span class="line">class ThreadPool</span><br><span class="line">&#123;</span><br><span class="line">  private:</span><br><span class="line">    std::queue&lt;Task&gt; _queue;//任务队列</span><br><span class="line">    int _capacity;//线程池最大任务数量</span><br><span class="line">    pthread_mutex_t _mutex;//锁，完成互斥，类似于生产者消费者模型</span><br><span class="line">    pthread_cond_t _cond_pro;//条件变量，完成</span><br><span class="line">    pthread_cond_t _cond_con;</span><br><span class="line">    int _thr_max;//线程池拥有的总线程数</span><br><span class="line">    std::vector&lt;std::thread&gt; _thr_list;//线程组，存储线程操作句柄</span><br><span class="line">    bool _quit_flag;//用于控制线程是否退出</span><br><span class="line">    int _thr_cur;//线程的数量，线程退出时，判断当前线程数量</span><br><span class="line">    void thr_start()</span><br><span class="line">    &#123;</span><br><span class="line">      while(1)</span><br><span class="line">      &#123;</span><br><span class="line">        pthread_mutex_lock(&amp;_mutex);</span><br><span class="line">        while(_queue.empty())</span><br><span class="line">        &#123;                                                                 </span><br><span class="line">          if(_quit_flag == true)</span><br><span class="line">          &#123;</span><br><span class="line">            std::cout &lt;&lt; &quot;thread exit &quot; &lt;&lt; pthread_self() &lt;&lt; std::endl; </span><br><span class="line">            pthread_mutex_unlock(&amp;_mutex);</span><br><span class="line">            _thr_cur--;</span><br><span class="line">            return;</span><br><span class="line">          &#125;</span><br><span class="line">          pthread_cond_wait(&amp;_cond_con, &amp;_mutex);</span><br><span class="line">        &#125;</span><br><span class="line">        Task tt = _queue.front();</span><br><span class="line">        _queue.pop();</span><br><span class="line">        pthread_mutex_unlock(&amp;_mutex);</span><br><span class="line">        pthread_cond_signal(&amp;_cond_pro);</span><br><span class="line">        //任务处理放到锁外，防止线程处理任务时间过长，一直加锁导致其他线程无法处理其他任务</span><br><span class="line">        tt.Run();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  public:</span><br><span class="line">    //初始化线程池</span><br><span class="line">    ThreadPool(int maxq = MAX_QUEUE, int maxt = MAX_THREAD)</span><br><span class="line">      :_capacity(maxq)</span><br><span class="line">      ,_thr_max(maxt)</span><br><span class="line">      ,_thr_list(maxt)</span><br><span class="line">      ,_thr_cur(0)</span><br><span class="line">    &#123;</span><br><span class="line">      pthread_mutex_init(&amp;_mutex, NULL);</span><br><span class="line">      pthread_cond_init(&amp;_cond_pro, NULL);</span><br><span class="line">      pthread_cond_init(&amp;_cond_con, NULL);</span><br><span class="line">    &#125;</span><br><span class="line">    ~ThreadPool()</span><br><span class="line">    &#123;</span><br><span class="line">      pthread_mutex_destroy(&amp;_mutex);</span><br><span class="line">      pthread_cond_destroy(&amp;_cond_pro);                                                     </span><br><span class="line">      pthread_cond_destroy(&amp;_cond_con);</span><br><span class="line">    &#125;</span><br><span class="line">    //初始化线程组</span><br><span class="line">    bool PoolInit()</span><br><span class="line">    &#123;</span><br><span class="line">      for(int i = 0; i &lt; _thr_max; i++)</span><br><span class="line">      &#123;</span><br><span class="line">        _thr_list[i] = std::thread(&amp;ThreadPool::thr_start, this);</span><br><span class="line">        _thr_list[i].detach();</span><br><span class="line">        _thr_cur++;</span><br><span class="line">      &#125;</span><br><span class="line">      return true;</span><br><span class="line">    &#125;</span><br><span class="line">    //添加任务</span><br><span class="line">    bool AddTask(Task&amp; tt)</span><br><span class="line">    &#123;</span><br><span class="line">      pthread_mutex_lock(&amp;_mutex);</span><br><span class="line">      while(_queue.size() == _capacity)</span><br><span class="line">      &#123;</span><br><span class="line">        pthread_cond_wait(&amp;_cond_pro, &amp;_mutex);</span><br><span class="line">      &#125;</span><br><span class="line">      _queue.push(tt);</span><br><span class="line">      pthread_mutex_unlock(&amp;_mutex);</span><br><span class="line">      pthread_cond_signal(&amp;_cond_con);</span><br><span class="line">      return true;</span><br><span class="line">    &#125;</span><br><span class="line">    //销毁线程池，停止工作</span><br><span class="line">    bool PoolStop()</span><br><span class="line">    &#123;</span><br><span class="line">      pthread_mutex_lock(&amp;_mutex);</span><br><span class="line">      _quit_flag = true;</span><br><span class="line">      pthread_mutex_unlock(&amp;_mutex);</span><br><span class="line">      while(_thr_cur &gt; 0)                                                    </span><br><span class="line">      &#123;</span><br><span class="line">        //std::cout &lt;&lt; &quot;cont:&quot; &lt;&lt; _thr_cur &lt;&lt; std::endl;</span><br><span class="line">        pthread_cond_broadcast(&amp;_cond_con);</span><br><span class="line">        usleep(1000);</span><br><span class="line">      &#125;</span><br><span class="line">      //for(int i = 0; i &lt; _thr_max; i++)</span><br><span class="line">      //&#123;</span><br><span class="line">      //  _thr_list[i].join();</span><br><span class="line">      //&#125;</span><br><span class="line">      return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">void test(int data)</span><br><span class="line">&#123;</span><br><span class="line">  srand(time(NULL));</span><br><span class="line">  int nsec = rand() % 5;</span><br><span class="line">  std::stringstream ss;</span><br><span class="line">  ss &lt;&lt; &quot;thread:&quot; &lt;&lt; pthread_self() &lt;&lt; &quot; processint data &quot;;</span><br><span class="line">  ss &lt;&lt; data &lt;&lt; &quot; and sleep &quot; &lt;&lt; nsec &lt;&lt; &quot; sec&quot; &lt;&lt; std::endl;  </span><br><span class="line">  std:: cout &lt;&lt; ss.str();</span><br><span class="line">  sleep(nsec);</span><br><span class="line">  return;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">  ThreadPool pool;</span><br><span class="line">  pool.PoolInit();</span><br><span class="line">  for(int i = 0; i &lt; 10; i++)</span><br><span class="line">  &#123;</span><br><span class="line">    Task tt(i, test);</span><br><span class="line">    pool.AddTask(tt);</span><br><span class="line">  &#125;</span><br><span class="line">  pool.PoolStop();</span><br><span class="line">&#125;                                </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[misaki@localhost thread]$ ./threadpool</span><br><span class="line">thread:139941165012736 processint data 0 and sleep 4 sec</span><br><span class="line">thread:139941156620032 processint data 1 and sleep 4 sec</span><br><span class="line">thread:139941190190848 processint data 2 and sleep 4 sec</span><br><span class="line">thread:139941181798144 processint data 3 and sleep 4 sec</span><br><span class="line">thread:139941173405440 processint data 4 and sleep 4 sec</span><br><span class="line">thread:139941190190848 processint data 6 and sleep 4 sec</span><br><span class="line">thread:139941156620032 processint data 7 and sleep 4 sec</span><br><span class="line">thread:139941181798144 processint data 8 and sleep 4 sec</span><br><span class="line">thread:139941165012736 processint data 5 and sleep 4 sec</span><br><span class="line">thread:139941173405440 processint data 9 and sleep 4 sec</span><br><span class="line">thread exit 139941156620032</span><br><span class="line">thread exit 139941190190848</span><br><span class="line">thread exit 139941181798144</span><br><span class="line">thread exit 139941165012736</span><br><span class="line">thread exit 139941173405440</span><br></pre></td></tr></table></figure>
<h2 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h2><h3 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h3><p>&emsp;&emsp;单例模式是一种常见设计模式，之前已经多次介绍，Cpp章节中也有实现。单例模式使用场景是在一个资源只能被加载分配一次，一个类只能实例化一个对象的情况。</p>
<h4 id="饿汉模式"><a href="#饿汉模式" class="headerlink" title="饿汉模式"></a>饿汉模式</h4><p>&emsp;&emsp;资源一次性加载分配完，对象在程序初始化阶段实例化完毕，这种实现是线程安全的，程序运行起来比较流畅，但是启动加载时间可能过长。</p>
<h4 id="懒汉模式"><a href="#懒汉模式" class="headerlink" title="懒汉模式"></a>懒汉模式</h4><p>&emsp;&emsp;资源使用时再加载分配，对象再使用的时候再去实例化，这种实现加载快，同一时间消耗资源少，但是运行中可能卡顿。这种实现是线程不安全的，因此我们要加锁判断类是否实例化过，如果没有则实例化。# 第八章 多线程</p>
<h2 id="线程概念-1"><a href="#线程概念-1" class="headerlink" title="线程概念"></a>线程概念</h2><p>&emsp;&emsp;多进程任务处理是同时通过多个进程进行任务，多个pcb拥有多个虚拟地址空间，分别执行不同的代码，之间互不关联。而多线程是通过多个pcb共用一个虚拟地址空间，分别执行虚拟地址空间上所对应的多个不同的物理内存中的代码。即一个虚拟地址空间对应多个物理内存。<br>&emsp;&emsp;之前我们说linux下pcb是一个进程，但其实linux下线程以进程pcb模拟实现线程，因此linux下pcb是线程；因此linux线程也叫轻量级进程。一个进程可能拥有多个线程，而每个进程势必有一个主线程，我们在主线程中创建其他线程。那么一个进程可以理解为一堆线程的集合，我们称其为线程组，而进程的pid为了不冲突则规定是主线程的pid。<br>&emsp;&emsp;因为linux线程是pcb——因此线程是cpu的基本单位。因为进程是线程组，程序运行起来，资源是分配给整个线程组的，因此进程是资源分配的基本单位。</p>
<h3 id="进程与线程的对比-1"><a href="#进程与线程的对比-1" class="headerlink" title="进程与线程的对比"></a>进程与线程的对比</h3><p>&emsp;&emsp;一个进程中的线程共用同一个虚拟地址空间，因此线程间通信更加方便；线程的创建/销毁成本更低；线程间切换调度成本更低；线程的执行粒度更细。<br>&emsp;&emsp;线程之间缺乏访问控制——系统调用，异常针对的是整个进程，健壮性低。<br>&emsp;&emsp;<code>vfork</code>创建一个子进程共用同一个虚拟地址空间，怕出现调用栈混乱，因此子进程运行完毕或程序替换后父进程才开始运行。而线程也共用同一个虚拟地址空间却不会发生调用栈混乱的情况，因为每个线程都会有一些独立的信息，会为每个线程在虚拟地址空间中单独分配一块内存用来存储这些独立的信息：<strong>栈，寄存器，errno，信号屏蔽字，调度优先级</strong>。同时线程间也有共享的数据：<strong>代码段，数据段，文件描述符表，信号处理方式，用户和组，当前工作目录</strong>。<br>&emsp;&emsp;多线程相比多进程的优点：<br>&emsp;&emsp;1、通信更加方便，灵活。<br>&emsp;&emsp;2、创建/销毁成本更低。<br>&emsp;&emsp;3、切换调度成本更低。<br>&emsp;&emsp;多线程相比多进程的缺点：<br>&emsp;&emsp;1、缺乏访问控制并且一些系统调用以及错误针对整个进程，健壮性/稳定性更低。</p>
<h3 id="多进程-多线程进行多任务处理的优势-1"><a href="#多进程-多线程进行多任务处理的优势-1" class="headerlink" title="多进程/多线程进行多任务处理的优势"></a>多进程/多线程进行多任务处理的优势</h3><h4 id="cpu密集型程序-1"><a href="#cpu密集型程序-1" class="headerlink" title="cpu密集型程序"></a>cpu密集型程序</h4><p>&emsp;&emsp;对于读写操作比较少，更多的则是计算方面的操作，这类程序尽量少用多线程/进程，因为cpu调度线程/进程会浪费cpu资源。</p>
<h4 id="io密集型程序-1"><a href="#io密集型程序-1" class="headerlink" title="io密集型程序"></a>io密集型程序</h4><p>&emsp;&emsp;对于读写操作较多，cpu计算操作较少的程序则应该多使用多进程/线程进行io操作，由此来并行执行程序，减少执行时间。</p>
<h2 id="线程控制-1"><a href="#线程控制-1" class="headerlink" title="线程控制"></a>线程控制</h2><h3 id="线程创建-1"><a href="#线程创建-1" class="headerlink" title="线程创建"></a>线程创建</h3><p>&emsp;&emsp;操作系统并没有为用户提供直接创建线程的系统调用接口，但是有人自己封装了一套线程库实现线程控制。</p>
<h4 id="pthread-create-1"><a href="#pthread-create-1" class="headerlink" title="pthread_create"></a>pthread_create</h4><p>&emsp;&emsp;由于<code>pthread_create</code>所在的库<code>pthread</code>并不在gcc默认的链接库中，因此我们在编译时要加参数<code>-pthread</code>或者<code>-lpthread</code>让其连接到这个库中。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 线程创建</span><br><span class="line"> **/</span><br><span class="line">/**</span><br><span class="line"> * int pthread_create(pthread_t *thread, const pthread_attr_t *attr,</span><br><span class="line"> *        void *(*start_routine) (void *), void *arg);</span><br><span class="line"> * thread:输出型参数，获取新创建的线程id</span><br><span class="line"> * attr:  设置线程属性，通常置空</span><br><span class="line"> * start_routine:  线程入口函数</span><br><span class="line"> * arg:通过线程入口函数传递给线程的参数</span><br><span class="line"> **/</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;errno.h&gt;</span><br><span class="line">#include &lt;pthread.h&gt;</span><br><span class="line">void* thr_start(void* arg)</span><br><span class="line">&#123;</span><br><span class="line">  while(1)</span><br><span class="line">  &#123;</span><br><span class="line">    //pthread_self查看此线程的tid</span><br><span class="line">    printf(&quot;i am child---%d\n&quot;,pthread_self());                           </span><br><span class="line">    sleep(1);</span><br><span class="line">  &#125;</span><br><span class="line">  return NULL;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">  pthread_t tid;</span><br><span class="line">  int ret = pthread_create(&amp;tid, NULL, thr_start, (void*)&quot;Misaki&quot;);</span><br><span class="line">  printf(&quot;%d\n&quot;,tid);</span><br><span class="line">  if(ret != 0)//0为成功</span><br><span class="line">  &#123;</span><br><span class="line">    printf(&quot;thread vreate errno!\n&quot;);</span><br><span class="line">    return -1;</span><br><span class="line">  &#125;</span><br><span class="line">  while(1)</span><br><span class="line">  &#123;</span><br><span class="line">    //thread_self查看自己的线程id</span><br><span class="line">    printf(&quot;Misaki!%d\n&quot;,getpid());</span><br><span class="line">    sleep(1);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">[misaki@localhost 第八章-多线程]$ ./create</span><br><span class="line">-1544186112</span><br><span class="line">Misaki!5429</span><br><span class="line">i am child----1544186112</span><br><span class="line">i am child----1544186112</span><br><span class="line">Misaki!5429</span><br><span class="line">i am child----1544186112</span><br><span class="line">Misaki!5429</span><br><span class="line">i am child----1544186112</span><br><span class="line">Misaki!5429</span><br><span class="line">i am child----1544186112</span><br><span class="line">Misaki!5429</span><br><span class="line">i am child----1544186112</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;这个创建线程的函数中的返回值<code>tid</code>为线程在虚拟地址空间上所分配的属于自己的独立空间的首地址，我们以后要靠这个参数来控制线程。一个<code>tid</code>唯一的表示一个线程。<br></p>
<h3 id="线程终止-1"><a href="#线程终止-1" class="headerlink" title="线程终止"></a>线程终止</h3><h4 id="在线程入口函数中return-1"><a href="#在线程入口函数中return-1" class="headerlink" title="在线程入口函数中return"></a>在线程入口函数中return</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;errno.h&gt;</span><br><span class="line">#include &lt;pthread.h&gt;</span><br><span class="line">void* thr_start(void* arg)</span><br><span class="line">&#123;</span><br><span class="line">  while(1)</span><br><span class="line">  &#123;</span><br><span class="line">      printf(&quot;i am child\n&quot;);</span><br><span class="line">      reutrn NULL;</span><br><span class="line">  &#125;</span><br><span class="line">  return NULL;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">  pthread_t tid;</span><br><span class="line">  int ret = pthread_create(&amp;tid, NULL, thr_start, (void*)&quot;Misaki&quot;);</span><br><span class="line">  printf(&quot;%d\n&quot;,tid);</span><br><span class="line">  if(ret != 0)</span><br><span class="line">  &#123;</span><br><span class="line">    printf(&quot;thread vreate errno!\n&quot;);</span><br><span class="line">    return -1;</span><br><span class="line">  &#125;</span><br><span class="line">  while(1)</span><br><span class="line">  &#123;</span><br><span class="line">    //thread_self查看自己的线程id</span><br><span class="line">    printf(&quot;Misaki!%d\n&quot;,getpid());</span><br><span class="line">    sleep(1);</span><br><span class="line">    return 0;                                                      </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">[misaki@localhost 第八章-多线程]$ ./exit</span><br><span class="line">2052687616</span><br><span class="line">Misaki!5710</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;在线程入口函数中<code>return</code>会让线程退出。当在主函数中使用<code>return</code>退出主函数的时候这时会导致进程终止，由此进程中的所有线程都会终止。<br></p>
<h4 id="pthread-exit-1"><a href="#pthread-exit-1" class="headerlink" title="pthread_exit()"></a>pthread_exit()</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;pthread.h&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line"></span><br><span class="line">void* thr_start(void* arg)</span><br><span class="line">&#123;</span><br><span class="line">  while(1)</span><br><span class="line">  &#123;</span><br><span class="line">    printf(&quot;i am child---%s\n&quot;, arg);</span><br><span class="line">    sleep(1);</span><br><span class="line">    //退出调用这个函数的线程         </span><br><span class="line">    pthread_exit(0);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return NULL;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">  pthread_t tid;</span><br><span class="line">  int ret = pthread_create(&amp;tid, NULL, thr_start, (void*)&quot;Misaki&quot;);</span><br><span class="line">  while(1)</span><br><span class="line">  &#123;</span><br><span class="line">    printf(&quot;i am main!\n&quot;);</span><br><span class="line">    sleep(1);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[misaki@localhost 第八章-多线程]$ ./exit</span><br><span class="line">i am main!</span><br><span class="line">i am child---Misaki</span><br><span class="line">i am main!</span><br><span class="line">i am main!</span><br><span class="line">i am main!</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;可以看出我们自己创建的线程在执行<code>pthread_exit()</code>后退出了。如果我们的主线程调用这个函数会怎样呢？<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;pthread.h&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line"></span><br><span class="line">void* thr_start(void* arg)</span><br><span class="line">&#123;</span><br><span class="line">  while(1)</span><br><span class="line">  &#123;</span><br><span class="line">    printf(&quot;i am child---%s\n&quot;, arg);</span><br><span class="line">    sleep(1);</span><br><span class="line">  &#125;</span><br><span class="line">  return NULL;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">  pthread_t tid;</span><br><span class="line">  int ret = pthread_create(&amp;tid, NULL, thr_start, (void*)&quot;Misaki&quot;);</span><br><span class="line">  if(ret != 0)                      </span><br><span class="line">  &#123;             </span><br><span class="line">    printf(&quot;thread create error\n&quot;);</span><br><span class="line">    return -1;</span><br><span class="line">  &#125;</span><br><span class="line">  while(1)</span><br><span class="line">  &#123;</span><br><span class="line">    printf(&quot;i am main!\n&quot;);</span><br><span class="line">    sleep(1);</span><br><span class="line">    //退出调用这个函数的线程                                       </span><br><span class="line">    pthread_exit(0);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[misaki@localhost 第八章-多线程]$ ./exit</span><br><span class="line">i am main!</span><br><span class="line">i am child---Misaki</span><br><span class="line">i am child---Misaki</span><br><span class="line">i am child---Misaki</span><br><span class="line">i am child---Misaki</span><br><span class="line">i am child---Misaki</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;可以看出我们虽然在主线程中调用了退出函数，主线程也确实退出了，但是进程却并没有退出，这说明，<strong>主线程终止并不会让进程终止</strong>。但是我们要注意线程退出也会成为僵尸线程，但是普通线程退出并不会有过于明显大的影响。</p>
<h4 id="pthread-cancel-1"><a href="#pthread-cancel-1" class="headerlink" title="pthread_cancel"></a>pthread_cancel</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;pthread.h&gt;                                               </span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line"></span><br><span class="line">void* thr_start(void* arg)</span><br><span class="line">&#123;</span><br><span class="line">  while(1)</span><br><span class="line">  &#123;</span><br><span class="line">    printf(&quot;i am child---%s\n&quot;, arg);</span><br><span class="line">    sleep(1);</span><br><span class="line">  &#125;</span><br><span class="line">  return NULL;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">  pthread_t tid;</span><br><span class="line">  int ret = pthread_create(&amp;tid, NULL, thr_start, (void*)&quot;Misaki&quot;);</span><br><span class="line">  if(ret != 0)</span><br><span class="line">  &#123;</span><br><span class="line">    printf(&quot;thread create error\n&quot;);</span><br><span class="line">    return -1;</span><br><span class="line">  &#125;</span><br><span class="line">  while(1)</span><br><span class="line">  &#123;</span><br><span class="line">    printf(&quot;i am main!\n&quot;);</span><br><span class="line">    sleep(1);</span><br><span class="line">    //退出id = tid的线程</span><br><span class="line">    pthread_cancel(tid);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;                       </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[misaki@localhost 第八章-多线程]$ ./exit</span><br><span class="line">i am main!</span><br><span class="line">i am child---Misaki</span><br><span class="line">i am child---Misaki</span><br><span class="line">i am main!</span><br><span class="line">i am main!</span><br><span class="line">i am main!</span><br></pre></td></tr></table></figure>
<h3 id="线程等待-1"><a href="#线程等待-1" class="headerlink" title="线程等待"></a>线程等待</h3><p>&emsp;&emsp;线程等待是为了获取指定线程的返回值，和进程等待一样为了让系统可以释放资源，因为一个线程运行起来，默认有一个属性：<code>joinable</code>。这个属性决定了线程退出后，必须被等待，否则线程资源无法完全释放，成为僵尸线程，因此我们必须进行线程等待，获取线程返回值，允许系统释放资源。当然线程等待也有一个前提，线程能够被等待，即<code>joinable</code>属性。</p>
<h4 id="pthread-join-1"><a href="#pthread-join-1" class="headerlink" title="pthread_join()"></a>pthread_join()</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * int pthread_join(pthread_t thread, void **retval);</span><br><span class="line"> * 线程等待，获取线程退出返回值。</span><br><span class="line"> * thread:要等待的线程id</span><br><span class="line"> * retval:输出型参数，用于获取退出线程的返回值</span><br><span class="line"> **/</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;pthread.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">void* thr_start(void* arg)</span><br><span class="line">&#123;</span><br><span class="line">  sleep(3);</span><br><span class="line">  return (void*)&quot;Misaki&quot;;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">  pthread_t tid;</span><br><span class="line">  int ret = pthread_create(&amp;tid, NULL, thr_start, NULL);</span><br><span class="line">  if(ret != 0)</span><br><span class="line">  &#123;</span><br><span class="line">    printf(&quot;thread create error\n&quot;);</span><br><span class="line">    return -1;</span><br><span class="line">  &#125;</span><br><span class="line">  char* ptr;</span><br><span class="line">  pthread_join(tid, (void**)&amp;ptr);</span><br><span class="line">  printf(&quot;%s\n&quot;, ptr);                                </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[misaki@localhost 第八章-多线程]$ ./join</span><br><span class="line">Misaki</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;如果一个线程是被取消，则返回值是一个宏：<code>PTHREAD_CANCELED</code>，它的值是-1。线程等待<code>pthread_join</code>是阻塞函数，一个一个线程没有推出则会一直等待。</p>
<h3 id="线程分离-1"><a href="#线程分离-1" class="headerlink" title="线程分离"></a>线程分离</h3><p>&emsp;&emsp;将线程的一个属性从<code>joinable</code>设置为<code>detach</code>属性。属于<code>detach</code>属性的线程，退出后资源直接自动被回收，这类线程不能被等待。</p>
<h4 id="pthread-detach-1"><a href="#pthread-detach-1" class="headerlink" title="pthread_detach()"></a>pthread_detach()</h4><p>&emsp;&emsp;如果用户对一个线程的返回值不关心，则可以在线程入口函数对线程进行分离。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">/**                                                            </span><br><span class="line"> * int pthread_detach(pthread_t thread);</span><br><span class="line"> * 线程分离。</span><br><span class="line"> * thread:要分离的线程id</span><br><span class="line"> **/                </span><br><span class="line">#include &lt;stdio.h&gt;                                          </span><br><span class="line">#include &lt;stdlib.h&gt;                </span><br><span class="line">#include &lt;pthread.h&gt;     </span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;errno.h&gt;</span><br><span class="line">void* thr_start(void* arg)</span><br><span class="line">&#123;               </span><br><span class="line">                                                        </span><br><span class="line">  //分离自己这个线程</span><br><span class="line">  //线程的分离对于一个线程来说，任意线程在任意位置调用都可以</span><br><span class="line"> // pthread_detach(pthread_self());</span><br><span class="line">  return (void*)&quot;Misaki&quot;;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">  pthread_t tid;</span><br><span class="line">  int ret = pthread_create(&amp;tid, NULL, thr_start, NULL);</span><br><span class="line">  if(ret != 0)      </span><br><span class="line">  &#123;                                 </span><br><span class="line">    printf(&quot;thread create error\n&quot;);</span><br><span class="line">    return -1;      </span><br><span class="line">  &#125;</span><br><span class="line">  //分离这个线程</span><br><span class="line">  pthread_detach(tid);</span><br><span class="line">  char* ptr;</span><br><span class="line">  ret = pthread_join(tid, (void**)&amp;ptr);</span><br><span class="line">  //如果一个线程无法被等待则返回值为一个宏EINVAL</span><br><span class="line">  if(ret == EINVAL)</span><br><span class="line">  &#123;</span><br><span class="line">    printf(&quot;this thread can not be wait!!\n&quot;);</span><br><span class="line">    return -1;</span><br><span class="line">  &#125;</span><br><span class="line">  printf(&quot;%s\t%d\n&quot;, ptr, ret);</span><br><span class="line">&#125;                                               </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[misaki@localhost 第八章-多线程]$ ./join</span><br><span class="line">this thread can not be wait!!</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;会发现我们已经分离了我们自己创建的线程，这个线程已经无法被等待了，并且我们无法接收到线程的返回值。</p>
<h2 id="线程安全-1"><a href="#线程安全-1" class="headerlink" title="线程安全"></a>线程安全</h2><p>&emsp;&emsp;多个线程同时操作临界资源而不会出现数据二义性就说这个线程是安全的。如果在线程中进行了非原子性操作就可能会导致线程不安全，这些非原子性操作也叫做不可重入函数，即多个执行流中同时进入函数运行会出现问题的函数。<br><br>&emsp;&emsp;如何实现线程安全？这就要靠<strong>同步与互斥</strong>。同步指临界资源的合理访问，互斥指临界资源同一时间唯一访问。</p>
<h3 id="互斥-1"><a href="#互斥-1" class="headerlink" title="互斥"></a>互斥</h3><p>&emsp;&emsp;同步和互斥要如何实现呢？我们先从互斥开始讨论。为了保证操作的原子性，在C语言中<strong>互斥锁</strong>可以帮助我们保证互斥，使我们的函数变为可重入函数。</p>
<h4 id="互斥锁-1"><a href="#互斥锁-1" class="headerlink" title="互斥锁"></a>互斥锁</h4><p>&emsp;&emsp;互斥锁的值只能为0或1。1表示可以加锁，加锁后值-1，操作结束后就会解锁，解锁就会将值+1。如果一个操作已经加锁则值为0，因此当锁值为0时其他线程则不能加锁，不能加锁线程就会陷入等待。<br><br>&emsp;&emsp;互斥锁操作步骤：<br><br>&emsp;&emsp;1、定义互斥锁变量：<code>pthread_mutex_t</code>。<br><br>&emsp;&emsp;2、初始化互斥锁变量：<code>pthread_mutex_init</code>。<br><br>&emsp;&emsp;3、加锁：<code>pthread_mutex_lock</code>。<br><br>&emsp;&emsp;4、解锁：<code>pthread_mutex_unlock</code>。<br><br>&emsp;&emsp;5、删除锁：<code>pthread_mutex_destroy</code>。<br>&emsp;&emsp;接下来我用互斥锁将一个不可重入的函数使它可重入从而使多个线程同时运行函数时变得安全。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br></pre></td><td class="code"><pre><span class="line">/*实现互斥锁的基本使用以及线程安全的基本认识*/                                    </span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;errno.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;pthread.h&gt;</span><br><span class="line">int ticket = 100;</span><br><span class="line">//互斥锁变量不一定非要全局变量,使用的线程都能访问到就行     </span><br><span class="line">//互斥锁变量                                         </span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;pthread.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">int ticket = 100;</span><br><span class="line">pthread_mutex_t mutex;</span><br><span class="line">void* ticket_scalper(void* arg)</span><br><span class="line">&#123;</span><br><span class="line">  int id = (int)arg;</span><br><span class="line">  while(1)</span><br><span class="line">  &#123;</span><br><span class="line">    //加锁要在临界资源访问之前</span><br><span class="line">    //int pthread_mutex_lock(pthread_mutex_t* mutex);阻塞加锁</span><br><span class="line">    //int pthread_mutex_trylock(pthread_mutex_t* mutex);非阻塞加锁，加不上锁就返回</span><br><span class="line">    pthread_mutex_lock(&amp;mutex);</span><br><span class="line">    if(ticket &gt; 0)</span><br><span class="line">    &#123;</span><br><span class="line">      printf(&quot;scalper:%d--get a ticket:%d\n&quot;, id, ticket);</span><br><span class="line">      ticket--;</span><br><span class="line">      usleep(1000);</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">      //解锁</span><br><span class="line">      pthread_mutex_unlock(&amp;mutex);                                               </span><br><span class="line">      pthread_exit(0);</span><br><span class="line">    &#125;</span><br><span class="line">    //解锁</span><br><span class="line">    pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">  &#125;</span><br><span class="line">  return NULL;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">  int i = 0;</span><br><span class="line">  int ret;</span><br><span class="line">  pthread_t tid[4];</span><br><span class="line">  //初始化互斥锁</span><br><span class="line">  //int pthread_mutex_init(pthread_mutex_t *restrict mutex,</span><br><span class="line">  //         const pthread_mutexattr_t *restrict attr);</span><br><span class="line">  //             </span><br><span class="line">  pthread_mutex_init(&amp;mutex, NULL);</span><br><span class="line">  //创建线程</span><br><span class="line">  for(i = 0; i &lt; 4; i++)</span><br><span class="line">  &#123;</span><br><span class="line">    ret = pthread_create(&amp;tid[i], NULL, ticket_scalper, (void*)i);</span><br><span class="line">    if(ret != 0)</span><br><span class="line">    &#123;</span><br><span class="line">      perror(&quot;thread creat error:&quot;);</span><br><span class="line">      return -1;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  for(i = 0; i &lt; 4; i++)</span><br><span class="line">  &#123;</span><br><span class="line">    pthread_join(tid[i], NULL);</span><br><span class="line">  &#125;</span><br><span class="line">  //销毁互斥锁</span><br><span class="line">  //int pthread_mutex_destroy(pthread_mutex_t *mutex);</span><br><span class="line">  pthread_mutex_destroy(&amp;mutex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[misaki@localhost thread_2019_9_2_class45]$ ./main </span><br><span class="line">scalper:2--get a ticket:100</span><br><span class="line">scalper:2--get a ticket:99</span><br><span class="line">scalper:2--get a ticket:98</span><br><span class="line">scalper:2--get a ticket:97</span><br><span class="line">scalper:2--get a ticket:96</span><br><span class="line">scalper:2--get a ticket:95</span><br><span class="line">scalper:3--get a ticket:94</span><br><span class="line">scalper:3--get a ticket:93</span><br><span class="line">scalper:3--get a ticket:92</span><br><span class="line">scalper:3--get a ticket:91</span><br><span class="line">scalper:3--get a ticket:90</span><br><span class="line">scalper:3--get a ticket:89</span><br><span class="line">scalper:3--get a ticket:88</span><br><span class="line">scalper:3--get a ticket:87</span><br><span class="line">scalper:3--get a ticket:86</span><br><span class="line">scalper:3--get a ticket:85</span><br><span class="line">scalper:3--get a ticket:84</span><br><span class="line">scalper:3--get a ticket:83</span><br><span class="line">scalper:3--get a ticket:82</span><br><span class="line">scalper:3--get a ticket:81</span><br><span class="line">scalper:3--get a ticket:80</span><br><span class="line">scalper:3--get a ticket:79</span><br><span class="line">scalper:3--get a ticket:78</span><br><span class="line">scalper:3--get a ticket:77</span><br><span class="line">scalper:3--get a ticket:76</span><br><span class="line">scalper:3--get a ticket:75</span><br><span class="line">scalper:3--get a ticket:74</span><br><span class="line">scalper:3--get a ticket:73</span><br><span class="line">scalper:3--get a ticket:72</span><br><span class="line">scalper:3--get a ticket:71</span><br><span class="line">scalper:3--get a ticket:70</span><br><span class="line">scalper:3--get a ticket:69</span><br><span class="line">scalper:3--get a ticket:68</span><br><span class="line">scalper:3--get a ticket:67</span><br><span class="line">scalper:3--get a ticket:66</span><br><span class="line">scalper:3--get a ticket:65</span><br><span class="line">scalper:3--get a ticket:64</span><br><span class="line">scalper:3--get a ticket:63</span><br><span class="line">scalper:3--get a ticket:62</span><br><span class="line">scalper:3--get a ticket:61</span><br><span class="line">scalper:3--get a ticket:60</span><br><span class="line">scalper:3--get a ticket:59</span><br><span class="line">scalper:3--get a ticket:58</span><br><span class="line">scalper:3--get a ticket:57</span><br><span class="line">scalper:3--get a ticket:56</span><br><span class="line">scalper:3--get a ticket:55</span><br><span class="line">scalper:3--get a ticket:54</span><br><span class="line">scalper:3--get a ticket:53</span><br><span class="line">scalper:3--get a ticket:52</span><br><span class="line">scalper:3--get a ticket:51</span><br><span class="line">scalper:3--get a ticket:50</span><br><span class="line">scalper:3--get a ticket:49</span><br><span class="line">scalper:3--get a ticket:48</span><br><span class="line">scalper:3--get a ticket:47</span><br><span class="line">scalper:3--get a ticket:46</span><br><span class="line">scalper:3--get a ticket:45</span><br><span class="line">scalper:3--get a ticket:44</span><br><span class="line">scalper:3--get a ticket:43</span><br><span class="line">scalper:3--get a ticket:42</span><br><span class="line">scalper:3--get a ticket:41</span><br><span class="line">scalper:3--get a ticket:40</span><br><span class="line">scalper:3--get a ticket:39</span><br><span class="line">scalper:3--get a ticket:38</span><br><span class="line">scalper:3--get a ticket:37</span><br><span class="line">scalper:3--get a ticket:36</span><br><span class="line">scalper:3--get a ticket:35</span><br><span class="line">scalper:3--get a ticket:34</span><br><span class="line">scalper:3--get a ticket:33</span><br><span class="line">scalper:3--get a ticket:32</span><br><span class="line">scalper:3--get a ticket:31</span><br><span class="line">scalper:3--get a ticket:30</span><br><span class="line">scalper:3--get a ticket:29</span><br><span class="line">scalper:3--get a ticket:28</span><br><span class="line">scalper:3--get a ticket:27</span><br><span class="line">scalper:3--get a ticket:26</span><br><span class="line">scalper:3--get a ticket:25</span><br><span class="line">scalper:3--get a ticket:24</span><br><span class="line">scalper:3--get a ticket:23</span><br><span class="line">scalper:3--get a ticket:22</span><br><span class="line">scalper:3--get a ticket:21</span><br><span class="line">scalper:3--get a ticket:20</span><br><span class="line">scalper:3--get a ticket:19</span><br><span class="line">scalper:3--get a ticket:18</span><br><span class="line">scalper:3--get a ticket:17</span><br><span class="line">scalper:3--get a ticket:16</span><br><span class="line">scalper:3--get a ticket:15</span><br><span class="line">scalper:3--get a ticket:14</span><br><span class="line">scalper:3--get a ticket:13</span><br><span class="line">scalper:3--get a ticket:12</span><br><span class="line">scalper:3--get a ticket:11</span><br><span class="line">scalper:3--get a ticket:10</span><br><span class="line">scalper:3--get a ticket:9</span><br><span class="line">scalper:3--get a ticket:8</span><br><span class="line">scalper:3--get a ticket:7</span><br><span class="line">scalper:3--get a ticket:6</span><br><span class="line">scalper:3--get a ticket:5</span><br><span class="line">scalper:3--get a ticket:4</span><br><span class="line">scalper:3--get a ticket:3</span><br><span class="line">scalper:3--get a ticket:2</span><br><span class="line">scalper:3--get a ticket:1</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;这样就达成了互斥，在一个线程操作临界资源时，其他线程不会同时干涉。</p>
<h4 id="死锁-1"><a href="#死锁-1" class="headerlink" title="死锁"></a>死锁</h4><p>&emsp;&emsp;死锁是指因为对一些无法加锁的锁进行加锁操作而导致程序卡死。死锁是我们一定要在使用锁时要注意和避免的<br><br>&emsp;&emsp;死锁产生的四个必要条件：<br><br>&emsp;&emsp;1、互斥条件。一个线程操作时其他线程不能操作。<br><br>&emsp;&emsp;2、不可剥夺条件。一个线程加的锁别的线程不能释放。<br><br>&emsp;&emsp;3、请求与保持条件。一个线程已经有了锁却还在请求其他的锁，但是其他的锁请求不到第一个锁也不释放。<br><br>&emsp;&emsp;4、环路等待条件。<br><br>&emsp;&emsp;死锁产生往往是因为加锁解锁的顺序不同。要想避免死锁就要避免死锁产生的四个必要条件——死锁检测算法，银行家算法。<br></p>
<h3 id="同步-1"><a href="#同步-1" class="headerlink" title="同步"></a>同步</h3><p>&emsp;&emsp;通过对当前是否满足对临界资源的操作条件来判断线程是否该等待或唤醒这种方式实现对临界资源访问的合理性。资源产生后才能进行使用，没有资源则等待资源产生，生产资源后则唤醒等待，这样则达成同步。然而互斥锁虽然可以帮助我们完成等待但是无法判断何时将我们唤醒，不能在合适的事件唤醒，因此便要借助新的东西——条件变量。</p>
<h4 id="条件变量-1"><a href="#条件变量-1" class="headerlink" title="条件变量"></a>条件变量</h4><p>&emsp;&emsp;条件变量的使用流程：<br><br>&emsp;&emsp;1、定义条件变量：<code>pthread_cond_t</code>。<br><br>&emsp;&emsp;2、初始化条件变量：<code>pthread_cond_init</code>。<br><br>&emsp;&emsp;3、等待或者唤醒：<code>pthread_cond_wait/pthread_cond_signal</code>。<br><br>&emsp;&emsp;4、销毁条件变量：<code>pthread_cond_destroy</code>。<br><br>&emsp;&emsp;<code>pthread_cond_wait</code>中一共有三个操作，首先它要让让当前线程等待，但是此时有一点，此时的互斥量还处于加锁状态其他线程无法操作临界资源，呢又怎么做到让临界资源达到要求呢？因此他在让线程等待前要先解除了互斥量的加锁状态，并且这两部操作为<strong>原子操作</strong>。为什么要是原子操作？因为如果不是原子操作有可能在解锁后已经条件满足而此时线程还未进行等待可能会忽略唤醒。之后在线程被唤醒后<code>pthread_cond_wait</code>还会再加锁保证互斥。这就是三部操作：<code>解锁-&gt;等待-&gt;唤醒后加锁</code>。<br>&emsp;&emsp;在每一个条件变量内部都有一个等待队列，将所有等待的线程排列在上面，如果有其他线程唤醒则逐一唤醒。<br>&emsp;&emsp;接下来我们用互斥锁加条件变量模拟实现一个顾客去餐馆吃饭的情景，但是在这个情境中为了符合设计要注意两个顾客不能同时吃一碗饭，并且只有一个锅因此两个厨师不能同时做饭。如果没饭了2个厨师中其中一个做饭，又犯了2个顾客其中一个吃饭。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br></pre></td><td class="code"><pre><span class="line">/*实现条件变量的基本使用*/                                           </span><br><span class="line">/*吃面前提有人吃面，如果没有线程的面，等待老板做出来</span><br><span class="line"> * 老板做出来面就要唤醒顾客</span><br><span class="line"> * 老板不会做太多的面，老板只会提前做一碗面         </span><br><span class="line"> * 如果已经有面做出来，但是没人吃，不会再做（等待）</span><br><span class="line"> * 顾客吃完面后，老板再来一碗（唤醒老板的等待）*/</span><br><span class="line">#include &lt;stdio.h&gt;       </span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;errno.h&gt;</span><br><span class="line">#include &lt;pthread.h&gt;      </span><br><span class="line">//是否右面</span><br><span class="line">int have_noodle = 1;                                    </span><br><span class="line">//为了让客人与厨师间的不同的同步性，需要定义多个条件变量</span><br><span class="line">pthread_cond_t customer;</span><br><span class="line">pthread_cond_t boss;         </span><br><span class="line">pthread_mutex_t mutex;</span><br><span class="line">//老板做面</span><br><span class="line">void* thr_boss(void* arg)</span><br><span class="line">&#123;                        </span><br><span class="line">  while(1)               </span><br><span class="line">  &#123;           </span><br><span class="line">    pthread_mutex_lock(&amp;mutex);                  </span><br><span class="line">    //由于多个顾客，为了避免两个顾客吃一碗面的情况这里要循环判断</span><br><span class="line">    while(have_noodle == 1)//有面</span><br><span class="line">    &#123;    </span><br><span class="line">      //等待                  </span><br><span class="line">      //int pthread_cond_timedwait(pthread_cond_t *restrict cond,</span><br><span class="line">      //       pthread_mutex_t *restrict mutex,</span><br><span class="line">      //              const struct timespec *restrict abstime);</span><br><span class="line">      //限时等待</span><br><span class="line">      //cond:条件变量</span><br><span class="line">      //mutex:互斥锁</span><br><span class="line">      //abstime:限时等待时长</span><br><span class="line">      //时间到后返回时间超市，停止阻塞</span><br><span class="line">      //int pthread_cond_wait(pthread_cond_t *restrict cond,</span><br><span class="line">      //       pthread_mutex_t *restrict mutex);</span><br><span class="line">      //cond:条件变量</span><br><span class="line">      //mutex:互斥锁</span><br><span class="line">      //pthread_cond_wait 集合了解锁后挂起的操作（原子操作，不可被打断）</span><br><span class="line">      //有可能还没来得及挂起就已经有人唤醒，白唤醒，导致死等</span><br><span class="line">      //因此这里的wait将三个操作进行了原子性封装不让其中断</span><br><span class="line">      //解锁 -》 等待 -》 被唤醒后加锁</span><br><span class="line">      pthread_cond_wait(&amp;boss, &amp;mutex);</span><br><span class="line">    &#125;</span><br><span class="line">    //面没了，要再做</span><br><span class="line">    printf(&quot;拉面 + 1\n&quot;);</span><br><span class="line">    have_noodle = 1;</span><br><span class="line">    //面好了，唤醒顾客</span><br><span class="line">    pthread_cond_signal(&amp;customer);                                      </span><br><span class="line">    //解锁</span><br><span class="line">    pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">  &#125;</span><br><span class="line">    return NULL;</span><br><span class="line">&#125;</span><br><span class="line">//顾客吃面</span><br><span class="line">void* thr_customer(void* arg)</span><br><span class="line">&#123;</span><br><span class="line">  while(1)</span><br><span class="line">  &#123;</span><br><span class="line">    while(have_noodle == 0)</span><br><span class="line">    &#123;</span><br><span class="line">      //若没有现成的面等老板做好</span><br><span class="line">      //等待</span><br><span class="line">      pthread_cond_wait(&amp;customer, &amp;mutex);</span><br><span class="line">    &#125;</span><br><span class="line">    //有面了</span><br><span class="line">    printf(&quot;真好吃！\n&quot;);</span><br><span class="line">    have_noodle -= 1;                               </span><br><span class="line">    //唤醒厨师再做一碗</span><br><span class="line">    pthread_cond_signal(&amp;boss);</span><br><span class="line">    //解锁</span><br><span class="line">    pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">  &#125;</span><br><span class="line">  return NULL;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">  pthread_t tid1, tid2;</span><br><span class="line">  int ret;</span><br><span class="line">  //条件变量初始化</span><br><span class="line">  //int pthread_cond_init(pthread_cond_t *restrict cond,</span><br><span class="line">  //       const pthread_condattr_t *restrict attr);</span><br><span class="line">  pthread_cond_init(&amp;boss, NULL);</span><br><span class="line">  pthread_cond_init(&amp;customer, NULL);</span><br><span class="line">  pthread_mutex_init(&amp;mutex, NULL);</span><br><span class="line">  //各建立两个线程同时工作，相当于两个厨师两个客人</span><br><span class="line">  //客人间具有互斥性，厨师间也有互斥性，客人与厨师间有同步与互斥性</span><br><span class="line">  for(int i = 0; i &lt; 2; i++)</span><br><span class="line">  &#123;                                                                </span><br><span class="line">    ret = pthread_create(&amp;tid1, NULL, thr_boss, NULL);</span><br><span class="line">    if(ret != 0)</span><br><span class="line">    &#123;</span><br><span class="line">      printf(&quot;boss error&quot;);</span><br><span class="line">      return -1;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  for(int i = 0; i &lt; 2; i++)</span><br><span class="line">  &#123;</span><br><span class="line">    ret = pthread_create(&amp;tid2, NULL, thr_customer, NULL);</span><br><span class="line">    if(ret != 0)</span><br><span class="line">    &#123;</span><br><span class="line">      printf(&quot;customer error&quot;);</span><br><span class="line">      return -1;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  pthread_join(tid1, NULL);</span><br><span class="line">  pthread_join(tid2, NULL);</span><br><span class="line">  //销毁条件变量</span><br><span class="line">  //int pthread_cond_destroy(pthread_cond_t *cond);</span><br><span class="line">  pthread_cond_destroy(&amp;customer);                              </span><br><span class="line">  pthread_cond_destroy(&amp;boss);</span><br><span class="line">  //销毁锁</span><br><span class="line">  pthread_mutex_destroy(&amp;mutex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">真好吃！</span><br><span class="line">拉面 + 1</span><br><span class="line">真好吃！</span><br><span class="line">拉面 + 1</span><br><span class="line">真好吃！</span><br><span class="line">拉面 + 1</span><br><span class="line">真好吃！</span><br><span class="line">拉面 + 1</span><br><span class="line">真好吃！</span><br><span class="line">拉面 + 1</span><br><span class="line">真好吃！</span><br><span class="line">拉面 + 1</span><br><span class="line">真好吃！</span><br><span class="line">拉面 + 1</span><br><span class="line">^C真好吃！</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;在以上这个例子中要注意几个点：<br>&emsp;&emsp;1、用户对条件判断需要使用循环进行判断（防止角色不符合条件被唤醒之后因为不循环判断直接操作临界资源）。这个问题也被称为<strong>虚假唤醒</strong>问题。在多核处理器下，<code>pthread_cond_signal</code>可能会激活多于一个线程（阻塞在条件变量上的线程）。结果就是，当一个线程调用<code>pthread_cond_signal()</code>后，多个调用<code>pthread_cond_wait()</code>或其他等待在队列上的线程返回。这种效应就会造成<strong>虚假唤醒</strong>。<br>&emsp;&emsp;2、不同角色的线程因该等待在不同的条件变量上。（防止角色的误唤醒，导致程序阻塞）<br>&emsp;&emsp;但是要注意条件变量并不保证安全，因此往往使用条件变量的时候会与互斥锁共同使用。面生产一碗顾客吃一碗没有出现异常，因此实现是成功的。这种在多线程情况下有人生产数据有人消费数据利用同步与互斥达到合理与安全的模式十分经典，因此产生了一种固定的设计模型，这就是<strong>生产者消费者模型</strong>。</p>
<h3 id="生产者与消费者模型-1"><a href="#生产者与消费者模型-1" class="headerlink" title="生产者与消费者模型"></a>生产者与消费者模型</h3><p>&emsp;&emsp;生产者与消费者模型中有两种角色：生产者与消费者，同时包含三种关系：生产者与生产者之间互斥，消费者与消费者之间互斥，生产者与消费者之间同步与互斥。他们工作在一个场景中，这个场景通常是一个队列，用来保存数据。</p>
<h4 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br></pre></td><td class="code"><pre><span class="line">/**                                                   </span><br><span class="line"> * 基于互斥锁与条件变量实现一个线程安全的队列</span><br><span class="line"> * 实现生产者与消费者模型</span><br><span class="line"> **/                 </span><br><span class="line">#include &lt;iostream&gt;                                   </span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line">#include &lt;pthread.h&gt;</span><br><span class="line">#define MAXQ 10</span><br><span class="line">class BlockQueue</span><br><span class="line">&#123;</span><br><span class="line">public:                    </span><br><span class="line">  BlockQueue(int maxq = MAXQ)</span><br><span class="line">    :_capacity(maxq)</span><br><span class="line">  &#123;                   </span><br><span class="line">    pthread_mutex_init(&amp;_mutex, NULL);</span><br><span class="line">    pthread_cond_init(&amp;_cond_consumer, NULL);         </span><br><span class="line">    pthread_cond_init(&amp;_cond_productor, NULL);</span><br><span class="line">  &#125;</span><br><span class="line">  ~BlockQueue()                                     </span><br><span class="line">  &#123;</span><br><span class="line">    pthread_mutex_destroy(&amp;_mutex);</span><br><span class="line">    pthread_cond_destroy(&amp;_cond_consumer);</span><br><span class="line">    pthread_cond_destroy(&amp;_cond_productor);</span><br><span class="line">  &#125;                                                   </span><br><span class="line">  bool QueuePush(int data)</span><br><span class="line">  &#123;</span><br><span class="line">    pthread_mutex_lock(&amp;_mutex);                    </span><br><span class="line">    while(_queue.size() == _capacity)</span><br><span class="line">    &#123;</span><br><span class="line">      pthread_cond_wait(&amp;_cond_productor, &amp;_mutex);</span><br><span class="line">    &#125;</span><br><span class="line">    _queue.push(data);        </span><br><span class="line">    pthread_mutex_unlock(&amp;_mutex);</span><br><span class="line">    pthread_cond_signal(&amp;_cond_consumer);</span><br><span class="line">    return true;</span><br><span class="line">  &#125;</span><br><span class="line">  bool QueuePop(int &amp;data)</span><br><span class="line">  &#123;</span><br><span class="line">    pthread_mutex_lock(&amp;_mutex);</span><br><span class="line">    while(_queue.empty())</span><br><span class="line">    &#123;</span><br><span class="line">      pthread_cond_wait(&amp;_cond_consumer, &amp;_mutex);</span><br><span class="line">    &#125;</span><br><span class="line">    data = _queue.front();</span><br><span class="line">    _queue.pop();</span><br><span class="line">    pthread_mutex_unlock(&amp;_mutex);</span><br><span class="line">    pthread_cond_signal(&amp;_cond_productor);</span><br><span class="line">    return true;</span><br><span class="line">  &#125;</span><br><span class="line">private:</span><br><span class="line">  std::queue&lt;int&gt; _queue;</span><br><span class="line">  int _capacity;</span><br><span class="line">  pthread_mutex_t _mutex;</span><br><span class="line">  pthread_cond_t _cond_productor;</span><br><span class="line">  pthread_cond_t _cond_consumer;</span><br><span class="line">&#125;;</span><br><span class="line">void* thr_consumer(void* arg)</span><br><span class="line">&#123;</span><br><span class="line">  BlockQueue* q = (BlockQueue*)arg;</span><br><span class="line">  int data;</span><br><span class="line">  while(1)</span><br><span class="line">  &#123;</span><br><span class="line">    //消费者一直获取数据进行打印</span><br><span class="line">    q-&gt;QueuePop(data);                                                       </span><br><span class="line">    std::cout &lt;&lt; &quot;consumer gets a piece of data--&quot; &lt;&lt; data &lt;&lt; std::endl;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">void* thr_productor(void* arg)</span><br><span class="line">&#123;</span><br><span class="line">  BlockQueue* q = (BlockQueue*)arg;</span><br><span class="line">  int data = 0;</span><br><span class="line">  while(1)</span><br><span class="line">  &#123;</span><br><span class="line">    //生产者一直添加数据</span><br><span class="line">    q-&gt;QueuePush(data);</span><br><span class="line">    std::cout &lt;&lt; &quot;producer produces a data--&quot;  &lt;&lt; (data++) &lt;&lt; std::endl;</span><br><span class="line">  &#125;</span><br><span class="line">  return NULL;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">  pthread_t ctid[4], ptid[4];</span><br><span class="line">  int ret, i;</span><br><span class="line">  BlockQueue q;</span><br><span class="line">  for(i = 0; i &lt; 4; i++)</span><br><span class="line">  &#123;</span><br><span class="line">    ret = pthread_create(&amp;ctid[i], NULL, thr_consumer, (void*)&amp;q);</span><br><span class="line">    if(ret != 0)</span><br><span class="line">    &#123;</span><br><span class="line">      std::cerr &lt;&lt; &quot;create thread error&quot; &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  for(i = 0; i &lt; 4; i++)</span><br><span class="line">  &#123;</span><br><span class="line">    ret = pthread_create(&amp;ptid[i], NULL, thr_productor, (void*)&amp;q);</span><br><span class="line">    if(ret != 0)                                                         </span><br><span class="line">    &#123;</span><br><span class="line">      std::cerr &lt;&lt; &quot;create thread error&quot; &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  for(i = 0; i &lt; 4; i++)</span><br><span class="line">  &#123;</span><br><span class="line">    pthread_join(ctid[i], NULL);</span><br><span class="line">    pthread_join(ptid[i], NULL);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;                             </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">consumer gets a piece of data--2111</span><br><span class="line">consumer gets a piece of data--2112</span><br><span class="line">consumer gets a piece of data--2113</span><br><span class="line">consumer gets a piece of data--2114</span><br><span class="line">consumer gets a piece of data--2115</span><br><span class="line">consumer gets a piece of data--2116</span><br><span class="line">consumer gets a piece of data--2117</span><br><span class="line">consumer gets a piece of data--2118</span><br><span class="line">producer produces a data--2119</span><br><span class="line">producer produces a data--2120</span><br><span class="line">producer produces a data--2121</span><br><span class="line">producer produces a data--2122</span><br><span class="line">producer produces a data--2123</span><br><span class="line">producer produces a data--2124</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;这里打印之所以看上去乱是因为xshell的显示跟不上虚拟机计算的速度。</p>
<h4 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h4><p>&emsp;&emsp;生产者与消费者模型有三个优点：<br>&emsp;&emsp;1、解耦合<br>&emsp;&emsp;2、支持忙闲不均<br>&emsp;&emsp;3、支持并发<br>&emsp;&emsp;一个场所，两种角色，三种关系。</p>
<h3 id="posix标准信号量-1"><a href="#posix标准信号量-1" class="headerlink" title="posix标准信号量"></a>posix标准信号量</h3><p>&emsp;&emsp;<code>system V</code>是内核中的计数器，<code>posix</code>是线程间的全局计数器。它也有着实现进程/进程间同步与互斥的贡藕功能。</p>
<h4 id="与条件变量的区别-1"><a href="#与条件变量的区别-1" class="headerlink" title="与条件变量的区别"></a>与条件变量的区别</h4><p>&emsp;&emsp;条件变量是通过等待、唤醒操作来让线程等待在等待队列上来完成同步，这需要用户自己进行外部条件判断并且要搭配互斥锁一起使用。<br>&emsp;&emsp;信号量是通过自身内部技术实现条件的判断，不需要搭配互斥锁，自身已经保证了原子操作。</p>
<h4 id="信号量的工作原理-1"><a href="#信号量的工作原理-1" class="headerlink" title="信号量的工作原理"></a>信号量的工作原理</h4><p>&emsp;&emsp;信号量通过一个计数器实现对资源的计数，并且通过这个计数来判断当前线程/进程能否对临界资源进行访问，对临界资源进行访问之前先发起调用访问信号量进行判断是否能够访问。<br>&emsp;&emsp;信号量实现同步：首先资源计数-1，若此时资源计数<code>&gt;=0</code>，则可以直接进行访问，调用直接返回，若信号量内部计数器<code>&lt;0</code>表示没有资源无法访问，调用阻塞（挂起线程）；若其他线程生产了一个资源则发起调用，首先资源计数+1，如果此时计数器<code>&lt;=0</code>则唤醒等待队列上的线程，若此时计数器<code>&gt;0</code>则什么都不做。<br>&emsp;&emsp;信号量实现互斥：计数只有0/1，资源只有一个，同一时间只有 一个线程可以访问。首先信号量-1，若此时信号量<code>&lt;0</code>则调用阻塞，若<code>&gt;0</code>，则调用返回，对临界资源进行访问，访问完毕，进行计数+1，唤醒所有线程，所有线程继续进行抢夺。<br>&emsp;同时如果信号量小于0则表示当前阻塞在等待队列上的线程/进程数，等于0表示资源刚好完全分配，大于0则表示多余资源数。</p>
<h4 id="接口-1"><a href="#接口-1" class="headerlink" title="接口"></a>接口</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">sem_t//定义信号量。</span><br><span class="line">sem_init(sem_t* sem, int flag, int initval);//初始化，</span><br><span class="line">    //flag:0-线程间,!0-进程间</span><br><span class="line">    //initval:用于设置初值</span><br><span class="line">sem_wait(sem_t* sem);//，进行判断是否有资源，&lt;=0则阻塞，&gt;0则-1并调用返回并。</span><br><span class="line">sem_trywait(sem_t* sem);//非阻塞，没有资源直接报错返回。</span><br><span class="line">sem_timedwait(sem_t* sem);//限时阻塞，等待一段时间，若一直没有资源则超时报错返回</span><br><span class="line">sem_post(sem_t* sem);//计数+1，并且唤醒等待的线程</span><br><span class="line">sem_destroy(sem_t* sem);//销毁信号量</span><br></pre></td></tr></table></figure>
<h4 id="应用-1"><a href="#应用-1" class="headerlink" title="应用"></a>应用</h4><p>&emsp;&emsp;用信号量实现线程安全的环形队列。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 利用信号量完成线程安全的环形队列</span><br><span class="line"> **/</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;semaphore.h&gt;</span><br><span class="line">#include &lt;thread&gt;</span><br><span class="line">#define MAXQ 10</span><br><span class="line">class RingQueue</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">  RingQueue(int maxq = MAXQ)</span><br><span class="line">    :_capacity(maxq)</span><br><span class="line">    ,_queue(maxq)</span><br><span class="line">    ,_step_read(0)</span><br><span class="line">    ,_step_write(0)                                      </span><br><span class="line">  &#123;</span><br><span class="line">    sem_init(&amp;_lock, 0, 1);</span><br><span class="line">    sem_init(&amp;_idle_space, 0, maxq);</span><br><span class="line">    sem_init(&amp;_data_space, 0, 0);</span><br><span class="line">  &#125;</span><br><span class="line">  ~RingQueue()</span><br><span class="line">  &#123;</span><br><span class="line">    sem_destroy(&amp;_lock);</span><br><span class="line">    sem_destroy(&amp;_idle_space);</span><br><span class="line">    sem_destroy(&amp;_data_space);</span><br><span class="line">  &#125;</span><br><span class="line">  bool QueuePush(int data)</span><br><span class="line">  &#123;</span><br><span class="line">    //没有空闲空间则阻塞</span><br><span class="line">    sem_wait(&amp;_idle_space);</span><br><span class="line">    //加锁</span><br><span class="line">    sem_wait(&amp;_lock);</span><br><span class="line">    _queue[_step_write] = data;</span><br><span class="line">    _step_write = (_step_write + 1) % _capacity;</span><br><span class="line">    //解锁</span><br><span class="line">    sem_post(&amp;_lock);</span><br><span class="line">    //唤醒消费者</span><br><span class="line">    sem_post(&amp;_data_space);</span><br><span class="line">    return true;</span><br><span class="line">  &#125;</span><br><span class="line">  bool QueuePop(int&amp; data)</span><br><span class="line">  &#123;</span><br><span class="line">    sem_wait(&amp;_data_space);</span><br><span class="line">    sem_wait(&amp;_lock);</span><br><span class="line">    data = _queue[_step_read];</span><br><span class="line">    _step_read = (_step_read + 1) % _capacity;</span><br><span class="line">    sem_post(&amp;_lock);</span><br><span class="line">    sem_post(&amp;_idle_space);</span><br><span class="line">    return true;</span><br><span class="line">  &#125;</span><br><span class="line">private:</span><br><span class="line">  std::vector&lt;int&gt; _queue;//用vector实现环形队列</span><br><span class="line">  int _capacity;//容量</span><br><span class="line">  int _step_read;//读指针</span><br><span class="line">  int _step_write;//写指针</span><br><span class="line">  </span><br><span class="line">  sem_t _lock;//初始计数=1，负责完成互斥</span><br><span class="line"></span><br><span class="line">  //也需要有两个等待队列，分别完成两个角色间的同步</span><br><span class="line">  sem_t _idle_space;//空闲空间节点个数，生产者等待在这里，完成同步</span><br><span class="line">  sem_t _data_space;//数据节点个数，初始=0，消费者等待在这里，完成同步  </span><br><span class="line">&#125;;</span><br><span class="line">void thr_producer(RingQueue* q)</span><br><span class="line">&#123;</span><br><span class="line">  int data = 0;</span><br><span class="line">  while(1)</span><br><span class="line">  &#123;</span><br><span class="line">    q-&gt;QueuePush(data);</span><br><span class="line">    std::cout &lt;&lt; &quot;push data ----&quot; &lt;&lt; data++ &lt;&lt; std::endl;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">void thr_consumer(RingQueue* q)</span><br><span class="line">&#123;</span><br><span class="line">  int data = 0;</span><br><span class="line">  while(1)</span><br><span class="line">  &#123;</span><br><span class="line">    q-&gt;QueuePop(data);</span><br><span class="line">    std::cout &lt;&lt; &quot;get data ----&quot; &lt;&lt; data &lt;&lt; std::endl;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">  RingQueue q;</span><br><span class="line">  std::vector&lt;std::thread&gt; list_con(4);</span><br><span class="line">  std::vector&lt;std::thread&gt; list_pro(4);</span><br><span class="line">  for(int i = 0; i &lt; 4; i++)</span><br><span class="line">  &#123;</span><br><span class="line">    list_pro[i] = (std::thread(thr_producer, &amp;q));</span><br><span class="line">  &#125;</span><br><span class="line">  for(int i = 0; i &lt; 4; i++)</span><br><span class="line">  &#123;</span><br><span class="line">    list_con[i] = (std::thread(thr_consumer, &amp;q));        </span><br><span class="line">  &#125;</span><br><span class="line">  for(int i = 0; i &lt; 4; i++)</span><br><span class="line">  &#123;</span><br><span class="line">    list_con[i].join();</span><br><span class="line">    list_pro[i].join();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;       </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">push data ----4028</span><br><span class="line">get data ----push data ----4102</span><br><span class="line">41004029</span><br><span class="line">3996push data ----4030</span><br><span class="line">push data ----4031</span><br><span class="line">push data ----4032</span><br><span class="line">push data ----push data ----4033</span><br><span class="line">push data ----4034</span><br><span class="line">push data ----4101</span><br><span class="line">push data ----4102</span><br><span class="line">get data ----</span><br><span class="line">push data ----4103</span><br><span class="line">push data ----4104</span><br><span class="line">40974102</span><br><span class="line">get data ----4101</span><br><span class="line"></span><br><span class="line">push data ----4103</span><br><span class="line"></span><br><span class="line">push data ----get data ----4029</span><br><span class="line">4095</span><br><span class="line">get data ----4031</span><br><span class="line">get data ----4032</span><br><span class="line">get data ----4033</span><br><span class="line">get data ----4034</span><br><span class="line">get data ----4102</span><br><span class="line">get data ----get data ----40304103</span><br><span class="line">push data ----get data ----4104</span><br><span class="line">get data ----4103</span><br><span class="line">get data ----4105</span><br><span class="line">get data ----4104</span><br><span class="line">push data ----3997</span><br><span class="line">push data ----3998</span><br><span class="line">push data ----3999</span><br><span class="line">push data ----4000</span><br><span class="line">push data ----4001</span><br><span class="line">4104get data ----</span><br><span class="line">push data ----4105</span><br><span class="line">push data ----4106</span><br><span class="line">push data ----4107</span><br><span class="line">push data ----4108</span><br><span class="line">push data ----push data ----4035</span><br><span class="line">3997</span><br><span class="line">get data ----3999</span><br><span class="line">get data ----4000</span><br></pre></td></tr></table></figure></p>
<h3 id="读写锁-1"><a href="#读写锁-1" class="headerlink" title="读写锁"></a>读写锁</h3><p>&emsp;&emsp;读写锁在数据库中就有着极为重要的应用，这样才得以让数据得到共享修改得到合理的保存而不出现数据的二义性。</p>
<h4 id="特点，原理及应用-1"><a href="#特点，原理及应用-1" class="headerlink" title="特点，原理及应用"></a>特点，原理及应用</h4><p>&emsp;&emsp;读写锁有着自己的特点：<strong>写互斥，读共享</strong>，一个用户写时所有其他所有用户都不能读和写；一个用户读时其他所有用户都可以读但不能写，因此适用于多读少写的应用场景，保证数据不会出现二义性并且保证读取和写入的效率。<br>&emsp;&emsp;读写锁内部有两个计数器，读者计数与写者计数。加写锁时对两个技术进行判断如果任意一个计数器&gt;0，都无法加写锁需要等待。加读锁时对写者计数进行判断，若大于0，则无法加读锁需要进行等待。<br>&emsp;&emsp;读写锁通过<strong>自旋锁</strong>实现，不满足条件时自旋等待。自旋锁的特点是：等待中不停循环对条件进行判断，因此可以及时响应，但是cpu消耗较高。自旋锁一般应用在对于挂起等待被唤醒时间相较于数据处理时间可以忽略不记的情况下，这样更倾向于挂起。</p>
<h2 id="线程池-1"><a href="#线程池-1" class="headerlink" title="线程池"></a>线程池</h2><h3 id="为什么要有线程池-1"><a href="#为什么要有线程池-1" class="headerlink" title="为什么要有线程池"></a>为什么要有线程池</h3><p>&emsp;&emsp;假如在一个任务的处理时间中，若线程创建及销毁的时间占用任务处理的大量比例，则意味着大量任务处理中，资源被浪费在线程的创建与销毁中。因此产生线程池，创建大量线程，但并不推出线程并不断把任务交给这些线程处理，避免了大量创建线程/销毁带来的时间成本。<br>&emsp;&emsp;线程池中线程数量是有上限的，为了防止出现峰值压力导致资源瞬间耗尽程序崩溃。</p>
<h3 id="线程池的实现-1"><a href="#线程池的实现-1" class="headerlink" title="线程池的实现"></a>线程池的实现</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br></pre></td><td class="code"><pre><span class="line">/**                                                                             </span><br><span class="line"> * 线程池由两个部分构成一个是一个任务类</span><br><span class="line"> * 另一个部分是一个线程安全的队列，由此构成任务队列，</span><br><span class="line"> * 再用一组线程从任务队列中获取任务来执行</span><br><span class="line"> * 由此构成线程池        </span><br><span class="line"> **/</span><br><span class="line">#include &lt;iostream&gt;                                     </span><br><span class="line">#include &lt;unistd.h&gt;                        </span><br><span class="line">#include &lt;pthread.h&gt; </span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line">#include &lt;thread&gt;                        </span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">#include &lt;time.h&gt;             </span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;sstream&gt;</span><br><span class="line">#define MAX_THREAD 5</span><br><span class="line">#define MAX_QUEUE 10</span><br><span class="line">typedef void(*handler_t)(int val);</span><br><span class="line">//任务类</span><br><span class="line">//1、决定线程处理的任务，处理什么数据，怎么处理都由用户传入</span><br><span class="line">class Task              </span><br><span class="line">&#123;                      </span><br><span class="line">  private:                                                 </span><br><span class="line">    int _data;//数据                                        </span><br><span class="line">    handler_t _handler;//处理数据的方法，函数指针，用于传入线程中给线程下达命令</span><br><span class="line">  public:     </span><br><span class="line">    Task(int data, handler_t handler)</span><br><span class="line">      :_data(data)</span><br><span class="line">      ,_handler(handler)</span><br><span class="line">    &#123;</span><br><span class="line">                  </span><br><span class="line">    &#125;             </span><br><span class="line">    void SetTask(int data, handler_t handler)</span><br><span class="line">    &#123;</span><br><span class="line">      _data = data;  </span><br><span class="line">      _handler = handler;</span><br><span class="line">    &#125;</span><br><span class="line">    void Run()</span><br><span class="line">    &#123;</span><br><span class="line">      return _handler(_data);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line">//线程池类</span><br><span class="line">class ThreadPool</span><br><span class="line">&#123;</span><br><span class="line">  private:</span><br><span class="line">    std::queue&lt;Task&gt; _queue;//任务队列</span><br><span class="line">    int _capacity;//线程池最大任务数量</span><br><span class="line">    pthread_mutex_t _mutex;//锁，完成互斥，类似于生产者消费者模型</span><br><span class="line">    pthread_cond_t _cond_pro;//条件变量，完成</span><br><span class="line">    pthread_cond_t _cond_con;</span><br><span class="line">    int _thr_max;//线程池拥有的总线程数</span><br><span class="line">    std::vector&lt;std::thread&gt; _thr_list;//线程组，存储线程操作句柄</span><br><span class="line">    bool _quit_flag;//用于控制线程是否退出</span><br><span class="line">    int _thr_cur;//线程的数量，线程退出时，判断当前线程数量</span><br><span class="line">    void thr_start()</span><br><span class="line">    &#123;</span><br><span class="line">      while(1)</span><br><span class="line">      &#123;</span><br><span class="line">        pthread_mutex_lock(&amp;_mutex);</span><br><span class="line">        while(_queue.empty())</span><br><span class="line">        &#123;                                                                 </span><br><span class="line">          if(_quit_flag == true)</span><br><span class="line">          &#123;</span><br><span class="line">            std::cout &lt;&lt; &quot;thread exit &quot; &lt;&lt; pthread_self() &lt;&lt; std::endl; </span><br><span class="line">            pthread_mutex_unlock(&amp;_mutex);</span><br><span class="line">            _thr_cur--;</span><br><span class="line">            return;</span><br><span class="line">          &#125;</span><br><span class="line">          pthread_cond_wait(&amp;_cond_con, &amp;_mutex);</span><br><span class="line">        &#125;</span><br><span class="line">        Task tt = _queue.front();</span><br><span class="line">        _queue.pop();</span><br><span class="line">        pthread_mutex_unlock(&amp;_mutex);</span><br><span class="line">        pthread_cond_signal(&amp;_cond_pro);</span><br><span class="line">        //任务处理放到锁外，防止线程处理任务时间过长，一直加锁导致其他线程无法处理其他任务</span><br><span class="line">        tt.Run();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  public:</span><br><span class="line">    //初始化线程池</span><br><span class="line">    ThreadPool(int maxq = MAX_QUEUE, int maxt = MAX_THREAD)</span><br><span class="line">      :_capacity(maxq)</span><br><span class="line">      ,_thr_max(maxt)</span><br><span class="line">      ,_thr_list(maxt)</span><br><span class="line">      ,_thr_cur(0)</span><br><span class="line">    &#123;</span><br><span class="line">      pthread_mutex_init(&amp;_mutex, NULL);</span><br><span class="line">      pthread_cond_init(&amp;_cond_pro, NULL);</span><br><span class="line">      pthread_cond_init(&amp;_cond_con, NULL);</span><br><span class="line">    &#125;</span><br><span class="line">    ~ThreadPool()</span><br><span class="line">    &#123;</span><br><span class="line">      pthread_mutex_destroy(&amp;_mutex);</span><br><span class="line">      pthread_cond_destroy(&amp;_cond_pro);                                                     </span><br><span class="line">      pthread_cond_destroy(&amp;_cond_con);</span><br><span class="line">    &#125;</span><br><span class="line">    //初始化线程组</span><br><span class="line">    bool PoolInit()</span><br><span class="line">    &#123;</span><br><span class="line">      for(int i = 0; i &lt; _thr_max; i++)</span><br><span class="line">      &#123;</span><br><span class="line">        _thr_list[i] = std::thread(&amp;ThreadPool::thr_start, this);</span><br><span class="line">        _thr_list[i].detach();</span><br><span class="line">        _thr_cur++;</span><br><span class="line">      &#125;</span><br><span class="line">      return true;</span><br><span class="line">    &#125;</span><br><span class="line">    //添加任务</span><br><span class="line">    bool AddTask(Task&amp; tt)</span><br><span class="line">    &#123;</span><br><span class="line">      pthread_mutex_lock(&amp;_mutex);</span><br><span class="line">      while(_queue.size() == _capacity)</span><br><span class="line">      &#123;</span><br><span class="line">        pthread_cond_wait(&amp;_cond_pro, &amp;_mutex);</span><br><span class="line">      &#125;</span><br><span class="line">      _queue.push(tt);</span><br><span class="line">      pthread_mutex_unlock(&amp;_mutex);</span><br><span class="line">      pthread_cond_signal(&amp;_cond_con);</span><br><span class="line">      return true;</span><br><span class="line">    &#125;</span><br><span class="line">    //销毁线程池，停止工作</span><br><span class="line">    bool PoolStop()</span><br><span class="line">    &#123;</span><br><span class="line">      pthread_mutex_lock(&amp;_mutex);</span><br><span class="line">      _quit_flag = true;</span><br><span class="line">      pthread_mutex_unlock(&amp;_mutex);</span><br><span class="line">      while(_thr_cur &gt; 0)                                                    </span><br><span class="line">      &#123;</span><br><span class="line">        //std::cout &lt;&lt; &quot;cont:&quot; &lt;&lt; _thr_cur &lt;&lt; std::endl;</span><br><span class="line">        pthread_cond_broadcast(&amp;_cond_con);</span><br><span class="line">        usleep(1000);</span><br><span class="line">      &#125;</span><br><span class="line">      //for(int i = 0; i &lt; _thr_max; i++)</span><br><span class="line">      //&#123;</span><br><span class="line">      //  _thr_list[i].join();</span><br><span class="line">      //&#125;</span><br><span class="line">      return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">void test(int data)</span><br><span class="line">&#123;</span><br><span class="line">  srand(time(NULL));</span><br><span class="line">  int nsec = rand() % 5;</span><br><span class="line">  std::stringstream ss;</span><br><span class="line">  ss &lt;&lt; &quot;thread:&quot; &lt;&lt; pthread_self() &lt;&lt; &quot; processint data &quot;;</span><br><span class="line">  ss &lt;&lt; data &lt;&lt; &quot; and sleep &quot; &lt;&lt; nsec &lt;&lt; &quot; sec&quot; &lt;&lt; std::endl;  </span><br><span class="line">  std:: cout &lt;&lt; ss.str();</span><br><span class="line">  sleep(nsec);</span><br><span class="line">  return;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">  ThreadPool pool;</span><br><span class="line">  pool.PoolInit();</span><br><span class="line">  for(int i = 0; i &lt; 10; i++)</span><br><span class="line">  &#123;</span><br><span class="line">    Task tt(i, test);</span><br><span class="line">    pool.AddTask(tt);</span><br><span class="line">  &#125;</span><br><span class="line">  pool.PoolStop();</span><br><span class="line">&#125;                                </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[misaki@localhost thread]$ ./threadpool</span><br><span class="line">thread:139941165012736 processint data 0 and sleep 4 sec</span><br><span class="line">thread:139941156620032 processint data 1 and sleep 4 sec</span><br><span class="line">thread:139941190190848 processint data 2 and sleep 4 sec</span><br><span class="line">thread:139941181798144 processint data 3 and sleep 4 sec</span><br><span class="line">thread:139941173405440 processint data 4 and sleep 4 sec</span><br><span class="line">thread:139941190190848 processint data 6 and sleep 4 sec</span><br><span class="line">thread:139941156620032 processint data 7 and sleep 4 sec</span><br><span class="line">thread:139941181798144 processint data 8 and sleep 4 sec</span><br><span class="line">thread:139941165012736 processint data 5 and sleep 4 sec</span><br><span class="line">thread:139941173405440 processint data 9 and sleep 4 sec</span><br><span class="line">thread exit 139941156620032</span><br><span class="line">thread exit 139941190190848</span><br><span class="line">thread exit 139941181798144</span><br><span class="line">thread exit 139941165012736</span><br><span class="line">thread exit 139941173405440</span><br></pre></td></tr></table></figure>
<h2 id="设计模式-1"><a href="#设计模式-1" class="headerlink" title="设计模式"></a>设计模式</h2><h3 id="单例模式-1"><a href="#单例模式-1" class="headerlink" title="单例模式"></a>单例模式</h3><p>&emsp;&emsp;单例模式是一种常见设计模式，之前已经多次介绍，Cpp章节中也有实现。单例模式使用场景是在一个资源只能被加载分配一次，一个类只能实例化一个对象的情况。</p>
<h4 id="饿汉模式-1"><a href="#饿汉模式-1" class="headerlink" title="饿汉模式"></a>饿汉模式</h4><p>&emsp;&emsp;资源一次性加载分配完，对象在程序初始化阶段实例化完毕，这种实现是线程安全的，程序运行起来比较流畅，但是启动加载时间可能过长。</p>
<h4 id="懒汉模式-1"><a href="#懒汉模式-1" class="headerlink" title="懒汉模式"></a>懒汉模式</h4><p>&emsp;&emsp;资源使用时再加载分配，对象再使用的时候再去实例化，这种实现加载快，同一时间消耗资源少，但是运行中可能卡顿。这种实现是线程不安全的，因此我们要加锁判断类是否实例化过，如果没有则实例化。</p>

          
        
      
    </div>
    
    
    

    

    <div>
    
    </div>

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/05/15/【Cpp】第二章-类和对象-中/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="MisakiFx">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/blog-logo.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Misaki`s blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/05/15/【Cpp】第二章-类和对象-中/" itemprop="url">【Cpp】第二章-类和对象-中</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-05-15T17:56:39+08:00">
                2019-05-15
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Cpp/" itemprop="url" rel="index">
                    <span itemprop="name">Cpp</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  3.2k
                </span>
              

              

              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="类和对象"><a href="#类和对象" class="headerlink" title="类和对象"></a>类和对象</h1><h2 id="类的六个默认成员函数"><a href="#类的六个默认成员函数" class="headerlink" title="类的六个默认成员函数"></a>类的六个默认成员函数</h2><p>&emsp;&emsp;在我们构建一个类之后即使我们在其中不写任何的成员函数，在其中也会有6个默认编译器自动生成的成员函数，这些函数构成了类的基本功能包括初始化，销毁后的清理工作等。当然这些自动生成的成员函数功能有限有时候或许无法达到预期的效果，因此我们可以对其进行重载让其能够达到我们需要的功能。<br><br>&emsp;&emsp;1、构造函数<br>&emsp;&emsp;2、析构函数<br>&emsp;&emsp;3、拷贝构造函数<br>&emsp;&emsp;4、赋值运算符重载函数<br>&emsp;&emsp;5、对普通对象取地址运算符重载<br>&emsp;&emsp;6、对常对象取地址运算符重载<br>&emsp;&emsp;以上这6个函数中前四个我们都有极大可能性会对其重载因此需要重点学习，而后两个则很少需要自己实现。</p>
<h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><p>&emsp;&emsp;构造函数时在<strong>类刚刚实例化创建出对象时自动进行调用的</strong>，主要负责类的初始化。因此我们就要注意一点，我们在调用构造函数的时候只是对对象进行初始化并不为其分配空间，因此构造函数并不是在构造对象，而是在初始化对象。</p>
<h3 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h3><p>&emsp;&emsp;构造函数具有以下特性<br>&emsp;&emsp;1、与类名相同<br>&emsp;&emsp;2、实例化自动调用<br>&emsp;&emsp;3、无返回值<br>&emsp;&emsp;4、支持重载</p>
<h3 id="默认构造函数"><a href="#默认构造函数" class="headerlink" title="默认构造函数"></a>默认构造函数</h3><p>&emsp;&emsp;所有的无参或是全缺省的构造函数都可以看作是默认的构造函数，并不一定非要是默认生成的构造函数，因此默认构造函数大致分为三种。<br>&emsp;&emsp;1、自定义无参构造函数<br>&emsp;&emsp;2、自定义全缺省构造函数<br>&emsp;&emsp;3、自动生成无参构造函数<br>&emsp;&emsp;如果类中没有构造函数，则会默认生成一个无参构造函数，但是如果我们定义了构造函数则不会再默认生成。但是默认生成的无参构造函数不会进行成员变量的初始化，如果成员中有其他自定义类型的成员变量会调用它的构造函数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;                                                                      </span><br><span class="line">using std::cout;         </span><br><span class="line">using std::endl;         </span><br><span class="line">using std::string;                                  </span><br><span class="line">class Student                                       </span><br><span class="line">&#123;                                           </span><br><span class="line">private:            </span><br><span class="line">  int _num;//学号                         </span><br><span class="line">  string _name;//姓名                                           </span><br><span class="line">  int _classId;//班级编号                                       </span><br><span class="line">public:                                                        </span><br><span class="line">  //一个类中默认的构造函数只能有一个，否则会产生歧义</span><br><span class="line">  //默认构造函数(自动生成的构造函数与它相同)</span><br><span class="line">  //Student()&#123;&#125;        </span><br><span class="line">  //构造函数重载       </span><br><span class="line">  //全缺省构造函数，也可以视为默认构造函数</span><br><span class="line">  //如果有默认值的情况下我们最好在类中将默认构造函数定义为全缺省</span><br><span class="line">  Student(int num = 1, string name = &quot;李狗蛋&quot;, int classId = 1)                       </span><br><span class="line">  &#123;                                                                                   </span><br><span class="line">    _num = num;     </span><br><span class="line">    _name = name;   </span><br><span class="line">    _classId = classId;</span><br><span class="line">  &#125;</span><br><span class="line">  void Print()                             </span><br><span class="line">  &#123;                              </span><br><span class="line">    cout &lt;&lt; &quot;学号：&quot; &lt;&lt; _num &lt;&lt; &quot;\t姓名：&quot; &lt;&lt; _name &lt;&lt; &quot;\t班级：&quot; &lt;&lt; _classId &lt;&lt; endl;</span><br><span class="line">  &#125;                </span><br><span class="line">&#125;;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">  //如果使用无参构造则不需要加括号，否则会和函数声明产生歧义</span><br><span class="line">  Student student1;//默认构造，全部用默认值</span><br><span class="line">  Student student2(2, &quot;张三&quot;, 2);</span><br><span class="line">  student1.Print();</span><br><span class="line">  student2.Print();</span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[misaki@localhost 第二章-类和对象]$ ./DefaultFun</span><br><span class="line">学号：1	姓名：李狗蛋	班级：1</span><br><span class="line">学号：2	姓名：张三	班级：2</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;这里需要注意的就是为了避免歧义<strong>一类中只能出现一个默认构造函数</strong>。同时自动生成的构造函数功能十分优先，不会进行成员变量初始化，所以我们往往需要重载。</p>
<h2 id="析构函数"><a href="#析构函数" class="headerlink" title="析构函数"></a>析构函数</h2><p>&emsp;&emsp;与构造函数向对立的就是析构函数，析构函数是在对象销毁时自动调用的，主要时为了帮助我们清理我们创建对象时分配的空间，清空指针之类的，析构函数在如果成员变量中没有指针或者没有动态分配内存亦或者没有需要关闭的文件的情况下往往时不需要自己进行定义的。</p>
<h3 id="特性-1"><a href="#特性-1" class="headerlink" title="特性"></a>特性</h3><p>&emsp;&emsp;1、定义在类名前加<code>~</code><br>&emsp;&emsp;2、无参数无返回值，意味着析构函数无法重载，只能存在一个<br>&emsp;&emsp;3、有且只有一个析构函数，若未显式定义则会生成默认析构<br>&emsp;&emsp;4、对象销毁时自动调用析构函数<br>&emsp;&emsp;析构函数特性与构造十分类似，最为主要的就是一个类中只会唯一存在一个析构函数。</p>
<h3 id="默认析构函数"><a href="#默认析构函数" class="headerlink" title="默认析构函数"></a>默认析构函数</h3><p>&emsp;&emsp;析构函数和构造函数一样如果我们并未定义则会自动生成一个，同样自动生成的析构函数不会做任何处理，析构函数在处理自定义类型时同样也会自动调用其对应的析构函数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//析构函数，默认生成的析构函数与它相同   </span><br><span class="line">~Student()&#123;&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="拷贝构造"><a href="#拷贝构造" class="headerlink" title="拷贝构造"></a>拷贝构造</h2><p>&emsp;&emsp;拷贝构造是用来实例化与某一对象相同的对象的，他会将该对象的数据完全复制一份相同的出来，拷贝构造是构造函数的一个重载。</p>
<h3 id="默认拷贝构造"><a href="#默认拷贝构造" class="headerlink" title="默认拷贝构造"></a>默认拷贝构造</h3><p>&emsp;&emsp;同样如果我们并未显式定义拷贝构造则会自动生成一个，但是要注意默认生成的拷贝构造只能完成简单的浅拷贝，因此如果我们想要对复杂的如链表类进行拷贝需要自行定义。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//默认拷贝构造  </span><br><span class="line">Student(const Student&amp; student)  </span><br><span class="line">&#123;  </span><br><span class="line">  _num = student._num;  </span><br><span class="line">  _name = student._name;</span><br><span class="line">  _classId = student._classId;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><p>&emsp;&emsp;拷贝构造在很多情况下都会调用，比如说我们将对象传给一个函数时，由于副本传参会复制一份副本进行传入，这个时候就已经调用了拷贝构造。那么我们在调用拷贝构造的时候就会将这个对象当作参数传入，如果我们这个时候调用了拷贝构造就是在拷贝构造中调用了拷贝构造会发生无限递归的情况，这该怎么解决呢？——传引用即可。因此拷贝构造的参数必定是本类对象的引用，不然就会报错。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">//拷贝构造  </span><br><span class="line">Student(Student student)  </span><br><span class="line">&#123;  </span><br><span class="line">  _num = student._num;  </span><br><span class="line">  _name = student._name;</span><br><span class="line">  _classId = student._classId;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">报错：</span><br><span class="line">DefaultFun.cpp:25:26: 错误：无效的构造函数：您要的可能是‘Student (const Student&amp;)’</span><br><span class="line">   Student(Student student)</span><br><span class="line">                          ^</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;在编写函数的时候建议多用引用类型，尤其是在面对占用空间大的自定义类型时，使用引用会提高效率，不会发生拷贝构造，如果我们并不希望修改传入的参数，在前面加上<code>const</code>来避免修改，这是很好的代码风格。这里极度推荐一定要传入常引用，不然可能会引发赋值运算符重载连续赋值时调用拷贝构造传参产生常引用参数类型不服无法调用的情况。</p>
<h2 id="赋值运算符重载"><a href="#赋值运算符重载" class="headerlink" title="赋值运算符重载"></a>赋值运算符重载</h2><p>&emsp;&emsp;赋值运算符重载是类似于拷贝构造的默认构造函数，不过是将拷贝构造通过<code>=</code>来使用，不过我们得先了解运算符重载。</p>
<h3 id="运算符重载"><a href="#运算符重载" class="headerlink" title="运算符重载"></a>运算符重载</h3><p>&emsp;&emsp;在C++中支持对运算符进行重载，使得给我们带来的很大的遍历，由此我们可以通过预算符来指定操作操作我们的自定义类型。</p>
<h4 id="重载规则"><a href="#重载规则" class="headerlink" title="重载规则"></a>重载规则</h4><p>&emsp;&emsp;1、不能创建新的操作符<br>&emsp;&emsp;2、必须有一个自定义类型或枚举类型操作数。<br>&emsp;&emsp;3、内置类型操作符不能改变其含义<br>&emsp;&emsp;4、在类内定义时会多一个默认形参<code>this</code>指针<br>&emsp;&emsp;5、<code>.*</code>、<code>::</code>、<code>sizeof</code>、<code>.</code>、<code>?:</code>这五个操作符不能重载。</p>
<h4 id="类外重载"><a href="#类外重载" class="headerlink" title="类外重载"></a>类外重载</h4><p>&emsp;&emsp;在类外进行操作符重载定义的成为类外重载，往往有两个参数，其中要求至少有一个是自定义类型。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">bool operator==(const Student&amp; stu1, const Student&amp; stu2)</span><br><span class="line">&#123;</span><br><span class="line">  return stu1._num == stu2._num &amp;&amp; stu1._name == stu2._name &amp;&amp; stu1._classId == stu2._classId;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">  //如果使用无参构造则不需要加括号，否则会和函数声明产生歧义</span><br><span class="line">  Student student1(2, &quot;张三&quot;, 2);//默认构造，全部用默认值</span><br><span class="line">  Student student2(2, &quot;张三&quot;, 2);</span><br><span class="line">  cout &lt;&lt; (student1 == student2) &lt;&lt; endl;</span><br><span class="line">  //实际上会转换为operator==(student1, student2);</span><br><span class="line">&#125;                                                                                              </span><br><span class="line"></span><br><span class="line">[misaki@localhost 第二章-类和对象]$ ./DefaultFun</span><br><span class="line">1</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;但是类外构造有一个致命的缺点，就是在类外我们往往无法访问到类内的很多成员变量，为了实现重载将其改为公有有点以小失大，因此就有了类内构造。</p>
<h4 id="类内重载"><a href="#类内重载" class="headerlink" title="类内重载"></a>类内重载</h4><p>&emsp;&emsp;类内重载则能解决成员在类外无法调用的问题。定义的类则自动被视为左操作数，参数则为右操作数。不过要注意类内重载会默认有一个形参<code>this</code>。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">//类内重载                                                                     </span><br><span class="line">bool operator==(const Student&amp; stu2)</span><br><span class="line">&#123;                                                                              </span><br><span class="line">  return _num == stu2._num &amp;&amp; _name == stu2._name &amp;&amp; _classId == stu2._classId;</span><br><span class="line">&#125;                                     </span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">  //如果使用无参构造则不需要加括号，否则会和函数声明产生歧义</span><br><span class="line">  Student student1(2, &quot;张三&quot;, 2);//默认构造，全部用默认值</span><br><span class="line">  Student student2(2, &quot;张三&quot;, 2);</span><br><span class="line">  cout &lt;&lt; (student1 == student2) &lt;&lt; endl;</span><br><span class="line">  //实际调用：student1.operator==(&amp;student1, student2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="赋值运算符重载-1"><a href="#赋值运算符重载-1" class="headerlink" title="赋值运算符重载"></a>赋值运算符重载</h4><p>&emsp;&emsp;赋值运算符重载不过是将拷贝构造的内容通过赋值运算符重载来表示，这样更加直观，同样的如果我们未显式定义则会默认生成一个。同时这个运算符重载是有返回值的，是为了用于实现连续赋值。这里推荐一定传入引用类型的参数，是为了防止连续赋值时调用拷贝构造出现问题,同时返回值也要返回引用类型，防止调用拷贝构造影响效率。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">//赋值运算符重载，自动生成的重载与他相同</span><br><span class="line">Student&amp; operator=(const Student&amp; stu)</span><br><span class="line">&#123;</span><br><span class="line">  _num = stu._num;</span><br><span class="line">  _name = stu._name;</span><br><span class="line">  _classId = stu._classId;</span><br><span class="line">  return *this;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">  Student student1(2, &quot;张三&quot;, 2);//默认构造，全部用默认值</span><br><span class="line">  Student student2 = student1;</span><br><span class="line">  student2.Print();</span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[misaki@localhost 第二章-类和对象]$ ./DefaultFun</span><br><span class="line">学号：2	姓名：张三	班级：2</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;自动生成的运算符重载也只能完成浅拷贝。</p>
<h2 id="const成员"><a href="#const成员" class="headerlink" title="const成员"></a>const成员</h2><p>&emsp;&emsp;我们有时会定义常对象，即不可改变的对象，这种对象在调用成员函数如果调用的普通成员函数会出现问题。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">  const Student student1(2, &quot;张三&quot;, 2);</span><br><span class="line">  student1.Print();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">[misaki@localhost 第二章-类和对象]$ make</span><br><span class="line">g++ -g DefaultFun.cpp -o DefaultFun</span><br><span class="line">DefaultFun.cpp: 在函数‘int main()’中:</span><br><span class="line">DefaultFun.cpp:61:18: 错误：将‘const Student’作为‘void Student::Print()’的‘this’实参时丢弃了类型限定 [-fpermissive]</span><br><span class="line">   student1.Print();</span><br><span class="line">                  ^</span><br><span class="line">make: *** [DefaultFun] 错误 1</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;这里主要问题所在就在于调用函数由于我们的对象是<code>const</code>，那么对象本身不可改，在传给隐式<code>this</code>的时候这里的<code>this</code>的类型也应该为<code>const *</code>，否则就会出现这样的问题。那么我们怎么样解决呢？这里就要用到常成员函数。</p>
<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">void Print() const                                                                  </span><br><span class="line">&#123;                             </span><br><span class="line">  cout &lt;&lt; &quot;学号：&quot; &lt;&lt; _num &lt;&lt; &quot;\t姓名：&quot; &lt;&lt; _name &lt;&lt; &quot;\t班级：&quot; &lt;&lt; _classId &lt;&lt; endl;</span><br><span class="line">&#125;  </span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">  const Student student1(2, &quot;张三&quot;, 2);</span><br><span class="line">  student1.Print();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[misaki@localhost 第二章-类和对象]$ ./DefaultFun</span><br><span class="line">学号：2	姓名：张三	班级：2</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;在成员函数后加<code>const</code>将其变为常成员，常成员会将函数的形参<code>this</code>类型改为<code>const *</code>，这样在常成员函数中则不可再修改调用对象的数据。</p>
<h3 id="注意-1"><a href="#注意-1" class="headerlink" title="注意"></a>注意</h3><p>&emsp;&emsp;1、普通对象可以调用常成员函数。<br>&emsp;&emsp;2、常对象不可以调用普通成员函数。<br>&emsp;&emsp;3、建议将一切不会修改对象数据的成员函数都写为常成员函数。<br>&emsp;&emsp;4、常对象只能初始化，不能进行修改。</p>
<h2 id="取地址及const取地址操作符取地址"><a href="#取地址及const取地址操作符取地址" class="headerlink" title="取地址及const取地址操作符取地址"></a>取地址及const取地址操作符取地址</h2><p>&emsp;&emsp;这两个默认成员函数是最后的两个会默认生成的成员函数，一般情况下不需要我们显式定义，除非我们想让别人通过取地址符获得指定的数据。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//默认生成的取地址及const取地址操作符如下</span><br><span class="line">Student* operator&amp;()</span><br><span class="line">&#123;</span><br><span class="line">  return this ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const Student* operator&amp;() const</span><br><span class="line">&#123;</span><br><span class="line">  return this ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>

          
        
      
    </div>
    
    
    

    

    <div>
    
    </div>

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/05/12/【Cpp】第二章-类和对象-上/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="MisakiFx">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/blog-logo.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Misaki`s blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/05/12/【Cpp】第二章-类和对象-上/" itemprop="url">【Cpp】第二章-类和对象(上)</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-05-12T20:36:53+08:00">
                2019-05-12
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Cpp/" itemprop="url" rel="index">
                    <span itemprop="name">Cpp</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  2k
                </span>
              

              

              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="类和对象"><a href="#类和对象" class="headerlink" title="类和对象"></a>类和对象</h1><p>&emsp;&emsp;从本章开始我们就要开始学习C++ 中的最为重要的部分，也是让C++ 得以实现面向对象，得以更加方便的进行大型项目编程的最重要的部分——类和对象，类和对象的存在使C++得以完成封装。</p>
<h2 id="类和对象初步认识"><a href="#类和对象初步认识" class="headerlink" title="类和对象初步认识"></a>类和对象初步认识</h2><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>&emsp;&emsp;什么是类什么是对象呢？ <strong>类</strong>可以看作是一个类别，是一类事物的抽象和归纳。比如在现实世界中类可以是兔子，可以是人，可以是某一个职业，这是一类事物，我们将其抽象出来，而并非具体的。与之相对的是<strong>对象</strong>，对象就是类的实例化，比如说快递员这个类我们可以说快递员是一个类，而假如今天我们点了个外卖，呢么具体的今天来给我们送餐的这个人就是一个对象，对象是属于类的，，是类的具体实例。</p>
<h2 id="类的定义"><a href="#类的定义" class="headerlink" title="类的定义"></a>类的定义</h2><p>&emsp;&emsp;类在C++ 中的语法更加类似于C语言中结构体的语法，不过在C语言中结构体内部只能定义成员变量，不能定义函数，在C++ 中结构体中可以定义成员函数，使得我们可以讲很多东西封装到类中支持面向对象的编程思想。并且在C++中我们更崇尚于用<code>class</code>来代替<code>struct</code>。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">struct AddStruct  </span><br><span class="line">&#123;  </span><br><span class="line">  int num1;  </span><br><span class="line">  int num2;  </span><br><span class="line">  int AddNum()</span><br><span class="line">  &#123;  </span><br><span class="line">    return num1 + num2;  </span><br><span class="line">  &#125;  </span><br><span class="line">&#125;;  </span><br><span class="line">class AddClass  </span><br><span class="line">&#123;  </span><br><span class="line">  int num1;  </span><br><span class="line">  int num2;  </span><br><span class="line">  int AddNum()</span><br><span class="line">  &#123;  </span><br><span class="line">    return num1 + num2;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;以上我们用两种方法定义了两个类，可以看出在C++中<code>struct</code>与<code>class</code>的区别不是很大，但是即使如此它们之间依旧有所区别。其中最主要的区别就是在<code>struct</code>中的成员默认是公有的(<code>public</code>)，而<code>class</code>中成员默认是私有的(<code>private</code>)。</p>
<h2 id="类的访问限定符及封装"><a href="#类的访问限定符及封装" class="headerlink" title="类的访问限定符及封装"></a>类的访问限定符及封装</h2><h3 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h3><p>&emsp;&emsp;在C++中是如何实现封装的呢？其中最为重要的途径就是利用<strong>类</strong>和它*<em>访问限定符</em>，我们将对象的属性和方法封装在一个类中并为她们加上访问限定符让外界不能随意无序的进行访问我们就完成了封装。</p>
<h3 id="访问限定符"><a href="#访问限定符" class="headerlink" title="访问限定符"></a>访问限定符</h3><p>&emsp;&emsp;访问限定符一共有三个：<code>private</code>(私有);<code>public</code>(公有);<code>protected</code>(保护)。访问限定符的作用域是从当前访问限定符开始到下一个访问限定符结束或者到整个类的结束。<br><br>&emsp;&emsp;这里重点介绍前两个，<code>protected</code>的主要作用起在类的继承方面，后续再做讨论。</p>
<h4 id="public"><a href="#public" class="headerlink" title="public"></a>public</h4><p>&emsp;&emsp;公有的访问限定符范围内的成员可以被类外部进行访问，我们可以在类外和类内随意使用类中<code>public</code>的成员，因此我们往往将类向外部提供的接口放在<code>public</code>中。</p>
<h4 id="private"><a href="#private" class="headerlink" title="private"></a>private</h4><p>&emsp;&emsp;私有的访问限定符范围内的成员不能被类外部进行访问，我们只能在类内调用或使用<code>private</code>的成员，因此<code>private</code>往往有保护类内数据的作用，为了方便起见我们往往将类内的成员变量全部定义为<code>private</code>，如果想要对类内数据机型修改则需要另写接口，这样的安全性更高。<br><br>&emsp;&emsp;之后我们就用类访问限定符改造我们之前定义的<code>Add</code>类。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class AddClass                  </span><br><span class="line">&#123;                               </span><br><span class="line">private:                        </span><br><span class="line">  int _num1;                    </span><br><span class="line">  int _num2;                    </span><br><span class="line">public:                         </span><br><span class="line">  void GetNum1(int num1)        </span><br><span class="line">  &#123;                             </span><br><span class="line">    _num1 = num1;               </span><br><span class="line">  &#125;                             </span><br><span class="line">  void GetNum2(int num2)        </span><br><span class="line">  &#123;                             </span><br><span class="line">    _num2 = num2;               </span><br><span class="line">  &#125;                             </span><br><span class="line">  int AddNum()</span><br><span class="line">  &#123;</span><br><span class="line">    return _num1 + _num2;       </span><br><span class="line">  &#125;                             </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;经过改造的类中的成员变量由于是<code>private</code>类型受到保护因此我们要再向外多提供几个接口以便让外部可以修改内部的值。同时为了将成员变量与函数中的变量加以区分我们往往会用<code>_</code>来修饰成员变量，这不是必须但是会提升代码可读性。</p>
<h2 id="类的作用域"><a href="#类的作用域" class="headerlink" title="类的作用域"></a>类的作用域</h2><p>&emsp;&emsp;其实类一旦声明再类内就形成了一个域，域外无法访问域内的成员。我们在域内可以直接声明并且定义成员函数，但是<strong>在域内定义的成员函数会默认作为内联函数对待</strong>，而且为了代码的可读性我们也并不能将所有的成员函数都定义在类内，那么如何在类外定义成员函数呢？为此我们再将之前写的类进行改造。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">class AddClass  </span><br><span class="line">&#123;  </span><br><span class="line">private:  </span><br><span class="line">  int _num1;  </span><br><span class="line">  int _num2;  </span><br><span class="line">public:</span><br><span class="line">  //默认内联但为了可读性我们还是加上内联的标志</span><br><span class="line">  inline void GetNum1(int num1)</span><br><span class="line">  &#123;                </span><br><span class="line">    _num1 = num1;  </span><br><span class="line">  &#125;                            </span><br><span class="line">  inline void GetNum2(int num2)</span><br><span class="line">  &#123;                                            </span><br><span class="line">    _num2 = num2;                              </span><br><span class="line">  &#125;                                            </span><br><span class="line">  //在类内声明                                 </span><br><span class="line">  int AddNum();                                </span><br><span class="line">&#125;;                                             </span><br><span class="line">//在类外定义                                   </span><br><span class="line">int AddClass::AddNum()                         </span><br><span class="line">&#123;                                              </span><br><span class="line">  return _num1 + _num2;                        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;我们可以通过域限定符来在类外定义函数，这样我们就可以将声明和定义分开，使代码可读性更高。</p>
<h2 id="类的实例化"><a href="#类的实例化" class="headerlink" title="类的实例化"></a>类的实例化</h2><p>&emsp;&emsp;在定义完类之后我们就需要用类来建立我们真正要使用的对象，我们称这一过程也叫类的实例化。类进行实例化十分方便，和用结构体定义变量无异。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class AddClass</span><br><span class="line">&#123;</span><br><span class="line">private:                                        </span><br><span class="line">  int _num1;</span><br><span class="line">  int _num2;</span><br><span class="line">public:</span><br><span class="line">  //默认内联但为了可读性我们还是加上内联的标志</span><br><span class="line">  inline void GetNum1(int num1)</span><br><span class="line">  &#123;</span><br><span class="line">    _num1 = num1;</span><br><span class="line">  &#125;</span><br><span class="line">  inline void GetNum2(int num2)</span><br><span class="line">  &#123;</span><br><span class="line">    _num2 = num2;</span><br><span class="line">  &#125;</span><br><span class="line">  //在类内声明</span><br><span class="line">  int AddNum();</span><br><span class="line">&#125;;</span><br><span class="line">//在类外定义</span><br><span class="line">int AddClass::AddNum()</span><br><span class="line">&#123;</span><br><span class="line">  return _num1 + _num2;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">  AddClass add;</span><br><span class="line">  add.GetNum1(1);</span><br><span class="line">  add.GetNum2(2);</span><br><span class="line">  cout &lt;&lt; add.AddNum() &lt;&lt; endl;</span><br><span class="line">&#125;                               </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[misaki@localhost 第二章-类和对象]$ ./Class</span><br><span class="line">3</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;由此即完成了类的实例化即成员调用。</p>
<h2 id="类的大小计算"><a href="#类的大小计算" class="headerlink" title="类的大小计算"></a>类的大小计算</h2><p>&emsp;&emsp;类的大小计算与结构体无异遵循内存对齐的规则，但有几点需要注意：<br><br>&emsp;&emsp;1、类的大小只计算成员变量的大小，遵循内存对齐规则。<br><br>&emsp;&emsp;2、类中的方法不算做类的大小，为了节省空间将方法存储在公共的区域且只存一个。<br><br>&emsp;&emsp;3、空类的大小为1，这里占一个字节不进行数据存储只是为了在内存上占位。这里包括所有没有成员变量的类，哪怕有再多方法也是只有1字节大小。</p>
<h2 id="this指针"><a href="#this指针" class="headerlink" title="this指针"></a>this指针</h2><h3 id="什么是this指针"><a href="#什么是this指针" class="headerlink" title="什么是this指针"></a>什么是this指针</h3><p>&emsp;&emsp;既然我们类中的函数都存在同一块区域中，那么编译器使怎么区分是哪个对象调用了成员函数呢？这就牵扯到了每个类中隐藏的成员<code>this</code>指针。<br><br>&emsp;&emsp;实际上这是一个指向类自身的指针。它会默认作为成员函数调用的第一个参数，将调用成员函数的对象地址传入好在函数内部找到对象中的成员。这一切都是隐式进行的都有编译器进行处理。因此实际上我们调用的代码是这样传参的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class AddClass</span><br><span class="line">&#123;</span><br><span class="line">private:</span><br><span class="line">  int _num1;</span><br><span class="line">  int _num2;</span><br><span class="line">public:</span><br><span class="line">  //默认内联但为了可读性我们还是加上内联的标志</span><br><span class="line">  inline void GetNum1(int num1)</span><br><span class="line">  //inline void GetNum1(AddClass* this, int num1)</span><br><span class="line">  &#123;</span><br><span class="line">    _num1 = num1;</span><br><span class="line">  &#125;</span><br><span class="line">  inline void GetNum2(int num2)</span><br><span class="line">  &#123;</span><br><span class="line">    _num2 = num2;</span><br><span class="line">  &#125;</span><br><span class="line">  //在类内声明</span><br><span class="line">  int AddNum();</span><br><span class="line">  //int AddNum(AddClass* this);</span><br><span class="line">&#125;;</span><br><span class="line">//在类外定义</span><br><span class="line">int AddClass::AddNum()                           </span><br><span class="line">&#123;</span><br><span class="line">  return _num1 + _num2;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">  AddClass add;</span><br><span class="line">  add.GetNum1(1);</span><br><span class="line">  //add.GetNum1(&amp;add, 1);</span><br><span class="line">  add.GetNum2(2);</span><br><span class="line">  cout &lt;&lt; add.AddNum() &lt;&lt; endl;</span><br><span class="line">  //AddNum(&amp;add);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="this指针特性"><a href="#this指针特性" class="headerlink" title="this指针特性"></a>this指针特性</h3><p>&emsp;&emsp;1、this指针不存储在类中，每个编译器对this指针存储的地方都有所不同，在vs中this指针存储在寄存器中。<br>&emsp;&emsp;2、this指针可以为空，但是一旦调用需要访问对象中成员的函数就会由于this为空发生内存越界而导致崩溃。</p>

          
        
      
    </div>
    
    
    

    

    <div>
    
    </div>

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/05/11/【Cpp】第一章-Cpp入门/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="MisakiFx">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/blog-logo.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Misaki`s blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/05/11/【Cpp】第一章-Cpp入门/" itemprop="url">【Cpp】第一章-Cpp入门</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-05-11T23:06:35+08:00">
                2019-05-11
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Cpp/" itemprop="url" rel="index">
                    <span itemprop="name">Cpp</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  4.6k
                </span>
              

              

              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="第一章-C-入门"><a href="#第一章-C-入门" class="headerlink" title="第一章 C++入门"></a>第一章 C++入门</h1><h2 id="C-简介"><a href="#C-简介" class="headerlink" title="C++简介"></a>C++简介</h2><h3 id="什么是C"><a href="#什么是C" class="headerlink" title="什么是C++"></a>什么是C++</h3><p>&emsp;&emsp;C语言是面向过程式的语言，在处理小规模的问题时则能体现出其简单易上手的的优势，但是在面对大型程序或需要高度抽象化的程序时，C语言就显得略有鸡肋。在20实际80年代，计算机界为了解决软件危机提出了面向对象(OOP)思想的变成模式，于是支持OOP的编程语言也应运而生。<br><br>&emsp;&emsp;1982年<strong>Bjarne Stroustrup</strong>博士在C语言的基础上引入并且扩充了面向对象的概念，并且命名为C++，因此C++ 是在C语言基础上诞生的，它既可以支持面向过程编程也可以支持面向化程序设计。<br><br>&emsp;&emsp;C++ 发展至今和C语言一样已经拥有很多各版本，并在不停的升级中，目前最为常用时C++ 98(引入STL，以模板方式重新编写标准库)和C++ 11(增加了很多特性，例如范围for，auto关键字)，目前C++已经应用于互联网各个方向，例如大型系统开发，游戏开发，网络工具，嵌入式，数字图像处理……</p>
<h3 id="如何学习"><a href="#如何学习" class="headerlink" title="如何学习"></a>如何学习</h3><p>&emsp;&emsp;<strong>多看书</strong>，目前市面上有很多C++ 优秀书籍，有些甚至成为了C++ 工程师心中的标杆（《Effective C++》）。<br><br>&emsp;&emsp;<strong>多记录</strong>，每天的学习笔记，每周的学习总结，遇到的问题，这些都要多多记录，方便之后再次遇到相同的问题可以直接拿出来复习。<br><br>&emsp;&emsp;<strong>思维导图</strong>，思维导图是学习中必不可少的，可以帮我们理清学习路线，学习思路，方便复习。<br><br>&emsp;&emsp;<strong>多敲代码</strong>，语言都是如此多用才是巩固的基础，夺取在线OJ网上练习，或者自己敲几个小项目练练手都是练习的好思路。</p>
<h2 id="命名空间"><a href="#命名空间" class="headerlink" title="命名空间"></a>命名空间</h2><p>&emsp;&emsp;在一门高级语言中，变量是大量存在的，那么难免在定义变量的时候就会重名，尤其在一个项目或工程中有多个工程师的时候就跟容易与他人定义相同变量名的变量，重名问题就会更加明显，在C语言中我们没有一个有效的办法来解决这个问题，因此C语言在大型项目方面会很吃力，因此在C++中加入了命名空间的语法，不同的程序员之间使用不同的命名空间，在不同的命名空间中允许变量重名，由此在项目合作中十分有用。</p>
<h3 id="命名空间的定义"><a href="#命名空间的定义" class="headerlink" title="命名空间的定义"></a>命名空间的定义</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;                         </span><br><span class="line">//命名空间的定义                            </span><br><span class="line">namespace N1                                </span><br><span class="line">&#123;                                           </span><br><span class="line">  //在命名空间中可以定义函数、变量          </span><br><span class="line">  int a = 1;                                </span><br><span class="line">  int b = 1;                                </span><br><span class="line">  int Add(int a, int b)                     </span><br><span class="line">  &#123;                                         </span><br><span class="line">    return a + b;                           </span><br><span class="line">  &#125;                                         </span><br><span class="line">&#125;            </span><br><span class="line">//命名空间的嵌套</span><br><span class="line">namespace N2</span><br><span class="line">&#123;</span><br><span class="line">  int a = 2;          </span><br><span class="line">  int b = 2;</span><br><span class="line">  int Add(int a, int b)</span><br><span class="line">  &#123;</span><br><span class="line">    return a + b;</span><br><span class="line">  &#125;</span><br><span class="line">  namespace N3</span><br><span class="line">  &#123;</span><br><span class="line">    int a = 3;</span><br><span class="line">    int b = 3;</span><br><span class="line">    int Add(int a, int b)</span><br><span class="line">    &#123;</span><br><span class="line">      return a + b;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">//命名相同的命名空间</span><br><span class="line">namespace N1 </span><br><span class="line">&#123;</span><br><span class="line">  int c = 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;每一个命名空间都是一个作用域，空间中的内容都局限于该空间中，而我们要使用某空间中的某一变量或函数时指定命名空间即可找到指定的内容。<br>&emsp;&emsp;命名空间支持嵌套，如果一个工程中同时存在多个相同名称的命名空间，则最后会合成到一个命名空间中。</p>
<h3 id="命名空间的使用"><a href="#命名空间的使用" class="headerlink" title="命名空间的使用"></a>命名空间的使用</h3><p>&emsp;&emsp;在使用命名空间时要加上作用域限定符<code>::</code><br>进行作用域的限定。我们右三种使用命名空间的方法。<br><br>&emsp;&emsp;<strong>加命名空间加作用域限定符</strong>:<br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">  //三种使用命名空间的方法</span><br><span class="line">  //::为作用域限定符</span><br><span class="line">  //分别打印三个命名空间中的a;</span><br><span class="line">  std::cout &lt;&lt; &quot;N1::a = &quot; &lt;&lt; N1::a &lt;&lt; std::endl;</span><br><span class="line">  std::cout &lt;&lt; &quot;N2::a = &quot; &lt;&lt; N2::a &lt;&lt; std::endl;</span><br><span class="line">  std::cout &lt;&lt; &quot;N2::N3::a = &quot; &lt;&lt; N2::N3::a &lt;&lt; std::endl;</span><br><span class="line">&#125;           </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[misaki@localhost 第一章-C++入门]$ ./namespace </span><br><span class="line">N1::a = 1</span><br><span class="line">N2::a = 2</span><br><span class="line">N2::N3::a = 3</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;我们在进行输出的时候用到了<code>cout</code>函数以及<code>endl</code>换行函数，由于这两个函数都在<code>std</code>标准命名空间中，因此要想使用这两个函数也要用作用域限定符进行限定。<br><br>&emsp;&emsp;<strong>使用using将命名空间中成员引入:</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">using N1::a;</span><br><span class="line">using N2::b;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">  //三种使用命名空间的方法</span><br><span class="line">  //::为作用域限定符</span><br><span class="line">  //分别打印三个命名空间中的a;</span><br><span class="line">  std::cout &lt;&lt; &quot;N1::a = &quot; &lt;&lt; a &lt;&lt; std::endl;</span><br><span class="line">  std::cout &lt;&lt; &quot;N2::b = &quot; &lt;&lt; b &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[misaki@localhost 第一章-C++入门]$ ./namespace</span><br><span class="line">N1::a = 1</span><br><span class="line">N2::b = 2</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;<strong>使用命名空间名称引入:</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">using namespace N1;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">  //三种使用命名空间的方法</span><br><span class="line">  //::为作用域限定符</span><br><span class="line">  //分别打印三个命名空间中的a;</span><br><span class="line">  std::cout &lt;&lt; &quot;N1::a = &quot; &lt;&lt; a &lt;&lt; std::endl;</span><br><span class="line">  std::cout &lt;&lt; &quot;N1::b = &quot; &lt;&lt; b &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[misaki@localhost 第一章-C++入门]$ ./namespace</span><br><span class="line">N1::a = 1</span><br><span class="line">N1::b = 1</span><br></pre></td></tr></table></figure></p>
<h2 id="缺省参数（默认参数）"><a href="#缺省参数（默认参数）" class="headerlink" title="缺省参数（默认参数）"></a>缺省参数（默认参数）</h2><p>&emsp;&emsp;我们在C语言中书写函数时如果我们为一个函数设置了参数则在调用时必须对参数进行传入否则就会调用失败，但有的时候会出现大量的相同的冗余的参数，我嫩不得不手动将参数一一传入，但是C++中得益于缺省参数的语法是的我们可以在函数中提前设置默认的参数，如果有新参数传入则使用新的参数否则使用默认参数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int func1(int a = 10, int b = 20, int c = 30)</span><br><span class="line">&#123;</span><br><span class="line">  return a + b + c;</span><br><span class="line">&#125;</span><br><span class="line">int func2(int a, int b = 20, int c = 30)</span><br><span class="line">&#123;</span><br><span class="line">  return a + b + c;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">  cout &lt;&lt; func1() &lt;&lt; endl;</span><br><span class="line">  cout &lt;&lt; func1(1, 2, 3) &lt;&lt; endl;            </span><br><span class="line">  cout &lt;&lt; func2(1) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[misaki@localhost 第一章-C++入门]$ ./缺省参数</span><br><span class="line">60</span><br><span class="line">6</span><br><span class="line">51</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;在设置默认参数时一定要注意以下几点：<br><br>&emsp;&emsp;1、为了不产生歧义我们<strong>只能从最后一个参数向前开始设置，并且中间不能跳过某个参数要保持默认参数连续。</strong><br><br>&emsp;&emsp;2、<strong>默认值只能是常量或是全局变量。</strong><br><br>&emsp;&emsp;3、<strong>缺省参数不能在函数的定义和声明中同时出现。</strong></p>
<h2 id="函数重载"><a href="#函数重载" class="headerlink" title="函数重载"></a>函数重载</h2><p>&emsp;&emsp;在C语言中我们要求函数名不能重名，因此往往我们需要功能相同的函数但向外提供不同的接口时就需要通过自己改变函数名的方式来进行区别。但在C++中我们有了函数重载，我们可以通过不同的参数对名字相同的函数进行修饰，使得函数的功能更加强大更加方便。</p>
<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int Add(int num1, int num2)</span><br><span class="line">&#123;</span><br><span class="line">  cout &lt;&lt; &quot;call Add1&quot; &lt;&lt; endl;</span><br><span class="line">  return num1 + num2;</span><br><span class="line">&#125;</span><br><span class="line">double Add(double num1, double num2)</span><br><span class="line">&#123;</span><br><span class="line">  cout &lt;&lt; &quot;call Add2&quot; &lt;&lt; endl;</span><br><span class="line">  return num1 + num2;</span><br><span class="line">&#125;</span><br><span class="line">float Add(float num1, float num2)</span><br><span class="line">&#123;</span><br><span class="line">  cout &lt;&lt; &quot;call Add3&quot; &lt;&lt; endl;                       </span><br><span class="line">  return num1 + num2;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">  cout &lt;&lt; &quot;1 + 2 =&quot; &lt;&lt; Add(1, 2) &lt;&lt; endl;</span><br><span class="line">  cout &lt;&lt; &quot;1.5 + 2.5 =&quot; &lt;&lt; Add(1.5, 2.5) &lt;&lt; endl;</span><br><span class="line">  cout &lt;&lt; &quot;1.5f + 2.5f =&quot; &lt;&lt; Add(1.5f, 2.5f) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[misaki@localhost 第一章-C++入门]$ ./函数重载</span><br><span class="line">call Add1</span><br><span class="line">1 + 2 =3</span><br><span class="line">call Add2</span><br><span class="line">1.5 + 2.5 =4</span><br><span class="line">call Add3</span><br><span class="line">1.5f + 2.5f =4</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;在C++如果定义同名函数我们必须保证参数列表不同，即参数的<strong>个数</strong>或参数<strong>类型</strong>或参数<strong>顺序</strong>不同才能完成重载，并且<strong>返回值不同不会进行函数的重载</strong>。</p>
<h3 id="名字修饰"><a href="#名字修饰" class="headerlink" title="名字修饰"></a>名字修饰</h3><p>&emsp;&emsp;在C++中我们之所以可以使函数重名是因为在编译过程中编译器根据函数的参数列表对我们的函数名进行了处理，使得其在最后得以唯一化，至于其名字修饰规则较为复杂，不同的编译器在修饰中的处理都不尽相同。我们可以利用反汇编看一下gcc的处理规则。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//三个Add()函数在编译中的修饰结果：</span><br><span class="line">int Add(int, int):</span><br><span class="line">000000000040089d &lt;_Z3Addii&gt;</span><br><span class="line">double Add(double, double):</span><br><span class="line">00000000004008d1 &lt;_Z3Adddd&gt;</span><br><span class="line">float Add(float, float):</span><br><span class="line">000000000040091d &lt;_Z3Addff&gt;</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;从上面的例子中我们大致可以摸索出gcc函数修饰的规则，它会根据参数列表对函数名进行唯一化修饰。无论如何在编译中到最后一步链接之前我们的目标文件中一定不会出现重名的函数，不然在连接时就会产生歧义。</p>
<h3 id="extern-“C”"><a href="#extern-“C”" class="headerlink" title="extern “C”"></a>extern “C”</h3><p>&emsp;&emsp;C++ 支持向前兼容，就是说我们可以在C++ 中无缝调用C语言的代码，那么我们可以在C语言中调用C++ 的代码么？答案是肯定的。我们在C++ 的函数中只需要加上<code>extern &quot;C&quot;</code>就可以做到让编译器根据C语言的编译规则来进行编译，这样我们就可以在C语言中调用C++的代码。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">extern &quot;C&quot; int Add(int a, int b)</span><br><span class="line">&#123;</span><br><span class="line">  return a + b;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">  cout &lt;&lt; Add(1, 2) &lt;&lt; endl;</span><br><span class="line">&#125;                               </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[misaki@localhost 第一章-C++入门]$ ./externC</span><br><span class="line">3</span><br></pre></td></tr></table></figure></p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>&emsp;&emsp;C++ 支持重载而C语言不支持重载的原因是什么呢？C++支持函数名修饰，而C语言不支持。其实<code>const</code>也可以进行重载，但是要看情况，<code>const</code>只能支持指针和引用的重载。因为指针或引用指向不可更改的数据内容也是可以在编译过程中进行函数修饰的。</p>
<h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><p>&emsp;&emsp;引用是C++中一种新的类似于指针的语法，但是我们在使用指针指向另外一个变量的时候会创建一个新的指针变量，这个变量会存储指向的变量的地址，但是我们在使用引用的时候并不会分配新的内存空间。所谓引用<strong>不过是给某一个变量起了一个别名</strong>。</p>
<h3 id="使用-1"><a href="#使用-1" class="headerlink" title="使用"></a>使用</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">  int a = 10;</span><br><span class="line">  cout &lt;&lt; &quot;a = &quot; &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">  int&amp; b = a;//定义引用类型</span><br><span class="line">  cout &lt;&lt; &quot;a = &quot; &lt;&lt; b &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[misaki@localhost 第一章-C++入门]$ ./Ref</span><br><span class="line">a = 10</span><br><span class="line">a = 10</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;以上就是定义了一个引用<code>b</code>让它成为<code>a</code>的别名，之后我们就可以用<code>b</code>代替<code>a</code>。</p>
<h3 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h3><p>&emsp;&emsp;在使用引用的过程中有以下规则：<br><br>&emsp;&emsp;1、引用在定义的时候必须初始化，不像我们在定义指针的时候如果一开始不使用可以置空，但是引用相当于是别名因此不可以不进行初始化。<br><br>&emsp;&emsp;2、一个变量可以有多个引用，就像是一个人可以有多个别名一样。<br><br>&emsp;&emsp;3、一个引用一旦引用一个实体则不能再引用其他实体。一个引用一旦已经变成了某个实体的别名则它不可以再成为其他变量的别名了。<br></p>
<h3 id="常引用"><a href="#常引用" class="headerlink" title="常引用"></a>常引用</h3><p>&emsp;&emsp;常引用和常量指针一样是指向不可更改的数据的类型。被它所指向的数据不可进行更改。<br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">  const int&amp; c = 10;          </span><br><span class="line">  cout &lt;&lt; &quot;a = &quot; &lt;&lt; c &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[misaki@localhost 第一章-C++入门]$ ./Ref</span><br><span class="line">a = 10</span><br></pre></td></tr></table></figure></p>
<h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><h4 id="做参数"><a href="#做参数" class="headerlink" title="做参数"></a>做参数</h4><p>&emsp;&emsp;引用和指针一样在传参的使用上有独特的优势，他和指针一样可以将参数本身传入而不是传入副本，因此我们在函数内部可以进行函数参数值的更改。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">void Add(int a, int b, int&amp; result)</span><br><span class="line">&#123;</span><br><span class="line">  result = a + b;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">  int result;</span><br><span class="line">  Add(1, 2, result);</span><br><span class="line">  cout &lt;&lt; &quot;1 + 2 = &quot; &lt;&lt; result &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[misaki@localhost 第一章-C++入门]$ ./Ref</span><br><span class="line">1 + 2 = 3</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;这样我们就可以将传入参数的值在函数内进行更改，使用比指针更为简单。</p>
<h4 id="做返回值"><a href="#做返回值" class="headerlink" title="做返回值"></a>做返回值</h4><p>&emsp;&emsp;就像我们如果一个函数的返回值是指针一样，我们如果用引用作为函数的返回值我们就要保证引用的实体在函数声明周期后依然存在。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int&amp; Add(int a, int b)</span><br><span class="line">&#123;</span><br><span class="line">  int result = a + b;</span><br><span class="line">  return result;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">  int&amp; result = Add(1, 2);</span><br><span class="line">  Add(2, 3);                           </span><br><span class="line">  cout &lt;&lt; &quot;result = &quot;&lt;&lt; result &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[misaki@localhost 第一章-C++入门]$ ./Ref</span><br><span class="line">result = 5</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;以上这个<code>result</code>的值为什么变成了5呢？我们在用引用的时候实际上是给一块内存地址取了别名，我们让函数返回了在函数结束后已经释放的空间的别名。在函数结束后空间中的数据并不会立刻删除，会保留直到下次使用进行覆盖，而我们紧接着再次调用函数，由于栈帧相同使相同的内存空间的数据进行更改，因此我们用别名得到它的数据也会更改。那么如果我们在之后执行一个其他的函数呢？<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int&amp; Add(int a, int b)</span><br><span class="line">&#123;</span><br><span class="line">  int result = a + b;</span><br><span class="line">  return result;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">  int&amp; result = Add(1, 2);</span><br><span class="line">  Add(2, 3);</span><br><span class="line">  cout &lt;&lt; &quot;Ref&quot;&lt;&lt; endl;                </span><br><span class="line">  cout &lt;&lt; &quot;result = &quot;&lt;&lt; result &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[misaki@localhost 第一章-C++入门]$ ./Ref</span><br><span class="line">Ref</span><br><span class="line">result = 32635</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;可以看到数据已经变成了完全无关的数据，因此我们如果用引用作为返回值就一定要保证我们引用所指内存空间在函数结束后并不会释放。</p>
<h3 id="指针和引用"><a href="#指针和引用" class="headerlink" title="指针和引用"></a>指针和引用</h3><p>&emsp;&emsp;1. 引用在定义时必须初始化，指针没有要求。<br><br>&emsp;&emsp;2. 引用在初始化时引用一个实体后，就不能再引用其他实体，而指针可以在任何时候指向任何一个同类型实<br>体。<br><br>&emsp;&emsp;3. 没有NULL引用，但有NULL指针。<br><br>&emsp;&emsp;4. 在sizeof中含义不同：引用结果为引用类型的大小，但指针始终是地址空间所占字节个数(32位平台下占4<br>个字节)。<br><br>&emsp;&emsp;5. 引用自加即引用的实体增加1，指针自加即指针向后偏移一个类型的大小。<br><br>&emsp;&emsp;6. 有多级指针，但是没有多级引用。<br><br>&emsp;&emsp;7. 访问实体方式不同，指针需要显式解引用，引用编译器自己处理。<br><br>&emsp;&emsp;8. 引用比 指针使用起来 更为方便。<br></p>
<h2 id="inline内联函数"><a href="#inline内联函数" class="headerlink" title="inline内联函数"></a>inline内联函数</h2><p>&emsp;&emsp;在C语言中我们可以用宏来定义常量，定义函数，宏只是单纯的文本替换，因此使用时缺点很多，例如其<strong>不支持调试，可读性差，不容易控制</strong>，因此在C++中诞生了内联函数，依旧可以帮助我们达到和宏一样的功能减少函数调用生成栈帧的开销。</p>
<h3 id="使用-2"><a href="#使用-2" class="headerlink" title="使用"></a>使用</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">inline int Add(int num1, int num2)</span><br><span class="line">&#123;</span><br><span class="line">  return num1 + num2;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">  cout &lt;&lt; Add(1, 2) &lt;&lt; endl;      </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[misaki@localhost 第一章-C++入门]$ ./inline</span><br><span class="line">3</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;因此我们在C++中当我们需要写一些小型的函数时为了减少调用时形成栈帧的开销以减少时间就可以加上<code>inline</code>关键字</p>
<h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><p>&emsp;&emsp;1、内联函数不能声明和定义分离 他们必须在通过一个文件中，因为内联函数在调用处会被展开是不会有内存地址的，如果分离是无法进行链接的。<br><br>&emsp;&emsp;2、就算我们加上<code>inline</code>关键字到底是否会展开是由编译器决定的，我们仅仅是提个建议。<br><br>&emsp;&emsp;3、在<code>debug</code>模式中编译器不会进行代码优化因此默认不会将<code>inline</code>进行展开。</p>
<h2 id="C-11新增语法"><a href="#C-11新增语法" class="headerlink" title="C++11新增语法"></a>C++11新增语法</h2><h3 id="auto关键字"><a href="#auto关键字" class="headerlink" title="auto关键字"></a>auto关键字</h3><p>&emsp;&emsp;<code>auto</code>是C++11最新的关键字，可以自动检测类型，因此在某些类型名很长情况下可以起到简化代码的作用。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">  int a = 10;</span><br><span class="line">  auto b = a;</span><br><span class="line">  auto c = &apos;a&apos;;</span><br><span class="line">  cout &lt;&lt; b &lt;&lt; endl;</span><br><span class="line">  cout &lt;&lt; c &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[misaki@localhost 第一章-C++入门]$ ./C++11</span><br><span class="line">10</span><br><span class="line">a</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;但是使用<code>auto</code>要注意以下几点：<br><br>&emsp;&emsp;1、<code>auto</code>在生命变量时一定要初始化。<br><br>&emsp;&emsp;2、auto不能作为函数参数或者数组类型，因为无法计算其大小。<br><br>&emsp;&emsp;3、<code>auto*</code>与<code>auto</code>无异，但是在定义引用时要加上<code>&amp;</code>。</p>
<h3 id="范围for"><a href="#范围for" class="headerlink" title="范围for"></a>范围for</h3><p>&emsp;&emsp;这个语法十分类似JAVA中的范围for，也是为了简便代码而存在的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">  int arr[5] = &#123;1, 2, 3, 4, 5&#125;;</span><br><span class="line">  for(auto e : arr)</span><br><span class="line">  &#123;</span><br><span class="line">    cout &lt;&lt; e &lt;&lt; endl;         </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[misaki@localhost 第一章-C++入门]$ ./C++11</span><br><span class="line">1	</span><br><span class="line">2	</span><br><span class="line">3	</span><br><span class="line">4	</span><br><span class="line">5</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;范围for可以和auto共同使用，这样会更为方便，但是要注意<strong>范围for不能遍历传入函数中的数组，因为其实际上穿得是指针</strong>。<br><br>&emsp;&emsp;以上这两种语法我们称之为语法糖，就是可以简化代码的语法，但是这种语法会让代码可读性变差。<br></p>
<h3 id="nullptr"><a href="#nullptr" class="headerlink" title="nullptr"></a>nullptr</h3><p>&emsp;&emsp;在C++中有一个新的可以标记空指针的关键字，之前我们使用的<code>NULL</code>可以完全被他代替，并且我们之前使用的<code>NULL</code>为一个宏，值为0，未标记类型，因此我们在进行函数传参时，会将我们传入的空指针的值当作<code>int</code>处理，但是<code>nullptr</code>的值为0类型为<code>int*</code>，加入了值类型上的限定，因此在传参和重载中不会出现问题。</p>

          
        
      
    </div>
    
    
    

    

    <div>
    
    </div>

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/05/02/【Linux】第七章-进程信号/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="MisakiFx">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/blog-logo.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Misaki`s blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/05/02/【Linux】第七章-进程信号/" itemprop="url">【Linux】第七章-进程信号</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-05-02T15:40:40+08:00">
                2019-05-02
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Linux/" itemprop="url" rel="index">
                    <span itemprop="name">Linux</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  2.6k
                </span>
              

              

              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="第七章-进程信号"><a href="#第七章-进程信号" class="headerlink" title="第七章-进程信号"></a>第七章-进程信号</h1><h2 id="信号基本认识"><a href="#信号基本认识" class="headerlink" title="信号基本认识"></a>信号基本认识</h2><p>&emsp;&emsp;生活中处处充满信号，信号的存在就是是为了传递和表达信息，通知事件的发生。并且信号是有生命周期的，信号在产生后到处理完毕之前才是信号的有效期。<br><br>&emsp;&emsp;在对于系统来说，当软件中断，便会产生信号，通知发生了某件事情，为了说明不同的事件，所以系统中的信号有不同的种类。</p>
<h3 id="信号的种类"><a href="#信号的种类" class="headerlink" title="信号的种类"></a>信号的种类</h3><p>&emsp;&emsp;在Linux下我们可以使用<code>kill -l</code>产看信号的种类，会发现一共有62种不同的信号。其中1-31号信号每个都有各自对应的事件，它们继承于Unix，被称为<strong>非可靠信号/非实时信号</strong>；而34-64号信号是后续添加的信号，并无对应的事件，成为<strong>可靠信号/实时信号</strong>。所谓可靠信号与非可靠信号的区别在于非可靠信号是可能会丢失的，有可能产生多次信号才只会处理一次，而可靠信号产生多少次信号就必定会执行多少次。实时信号与非实时信号的区别在于实时信号在信号产生后便会立刻处理，而非实时信号则可能会延时处理。<br></p>
<h3 id="信号的生命周期"><a href="#信号的生命周期" class="headerlink" title="信号的生命周期"></a>信号的生命周期</h3><p>&emsp;&emsp;操作系统产生信号，注册在进程中，进程就收到了信号，但并不会立刻处理，在处理前会先注销信号，之后才会处理信号。<br><br>&emsp;&emsp;&emsp;&emsp;<code>产生-&gt;信号在进程中注册-&gt;信号在进程中注销-&gt;处理信号</code></p>
<h2 id="信号的产生"><a href="#信号的产生" class="headerlink" title="信号的产生"></a>信号的产生</h2><p>&emsp;&emsp;信号的产生分为两个途径：<strong>硬件产生</strong>，<strong>软件产生</strong>。</p>
<h3 id="硬件产生"><a href="#硬件产生" class="headerlink" title="硬件产生"></a>硬件产生</h3><p>&emsp;&emsp;我们在终止我们的进程时往往会使用快捷键<code>ctrl + c</code>，其实这个快捷键原理就是操作系统向进程发送了<code>SIGINT</code>信号造成进程结束，这就是硬件产生的信号。由硬件产生的信号还有很多例如<code>ctrl + |:终止信号</code>，<code>ctrl + z 停止信号</code>等等。</p>
<h3 id="软件产生"><a href="#软件产生" class="headerlink" title="软件产生"></a>软件产生</h3><p>&emsp;&emsp;我们在强杀进程时会使用<code>kill -9 pid</code>，这里<code>kill</code>就是一个软件，会向指定进程发送指定信号，在使用强杀时则是发送了9号信号，将进程强制杀死。<br><br>&emsp;&emsp;同时我们还可以在进程中向进程发送信号，C语言中将信号已经提前定义成了宏为了方便我们使用一些函数来发送信号。</p>
<h4 id="kill"><a href="#kill" class="headerlink" title="kill()"></a>kill()</h4><p>&emsp;&emsp;<code>int kill(pid_t pid, int sig);</code>函数来向指定进程发送指定信号。</p>
<h4 id="raise"><a href="#raise" class="headerlink" title="raise"></a>raise</h4><p>&emsp;&emsp;使用<code>int raise(int sig);</code>向调用进程发送指定信号。</p>
<h4 id="abort"><a href="#abort" class="headerlink" title="abort"></a>abort</h4><p>&emsp;&emsp;使用<code>abort()</code>向调用进程发送<code>SIGABRT</code>信号。</p>
<h4 id="alarm"><a href="#alarm" class="headerlink" title="alarm"></a>alarm</h4><p>&emsp;&emsp;使用<code>unsigned int alarm(unsigned int seconds);</code>在<code>seconds</code>秒后向调用进程发送信号。</p>
<h3 id="核心转储"><a href="#核心转储" class="headerlink" title="核心转储"></a>核心转储</h3><p>&emsp;&emsp;核心转储文件(core dump)是在事件发生后记录事件发生的过程和原因的文件，方便我们事后调试，由于核心转储文件占用空间，默认是关闭的。我们可以用<code>ulimit -a</code>查看core dump是否开启，使用<code>ulimit -c 大小</code>设置核心转储文件大小，开启核心转储。在发生段错误后我们即可使用<code>gdb core.pid</code>来查看核心转储文件的信息。<br><br>&emsp;&emsp;不过，我们直到在发生内存错误的时候Linux会报错说产生段错误并且退出进程，产生核心转储文件，但其实进程退出并非是由进程自己退出的，而是收到了操作系统发出的11号信号<code>SIGSEGV</code>，一旦进程收到这个信号便会终止并且报错说产生段错误随后生成核心转储文件，因此进程的退出和终止其实是由这个信号导致的。当发生内存错误时系统会自动调用<code>kill()</code>函数发送<code>SIGSEGV</code>信号到该进程，终止进程。</p>
<h2 id="信号的注册"><a href="#信号的注册" class="headerlink" title="信号的注册"></a>信号的注册</h2><p>&emsp;&emsp;给一个进程注册信号是在进程的pcb中进行了一个标记，这个标记由一个结构体<code>sigset_t</code>利用位图构成<strong>信号集</strong>进行标记，并且存入pcb中的<code>pending</code>信号集中，用来对应62种信号是否已经注册到进程中。同时还有另外一个<code>sigqueque</code>队列，用来按照注册顺序逐一处理信号。信号传入进程将<code>pending</code>上对应位置1表示此类信号存在，随后将信号存入<code>sigqueque</code>队列。但非可靠信号和可靠信号的注册还有区别。</p>
<h3 id="非可靠信号的注册"><a href="#非可靠信号的注册" class="headerlink" title="非可靠信号的注册"></a>非可靠信号的注册</h3><p>&emsp;&emsp;当信号传给进程时，进程会判断<code>pending</code>集合位图相应位是否为1；若为0则将其置1，并将其组织到<code>sigqueque</code>队列中；若为1则什么都不做（信号丢失）。</p>
<h3 id="可靠信号的注册"><a href="#可靠信号的注册" class="headerlink" title="可靠信号的注册"></a>可靠信号的注册</h3><p>&emsp;&emsp;信号传递给进程时，进程不管位图上是否为1，都会将位图置1，并且再添加到<code>sigqueque</code>队列中，如果有多次传入则拥有多个结点（信号不会丢失）。</p>
<h2 id="信号的注销"><a href="#信号的注销" class="headerlink" title="信号的注销"></a>信号的注销</h2><h3 id="非可靠信号的注销"><a href="#非可靠信号的注销" class="headerlink" title="非可靠信号的注销"></a>非可靠信号的注销</h3><p>&emsp;&emsp;因为非可靠信号的信号结点只有一个，因此删除结点，位图直接置0；</p>
<h3 id="可靠信号的注销"><a href="#可靠信号的注销" class="headerlink" title="可靠信号的注销"></a>可靠信号的注销</h3><p>&emsp;&emsp;因为可靠信号的信号结点可能有多个，若还有相同结点，则位图依然置1，否则置0。</p>
<h2 id="信号的处理"><a href="#信号的处理" class="headerlink" title="信号的处理"></a>信号的处理</h2><p>&emsp;&emsp;信号处理有三大方式：默认，忽略，自定义。</p>
<h3 id="信号捕捉初识"><a href="#信号捕捉初识" class="headerlink" title="信号捕捉初识"></a>信号捕捉初识</h3><h4 id="signal"><a href="#signal" class="headerlink" title="signal()"></a>signal()</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;                           </span><br><span class="line">#include &lt;unistd.h&gt;            </span><br><span class="line">#include &lt;stdlib.h&gt;  </span><br><span class="line">#include &lt;signal.h&gt;</span><br><span class="line">/**                            </span><br><span class="line"> *                      </span><br><span class="line"> * typedef void (*sighandler_t)(int);</span><br><span class="line"> * sighandler_t signal(int signum, sighandler_t handler);</span><br><span class="line"> * signum: 信号编号</span><br><span class="line"> * handler: 信号处理方式，函数指针</span><br><span class="line"> *          SIG_DFL    默认处理方式                                            </span><br><span class="line"> *          SIG_IGN    忽略处理方式                                      </span><br><span class="line"> * 修改信号的处理方式                                                 </span><br><span class="line"> */                        </span><br><span class="line">void sigcb(int signo)</span><br><span class="line">&#123;                             </span><br><span class="line">  printf(&quot;signal:%d\n&quot;, signo);      </span><br><span class="line">&#125;                                         </span><br><span class="line">int main()</span><br><span class="line">&#123;  </span><br><span class="line">  //signal(SIGINT, SIG_DFL);//执行默认的SIGINT功能</span><br><span class="line">  //signal(SIGINT, SIG_IGN);//忽略SIGINT信号的处理</span><br><span class="line">  signal(SIGINT, sigcb);//按自定义方式处理</span><br><span class="line">  while(1)</span><br><span class="line">  &#123;</span><br><span class="line">    printf(&quot;----------\n&quot;);</span><br><span class="line">    sleep(1);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[misaki@localhost 第七章-进程信号]$ ./signal</span><br><span class="line">----------</span><br><span class="line">----------</span><br><span class="line">^Csignal:2</span><br><span class="line">----------</span><br><span class="line">----------</span><br><span class="line">----------</span><br><span class="line">----------</span><br><span class="line">^Csignal:2</span><br><span class="line">----------</span><br><span class="line">^Csignal:2</span><br><span class="line">----------</span><br><span class="line">^Csignal:2</span><br><span class="line">----------</span><br><span class="line">^Csignal:2</span><br><span class="line">----------</span><br><span class="line">----------</span><br><span class="line">----------</span><br><span class="line">----------</span><br><span class="line">^\退出(吐核)</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;可以看到我们再向进程发送<code>SIGINT</code>信号时，执行的已经是我们自定义的功能了。<br><br>&emsp;&emsp;信号默认的处理方式和忽略处理方式都是在内核中定义好的，那么自定义处理方式又是怎么捕捉的呢？<br><br>&emsp;&emsp;当进程因为系统调用、中断或者异常进入内核态，当完成内核功能，准备返回用户态主控流程时检测是否有信号待处理，如果有调用<code>do_signal()</code>函数处理信号，如果信号处理方式是自定义的则返回用户态执行自定义处理函数，再通过<code>sigreturn()</code>返回内核态，再次检查是否有信号待处理，若无则调用<code>sys_sigreturn</code>返回用户态从主控流程上次被中断的地方继续执行。</p>
<h4 id="sigaction"><a href="#sigaction" class="headerlink" title="sigaction()"></a>sigaction()</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;                                                           </span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;signal.h&gt;</span><br><span class="line">struct sigaction act, oldact;</span><br><span class="line">void sigcb(int signo)</span><br><span class="line">&#123;</span><br><span class="line">  printf(&quot;signal:%d\n&quot;, signo);</span><br><span class="line">  //将原本的处理方式还原</span><br><span class="line">  sigaction(SIGINT, &amp;oldact, NULL);</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">  //int sigaction(int signum, struct sigaction* act, struct sigaction* oldact);</span><br><span class="line">  //使用act动作替换signum原有的处理动作，并且将原有处理动作拷贝到oldact中</span><br><span class="line">  //struct sigaction是预先定义好的结构体，用于存放信号修改的功能的数据</span><br><span class="line">  act.sa_handler = sigcb;  </span><br><span class="line">  act.sa_flags = 0;   </span><br><span class="line">  //清空信号集合</span><br><span class="line">  sigemptyset(&amp;act.sa_mask);</span><br><span class="line">  sigaction(SIGINT, &amp;act, &amp;oldact);</span><br><span class="line">  while(1)</span><br><span class="line">  &#123;</span><br><span class="line">    printf(&quot;----------\n&quot;);</span><br><span class="line">    sleep(1);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[misaki@localhost 第七章-进程信号]$ ./signal</span><br><span class="line">----------</span><br><span class="line">----------</span><br><span class="line">^Csignal:2</span><br><span class="line">----------</span><br><span class="line">----------</span><br><span class="line">^C</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;这段代码中我们先将<code>SIGINT</code>的处理方式替换为我们自定义的方式，调用一次自定义处理的同时又将其还原。</p>
<h2 id="信号的阻塞"><a href="#信号的阻塞" class="headerlink" title="信号的阻塞"></a>信号的阻塞</h2><p>&emsp;&emsp;暂时阻止信号被递达，信号依然可以注册，只是暂时不处理，解除阻塞之后才会处理。<br><br>&emsp;&emsp;信号的递达：动作-信号的处理。<br><br>&emsp;&emsp;信号的未决：状态-信号冲产生到处理之前的状态。<br><br>&emsp;&emsp;在进程的pcb中有一个<code>blocked</code>集合，当某一种信号被阻塞时，会将<code>blocked</code>集合中对应的位置1，表示这种信号被阻塞。因此信号的阻塞过程实际就是在pcb的<code>blocked</code>信号阻塞集合中标记信号，信号到来之后暂时不处理。<br><br>&emsp;&emsp;但是有两个信号无法被阻塞——<code>SIGKILL-9,SIGSTOP-19</code>无法被阻塞，无法被自定义，无法被忽略。<br></p>
<h2 id="竞态条件"><a href="#竞态条件" class="headerlink" title="竞态条件"></a>竞态条件</h2><p>&emsp;&emsp;因为运行时序而造成数据竞争——导致数据二义性。函数中所完成的操作并非原子性操作，并且操作的数据是一个全局数据。如果一个函数中操作了全局性数据，并且这个操作不是原子性操作，并且这个操作不受保护，则这个函数是一个不可重入函数。不可重入函数指不能在多个时序的运行中重复调用（重复调用有可能会造成数据二义性）。可重入函数指在多个是虚的运行中重复调用，不会造成异常影响。<code>malloc/free</code>就是不可重入函数。<br></p>
<h2 id="volatile关键字"><a href="#volatile关键字" class="headerlink" title="volatile关键字"></a>volatile关键字</h2><p>&emsp;&emsp;保持内存可见性——每次操作变量都需要重新从内存中获取。防止编译器过度优化。</p>
<h2 id="SIGCHLD"><a href="#SIGCHLD" class="headerlink" title="SIGCHLD"></a>SIGCHLD</h2><p>&emsp;&emsp;自定义信号处理方式<code>sigcb</code>，当子进程退出，操作系统发送信号给父进程，直接触发信号回调<code>sigcb</code>，用户主要在<code>sigcb</code>中调用<code>wait/waitpid</code>就可以处理子进程的退出。<br><br>&emsp;&emsp;<code>SIGCHLD</code>是一个非可靠信号，假如有多个子进程同时退出了，则有可能造成时间丢失，造成<code>sigcb</code>只被回调一次，只处理了一个子进程。<br><br>&emsp;&emsp;必须使用非阻塞，否则没有子进程退出的时候waitpid将阻塞导致程序无法回到主控流程。</p>

          
        
      
    </div>
    
    
    

    

    <div>
    
    </div>

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/3/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/3/">3</a><span class="page-number current">4</span><a class="page-number" href="/page/5/">5</a><span class="space">&hellip;</span><a class="page-number" href="/page/8/">8</a><a class="extend next" rel="next" href="/page/5/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/blog-logo.jpg"
                alt="MisakiFx" />
            
              <p class="site-author-name" itemprop="name">MisakiFx</p>
              <p class="site-description motion-element" itemprop="description">Hard working or giving up!!!</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">80</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">9</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">57</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/MisakiFx" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="mailto:1761607418@qq.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope-open"></i>E-Mail</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://music.163.com/#/user/home?id=432551242" target="_blank" title="网易云音乐">
                      
                        <i class="fa fa-fw fa-music"></i>网易云音乐</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://blog.csdn.net/qq_41669298" target="_blank" title="CSDN">
                      
                        <i class="fa fa-fw fa-crosshairs"></i>CSDN</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        ﻿<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js">
</script>
<div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">MisakiFx</span>

  
</div>


<div class="powered-by">
  <i class="fa fa-user-md"></i>
  <span id="busuanzi_container_site_uv">
    我的网站的访客数:<span id="busuanzi_value_site_uv"></span>
  </span>
</div>



<span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.4</div>




<div class="theme-info">
  <div class="powered-by"></div>
  <span class="post-count">博客全站共243k字</span>
</div>

        ﻿







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  


  











  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  

  
  
    <script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

  <!-- 页面点击小红心 -->
        <script type="text/javascript" src="/js/src/love.js"></script>
<script src="/live2dw/lib/L2Dwidget.min.js?0c58a1486de42ac6cc1c59c7d98ae887"></script><script>L2Dwidget.init({"pluginModelPath":"assets/","model":{"jsonPath":"/live2dw/assets/z16.model.json"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":false},"log":false,"pluginJsPath":"lib/","pluginRootPath":"live2dw/","tagMode":false});</script></body>
</html>
