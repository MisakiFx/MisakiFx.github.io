<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.ico?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon_16.ico?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="网络," />










<meta name="description" content="套接字编程&amp;emsp;&amp;emsp;套接字编程也叫Socket编程。这个章节将总结和归纳Linux操作系统下如何利用系统接口进行网络编程。 网络字节序&amp;emsp;&amp;emsp;之前有讲过字节序这个概念，不同的主机往往有着不同的数据存储协议，分为大端以及小端两种，但既然是网络通信，不同主机之间就必须要统一规定一个字节序来规定数据传输方式，这个就被称为网络字节序。好在系统中有一些系统接口ntohs和hto">
<meta name="keywords" content="网络">
<meta property="og:type" content="article">
<meta property="og:title" content="【网络】第二章-套接字编程">
<meta property="og:url" content="http://yoursite.com/2019/09/16/【网络】第二章-套接字编程/index.html">
<meta property="og:site_name" content="Misaki`s blog">
<meta property="og:description" content="套接字编程&amp;emsp;&amp;emsp;套接字编程也叫Socket编程。这个章节将总结和归纳Linux操作系统下如何利用系统接口进行网络编程。 网络字节序&amp;emsp;&amp;emsp;之前有讲过字节序这个概念，不同的主机往往有着不同的数据存储协议，分为大端以及小端两种，但既然是网络通信，不同主机之间就必须要统一规定一个字节序来规定数据传输方式，这个就被称为网络字节序。好在系统中有一些系统接口ntohs和hto">
<meta property="og:locale" content="zh-Hans">
<meta property="og:updated_time" content="2019-09-16T07:07:13.655Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="【网络】第二章-套接字编程">
<meta name="twitter:description" content="套接字编程&amp;emsp;&amp;emsp;套接字编程也叫Socket编程。这个章节将总结和归纳Linux操作系统下如何利用系统接口进行网络编程。 网络字节序&amp;emsp;&amp;emsp;之前有讲过字节序这个概念，不同的主机往往有着不同的数据存储协议，分为大端以及小端两种，但既然是网络通信，不同主机之间就必须要统一规定一个字节序来规定数据传输方式，这个就被称为网络字节序。好在系统中有一些系统接口ntohs和hto">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2019/09/16/【网络】第二章-套接字编程/"/>





  <title>【网络】第二章-套接字编程 | Misaki`s blog</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

<a href="https://github.com/MisakiFx" class="github-corner" aria-label="View source on GitHub"><svg width="80" height="80" viewBox="0 0 250 250" style="fill:#64CEAA; color:#fff; position: absolute; top: 0; border: 0; left: 0; transform: scale(-1, 1);" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Misaki`s blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">学习是一种态度</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/09/16/【网络】第二章-套接字编程/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="MisakiFx">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/blog-logo.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Misaki`s blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">【网络】第二章-套接字编程</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-09-16T14:56:31+08:00">
                2019-09-16
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/网络/" itemprop="url" rel="index">
                    <span itemprop="name">网络</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  6.3k
                </span>
              

              

              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="套接字编程"><a href="#套接字编程" class="headerlink" title="套接字编程"></a>套接字编程</h1><p>&emsp;&emsp;套接字编程也叫<code>Socket</code>编程。这个章节将总结和归纳Linux操作系统下如何利用系统接口进行网络编程。</p>
<h2 id="网络字节序"><a href="#网络字节序" class="headerlink" title="网络字节序"></a>网络字节序</h2><p>&emsp;&emsp;之前有讲过字节序这个概念，不同的主机往往有着不同的数据存储协议，分为大端以及小端两种，但既然是网络通信，不同主机之间就必须要统一规定一个字节序来规定数据传输方式，这个就被称为<strong>网络字节序</strong>。好在系统中有一些系统接口<code>ntohs</code>和<code>htons</code>来帮助我们完成网络字节序和本机字节序之间的相互转换。</p>
<h2 id="传输层协议"><a href="#传输层协议" class="headerlink" title="传输层协议"></a>传输层协议</h2><p>&emsp;&emsp;网络通信是两端通信，客户端与服务端。主动发起请求的是客户端，被动接受请求的一段是服务端。永远是客户端先向服务端发送数据。通信中数据需要经过层层封装，每一层都有典型协议，但是传输层有两个协议，TCP/UDP协议。</p>
<h3 id="协议特点"><a href="#协议特点" class="headerlink" title="协议特点"></a>协议特点</h3><p>&emsp;&emsp;TCP协议特点：传输控制协议，<strong>面向连接，可靠传输，提供字节流传输服务</strong>。<br>&emsp;&emsp;UFP协议特点：用户数据报协议，<strong>无连接，不可靠，面向数据报</strong>。<br>&emsp;&emsp;TCP为了保证可靠传输牺牲了性能，因此适用于文件/压缩包/程序的传输；UDP速度快但是不够安全可靠，因此多应用于视频在线观看的传输。</p>
<h2 id="UDP网络通信编程"><a href="#UDP网络通信编程" class="headerlink" title="UDP网络通信编程"></a>UDP网络通信编程</h2><h3 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h3><p>&emsp;&emsp;1、创建套接字，是进程与网卡直接建立关联。在内核中会创建一个<code>socket</code>结构体。在这个结构体中会包含很多与网络通信有关的信息。<br>&emsp;&emsp;2、为套接字绑定地址信息(ip/port)。为了告诉操作系统哪些数据应该由这个进程处理。在操作系统内核中每一个套接字都会有一块缓冲区，上面存放着这个套接字绑定的地址信息所属的进程应该接收的数据。网络通信过程中操作系统会把本机上所有进程需要接收数据统一放进套接字缓冲区后再发送给绑定的进程，同样的发送数据也是一样的原理，因此才需要跟操作系统内核中的套接字绑定地址信息来认领属于自己的那一块缓冲区。<br>&emsp;&emsp;3、客户端首先向服务端发送数据。服务端指定对端的地址，这时候<code>socket</code>就会将数据从绑定的地址发送出去。通常服务端必须固定一个地址信息，不能随意改变，保证客户端能够连上固定的服务器。但是客户端的地址可以随意，因为数据先由客户端发送，发送给服务端，服务端就能获知客户端的地址。<br>&emsp;&emsp;4、服务端接收数据。客户端发送的数据道道服务端主机后，服务端操作系统根据这个数据的地址信息决定将这个数据放到哪一个套接字的缓冲区中。服务端通过创建套接字返回的描述符，在内核中找到套接字结构体，进而从缓冲区中取出数据。<br>&emsp;&emsp;5、关闭套接字，释放内核中套接字占用的资源。</p>
<h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">//创建套接字</span><br><span class="line">int socket(int domain, int type, int protocol);</span><br><span class="line">    //domain:地址域，一般用AF_INET表示IPV4</span><br><span class="line">    //type:SOCK_STREAM-流式套接字，tcp可用；SOCK_DGRAM-数据报套接字，udp可用</span><br><span class="line">    //protocol:0-套接字类型默认协议；IPPROTO_TCP -6；IPPROTO_TCP -17</span><br><span class="line">    //返回值：套接字文件描述符，操作句柄</span><br><span class="line">//绑定地址信息</span><br><span class="line">int bind(int sockfd, const struct sockaddr* addr, socklen_t addrlen);</span><br><span class="line">    //这其中sockaddr是一个结构体，其中存放着地址信息，但是在操作系统中有很多不同的地址信息结构体，ipv4和ipv6都不同，但是为了方便使用只有这一个接口，</span><br><span class="line">    //于是为了方便使用单独设计了一个地址信息结构体就是这个sockaddr，如果使用其他地址信息结构体可以用类型强转转过来再传入</span><br><span class="line">    //addrlen就是这个结构体的大小，常用的结构体由sockaddr_in供ipv4使用</span><br><span class="line">    //返回值:成功返回0，失败返回-1</span><br><span class="line">//发送数据</span><br><span class="line">ssize_t sendto(int sockfd, const void *buf, size_t len, int flags, const struct sockaddr *dest_addr, socklen_t addrlen);</span><br><span class="line">    //sockfd:套接字描述符</span><br><span class="line">    //buf:发送数据缓冲区指针</span><br><span class="line">    //len:发送数据长度</span><br><span class="line">    //flags:标志位，默认为0，缓冲区无数据则阻塞</span><br><span class="line">    //dest_addr:目的地址信息</span><br><span class="line">    //addrlen:目的地址信息结构体大小</span><br><span class="line">    //返回值:实际发送的数据长度,出错返回-1</span><br><span class="line">//接收数据</span><br><span class="line">ssize_t recvfrom(int sockfd, void *buf, size_t len, int flags,struct sockaddr *src_addr, socklen_t *addrlen);</span><br><span class="line">    //sockfd:套接字文件描述符</span><br><span class="line">    //buf:接受数据的缓冲区指针</span><br><span class="line">    //len:接受数据长度</span><br><span class="line">    //flags:标志位，默认为0，缓冲区无数据则阻塞</span><br><span class="line">    //src_addr:对端地址信息结构体</span><br><span class="line">    //addrlen:输入输出型参数，要接收的对端地址信息结构体的大小，如果超过对端结构体大小会自动改为实际接收的大小</span><br><span class="line">    //返回值:实际接收的数据长度，出错返回-1。</span><br><span class="line">//关闭套接字</span><br><span class="line">int close(int fd);</span><br><span class="line">    //fd:套接字描述符</span><br></pre></td></tr></table></figure>
<h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>&emsp;&emsp;这里首先完全使用C来完成服务端的功能，虽然没有经过封装流程过于复杂但是可以帮助我们更好的理解udp通讯的流程。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">/**                                                           </span><br><span class="line"> * 传输层基于UDP协议的服务端程序</span><br><span class="line"> * 1、创建套接字</span><br><span class="line"> * 2、为套接字绑定地址信息</span><br><span class="line"> * 3、接收数据</span><br><span class="line"> * 4、发送数据</span><br><span class="line"> * 5、关闭套接字</span><br><span class="line"> **/</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;arpa/inet.h&gt;</span><br><span class="line">#include &lt;netinet/in.h&gt;</span><br><span class="line">#include &lt;sys/socket.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">int main(int argc, char* argv[])</span><br><span class="line">&#123;</span><br><span class="line">  if(argc != 3)</span><br><span class="line">  &#123;</span><br><span class="line">    printf(&quot;Usage: ./main 192.168.122.132 9000\n&quot;);</span><br><span class="line">    return -1;</span><br><span class="line">  &#125;</span><br><span class="line">  int sockfd = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP);</span><br><span class="line">  if(sockfd &lt; 0)</span><br><span class="line">  &#123;</span><br><span class="line">    perror(&quot;socket error\n&quot;);</span><br><span class="line">    return -1;</span><br><span class="line">  &#125;</span><br><span class="line">  struct sockaddr_in addr;</span><br><span class="line">  addr.sin_family = AF_INET;</span><br><span class="line">  addr.sin_port = htons(atoi(argv[2]));</span><br><span class="line">  //inet_addr将点分十进制ip地址转换为网络字节序ip地址</span><br><span class="line">  addr.sin_addr.s_addr = inet_addr(argv[1]);</span><br><span class="line">  socklen_t len = sizeof(struct sockaddr_in);</span><br><span class="line">  int ret = bind(sockfd, (struct sockaddr*)&amp;addr, len);</span><br><span class="line">  if(ret &lt; 0)</span><br><span class="line">  &#123;</span><br><span class="line">    perror(&quot;bind error&quot;);</span><br><span class="line">    return -1;</span><br><span class="line">  &#125;</span><br><span class="line">  while(1)</span><br><span class="line">  &#123;</span><br><span class="line">    char buf[1024] = &#123;0&#125;;</span><br><span class="line">    struct sockaddr_in cliaddr;</span><br><span class="line">    socklen_t len = sizeof(struct sockaddr_in);</span><br><span class="line">    int ret = recvfrom(sockfd, buf, 1023, 0, (struct sockaddr*)&amp;cliaddr, &amp;len);</span><br><span class="line">    if(ret &lt; 0)</span><br><span class="line">    &#123;</span><br><span class="line">      perror(&quot;recvfrom error&quot;);</span><br><span class="line">      close(sockfd);</span><br><span class="line">      return -1;</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;client say: %s\n&quot;, buf);</span><br><span class="line">    memset(buf, 0, 1024);</span><br><span class="line">    scanf(&quot;%s&quot;, buf);</span><br><span class="line">    len = sizeof(struct sockaddr_in);</span><br><span class="line">    ret = sendto(sockfd, buf, strlen(buf), 0, (struct sockaddr*)&amp;cliaddr, len);</span><br><span class="line">    if(ret &lt; 0)</span><br><span class="line">    &#123;</span><br><span class="line">      perror(&quot;sendto error&quot;);</span><br><span class="line">      close(sockfd);</span><br><span class="line">      return -1;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  close(sockfd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;接下来使用Cpp对udp通讯再进行一次封装，这样可以方便我们之后的使用，使用也会更有模块化，之后用其实现客户端，这里可以选择把客户端地址信息写死，或者不绑定系统自己分配都可以。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><span class="line">/**                                                                </span><br><span class="line"> * 封装实现一个udpsocjet类，向外提供更加容易使用的udp接口</span><br><span class="line"> **/ </span><br><span class="line">#include &lt;iostream&gt;   </span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">#include &lt;netinet/in.h&gt;</span><br><span class="line">#include &lt;arpa/inet.h&gt;</span><br><span class="line">#include &lt;sys/socket.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#define CHECK_RET(q) if((q) == false)&#123;return -1;&#125;</span><br><span class="line">using std::string;</span><br><span class="line">class UdpSocket</span><br><span class="line">&#123;                               </span><br><span class="line">  public:</span><br><span class="line">    UdpSocket()</span><br><span class="line">      :_sockfd(-1)</span><br><span class="line">    &#123;                                                         </span><br><span class="line">              </span><br><span class="line">    &#125;</span><br><span class="line">    ~UdpSocket() </span><br><span class="line">    &#123;                      </span><br><span class="line">        Close();</span><br><span class="line">    &#125;     </span><br><span class="line">    //创建套接字</span><br><span class="line">    bool Socket()</span><br><span class="line">    &#123;               </span><br><span class="line">      _sockfd = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP);</span><br><span class="line">      if(_sockfd &lt; 0)</span><br><span class="line">      &#123;       </span><br><span class="line">        std::cerr &lt;&lt; &quot;socket error&quot; &lt;&lt; std::endl;</span><br><span class="line">        return false;                   </span><br><span class="line">      &#125;                                             </span><br><span class="line">      return true;</span><br><span class="line">    &#125;</span><br><span class="line">    //绑定本机ip地址及端口信息</span><br><span class="line">    bool Bind(const string&amp; ip, uint16_t port)</span><br><span class="line">    &#123;</span><br><span class="line">      struct sockaddr_in addr;</span><br><span class="line">      addr.sin_family = AF_INET;</span><br><span class="line">      addr.sin_port = htons(port);</span><br><span class="line">      addr.sin_addr.s_addr = inet_addr(ip.c_str());                                          </span><br><span class="line">      socklen_t len = sizeof(struct sockaddr_in);</span><br><span class="line">      int ret = bind(_sockfd, (struct sockaddr*)&amp;addr, len);</span><br><span class="line">      if(ret &lt; 0)</span><br><span class="line">      &#123;</span><br><span class="line">        std::cerr &lt;&lt; &quot;bind error&quot; &lt;&lt; std::endl;</span><br><span class="line">        return false;</span><br><span class="line">      &#125;</span><br><span class="line">      return true;</span><br><span class="line">    &#125;</span><br><span class="line">    //接收数据并接收对端的ip地址及端口信息</span><br><span class="line">    bool Recv(string&amp; buf, string&amp; ip, uint16_t&amp; port)</span><br><span class="line">    &#123;</span><br><span class="line">      char tmp[4096];</span><br><span class="line">      struct sockaddr_in peeraddr;</span><br><span class="line">      socklen_t len = sizeof(peeraddr);</span><br><span class="line">      int ret = recvfrom(_sockfd, tmp, 4096, 0, (struct sockaddr*)&amp;peeraddr, &amp;len);</span><br><span class="line">      if(ret &lt; 0)</span><br><span class="line">      &#123;</span><br><span class="line">        std::cerr &lt;&lt; &quot;recvfrom error&quot; &lt;&lt; std::endl;</span><br><span class="line">        return false;</span><br><span class="line">      &#125;</span><br><span class="line">      buf.assign(tmp, ret);</span><br><span class="line">      port = ntohs(peeraddr.sin_port);</span><br><span class="line">      ip = inet_ntoa(peeraddr.sin_addr);</span><br><span class="line">      return true;</span><br><span class="line">    &#125;</span><br><span class="line">    //发送数据</span><br><span class="line">    bool Send(const string&amp; data, const string&amp; ip, const uint16_t&amp; port)</span><br><span class="line">    &#123;</span><br><span class="line">      struct sockaddr_in addr;</span><br><span class="line">      addr.sin_family = AF_INET;</span><br><span class="line">      addr.sin_port = htons(port);</span><br><span class="line">      addr.sin_addr.s_addr = inet_addr(ip.c_str());</span><br><span class="line">      socklen_t len = sizeof(struct sockaddr_in);</span><br><span class="line">      int ret = sendto(_sockfd, &amp;data[0], data.size(), 0, (struct sockaddr*)&amp;addr, len);</span><br><span class="line">      if(ret &lt; 0)</span><br><span class="line">      &#123;</span><br><span class="line">        std::cerr &lt;&lt; &quot;send error&quot; &lt;&lt; std::endl;</span><br><span class="line">        return false;</span><br><span class="line">      &#125;</span><br><span class="line">      return true;</span><br><span class="line">    &#125;</span><br><span class="line">    bool Close()</span><br><span class="line">    &#123;</span><br><span class="line">      if(_sockfd &gt;= 0)</span><br><span class="line">      &#123;</span><br><span class="line">        close(_sockfd);                                                                  </span><br><span class="line">        _sockfd = -1;</span><br><span class="line">      &#125;</span><br><span class="line">      return true;</span><br><span class="line">    &#125;</span><br><span class="line">  private:</span><br><span class="line">    int _sockfd;</span><br><span class="line">&#125;;</span><br><span class="line">int main(int argc, char* argv[])</span><br><span class="line">&#123;</span><br><span class="line">  if(argc != 3)</span><br><span class="line">  &#123;</span><br><span class="line">    std::cerr &lt;&lt; &quot;./udp_cli serverip serverport&quot; &lt;&lt; std::endl;</span><br><span class="line">    return -1;</span><br><span class="line">  &#125;</span><br><span class="line">  UdpSocket sock;</span><br><span class="line">  CHECK_RET(sock.Socket());</span><br><span class="line">  //CHECK_RET(sock.Bind(&quot;192.168.11.128&quot;, 8000));</span><br><span class="line">  while(1)</span><br><span class="line">  &#123;</span><br><span class="line">    string buf;</span><br><span class="line">    std::cin &gt;&gt; buf;</span><br><span class="line">    CHECK_RET(sock.Send(buf, argv[1], atoi(argv[2])));</span><br><span class="line">    buf.clear();</span><br><span class="line">    string ip;</span><br><span class="line">    uint16_t port;</span><br><span class="line">    CHECK_RET(sock.Recv(buf, ip, port));</span><br><span class="line">    std::cout &lt;&lt; &quot;server say: &quot; &lt;&lt; buf &lt;&lt; std::endl;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;然后我们把他们都跑起来完成通讯。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">(客户端发送数据)</span><br><span class="line">[misaki@localhost Net]$ ./client 192.168.11.128 9000</span><br><span class="line">nihao</span><br><span class="line">(服务端接收数据)</span><br><span class="line">[misaki@localhost Net]$ ./server 192.168.11.128 9000</span><br><span class="line">client say: nihao</span><br><span class="line">(服务端回复)</span><br><span class="line">[misaki@localhost Net]$ ./server 192.168.11.128 9000</span><br><span class="line">client say: nihao</span><br><span class="line">nihao     </span><br><span class="line">(客户端收到回复)</span><br><span class="line">[misaki@localhost Net]$ ./client 192.168.11.128 9000</span><br><span class="line">nihao</span><br><span class="line">server say: nihao</span><br></pre></td></tr></table></figure></p>
<h2 id="TCP网络通信编程"><a href="#TCP网络通信编程" class="headerlink" title="TCP网络通信编程"></a>TCP网络通信编程</h2><h3 id="流程-1"><a href="#流程-1" class="headerlink" title="流程"></a>流程</h3><p>&emsp;&emsp;TCP建立连接比UDP更为复杂一些，因为为了保证安全必须点对点一对一进行建立连接，于是TCP建立连接就产生了所谓的<strong>三次握手建立连接</strong>。<br>&emsp;&emsp;关于三次握手建立连接的解读这里给上一篇文章，这篇文章解读清晰易懂，有理有据，提供参考。<br><a href="https://baijiahao.baidu.com/s?id=1614404084382122793&amp;wfr=spider&amp;for=pc" target="_blank" rel="noopener">https://baijiahao.baidu.com/s?id=1614404084382122793&amp;wfr=spider&amp;for=pc</a><br><br>&emsp;&emsp;大概来说只有三次握手才能避免丢包延迟等情况造成的连接无效，才能完全确认连接已经建立。为了安全建立连接这是udp所没有的。<br>&emsp;&emsp;站在应用层面，我们服务端为了接收客户端的连接请求，需要有以下步骤：<br>&emsp;&emsp;1、建立套接字。<br>&emsp;&emsp;2、绑定地址信息。<br>&emsp;&emsp;3、服务端开始监听。<br>&emsp;&emsp;4、关闭每一个连接套接字，以及皮条套接字。<br>&emsp;&emsp;但是这里要注意tcp的套接字与udp不同一个套接字只能与一台客户端建立连接，而不是一个套接字即可接收所有发往本机的所有数据。一但一个套接字与一个主机已经建立连接，它的状态就会改变为已建立连接状态将无法再监听其他客户端的连接请求。那么此时其他客户端想要通讯我们的套接字还在与上一个主机通信呢其他客户端就都会无法连接到服务端，这该如何处理呢？<br>&emsp;&emsp;这里tcp在处理时利用了一种特殊的机制，这种机制十分类似于<strong>拉皮条</strong>。没错就是拉皮条，我们最开始建立的套接字只是一个监听套接字，这个套接字就是拉皮条的，我们称之为皮条套接字，开始监听后，只要有客户端想要与这个服务端建立连接，我们的皮条套接字就会自己创建一个新的套接字与客户端进行绑定，并将新产生的套接字返回给我们，我们就可以利用这个新的套接字与指定的客户端进行通信。意思是说我们的皮条套接字并不实质与服务端通信，它只负责创建新的套接字为客户端提供一对一服务。<br>&emsp;&emsp;当我们的服务端开始监听后，我们皮条套接字就开始工作了，表示客户端此时可以进来进行通信了，并且还是一对一服务哦，但是建立连接也是需要时间的，三次握手嘛，并且一对一通信也需要时间，如果此时客户端不断向服务端发送连接请求，每一个请求都会创建新的套接字，这会消耗大量资源，在高峰期可能资源就会耗尽。为了防止这样的情况发生，tcp在监听时会创建一个队列，我们称之为<strong>未完成连接队列</strong>，我们的皮条套接字会为这个队列依次创建套接字进行连接，如果这个队列满了，客户端此时就不能再连接服务端了，皮条套接字也不用再创建新的套接字了，着手完成眼下的套接字连接以及通信，以此来控制资源。至于这个队列有多大，我们可以在监听时来指定这个队列的大小。<br>&emsp;&emsp;4、获取新创建的套接字描述符进行通信。在创建连接后，我们得从皮条套接字那里获取新的建立连接的套接字才能进行通信。<br>&emsp;&emsp;对于客户端来说，为了和服务端建立连接，也要有以下这些步骤：<br>&emsp;&emsp;1、创建套接字。<br>&emsp;&emsp;2、绑定地址信息。<br>&emsp;&emsp;3、向服务端发起三次握手建立连接，这里需要给入服务端的地址信息。<br>&emsp;&emsp;4、接收发送数据。这里的接收和发送数据不需要再想udp呢样每次都必须给如详细的对端地址信息了，这里已经有套接字建立了稳定连接，只需要传入指定的套接字描述符即可。<br>&emsp;&emsp;5、关闭套接字。<br>&emsp;&emsp;从流程可以看出，udp和tcp在建立套接字和绑定地址信息上没有太大区别，区别主要在tcp在进行数据传输前要先建立一次连接，连接建立完成后使用套接字描述符即可进行数据传输。</p>
<h3 id="接口-1"><a href="#接口-1" class="headerlink" title="接口"></a>接口</h3><p>&emsp;&emsp;创建套接字与绑定地址信息的接口以及关闭套接字都与udp一致。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">//服务端监听</span><br><span class="line">int listen(int sockfd, int backlog);</span><br><span class="line">    //sockfd:皮条套接字</span><br><span class="line">    //backlog:未完成连接队列大小，并发连接数</span><br><span class="line">    //返回值:成功返回0，失败返回-1</span><br><span class="line">//客户端连接服务端</span><br><span class="line">int connect(int sockfd, sockaddr* srvaddr, socklen_t addrlen);</span><br><span class="line">    //sockfd:服务端套接字描述符</span><br><span class="line">    //srvaddr:服务端地址信息</span><br><span class="line">    //addrlen:服务端地址信息大小</span><br><span class="line">    //返回值:成功返回0，失败返回-1</span><br><span class="line">//服务端接收客户端连接</span><br><span class="line">int accept(int sockfd, sockaddr* srcaddr, socklen_t* len);</span><br><span class="line">    //sockfd:皮条套接字描述符</span><br><span class="line">    //srcaddr:客户端地址信息</span><br><span class="line">    //len:客户端地址信息长度</span><br><span class="line">    //返回值:返回皮条套接字新建立的套接字描述符，失败返回-1</span><br><span class="line">//接收数据</span><br><span class="line">int recv(int sockfd, void* buf, int len, int flags);</span><br><span class="line">    //sockfd:套接字描述符</span><br><span class="line">    //buf:接收缓冲区</span><br><span class="line">    //len:接收数据长度</span><br><span class="line">    //flags:默认0阻塞接收</span><br><span class="line">    //返回值:实际接收字节数，失败返回-1， 连接断开返回0</span><br><span class="line">//发送数据</span><br><span class="line">int send(int sockfd, void* buf, int len, int flags);</span><br><span class="line">    //sockfd:套接字描述符</span><br><span class="line">    //buf:发送缓冲区</span><br><span class="line">    //len:发送数据长度</span><br><span class="line">    //flags:默认0阻塞发送</span><br><span class="line">    //返回值:实际发送的字节数，失败返回-1</span><br></pre></td></tr></table></figure></p>
<h3 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br></pre></td><td class="code"><pre><span class="line">/**                                                                        </span><br><span class="line"> * 封装一个tcpsocket类，向外提供简单接口能够实现客户端服务端编程流程</span><br><span class="line"> * 1、创建套接字</span><br><span class="line"> * 2、绑定地址信息                   </span><br><span class="line"> * 3、开始监听/发起连接请求</span><br><span class="line"> * 4、获取已完成连接                                  </span><br><span class="line"> * 5、发送数据   </span><br><span class="line"> * 6、接收数据</span><br><span class="line"> * 7、关闭套接字                               </span><br><span class="line"> **/                 </span><br><span class="line">       </span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">#include &lt;netinet/in.h&gt;</span><br><span class="line">#include &lt;arpa/inet.h&gt;         </span><br><span class="line">#include &lt;sys/socket.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;        </span><br><span class="line">#define CHECK_RET(q) if(q == false) &#123;return -1;&#125;</span><br><span class="line">class TcpSocket  </span><br><span class="line">&#123;      </span><br><span class="line">  public:                                      </span><br><span class="line">    TcpSocket()      </span><br><span class="line">    &#123;  </span><br><span class="line">                       </span><br><span class="line">    &#125;  </span><br><span class="line">    ~TcpSocket()                                  </span><br><span class="line">    &#123;                </span><br><span class="line">      Close();</span><br><span class="line">    &#125;           </span><br><span class="line">    //创建套接字  </span><br><span class="line">    bool Socket()</span><br><span class="line">    &#123;     </span><br><span class="line">      //这里首先创建的时皮条套接字</span><br><span class="line">      _sockfd = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);</span><br><span class="line">      if(_sockfd &lt; 0) </span><br><span class="line">      &#123;</span><br><span class="line">        std::cerr &lt;&lt; &quot;socket error&quot; &lt;&lt; std::endl;</span><br><span class="line">        return false;</span><br><span class="line">      &#125;</span><br><span class="line">      return true;</span><br><span class="line">    &#125;</span><br><span class="line">    //绑定地址信息</span><br><span class="line">    bool Bind(const std::string&amp; ip, uint16_t port)</span><br><span class="line">    &#123;</span><br><span class="line">      struct sockaddr_in addr;</span><br><span class="line">      addr.sin_family = AF_INET;</span><br><span class="line">      addr.sin_port = htons(port);</span><br><span class="line">      addr.sin_addr.s_addr = inet_addr(&amp;ip[0]);</span><br><span class="line">      socklen_t len = sizeof(struct sockaddr_in);</span><br><span class="line">      int ret = bind(_sockfd, (struct sockaddr*)&amp;addr, len);</span><br><span class="line">      if(ret &lt; 0)</span><br><span class="line">      &#123;</span><br><span class="line">        std::cerr &lt;&lt; &quot;bind error&quot; &lt;&lt; std::endl;</span><br><span class="line">        return false;</span><br><span class="line">      &#125;</span><br><span class="line">      return true;</span><br><span class="line">    &#125;</span><br><span class="line">    //服务端开始监听</span><br><span class="line">    bool Listen(int backlog = 5)</span><br><span class="line">    &#123;</span><br><span class="line">      int ret = listen(_sockfd, backlog);</span><br><span class="line">      if(ret &lt; 0)</span><br><span class="line">      &#123;                                                                    </span><br><span class="line">        std::cerr &lt;&lt; &quot;listen error&quot; &lt;&lt; std::endl;</span><br><span class="line">        return false;</span><br><span class="line">      &#125;</span><br><span class="line">      return true;</span><br><span class="line">    &#125;</span><br><span class="line">     //连接服务端</span><br><span class="line">     bool Connect(const std::string&amp; ip, uint16_t port)</span><br><span class="line">     &#123;</span><br><span class="line">       int ret;</span><br><span class="line">       struct sockaddr_in addr;</span><br><span class="line">       addr.sin_family = AF_INET;</span><br><span class="line">       addr.sin_port = htons(port);</span><br><span class="line">       addr.sin_addr.s_addr = inet_addr(&amp;ip[0]);</span><br><span class="line">       socklen_t len = sizeof(struct sockaddr_in);</span><br><span class="line">       ret = connect(_sockfd, (struct sockaddr*)&amp;addr, len);</span><br><span class="line">       if(ret &lt; 0)</span><br><span class="line">       &#123;</span><br><span class="line">         std::cerr &lt;&lt; &quot;connet error&quot; &lt;&lt; std::endl;</span><br><span class="line">         return false;</span><br><span class="line">       &#125;</span><br><span class="line">       return true;</span><br><span class="line">     &#125;</span><br><span class="line">     //设置套接字</span><br><span class="line">     void SetFd(int fd)</span><br><span class="line">     &#123;</span><br><span class="line">       _sockfd = fd;</span><br><span class="line">     &#125;</span><br><span class="line">     //获取新的套接字</span><br><span class="line">     bool Accept(TcpSocket&amp; newsock)</span><br><span class="line">     &#123;</span><br><span class="line">       struct sockaddr_in addr;                                   </span><br><span class="line">       socklen_t len = sizeof(struct sockaddr_in);</span><br><span class="line">       //这里fd是皮条套接字新创建出来的连接套接字</span><br><span class="line">       int fd = accept(_sockfd, (struct sockaddr*)&amp;addr, &amp;len);</span><br><span class="line">       if(fd &lt; 0)</span><br><span class="line">       &#123;</span><br><span class="line">        std::cerr &lt;&lt; &quot;accept error&quot; &lt;&lt; std::endl;</span><br><span class="line">        return false;</span><br><span class="line">      &#125;</span><br><span class="line">      //newsock._sockfd = fd;</span><br><span class="line">      newsock.SetFd(fd);</span><br><span class="line">      return true;</span><br><span class="line">    &#125;</span><br><span class="line">    //发送数据</span><br><span class="line">    bool Send(const std::string&amp; buf)</span><br><span class="line">    &#123;</span><br><span class="line">      int ret = send(_sockfd, &amp;buf[0], buf.size(), 0);</span><br><span class="line">      if(ret &lt; 0)</span><br><span class="line">      &#123;</span><br><span class="line">        std::cerr &lt;&lt; &quot;send error&quot; &lt;&lt; std::endl;</span><br><span class="line">        return false;</span><br><span class="line">      &#125;</span><br><span class="line">      return true;</span><br><span class="line">    &#125;</span><br><span class="line">    //接收数据</span><br><span class="line">    bool Recv(std::string&amp; buf)</span><br><span class="line">    &#123;</span><br><span class="line">      char tmp[4096] = &#123;0&#125;;</span><br><span class="line">      int ret = recv(_sockfd, &amp;tmp[0], 4096, 0);</span><br><span class="line">      if(ret &lt; 0)</span><br><span class="line">      &#123;</span><br><span class="line">        std::cerr &lt;&lt; &quot;recv error&quot; &lt;&lt; std::endl;</span><br><span class="line">        return false;</span><br><span class="line">      &#125;</span><br><span class="line">      else if(ret == 0)</span><br><span class="line">      &#123;                                                                 </span><br><span class="line">        std::cerr &lt;&lt; &quot;peer shutdown&quot; &lt;&lt; std::endl;</span><br><span class="line">        return false;</span><br><span class="line">      &#125;</span><br><span class="line">      buf = tmp;</span><br><span class="line">      return true;</span><br><span class="line">    &#125;</span><br><span class="line">    //关闭</span><br><span class="line">    bool Close()</span><br><span class="line">    &#123;</span><br><span class="line">      if(_sockfd &gt;= 0)</span><br><span class="line">      &#123;</span><br><span class="line">        close(_sockfd);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  private:</span><br><span class="line">    int _sockfd;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;这里是对tcp的接口进行一次封装，接下来实现客户端与服务端。<br>&emsp;&emsp;客户端：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;tcp_socket.hpp&quot;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">/**</span><br><span class="line"> * 实现客户端</span><br><span class="line"> * 1、创建套接字</span><br><span class="line"> * 2、绑定地址信息（客户端不需要手动绑定）</span><br><span class="line"> * 3、向服务端发起连接请求</span><br><span class="line"> * 4、发送数据</span><br><span class="line"> * 5、接收数据</span><br><span class="line"> * 6、关闭套接字</span><br><span class="line"> **/</span><br><span class="line">int main(int argc, char* argv[])</span><br><span class="line">&#123;</span><br><span class="line">  if(argc != 3)</span><br><span class="line">  &#123;</span><br><span class="line">    std::cerr &lt;&lt; &quot;./tcp_cli srvip srvport&quot; &lt;&lt; std::endl;</span><br><span class="line">    return -1;</span><br><span class="line">  &#125;</span><br><span class="line">  TcpSocket sock;</span><br><span class="line">  CHECK_RET(sock.Socket());</span><br><span class="line">  std::string ip = argv[1];</span><br><span class="line">  uint16_t port = atoi(argv[2]);</span><br><span class="line">  CHECK_RET(sock.Connect(ip, port));</span><br><span class="line">  while(1)</span><br><span class="line">  &#123;</span><br><span class="line">    std::string buf;</span><br><span class="line">    std::cin &gt;&gt; buf;                                              </span><br><span class="line">    bool ret = sock.Send(buf);</span><br><span class="line">    if(ret == false)</span><br><span class="line">    &#123;</span><br><span class="line">      sock.Close();</span><br><span class="line">      return -1;</span><br><span class="line">    &#125;</span><br><span class="line">    buf.clear();</span><br><span class="line">    ret = sock.Recv(buf);</span><br><span class="line">    if(ret == false)</span><br><span class="line">    &#123;</span><br><span class="line">      sock.Close();</span><br><span class="line">      return -1;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; &quot;server say: &quot; &lt;&lt; buf &lt;&lt; std::endl;</span><br><span class="line">  &#125;</span><br><span class="line">  sock.Close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;服务端：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 服务端实现</span><br><span class="line"> * 1、创建套接字</span><br><span class="line"> * 2、绑定地址信息</span><br><span class="line"> * 3、开始监听</span><br><span class="line"> * 4、获取新连接</span><br><span class="line"> * 5、接收数据</span><br><span class="line"> * 6、发送数据</span><br><span class="line"> * 7、关闭套接字</span><br><span class="line"> **/</span><br><span class="line">#include &quot;tcp_socket.hpp&quot;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">int main(int argc, char* argv[])</span><br><span class="line">&#123;</span><br><span class="line">  if(argc != 3)</span><br><span class="line">  &#123;</span><br><span class="line">    std::cerr &lt;&lt; &quot;./tcp_srv 192.169.11.128 9000&quot; &lt;&lt; std::endl;</span><br><span class="line">    return -1;</span><br><span class="line">  &#125;</span><br><span class="line">  std::string ip = argv[1];</span><br><span class="line">  uint16_t port = atoi(argv[2]);</span><br><span class="line">  TcpSocket sock;</span><br><span class="line">  CHECK_RET(sock.Socket());</span><br><span class="line">  CHECK_RET(sock.Bind(ip, port));</span><br><span class="line">  CHECK_RET(sock.Listen());</span><br><span class="line">  //这个新的套接字要放在循环外部，否则一次循环结束变量销毁会关闭套接字连接就会断开   </span><br><span class="line">  TcpSocket newsock;</span><br><span class="line">  while(1)</span><br><span class="line">  &#123;</span><br><span class="line">    bool ret = sock.Accept(newsock);</span><br><span class="line">    if(ret == false)</span><br><span class="line">    &#123;</span><br><span class="line">      continue;</span><br><span class="line">    &#125;</span><br><span class="line">    std::string buf;</span><br><span class="line">    ret = newsock.Recv(buf);</span><br><span class="line">    if(ret == false)</span><br><span class="line">    &#123;</span><br><span class="line">      std::cerr &lt;&lt; &quot;recv error&quot; &lt;&lt; std::endl;</span><br><span class="line">      newsock.Close();</span><br><span class="line">      continue;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; &quot;client say: &quot; &lt;&lt; buf &lt;&lt; std::endl;</span><br><span class="line">    buf.clear();</span><br><span class="line">    std::cin &gt;&gt; buf;</span><br><span class="line">    newsock.Send(buf);</span><br><span class="line">  &#125;</span><br><span class="line">  sock.Close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;使用：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[misaki@localhost Net]$ ./tcpserver 192.168.11.128 9000</span><br><span class="line">client say: nihao</span><br><span class="line">wobuhao</span><br><span class="line"></span><br><span class="line">[misaki@localhost Net]$ ./tcpclient 192.168.11.128 9000</span><br><span class="line">nihao</span><br><span class="line">server say: wobuhao</span><br><span class="line">haha</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;但是在这里发现进行完一轮通信后，服务端无法再接收到客户端新的数据，这是因为此时监听套接字（我们还是叫的好听点）和通信套接字是在同一个进程中共同工作，此时监听套接字阻塞在了监听新的客户端，已经建立好的套接字就无法继续通信。为了解决这个问题我们必须使监听套接字和通信套接字共同同时工作，因此就牵扯到了并行的问题，这里有两种解决方案，利用多进程，或者多线程。<br>&emsp;&emsp;客户端代码是不用改变的，此时要改的只有服务端的代码。<br>&emsp;&emsp;1、多进程解决。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line">/**                                                                                   </span><br><span class="line"> * 服务端实现   </span><br><span class="line"> * 1、创建套接字  </span><br><span class="line"> * 2、绑定地址信息</span><br><span class="line"> * 3、开始监听  </span><br><span class="line"> * 4、获取新连接                                                      </span><br><span class="line"> * 5、接收数据                                                              </span><br><span class="line"> * 6、发送数据  </span><br><span class="line"> * 7、关闭套接字</span><br><span class="line"> **/                     </span><br><span class="line">#include &quot;tcp_socket.hpp&quot;       </span><br><span class="line">#include &lt;stdlib.h&gt;     </span><br><span class="line">#include &lt;sys/wait.h&gt;</span><br><span class="line">#include &lt;signal.h&gt;                              </span><br><span class="line">void sigcb(int signo)     </span><br><span class="line">&#123;                       </span><br><span class="line">  //等待任意一个进程退出       </span><br><span class="line">  //SIGCHLD信号是一个非可靠信号                                         </span><br><span class="line">  //多个进程同时退出有可能会造成事件丢失，导致有可能有僵尸进程没有被处理</span><br><span class="line">  //因此在一次事件回调中，将能够处理的僵尸进程全都处理掉</span><br><span class="line">  while(waitpid(-1, NULL, WNOHANG) &gt; 0);</span><br><span class="line">&#125;                               </span><br><span class="line">int main(int argc, char* argv[])</span><br><span class="line">&#123;              </span><br><span class="line">  if(argc != 3)</span><br><span class="line">  &#123;                                                           </span><br><span class="line">    std::cerr &lt;&lt; &quot;./tcp_srv 192.169.11.128 9000&quot; &lt;&lt; std::endl;</span><br><span class="line">    return -1;                                                                        </span><br><span class="line">  &#125;                  </span><br><span class="line">  //在这里进行信号改写</span><br><span class="line">  signal(SIGCHLD, sigcb);                                                             </span><br><span class="line">  std::string ip = argv[1];     </span><br><span class="line">  uint16_t port = atoi(argv[2]);                                                      </span><br><span class="line">  TcpSocket sock;          </span><br><span class="line">  CHECK_RET(sock.Socket());      </span><br><span class="line">  CHECK_RET(sock.Bind(ip, port));</span><br><span class="line">  CHECK_RET(sock.Listen());</span><br><span class="line">  //这个新的套接字要放在循环外部，否则一次循环结束变量销毁会关闭套接字连接就会断开</span><br><span class="line">  TcpSocket newsock;</span><br><span class="line">  //这里要并行执行，这里使用多进程</span><br><span class="line">  //让主进程继续获得新连接获取</span><br><span class="line">  //子进程负责与客户端通信</span><br><span class="line">  //并且这种处理方式更加稳定，子进程出现问题主进程并不会出现问题</span><br><span class="line">  while(1)</span><br><span class="line">  &#123;</span><br><span class="line">    bool ret = sock.Accept(newsock);</span><br><span class="line">    if(ret == false)</span><br><span class="line">    &#123;</span><br><span class="line">      continue;</span><br><span class="line">    &#125;</span><br><span class="line">    //子进程处理与客户端的数据通信</span><br><span class="line">    if(fork() == 0)</span><br><span class="line">    &#123;</span><br><span class="line">      //这里让子继承再创建一个子进程，本身直接退出，结束父进程的等待</span><br><span class="line">      /*</span><br><span class="line">      if(fork() &gt; 0)</span><br><span class="line">      &#123;</span><br><span class="line">        exit(0);</span><br><span class="line">      &#125;</span><br><span class="line">      */</span><br><span class="line">      //这里处理数据通信的实际上是子进程的子进程，但是子进程已经推出了                          </span><br><span class="line">      //这个孙子进程会变成孤儿进程，归init进程管理，并且退出不会变成僵尸进程</span><br><span class="line">      while(1)</span><br><span class="line">      &#123;</span><br><span class="line">        std::string buf;</span><br><span class="line">        ret = newsock.Recv(buf);</span><br><span class="line">        if(ret == false)</span><br><span class="line">        &#123;</span><br><span class="line">          std::cerr &lt;&lt; &quot;recv error&quot; &lt;&lt; std::endl;</span><br><span class="line">          newsock.Close();</span><br><span class="line">          exit(0);</span><br><span class="line">        &#125;</span><br><span class="line">        std::cout &lt;&lt; &quot;client say: &quot; &lt;&lt; buf &lt;&lt; std::endl;</span><br><span class="line">        buf.clear();</span><br><span class="line">        std::cin &gt;&gt; buf;</span><br><span class="line">        newsock.Send(buf);</span><br><span class="line">      &#125;</span><br><span class="line">      newsock.Close();</span><br><span class="line">      exit(0);</span><br><span class="line">    &#125;</span><br><span class="line">    //父进程直接关闭新连接的套接字</span><br><span class="line">    newsock.Close();</span><br><span class="line">    //父进程要等待子进程，防止变成僵尸进程，但是子进程如果一直不结束，父进程会造成阻塞</span><br><span class="line">    //因此这里有两种方式处理</span><br><span class="line">    //1、让子进程再创建孙子进程处理数据通信，子进程直接退出，孙子进程会变成孤儿进程不会变成僵尸进程</span><br><span class="line">    //wait(NULL);</span><br><span class="line">    //2、在子进程退出后会向父进程发送信号，信号会一直等着我们进行处理，因此我们可以通过改写这个信号来回收所有子进程</span><br><span class="line">  &#125;</span><br><span class="line">  sock.Close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;使用：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[misaki@localhost Net]$ ./tcpserver 192.168.11.128 9000</span><br><span class="line">client say: nihao</span><br><span class="line">wohenhao</span><br><span class="line">client say: haode</span><br><span class="line">heihei</span><br><span class="line"></span><br><span class="line">[misaki@localhost Net]$ ./tcpclient 192.168.11.128 9000</span><br><span class="line">nihao</span><br><span class="line">server say: wohenhao</span><br><span class="line">haode</span><br><span class="line">server say: heihei</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;这样就能进行多轮通信。<br>&emsp;&emsp;2、多线程解决。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 服务端实现</span><br><span class="line"> * 1、创建套接字</span><br><span class="line"> * 2、绑定地址信息</span><br><span class="line"> * 3、开始监听</span><br><span class="line"> * 4、获取新连接</span><br><span class="line"> * 5、接收数据</span><br><span class="line"> * 6、发送数据</span><br><span class="line"> * 7、关闭套接字</span><br><span class="line"> **/</span><br><span class="line">#include &quot;tcp_socket.hpp&quot;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;pthread.h&gt;</span><br><span class="line">//线程入口函数，创建线程进行数据通信                                           </span><br><span class="line">void* thr_start(void* arg)</span><br><span class="line">&#123;                                      </span><br><span class="line">  TcpSocket* newsock = (TcpSocket*)arg;</span><br><span class="line">  while(1)       </span><br><span class="line">  &#123;                 </span><br><span class="line">    std::string buf;              </span><br><span class="line">    bool ret = newsock-&gt;Recv(buf);</span><br><span class="line">    if(ret == false)</span><br><span class="line">    &#123;                                        </span><br><span class="line">      std::cerr &lt;&lt; &quot;recv error&quot; &lt;&lt; std::endl;</span><br><span class="line">      newsock-&gt;Close();</span><br><span class="line">      return NULL;</span><br><span class="line">    &#125;                                               </span><br><span class="line">    std::cout &lt;&lt; &quot;client say: &quot; &lt;&lt; buf &lt;&lt; std::endl;</span><br><span class="line">    buf.clear();    </span><br><span class="line">    std::cin &gt;&gt; buf;   </span><br><span class="line">    newsock-&gt;Send(buf);</span><br><span class="line">  &#125;                </span><br><span class="line">  newsock-&gt;Close();</span><br><span class="line">  delete newsock;</span><br><span class="line">  return NULL;</span><br><span class="line">&#125;</span><br><span class="line">int main(int argc, char* argv[])</span><br><span class="line">&#123;</span><br><span class="line">  if(argc != 3)</span><br><span class="line">  &#123;</span><br><span class="line">    std::cerr &lt;&lt; &quot;./tcp_srv 192.169.11.128 9000&quot; &lt;&lt; std::endl;</span><br><span class="line">    return -1;</span><br><span class="line">  &#125;</span><br><span class="line">  std::string ip = argv[1];</span><br><span class="line">  uint16_t port = atoi(argv[2]);</span><br><span class="line">  TcpSocket sock;</span><br><span class="line">  CHECK_RET(sock.Socket());</span><br><span class="line">  CHECK_RET(sock.Bind(ip, port));</span><br><span class="line">  CHECK_RET(sock.Listen());</span><br><span class="line">  while(1)</span><br><span class="line">  &#123;</span><br><span class="line">    //这个要分配内存在堆区才能达到数据共享</span><br><span class="line">    TcpSocket* newsock = new TcpSocket();</span><br><span class="line">    bool ret = sock.Accept(*newsock);</span><br><span class="line">    if(ret == false)</span><br><span class="line">    &#123;</span><br><span class="line">      //连接失败别忘了也要把空间销毁，以免内存泄露</span><br><span class="line">      delete newsock;</span><br><span class="line">      continue;</span><br><span class="line">    &#125;</span><br><span class="line">    pthread_t tid;</span><br><span class="line">    //创建线程</span><br><span class="line">    pthread_create(&amp;tid, NULL, thr_start, (void*)newsock);</span><br><span class="line">    pthread_detach(tid);</span><br><span class="line">  &#125;                                                            </span><br><span class="line">  sock.Close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;使用：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">[misaki@localhost Net]$ ./tcpserver 192.168.11.128 9000</span><br><span class="line">client say: nihao</span><br><span class="line">haode   </span><br><span class="line">client say: heihei</span><br><span class="line">wowotou</span><br><span class="line">client say: yikuaiqian</span><br><span class="line">sige</span><br><span class="line">client say: heihei</span><br><span class="line">client say: nihao</span><br><span class="line">heihei</span><br><span class="line">client say: haha</span><br><span class="line">houhu^Hou</span><br><span class="line">client say: haha</span><br><span class="line">heihei</span><br><span class="line">peer shutdown</span><br><span class="line">recv error</span><br><span class="line">chuwentile</span><br><span class="line">client say: dengdeng</span><br><span class="line">en</span><br><span class="line">client say: shia</span><br><span class="line">en</span><br><span class="line"></span><br><span class="line">[misaki@localhost Net]$ ./tcpclient 192.168.11.128 9000</span><br><span class="line">nihao</span><br><span class="line">server say: haode</span><br><span class="line">heihei</span><br><span class="line">server say: wowotou</span><br><span class="line">yikuaiqian</span><br><span class="line">server say: sige</span><br><span class="line"></span><br><span class="line">heihei</span><br><span class="line">server say: heihei</span><br><span class="line">haha</span><br><span class="line"></span><br><span class="line">[misaki@localhost Net]$ ./tcpclient 192.168.11.128 9000</span><br><span class="line">nihao</span><br><span class="line">server say: houhou</span><br><span class="line">haha</span><br><span class="line">dengdeng</span><br><span class="line">server say: chuwentile</span><br><span class="line">shia</span><br><span class="line">server say: en</span><br><span class="line">server say: en</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;这里起了两个客户端都是可以直接进行通信的，但是要注意一点有时候线程分离线程没有及时关闭情况下我们的数据有可能还会给已经关闭了的服务端发过去。</p>

      
    </div>
    
    
    

    

    <div>
    
    <div style="text-align:center;color: #ccc;font-size:14px;">-------------本文结束<i class="fa fa-paw"></i>感谢您的阅读!-------------</div>
    
    </div>

    
      <div>
        <div style="padding: 10px 0; margin: 20px auto; width: 90%; text-align: center;">
  <div>记录学习每一分，感谢您的赞助</div>
  <button id="rewardButton" disable="enable" onclick="var qr = document.getElementById('QR'); if (qr.style.display === 'none') {qr.style.display='block';} else {qr.style.display='none'}">
    <span>打赏</span>
  </button>
  <div id="QR" style="display: none;">

    
      <div id="wechat" style="display: inline-block">
        <img id="wechat_qr" src="/images/wechatpay.png" alt="MisakiFx 微信支付"/>
        <p>微信支付</p>
      </div>
    

    
      <div id="alipay" style="display: inline-block">
        <img id="alipay_qr" src="/images/alipay.jpg" alt="MisakiFx 支付宝"/>
        <p>支付宝</p>
      </div>
    

    

  </div>
</div>

      </div>
    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/网络/" rel="tag"># 网络</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2019/09/14/【项目】P2P下载帮/" rel="next" title="【项目】P2P下载帮">
                <i class="fa fa-chevron-left"></i> 【项目】P2P下载帮
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2019/09/21/【网络】第三章-应用层协议/" rel="prev" title="【网络】第三章-应用层协议">
                【网络】第三章-应用层协议 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/blog-logo.jpg"
                alt="MisakiFx" />
            
              <p class="site-author-name" itemprop="name">MisakiFx</p>
              <p class="site-description motion-element" itemprop="description">Hard working or giving up!!!</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">82</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">10</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">59</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/MisakiFx" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="mailto:1761607418@qq.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope-open"></i>E-Mail</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://music.163.com/#/user/home?id=432551242" target="_blank" title="网易云音乐">
                      
                        <i class="fa fa-fw fa-music"></i>网易云音乐</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://blog.csdn.net/qq_41669298" target="_blank" title="CSDN">
                      
                        <i class="fa fa-fw fa-crosshairs"></i>CSDN</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#套接字编程"><span class="nav-number">1.</span> <span class="nav-text">套接字编程</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#网络字节序"><span class="nav-number">1.1.</span> <span class="nav-text">网络字节序</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#传输层协议"><span class="nav-number">1.2.</span> <span class="nav-text">传输层协议</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#协议特点"><span class="nav-number">1.2.1.</span> <span class="nav-text">协议特点</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#UDP网络通信编程"><span class="nav-number">1.3.</span> <span class="nav-text">UDP网络通信编程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#流程"><span class="nav-number">1.3.1.</span> <span class="nav-text">流程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#接口"><span class="nav-number">1.3.2.</span> <span class="nav-text">接口</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#实现"><span class="nav-number">1.3.3.</span> <span class="nav-text">实现</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#TCP网络通信编程"><span class="nav-number">1.4.</span> <span class="nav-text">TCP网络通信编程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#流程-1"><span class="nav-number">1.4.1.</span> <span class="nav-text">流程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#接口-1"><span class="nav-number">1.4.2.</span> <span class="nav-text">接口</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#实现-1"><span class="nav-number">1.4.3.</span> <span class="nav-text">实现</span></a></li></ol></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        ﻿<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js">
</script>
<div class="copyright">&copy; <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">MisakiFx</span>

  
</div>


<div class="powered-by">
  <i class="fa fa-user-md"></i>
  <span id="busuanzi_container_site_uv">
    我的网站的访客数:<span id="busuanzi_value_site_uv"></span>
  </span>
</div>



<span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.4</div>




<div class="theme-info">
  <div class="powered-by"></div>
  <span class="post-count">博客全站共247.8k字</span>
</div>

        ﻿







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  


  











  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  

  
  
    <script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

  <!-- 页面点击小红心 -->
        <script type="text/javascript" src="/js/src/love.js"></script>
<script src="/live2dw/lib/L2Dwidget.min.js?0c58a1486de42ac6cc1c59c7d98ae887"></script><script>L2Dwidget.init({"pluginModelPath":"assets/","model":{"jsonPath":"/live2dw/assets/z16.model.json"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":false},"log":false,"pluginJsPath":"lib/","pluginRootPath":"live2dw/","tagMode":false});</script></body>
</html>
