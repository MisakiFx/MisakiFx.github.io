<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.ico?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon_16.ico?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Cpp,关联式容器,红黑树," />










<meta name="description" content="关联式容器&amp;emsp;&amp;emsp;STL中关联式容器有以下几种map/set/multimap/multiset/unordered_map/unordered_set/unordered_multimap/unordered_multiset，所谓关联式容器即他们内部存储的是具有关联性的key-value形式的键值对。本文先从他们的基础使用开始讲起，逐渐深入到底层实现原理，并且最后从二叉搜索树到">
<meta name="keywords" content="Cpp,关联式容器,红黑树">
<meta property="og:type" content="article">
<meta property="og:title" content="【Cpp】第十六章-关联式容器">
<meta property="og:url" content="http://yoursite.com/2019/10/21/【Cpp】第十六章-关联式容器/index.html">
<meta property="og:site_name" content="Misaki`s blog">
<meta property="og:description" content="关联式容器&amp;emsp;&amp;emsp;STL中关联式容器有以下几种map/set/multimap/multiset/unordered_map/unordered_set/unordered_multimap/unordered_multiset，所谓关联式容器即他们内部存储的是具有关联性的key-value形式的键值对。本文先从他们的基础使用开始讲起，逐渐深入到底层实现原理，并且最后从二叉搜索树到">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="http://yoursite.com/2019/10/21/【Cpp】第十六章-关联式容器/1.png">
<meta property="og:image" content="http://yoursite.com/2019/10/21/【Cpp】第十六章-关联式容器/2.png">
<meta property="og:image" content="http://yoursite.com/2019/10/21/【Cpp】第十六章-关联式容器/3.png">
<meta property="og:image" content="http://yoursite.com/2019/10/21/【Cpp】第十六章-关联式容器/4.png">
<meta property="og:image" content="http://yoursite.com/2019/10/21/【Cpp】第十六章-关联式容器/5.png">
<meta property="og:image" content="http://yoursite.com/2019/10/21/【Cpp】第十六章-关联式容器/7.png">
<meta property="og:image" content="http://yoursite.com/2019/10/21/【Cpp】第十六章-关联式容器/8.png">
<meta property="og:image" content="http://yoursite.com/2019/10/21/【Cpp】第十六章-关联式容器/6.png">
<meta property="og:image" content="http://yoursite.com/2019/10/21/【Cpp】第十六章-关联式容器/9.png">
<meta property="og:image" content="http://yoursite.com/2019/10/21/【Cpp】第十六章-关联式容器/10.png">
<meta property="og:image" content="http://yoursite.com/2019/10/21/【Cpp】第十六章-关联式容器/11.png">
<meta property="og:image" content="http://yoursite.com/2019/10/21/【Cpp】第十六章-关联式容器/12.png">
<meta property="og:image" content="http://yoursite.com/2019/10/21/【Cpp】第十六章-关联式容器/13.png">
<meta property="og:image" content="http://yoursite.com/2019/10/21/【Cpp】第十六章-关联式容器/14.png">
<meta property="og:image" content="http://yoursite.com/2019/10/21/【Cpp】第十六章-关联式容器/15.png">
<meta property="og:updated_time" content="2019-11-02T12:14:39.574Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="【Cpp】第十六章-关联式容器">
<meta name="twitter:description" content="关联式容器&amp;emsp;&amp;emsp;STL中关联式容器有以下几种map/set/multimap/multiset/unordered_map/unordered_set/unordered_multimap/unordered_multiset，所谓关联式容器即他们内部存储的是具有关联性的key-value形式的键值对。本文先从他们的基础使用开始讲起，逐渐深入到底层实现原理，并且最后从二叉搜索树到">
<meta name="twitter:image" content="http://yoursite.com/2019/10/21/【Cpp】第十六章-关联式容器/1.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2019/10/21/【Cpp】第十六章-关联式容器/"/>





  <title>【Cpp】第十六章-关联式容器 | Misaki`s blog</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

<a href="https://github.com/MisakiFx" class="github-corner" aria-label="View source on GitHub"><svg width="80" height="80" viewBox="0 0 250 250" style="fill:#64CEAA; color:#fff; position: absolute; top: 0; border: 0; left: 0; transform: scale(-1, 1);" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Misaki`s blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">学习是一种态度</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/10/21/【Cpp】第十六章-关联式容器/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="MisakiFx">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/blog-logo.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Misaki`s blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">【Cpp】第十六章-关联式容器</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-10-21T21:18:17+08:00">
                2019-10-21
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Cpp/" itemprop="url" rel="index">
                    <span itemprop="name">Cpp</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  12.6k
                </span>
              

              

              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="关联式容器"><a href="#关联式容器" class="headerlink" title="关联式容器"></a>关联式容器</h1><p>&emsp;&emsp;STL中关联式容器有以下几种<code>map/set/multimap/multiset/unordered_map/unordered_set/unordered_multimap/unordered_multiset</code>，所谓关联式容器即他们内部存储的是具有关联性的<code>key-value</code>形式的键值对。本文先从他们的基础使用开始讲起，逐渐深入到底层实现原理，并且最后从二叉搜索树到红黑树再到哈希桶逐步手动实现各个版本的关联式容器，<del>我已经预感到了这将是一篇非常之长的博客，但是为了知识的连贯性我并不打算将他们分开。</del></p>
<h2 id="pair"><a href="#pair" class="headerlink" title="pair"></a>pair</h2><p>&emsp;&emsp;关联式容器中诸如<code>map</code>都可以通过一个<code>key</code>来查找<code>value</code>，十分类似于查字典，这就得益于关联式容器中所存储的数据结构都是由一个一个<strong>键值对</strong>组成，因此我们对其的操作就更像是在查字典，要了解关联式容器我们就得先了解其内部存储的键值对的结构<code>pair</code>。<br>&emsp;&emsp;我们首先看一下SGI版本中对键值对<code>pair</code>的定义。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">template &lt;class T1, class T2&gt;</span><br><span class="line">struct pair</span><br><span class="line">&#123;</span><br><span class="line">    typedef T1 first_type;</span><br><span class="line">    typedef T2 second_type;</span><br><span class="line">    </span><br><span class="line">    T1 first;</span><br><span class="line">    T2 second;</span><br><span class="line">    pair()</span><br><span class="line">        :first(T1())</span><br><span class="line">        ,second(T2()) </span><br><span class="line">    &#123;&#125;</span><br><span class="line">    pair(const T1 &amp;a, const T2 &amp;b)</span><br><span class="line">        :first(a)</span><br><span class="line">        ,second(b) </span><br><span class="line">    &#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;<code>pair</code>的结构非常简单，简单来说其中就是存储了一个键值对，<code>first</code>对应<code>key</code>值，<code>second</code>对应<code>value</code>，同时提供了两个构造函数，仅此而已，不过不要忘记这个结构，在关联式容器的使用中，<code>pair</code>的使用也是必不可少。通常我们可以使用<code>make_pair()</code>函数快速帮助我们构造一个<code>pair</code>。</p>
<h2 id="map"><a href="#map" class="headerlink" title="map"></a>map</h2><p>&emsp;&emsp;<code>map</code>方便我们存储映射，并且会自动帮助我们根据<code>key</code>排序。</p>
<h3 id="模板参数"><a href="#模板参数" class="headerlink" title="模板参数"></a>模板参数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">template &lt;class Key,                                  // key的类型</span><br><span class="line">          class T,                                    // value的类型</span><br><span class="line">          class Compare = less&lt;Key&gt;,                  // 比较器</span><br><span class="line">          class Alloc = allocator&lt;pair&lt;const Key, T&gt;&gt; // 空间配置器</span><br><span class="line">          &gt;</span><br><span class="line">class map;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;<code>Key</code>和<code>T</code>很好理解，那么这里的比较器和空间配置器是什么呢？<code>Compare</code>比较器是用来使用在容器内部辅助完成数据排序的，默认按照<strong>小于</strong>来比较，一般情况下不需要特殊比较方式的话不需要传入，我们也可以利用仿函数自定义比较方式。对于比较器我们之前在<code>priority_queue</code>中也有使用过。关于空间配置器我们会发现很多容器模板中都存在这个参数，容器通过使用空间配置器申请底层空间，我们会在之后的章节进行整理，一般情况下也不需要我们手动传入。</p>
<h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">explicit map(const key_compare &amp;comp = key_compare(),</span><br><span class="line">             const allocator_type &amp;alloc = allocator_type());//创建一个空map</span><br><span class="line"></span><br><span class="line">template &lt;class InputIterator&gt;</span><br><span class="line">map(InputIterator first, InputIterator last,</span><br><span class="line">    const key_compare &amp;comp = key_compare(),</span><br><span class="line">    const allocator_type &amp;alloc = allocator_type());//用一个迭代器区间中的数据构造map</span><br><span class="line">    </span><br><span class="line">map (const map&amp; x);//拷贝构造</span><br></pre></td></tr></table></figure>
<h3 id="迭代器相关"><a href="#迭代器相关" class="headerlink" title="迭代器相关"></a>迭代器相关</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">iterator begin();                      //返回第一个元素的位置</span><br><span class="line">iterator end();                        //返回最后一个元素的下一个位置</span><br><span class="line">const_iterator begin() const;          //返回第一个元素的const迭代器</span><br><span class="line">const_iterator end() const;            //返回最后一个元素下一个位置的const迭代器</span><br><span class="line">reverse_iterator rbegin();             //返回第一个元素位置的反向迭代器即rend</span><br><span class="line">reverse_iterator rend();               //返回最后一个元素下一个位置的反向迭代器即 rbegin</span><br><span class="line">const_reverse_iterator rbegin() const; //返回第一个元素位置的const反向迭代器即rend</span><br><span class="line">const_reverse_iterator rend() const;   //返回最后一元素下一个位置的反向迭代器即rbegin</span><br></pre></td></tr></table></figure>
<h3 id="元素修改"><a href="#元素修改" class="headerlink" title="元素修改"></a>元素修改</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">pair&lt;iterator, bool&gt; insert(const value_type &amp;x);        //在map中插入键值对x，注意x是一个键值对，返回 值也是键值对：iterator代表新插入元素的位置， bool代表释放插入成功</span><br><span class="line">iterator insert(iterator position, const value_type &amp;x); //在position位置插入值为x的键值对，返回该键值对 在map中的位置，注意：元素不一定必须插在 position位置，该位置只是一个参考</span><br><span class="line">template &lt;class InputIterator&gt;</span><br><span class="line">void insert(InputIterator first, InputIterator last); //在map中插入[ﬁrst, last)区间中的元素</span><br><span class="line">void erase(iterator position);                        //删除position位置上的元素</span><br><span class="line">size_type erase(const key_type &amp;x);                   //删除键值为x的元素</span><br><span class="line">void erase(iterator ﬁrst, iterator last);             //删除[ﬁrst, last)区间中的元素</span><br><span class="line">void swap(map&lt;Key, T, Compare, Allocator&gt; &amp;mp);       //交换两个map中的元素</span><br><span class="line">void clear();                                         //将map中的元素清空</span><br><span class="line">iterator ﬁnd(const key_type &amp;x);                      //在map中插入key为x的元素，找到返回该元素的位 置的迭代器，否则返回end</span><br><span class="line">const_iterator ﬁnd(const key_type &amp;x) const;          //在map中插入key为x的元素，找到返回该元素的位 置的const迭代器，否则返回cend</span><br><span class="line">size_type count(const key_type &amp;x) const;             //返回key为x的键值在map中的个数，注意map中 key是唯一的，因此该函数的返回值要么为0，要么 为1，因此也可以用该函数来检测一个key是否在 map中</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;要注意<code>map</code>中一个<code>key</code>值仅存在一份，如果我们重复插入<code>key</code>相同的键值对，则会插入失败，并且<code>insert</code>的第一个重载要求插入的元素是一个<code>pair</code>并且返回的也是一个<code>pair</code>，返回的pair的类型为<code>std::pair&lt;std::map::iterator, bool&gt;</code>，第一个迭代器参数标识了结点插入的位置，如果已经存在该节点，则返回<code>map</code>中该节点的迭代器，如果不存在则插入新结点后返回新插入的结点的迭代器，<code>bool</code>标识了插入是否成功，也就是说无论如何当我们插入一个节点时返回的<code>pair</code>中都会给我们返回一个<code>key</code>对应的节点的迭代器。</p>
<h3 id="容量及元素访问"><a href="#容量及元素访问" class="headerlink" title="容量及元素访问"></a>容量及元素访问</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">bool empty() const;                         //检测map中的元素是否为空，是返回true，否则 返回false</span><br><span class="line">size_type size() const;                     //返回map中有效元素的个数</span><br><span class="line">mapped_type &amp;operator[](const key_type &amp;k); //返回去key对应的value</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;这里要注意<code>map</code>也重载了<code>operator[]</code>，那么如果我们去访问一个不存在的值会怎样呢？<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">#include &lt;map&gt;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    std::map&lt;std::string, int&gt; map;//空map</span><br><span class="line">    //访问不存在的key值</span><br><span class="line">    map[&quot;1&quot;] = 1;</span><br><span class="line">    map[&quot;2&quot;] = 2;</span><br><span class="line">    for(auto e : map)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; e.first &lt;&lt; &quot; &quot; &lt;&lt; e.second &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1 1</span><br><span class="line">2 2</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;我们会发现<code>map</code>自动在找不到这个节点的时候会自动插入新的节点，并且返回其<code>value</code>的应用，这里贴出其底层实现。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(*((this-&gt;insert(make_pair(k,mapped_type()))).first)).second</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;对只有这么一句话，我们应该就已经明白了为什么它可以帮助我们插入新节点了，因为它在底层调用了<code>insert</code>方法，<code>insert</code>方法之前已经说过他的返回值是一个特定的<code>pair</code>，其中的<code>key</code>包含了对应结点的迭代器，因此我们也就可以方便的取到对应结点的<code>value</code>并将其返回出来。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>&emsp;&emsp;1、<code>map</code>中的元素是键值对的形式存在的。<br>&emsp;&emsp;2、<code>map</code>中<code>key</code>值是唯一的，并且不能修改<code>key</code>只。<br>&emsp;&emsp;3、<code>map</code>底层是一个红黑树，因此查找效率较高<code>OlogN</code>。<br>&emsp;&emsp;4、<code>map</code>会自动根据<code>key</code>进行排序，当然这也是因为底层是一个红黑树。<br>&emsp;&emsp;5、默认按照小于的方式进行排序，排序结果升序。<br>&emsp;&emsp;6、支持<code>[]</code>操作，在底层调用<code>insert</code>方法。</p>
<h2 id="multimap"><a href="#multimap" class="headerlink" title="multimap"></a>multimap</h2><p>&emsp;&emsp;<code>map</code>中的元素<code>key</code>值不允许相同，由此便延伸出了<code>multimap</code>，<code>multimap</code>中允许元素<code>key</code>值相同，其他与<code>map</code>并没有太大区别。因此接口不再介绍，不过唯一要注意的是<code>insert</code>相关的接口永远都会插入新的元素，并不会存在因为<code>key</code>值存在而插入失败的情况。</p>
<h2 id="set"><a href="#set" class="headerlink" title="set"></a>set</h2><p>&emsp;&emsp;<code>set</code>在上层使用时我们很容易将其看成是一个会自动<strong>排序</strong>和<strong>去重</strong>的<code>vector</code>但是实际上在底层实现大有不同，这也是它被称为关联式容器的原因。其底层依然存储着一个<code>pair</code>不过其中<code>key</code>值和<code>value</code>值都是相同的即<code>&lt;value, value&gt;</code>，并且和<code>map</code>一样它的<code>key</code>一样是不允许修改的，这也就导致了<code>set</code>中的元素是不可修改的，只允许插入和删除。<code>set</code>插入元素时也是只需提供<code>value</code>即可。</p>
<h3 id="模板参数-1"><a href="#模板参数-1" class="headerlink" title="模板参数"></a>模板参数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">template &lt;class T,                   // value类型</span><br><span class="line">          class Compare = less&lt;T&gt;,   // 比较器</span><br><span class="line">          class Alloc = allocator&lt;T&gt; // 空间配置器</span><br><span class="line">          &gt;</span><br><span class="line">class set;</span><br></pre></td></tr></table></figure>
<h3 id="构造函数-1"><a href="#构造函数-1" class="headerlink" title="构造函数"></a>构造函数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">set(const Compare &amp;comp = Compare(), const Allocator &amp; = Allocator());                                         //构造空的set</span><br><span class="line">set(InputIterator ﬁrst, InputIterator last, const Compare &amp;comp = Compare(), const Allocator &amp; = Allocator()); //用[ﬁrst, last)区间 中的元素构造set</span><br><span class="line">set(const set&lt;Key, Compare, Allocator&gt; &amp;x);</span><br></pre></td></tr></table></figure>
<h3 id="迭代器相关-1"><a href="#迭代器相关-1" class="headerlink" title="迭代器相关"></a>迭代器相关</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">iterator begin();                       //返回set中起始位置元素的迭代器</span><br><span class="line">iterator end();                         //返回set中最后一个元素后面的迭代器</span><br><span class="line">const_iterator cbegin() const;          //返回set中起始位置元素的const迭代器</span><br><span class="line">const_iterator cend() const;            //返回set中最后一个元素后面的const迭代器</span><br><span class="line">reverse_iterator rbegin();              //返回set第一个元素的反向迭代器，即end</span><br><span class="line">reverse_iterator rend();                //返回set最后一个元素下一个位置的反向迭代器，即 rbegin</span><br><span class="line">const_reverse_iterator crbegin() const; //返回set第一个元素的反向const迭代器，即cend</span><br><span class="line">const_reverse_iterator crend() const;   //返回set最后一个元素下一个位置的反向const迭代器， 即crbegin</span><br></pre></td></tr></table></figure>
<h3 id="容量和修改"><a href="#容量和修改" class="headerlink" title="容量和修改"></a>容量和修改</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">bool empty() const;                                      //检测set是否为空，空返回true，否则返回true</span><br><span class="line">size_type size() const;                                  //返回set中有效元素的个数</span><br><span class="line">pair&lt;iterator, bool&gt; insert(const value_type &amp;x);        //在set中插入元素x，实际插入的是&lt;x, x&gt;构成的键值对， 如果插入成功，返回&lt;该元素在set中的位置，true&gt;,如果 插入失败，说明x在set中已经存在，返回&lt;x在set中的位 置，false&gt;</span><br><span class="line">iterator insert(iterator position, const value_type &amp;x); //在set的position位置插入x，实际插入的是&lt;x, x&gt;构成的 键值对，注意：position位置只是参考，x最终不一定在该 位置</span><br><span class="line">template &lt;class InputIterator&gt;</span><br><span class="line">void insert(InputIterator ﬁrst, InputIterator last); //在set中插入[ﬁrst, last)区间中的元素</span><br><span class="line">void erase(iterator position);                       //删除set中position位置上的元素</span><br><span class="line">size_type erase(const key_type &amp;x);                  //删除set中值为x的元素，返回删除的元素的个数</span><br><span class="line">void erase(iterator ﬁrst, iterator last);            //删除set中[ﬁrst, last)区间中的元素</span><br><span class="line">void swap(set&lt;Key, Compare, Allocator&gt; &amp;st);         //交换set中的元素</span><br><span class="line">void clear();                                        //将set中的元素清空</span><br><span class="line">iterator ﬁnd(const key_type &amp;x) const;               //返回set中值为x的元素的位置</span><br><span class="line">size_type count(const key_type &amp;x) const;            //返回set中值为x的元素的个数</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;<code>set</code>的接口与<code>map</code>的接口几乎没有差别，不同的是<code>set</code>的迭代器取值直接<code>*it</code>即可，并没有<code>map</code>中<code>first</code>和<code>second</code>的取值方式了。取消了<code>[]</code>操作，因为<code>set</code>的<code>key</code>和<code>value</code>一致并且不允许修改于是这个接口也不再有存在的必要。</p>
<h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p>&emsp;&emsp;1、<code>set</code>和<code>map</code>几乎一致，不同是<code>value</code>和<code>key</code>值相同，因此不能修改。<br>&emsp;&emsp;2、底层依然是一个红黑树进行实现，因此可以实现自动排序，查找速度也较快能够达到<code>OlogN</code>&gt;<br>&emsp;&emsp;3、<code>set</code>插入元素只需提供<code>value</code>即可。<br>&emsp;&emsp;4、<code>set</code>中的元素不可重复，因此可以达到驱虫的效果。<br>&emsp;&emsp;5、<code>set</code>中的元素默认按照小于的方式排序，结果升序。<br>&emsp;&emsp;6、<code>set</code>中的依然存储键值对<code>pair</code>，知识<code>key</code>值与<code>value</code>值相同。</p>
<h2 id="multiset"><a href="#multiset" class="headerlink" title="multiset"></a>multiset</h2><p>&emsp;&emsp;<code>multiset</code>与<code>set</code>的区别与<code>multimap</code>与<code>map</code>的区别相同，<code>set</code>中不允许存储相同的元素而<code>multiset</code>中允许存储，仅此而已。</p>
<h2 id="底层实现"><a href="#底层实现" class="headerlink" title="底层实现"></a>底层实现</h2><p>&emsp;&emsp;以上介绍的几种关联式容器底层都是一颗<strong>红黑树</strong>，什么是红黑树呢，这就得从<strong>BS树</strong>说起，于是接下来我们着重底层实现，从<code>BS Tree</code>开始逐步升级直到最终实现<strong>红黑树</strong>，并用其封装成<code>map/set</code>。</p>
<h3 id="BS-Tree"><a href="#BS-Tree" class="headerlink" title="BS Tree"></a>BS Tree</h3><h4 id="什么是BS-Tree"><a href="#什么是BS-Tree" class="headerlink" title="什么是BS Tree"></a>什么是BS Tree</h4><p>&emsp;&emsp;<code>BS Tree</code>即二叉搜索树，在一个二叉树的基础上使其满足某些要求，让其更加便于搜索。那么一棵二叉搜索树要满足哪些要求呢？<br>&emsp;&emsp;1、若它的左子树不为空，则左子树上所有节点的值都小于根节点的值 。<br>&emsp;&emsp;2、若它的右子树不为空，则右子树上所有节点的值都大于根节点的值。<br>&emsp;&emsp;3、它的左右子树也分别为二叉搜索树。<br>&emsp;&emsp;中序遍历二叉搜索树结果即为有序序列。如下即为一颗二叉搜搜树。<br><br><img src="/2019/10/21/【Cpp】第十六章-关联式容器/1.png" alt="BS Tree"><br><br>&emsp;&emsp;二叉搜索树的插入思路就是用一个<code>cur</code>结点和<code>parent</code>结点找到目标插入位置和其夫结点插入即可，位置的找法就是<code>key</code>值比<code>cur</code>的<code>key</code>大则往左子树走，小则往右子树走，相等则失败，查找也是相同的思路，而删除略微麻烦一些，要分为三种情况进行删除，有两个孩子的结点较难删除，需要找到合适的值进行替换再删除。</p>
<h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br></pre></td><td class="code"><pre><span class="line">#pragma once</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;utility&gt;</span><br><span class="line">template&lt;class K, class V&gt;</span><br><span class="line">//结点</span><br><span class="line">struct BSTreeNode</span><br><span class="line">&#123;</span><br><span class="line">    BSTreeNode(const std::pair&lt;K, V&gt;&amp; kv)</span><br><span class="line">        :_left(nullptr)</span><br><span class="line">        ,_right(nullptr)</span><br><span class="line">        ,_parent(nullptr)</span><br><span class="line">        ,_kv(kv)</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    std::pair&lt;K, V&gt; _kv;</span><br><span class="line">    BSTreeNode&lt;K, V&gt;* _left;</span><br><span class="line">    BSTreeNode&lt;K, V&gt;* _right;</span><br><span class="line">    //BSTree可以暂时先不使用_parent</span><br><span class="line">    BSTreeNode&lt;K, V&gt;* _parent;</span><br><span class="line">&#125;;</span><br><span class="line">//二叉搜索树</span><br><span class="line">template&lt;class K, class V&gt;</span><br><span class="line">class BSTree</span><br><span class="line">&#123;</span><br><span class="line">    typedef BSTreeNode&lt;K, V&gt; Node;</span><br><span class="line">public:</span><br><span class="line">    //这里先暂时忽略拷贝构造，析构，赋值的问题</span><br><span class="line">    BSTree()</span><br><span class="line">        :_root(nullptr)</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    //插入结点</span><br><span class="line">    bool Insert(const std::pair&lt;K, V&gt;&amp; kv)</span><br><span class="line">    &#123;</span><br><span class="line">        //插入第一个结点</span><br><span class="line">        if(_root == nullptr)</span><br><span class="line">        &#123;</span><br><span class="line">            _root = new Node(kv);</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">        Node* parent = nullptr;</span><br><span class="line">        Node* cur = _root;</span><br><span class="line">        while(cur)</span><br><span class="line">        &#123;</span><br><span class="line">            //比当前结点小，插在左边</span><br><span class="line">            if(cur-&gt;_kv.first &gt; kv.first)</span><br><span class="line">            &#123;</span><br><span class="line">                //记录上一个结点</span><br><span class="line">                parent = cur;</span><br><span class="line">                cur = cur-&gt;_left;</span><br><span class="line">            &#125;</span><br><span class="line">            //比当前结点大，插在右边</span><br><span class="line">            else if(cur-&gt;_kv.first &lt; kv.first)</span><br><span class="line">            &#123;</span><br><span class="line">                //记录上一个结点</span><br><span class="line">                parent = cur;</span><br><span class="line">                cur = cur-&gt;_right;</span><br><span class="line">            &#125;</span><br><span class="line">            //相等则说明已存在，插入失败</span><br><span class="line">            else</span><br><span class="line">            &#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        cur = new Node(kv);</span><br><span class="line">        if(parent-&gt;_kv.first &lt; kv.first)</span><br><span class="line">        &#123;</span><br><span class="line">            parent-&gt;_right = cur;</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            parent-&gt;_left = cur;</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    //查找，返回结点的指针</span><br><span class="line">    Node* Find(const K&amp; key)</span><br><span class="line">    &#123;</span><br><span class="line">        Node* cur = _root;</span><br><span class="line">        while(cur)</span><br><span class="line">        &#123;</span><br><span class="line">            if(cur-&gt;_kv.first &lt; key)</span><br><span class="line">            &#123;</span><br><span class="line">                cur = cur-&gt;_right;</span><br><span class="line">            &#125;</span><br><span class="line">            else if(cur-&gt;_kv.first &gt; key)</span><br><span class="line">            &#123;</span><br><span class="line">                cur = cur-&gt;_left;</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">            &#123;</span><br><span class="line">                return cur;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return nullptr;</span><br><span class="line">    &#125;</span><br><span class="line">    //删除结点</span><br><span class="line">    bool Remove(const K&amp; key)</span><br><span class="line">    &#123;</span><br><span class="line">        //1、叶子结点，直接删除，父结点对应指针指向空</span><br><span class="line">        //2、有一个孩子，如果左为空，父结点对应指针指向右，如果右为空，父结点对应指针指向左</span><br><span class="line">        //3、找右子树最左结点或左子树最右结点替代他，然后删除替代结点</span><br><span class="line">        Node* cur = _root;</span><br><span class="line">        Node* parent = nullptr;</span><br><span class="line">        while(cur)</span><br><span class="line">        &#123;</span><br><span class="line">            if(cur-&gt;_kv.first &lt; key)</span><br><span class="line">            &#123;</span><br><span class="line">                parent = cur;</span><br><span class="line">                cur = cur-&gt;_right;</span><br><span class="line">            &#125;</span><br><span class="line">            else if(cur-&gt;_kv.first &gt; key)</span><br><span class="line">            &#123;</span><br><span class="line">                parent = cur;</span><br><span class="line">                cur = cur-&gt;_left;</span><br><span class="line">            &#125;</span><br><span class="line">            //找到相等可以删除此结点了</span><br><span class="line">            else</span><br><span class="line">            &#123;</span><br><span class="line">                //只有0/1个孩子</span><br><span class="line">                //对于只有一个孩子或者没有孩子的结点来说要删除的结点就是cur</span><br><span class="line">                Node* del = cur;</span><br><span class="line">                //要删除的结点左孩子为空</span><br><span class="line">                if(cur-&gt;_left == nullptr)</span><br><span class="line">                &#123;</span><br><span class="line">                    </span><br><span class="line">                    //如果要删除的是根结点，父结点为空</span><br><span class="line">                    if(parent == nullptr)</span><br><span class="line">                    &#123;</span><br><span class="line">                        //直接改变根</span><br><span class="line">                        _root = cur-&gt;_right;</span><br><span class="line">                        return true;</span><br><span class="line">                    &#125;</span><br><span class="line">                    //判断要删除的结点是其父结点的左孩子还是右孩子</span><br><span class="line">                    if(cur == parent-&gt;_left)</span><br><span class="line">                    &#123;</span><br><span class="line">                        parent-&gt;_left = cur-&gt;_right;</span><br><span class="line">                    &#125;</span><br><span class="line">                    else</span><br><span class="line">                    &#123;</span><br><span class="line">                        parent-&gt;_right = cur-&gt;_right;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                //要删除的结点右孩子为空</span><br><span class="line">                else if(cur-&gt;_right == nullptr)</span><br><span class="line">                &#123;</span><br><span class="line">                    //如果要删除的是根结点，父结点为空</span><br><span class="line">                    if(parent == nullptr)</span><br><span class="line">                    &#123;</span><br><span class="line">                        _root = cur-&gt;_left;</span><br><span class="line">                        return true;</span><br><span class="line">                    &#125;</span><br><span class="line">                    //判断要删除的结点是其父结点的左孩子还是右孩子</span><br><span class="line">                    if(cur == parent-&gt;_left)</span><br><span class="line">                    &#123;</span><br><span class="line">                        parent-&gt;_left = cur-&gt;_left;</span><br><span class="line">                    &#125;</span><br><span class="line">                    else</span><br><span class="line">                    &#123;</span><br><span class="line">                        parent-&gt;_right = cur-&gt;_left;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                //有两个孩子，找右树的最左结点</span><br><span class="line">                else</span><br><span class="line">                &#123;</span><br><span class="line">                    //找到右树的最左结点和其父结点</span><br><span class="line">                    Node* rpParent = cur;</span><br><span class="line">                    Node* replace = cur-&gt;_right;</span><br><span class="line">                    while(replace-&gt;_left)</span><br><span class="line">                    &#123;</span><br><span class="line">                        rpParent = replace;</span><br><span class="line">                        replace = replace-&gt;_left;</span><br><span class="line">                    &#125;</span><br><span class="line">                    //此时要释放的结点是替代结点</span><br><span class="line">                    del = replace;</span><br><span class="line">                    //找到后开始替换</span><br><span class="line">                    cur-&gt;_kv = replace-&gt;_kv;</span><br><span class="line">                    //替换结点不一定一定是其父结点的左结点，因此做一次判断</span><br><span class="line">                    if(rpParent-&gt;_left == replace)</span><br><span class="line">                    &#123;</span><br><span class="line">                        rpParent-&gt;_left = replace-&gt;_right;</span><br><span class="line">                    &#125;</span><br><span class="line">                    else</span><br><span class="line">                    &#123;</span><br><span class="line">                        rpParent-&gt;_right = replace-&gt;_right;</span><br><span class="line">                    &#125;</span><br><span class="line">                    </span><br><span class="line">                &#125;</span><br><span class="line">                //释放结点</span><br><span class="line">                delete del;</span><br><span class="line">                std::cout &lt;&lt; &quot;del success&quot; &lt;&lt; std::endl;</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    //中序遍历</span><br><span class="line">    void InOrder()</span><br><span class="line">    &#123;</span><br><span class="line">        _InOrder(_root);</span><br><span class="line">        std::cout &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">private:</span><br><span class="line">    void _InOrder(Node* root)</span><br><span class="line">    &#123;</span><br><span class="line">        if(root == nullptr)</span><br><span class="line">        &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        _InOrder(root-&gt;_left);</span><br><span class="line">        std::cout &lt;&lt; root-&gt;_kv.first &lt;&lt; &quot; &quot;;</span><br><span class="line">        _InOrder(root-&gt;_right);</span><br><span class="line">    &#125;</span><br><span class="line">private:</span><br><span class="line">    Node* _root;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;二叉搜索树的搜索速度在理想状况下可以达到<code>OlogN</code>，此时二叉树为一棵<strong>完全二叉树</strong>，如果是一颗<strong>满二叉树</strong>更好，因为每次搜索都可以淘汰一半的数据。但是往往并不是理想的，如果插入的树本身就是有序的，则使二叉树可能会变成一条链，二叉树会完全失去平衡，此时的搜索便是<code>ON</code>的。为了让二叉树尽可能保持平衡，使其尽可能成为一颗完全二叉树，所有状况下都能达到理想状态，优化时间复杂度，于是我们需要在改变树的状态的时候维持它自身的平衡，便出现了<code>AVLTree</code>。</p>
<h3 id="AVLTree"><a href="#AVLTree" class="headerlink" title="AVLTree"></a>AVLTree</h3><h4 id="什么是AVLTree"><a href="#什么是AVLTree" class="headerlink" title="什么是AVLTree"></a>什么是AVLTree</h4><p>&emsp;&emsp;<code>AVLTree</code>也叫<strong>高度平衡二叉搜索树</strong>，其是对<code>BSTree</code>的一个改进，为了保证其在高度上的平衡性，使其可以尽可能的达到理想状态中的完全二叉树的形式，<code>AVLTree</code>引入了<strong>平衡因子</strong>的概念，平衡因子即左右子树的高度差。<strong><code>AVLTree</code>要求树上每一个结点的平衡因子都不能大于1</strong>，其它要求与<code>BSTree</code>一致。<br>&emsp;&emsp;这样一来<code>AVLTree</code>上任何状态下的操作都将与理想状态下<code>BSTree</code>的操作有着同样的时间复杂度<code>OlogN</code>，可以说<code>AVLTree</code>的存在就是为了任何时候都可以将<code>BSTree</code>限定在理想状态。</p>
<h4 id="AVLTree平衡因子的更新"><a href="#AVLTree平衡因子的更新" class="headerlink" title="AVLTree平衡因子的更新"></a>AVLTree平衡因子的更新</h4><p>&emsp;&emsp;我们这里都先假设平衡因子<code>bf = 右子树高度 - 左子树高度</code>。AVLTree引入平衡因子概念后我们在插入一个节点后必须要更新整棵树的平衡因子，那么我们该如何更新才能让整棵树的平衡因子能重新回到正确的状态下呢？<br>&emsp;&emsp;以下是一棵<code>AVLTree</code>，我用蓝色标识了每个结点的<code>bf</code>。<br><br><img src="/2019/10/21/【Cpp】第十六章-关联式容器/2.png" alt="AVLTree"><br><br>&emsp;&emsp;接下来我们假设插入7.5，或者任意一个比7大比8小的值，我们可以发现新插入的结点<code>bf == 0</code>，因为其没有左右孩子，所以并不受影响。新结点的插入只会影响它的祖先们，因此我们必须依次去更新他们的祖先。这里我们首当其冲更新了插入结点的父亲。更新其父亲的<code>bf</code>规律很好总结，<strong>如果我们插入在父亲的左则<code>bf = bf -  1</code>，插入在父亲的右则<code>bf = bf + 1</code></strong>。此时其父亲<code>bf == 0</code>。<br><br><img src="/2019/10/21/【Cpp】第十六章-关联式容器/3.png" alt="AVLTree"><br><br>&emsp;&emsp;在一次更新后我们是否还应该继续更新？当然，我们必须迭代上去继续更新，让<code>cur = parent, parent = parent-&gt;parent</code>。但是我们再次按照刚才的规律更新会发现<code>7</code>这个元素结点的平衡因子会被更新为2，但是这样的更新明显是错误的，因为虽然插入的新节点但<code>7</code>的右子树高度并没有增高，我们并不应该更新它，那么我们的更新该到何时为止呢？<br><br><img src="/2019/10/21/【Cpp】第十六章-关联式容器/4.png" alt="AVLTree"><br><br>&emsp;&emsp;经过实验我们可以总结出以下几种<code>parent</code>更新<code>bf</code>后的情况，由此来判断是否需要进一步更新或者执行其他操作：<br>&emsp;&emsp;1、<code>|bf| == 0</code>则说明此时当前父结点所在的子树高度并没有增加，我们自然也不需要再迭代上去继续更新其他祖先。<br>&emsp;&emsp;2、<code>parent == nullptr</code>，此时父结点已经指向空说明我们已经更新完了插入结点的所有祖先，没有祖先可以继续更新，这是更新的最坏情况。<br>&emsp;&emsp;3、<code>|bf| == 1</code>，此时当前父结点所在子树的高度增加了，但是父结点<code>bf</code>依然符合<code>AVLTree</code>的要求，我们需要继续向上迭代更新其祖先。<br>&emsp;&emsp;4、<code>|bf| == 2</code>，此时当前父结点所在子树的高度增加了，并且父结点<code>bf</code>不再符合<code>AVLTree</code>的要求，我们就此停止不再更新，并且利用<strong>旋转</strong>来解决眼下的问题。</p>
<h4 id="AVLTree的旋转"><a href="#AVLTree的旋转" class="headerlink" title="AVLTree的旋转"></a>AVLTree的旋转</h4><p>&emsp;&emsp;我们在更新平衡因子的过程中难免会遇到<code>bf == 2</code>的情况，此时这棵树不再满足<code>AVLTree</code>的要求，当然我们也有方法可以使其继续成为一棵<code>AVLTree</code>，就是<strong>旋转</strong>。<br>&emsp;&emsp;旋转分为一共四种情况，以下一一列举。</p>
<h5 id="左单旋"><a href="#左单旋" class="headerlink" title="左单旋"></a>左单旋</h5><p>&emsp;&emsp;使用场景：<br><br><img src="/2019/10/21/【Cpp】第十六章-关联式容器/5.png" alt="AVLTree"><br><br><img src="/2019/10/21/【Cpp】第十六章-关联式容器/7.png" alt="AVLTree"><br><br>&emsp;&emsp;由此我们可以归纳出这种情况的抽象图来。<br><img src="/2019/10/21/【Cpp】第十六章-关联式容器/8.png" alt="AVLTree"><br></p>
<h5 id="右单旋"><a href="#右单旋" class="headerlink" title="右单旋"></a>右单旋</h5><p>&emsp;&emsp;右单旋与左单旋类似：<br><br><img src="/2019/10/21/【Cpp】第十六章-关联式容器/6.png" alt="AVLTree"><br><br>&emsp;&emsp;抽象图。<br><img src="/2019/10/21/【Cpp】第十六章-关联式容器/9.png" alt="AVLTree"><br></p>
<h5 id="先右旋再左旋"><a href="#先右旋再左旋" class="headerlink" title="先右旋再左旋"></a>先右旋再左旋</h5><p>&emsp;&emsp;使用场景：<br><br><img src="/2019/10/21/【Cpp】第十六章-关联式容器/10.png" alt="AVLTree"><br><br>&emsp;&emsp;抽象图：<br><br><img src="/2019/10/21/【Cpp】第十六章-关联式容器/11.png" alt="AVLTree"><br><br>&emsp;&emsp;但是这里要注意，两次旋转后结点的平衡因子更新并不像单旋呢么简单，需要根据实际情况进行判断，具体请看代码中的实现。</p>
<h5 id="先左旋再右旋"><a href="#先左旋再右旋" class="headerlink" title="先左旋再右旋"></a>先左旋再右旋</h5><p>&emsp;&emsp;与先右旋再左旋类似，直接给出抽象图：<br><br><img src="/2019/10/21/【Cpp】第十六章-关联式容器/12.png" alt="AVLTree"><br><br>&emsp;&emsp;但是这里要注意，两次旋转后结点的平衡因子更新并不像单旋呢么简单，需要根据实际情况进行判断，具体请看代码中的实现。</p>
<h4 id="旋转场景"><a href="#旋转场景" class="headerlink" title="旋转场景"></a>旋转场景</h4><p>&emsp;&emsp;四种旋转搞明白后，<code>AVLTree</code>的调整就只剩最后一件事要考虑，那就是我们什么情况下应该使用哪种旋转来调整呢？<br>&emsp;&emsp;回到我们用<code>cur</code>和<code>parent</code>来更新插入结点祖先的平衡因子。以下我们分为四种情况：<br>&emsp;&emsp;1、<code>parent-&gt;_bf == 2 &amp;&amp; cur-&gt;_bf == 1</code>说明<code>parent</code>右子树高，并且<code>cur</code>的右子树也高，说明此时结点插入在了<code>parent</code>右子树的外侧，我们<strong>左单旋</strong>即可。<br>&emsp;&emsp;2、<code>parent-&gt;bf == 2 &amp;&amp; cur-&gt;bf == -1</code>说明<code>parent</code>右子树高，但是<code>cur</code>左子树高，说明此时结点插入在了<code>parent</code>右子树的内侧，我们要<strong>先右旋再左旋</strong>。<br>&emsp;&emsp;3、<code>parent-&gt;bf == -2 &amp;&amp; cur-&gt;bf == -1</code>说明此时<code>parent</code>左子树高，<code>cur</code>也是左子树高，则结点插入在了<code>parent</code>左子树的外侧，<strong>右单旋</strong>即可。<br>&emsp;&emsp;4、<code>parent-&gt;bf == -2 &amp;&amp; cur-&gt;bf == 1</code>说明此时<code>parent</code>左子树高，但是<code>cur</code>右子树高，说明此时结点插入在了<code>parent</code>左子树的内侧，我们要<strong>先左旋再右旋</strong>。</p>
<h4 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h4><p>&emsp;&emsp;这里仅仅实现了<code>AVLTree</code>的插入，删除与插入类似，需要用到<code>BSTree</code>的删除思想并且和<code>AVLTree</code>的插入中的调整平衡的思想相结合来实现。<br>&emsp;&emsp;直接上代码。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br></pre></td><td class="code"><pre><span class="line">#pragma once</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;utility&gt;</span><br><span class="line">#include &lt;assert.h&gt;</span><br><span class="line">//结点</span><br><span class="line">template&lt;class K, class V&gt;</span><br><span class="line">struct AVLTreeNode</span><br><span class="line">&#123;</span><br><span class="line">    AVLTreeNode(const std::pair&lt;K, V&gt;&amp; kv)</span><br><span class="line">        :_kv(kv)</span><br><span class="line">        ,_left(nullptr)</span><br><span class="line">        ,_right(nullptr)</span><br><span class="line">        ,_parent(nullptr)</span><br><span class="line">        ,_bf(0)</span><br><span class="line">    &#123;&#125;</span><br><span class="line">    std::pair&lt;K, V&gt; _kv;</span><br><span class="line">    AVLTreeNode&lt;K, V&gt;* _left;</span><br><span class="line">    AVLTreeNode&lt;K, V&gt;* _right;</span><br><span class="line">    AVLTreeNode&lt;K, V&gt;* _parent;</span><br><span class="line">    int _bf; //平衡因子 = 右子树高度 - 左子树高度</span><br><span class="line">&#125;;</span><br><span class="line">template&lt;class K, class V&gt;</span><br><span class="line">class AVLTree</span><br><span class="line">&#123;</span><br><span class="line">    typedef AVLTreeNode&lt;K, V&gt; Node;</span><br><span class="line">public:</span><br><span class="line">    bool Insert(const std::pair&lt;K, V&gt;&amp; kv)</span><br><span class="line">    &#123;</span><br><span class="line">        //插入结点，思路与BSTree一致，额外需要加入更新平衡因子</span><br><span class="line">        //插入的为第一个结点</span><br><span class="line">        if(_root == nullptr)</span><br><span class="line">        &#123;</span><br><span class="line">            _root = new Node(kv);</span><br><span class="line">            _root-&gt;_bf = 0;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">        Node* cur = _root;</span><br><span class="line">        Node* parent = nullptr;</span><br><span class="line">        while(cur)</span><br><span class="line">        &#123;</span><br><span class="line">            if(cur-&gt;_kv.first &lt; kv.first)</span><br><span class="line">            &#123;</span><br><span class="line">                parent = cur;</span><br><span class="line">                cur = cur-&gt;_right;</span><br><span class="line">            &#125;</span><br><span class="line">            else if(cur-&gt;_kv.first &gt; kv.first)</span><br><span class="line">            &#123;</span><br><span class="line">                parent = cur;</span><br><span class="line">                cur = cur-&gt;_left;</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">            &#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        cur = new Node(kv);</span><br><span class="line">        if(parent-&gt;_kv.first &lt; kv.first)</span><br><span class="line">        &#123;</span><br><span class="line">            cur-&gt;_parent = parent;</span><br><span class="line">            parent-&gt;_right = cur;</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            cur-&gt;_parent = parent;</span><br><span class="line">            parent-&gt;_left = cur;</span><br><span class="line">        &#125;</span><br><span class="line">        //调整平衡</span><br><span class="line">        //1、更新平衡因子</span><br><span class="line">        //新增在左，父亲bf - 1，新增在右，父亲bf + 1</span><br><span class="line">        //如果父亲的更新后|bf|:</span><br><span class="line">        //|bf| == 0 || 父结点为空时停止更新</span><br><span class="line">        //因为bf更新为0则说明当前父亲所在子树此时的高度并未发生变化，父结点为空说明此时更新完了整棵树</span><br><span class="line">        //|bf| == 2也停止更新，及时调整，旋转处理</span><br><span class="line">        //|bf| == 1则继续向上更新</span><br><span class="line">        while(parent)</span><br><span class="line">        &#123;</span><br><span class="line">            if(cur == parent-&gt;_right)</span><br><span class="line">            &#123;</span><br><span class="line">                parent-&gt;_bf++;</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">            &#123;</span><br><span class="line">                parent-&gt;_bf--;</span><br><span class="line">            &#125;</span><br><span class="line">            //|bf| == 0</span><br><span class="line">            if(parent-&gt;_bf == 0)//更新完成</span><br><span class="line">            &#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            else if(abs(parent-&gt;_bf) == 1)//继续向上更新</span><br><span class="line">            &#123;</span><br><span class="line">                cur = parent;</span><br><span class="line">                parent = parent-&gt;_parent;</span><br><span class="line">            &#125;</span><br><span class="line">            else if(abs(parent-&gt;_bf) == 2)//不满足AVLTree要求及时旋转调整</span><br><span class="line">            &#123;</span><br><span class="line">                //2、旋转</span><br><span class="line">                if(parent-&gt;_bf == 2)</span><br><span class="line">                &#123;</span><br><span class="line">                    if(cur-&gt;_bf == 1)</span><br><span class="line">                    &#123;</span><br><span class="line">                        RotateL(parent);</span><br><span class="line">                    &#125;</span><br><span class="line">                    else if(cur-&gt;_bf == -1)</span><br><span class="line">                    &#123;</span><br><span class="line">                        RotateRL(parent);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                else if(parent-&gt;_bf == -2)</span><br><span class="line">                &#123;</span><br><span class="line">                    if(cur-&gt;_bf == -1)</span><br><span class="line">                    &#123;</span><br><span class="line">                        RotateR(parent);</span><br><span class="line">                    &#125;</span><br><span class="line">                    else if(cur-&gt;_bf == 1)</span><br><span class="line">                    &#123;</span><br><span class="line">                        RotateLR(parent);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                break;//调整完一定要记着break</span><br><span class="line">            &#125;</span><br><span class="line">            else//在三种情况外，说明出现问题</span><br><span class="line">            &#123;</span><br><span class="line">                assert(false);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    void RotateL(Node* parent)</span><br><span class="line">    &#123;</span><br><span class="line">        Node* subR = parent-&gt;_right;</span><br><span class="line">        Node* subRL = parent-&gt;_right-&gt;_left;</span><br><span class="line"></span><br><span class="line">        parent-&gt;_right = subRL;</span><br><span class="line">        if(subRL)</span><br><span class="line">        &#123;</span><br><span class="line">            subRL-&gt;_parent = parent;</span><br><span class="line">        &#125;</span><br><span class="line">        subR-&gt;_left = parent;</span><br><span class="line">        Node* ppNode = parent-&gt;_parent;</span><br><span class="line">        parent-&gt;_parent = subR;</span><br><span class="line">        //根</span><br><span class="line">        if(ppNode == nullptr)</span><br><span class="line">        &#123;</span><br><span class="line">            _root = subR;</span><br><span class="line">            subR-&gt;_parent = nullptr;</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            if(ppNode-&gt;_right == parent)</span><br><span class="line">            &#123;</span><br><span class="line">                ppNode-&gt;_right = subR;</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">            &#123;</span><br><span class="line">                ppNode-&gt;_left = subR;</span><br><span class="line">            &#125;</span><br><span class="line">            subR-&gt;_parent = ppNode;</span><br><span class="line">        &#125;</span><br><span class="line">        //更新平衡因子</span><br><span class="line">        subR-&gt;_bf = parent-&gt;_bf = 0;</span><br><span class="line">    &#125;</span><br><span class="line">    void RotateR(Node* parent)</span><br><span class="line">    &#123;</span><br><span class="line">        Node* subL = parent-&gt;_left;</span><br><span class="line">        Node* subLR = parent-&gt;_left-&gt;_right;</span><br><span class="line"></span><br><span class="line">        parent-&gt;_left = subLR;</span><br><span class="line">        if(subLR)//subLR可能会为空，当h == 0时subLR为空</span><br><span class="line">        &#123;</span><br><span class="line">            subLR-&gt;_parent = parent;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        subL-&gt;_right = parent;//subL不可能为空</span><br><span class="line">        //记录下parent原来的父结点，为了方便parent移动可以找到这棵子树的父结点</span><br><span class="line">        Node* ppNode = parent-&gt;_parent;</span><br><span class="line">        parent-&gt;_parent = subL;</span><br><span class="line">        //更新这棵子树的新父结点subL与其父结点的连接</span><br><span class="line">        if(ppNode == nullptr)//如果子树的父结点为空则说明parent原本是整棵树的根节点</span><br><span class="line">        &#123;</span><br><span class="line">            _root = subL;</span><br><span class="line">            _root-&gt;_parent = nullptr;</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            if(ppNode-&gt;_right == parent)</span><br><span class="line">            &#123;</span><br><span class="line">                ppNode-&gt;_right = subL;</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">            &#123;</span><br><span class="line">                ppNode-&gt;_left = subL;</span><br><span class="line">            &#125;</span><br><span class="line">            subL-&gt;_parent = ppNode;</span><br><span class="line">        &#125;</span><br><span class="line">        parent-&gt;_bf = subL-&gt;_bf = 0;</span><br><span class="line">    &#125;</span><br><span class="line">    //先左旋再右旋</span><br><span class="line">    void RotateLR(Node* parent)</span><br><span class="line">    &#123;</span><br><span class="line">        Node* subL = parent-&gt;_left;</span><br><span class="line">        Node* subLR = subL-&gt;_right;</span><br><span class="line">        //保存subRL的平衡因子，之后要根据这个判断parent和subR的平衡因子分别更新为多少</span><br><span class="line">        int bf = subLR-&gt;_bf;</span><br><span class="line"></span><br><span class="line">        RotateL(parent-&gt;_left);</span><br><span class="line">        RotateR(parent);</span><br><span class="line">        //注意这里双旋过后父结点的平衡因子不一定会为0</span><br><span class="line">        if(bf == 0)</span><br><span class="line">        &#123;</span><br><span class="line">            parent-&gt;_bf = subLR-&gt;_bf = subL-&gt;_bf = 0;</span><br><span class="line">        &#125;</span><br><span class="line">        else if(bf == 1)</span><br><span class="line">        &#123;</span><br><span class="line">            subL-&gt;_bf = -1;</span><br><span class="line">            parent-&gt;_bf = 0;</span><br><span class="line">            subLR-&gt;_bf = 0;</span><br><span class="line">        &#125;</span><br><span class="line">        else if(bf == -1)</span><br><span class="line">        &#123;</span><br><span class="line">            parent-&gt;_bf = 1;</span><br><span class="line">            subL-&gt;_bf = 0;</span><br><span class="line">            subLR-&gt;_bf = 0;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    //先右旋再左旋</span><br><span class="line">    void RotateRL(Node* parent)</span><br><span class="line">    &#123;</span><br><span class="line">        Node* subR = parent-&gt;_right;</span><br><span class="line">        Node* subRL = subR-&gt;_left;</span><br><span class="line">        //保存subRL的平衡因子，之后要根据这个判断parent和subR的平衡因子分别更新为多少</span><br><span class="line">        int bf = subRL-&gt;_bf;</span><br><span class="line">        RotateR(parent-&gt;_right);</span><br><span class="line">        RotateL(parent);</span><br><span class="line">        //注意这里双旋过后父结点的平衡因子不一定会为0</span><br><span class="line">        //这里三个结点的平衡因子更新要根据新节点到底插在哪里来决定</span><br><span class="line">        if(bf == 0)//此时说明subRL为新增结点</span><br><span class="line">        &#123;</span><br><span class="line">            parent-&gt;_bf = subRL-&gt;_bf = subR-&gt;_bf = 0;</span><br><span class="line">        &#125;</span><br><span class="line">        else if(bf == 1)//此时说明新增节点插在c树上</span><br><span class="line">        &#123;</span><br><span class="line">            subR-&gt;_bf = 0;</span><br><span class="line">            parent-&gt;_bf = -1;</span><br><span class="line">            subRL-&gt;_bf = 0;</span><br><span class="line">        &#125;</span><br><span class="line">        else if(bf == -1)//此时说明新增结点插在b树上</span><br><span class="line">        &#123;</span><br><span class="line">            parent-&gt;_bf = 0;</span><br><span class="line">            subR-&gt;_bf = 1;</span><br><span class="line">            subRL-&gt;_bf = 0;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    //中序</span><br><span class="line">    void InOrder()</span><br><span class="line">    &#123;</span><br><span class="line">        _InOrder(_root);</span><br><span class="line">        std::cout &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    //为了判定它是一棵平衡树我们写一个求树高度的函数</span><br><span class="line">    int _Height(Node* root)</span><br><span class="line">    &#123;</span><br><span class="line">        if(root == nullptr)</span><br><span class="line">        &#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        int leftHeight = _Height(root-&gt;_left);</span><br><span class="line">        int rightHeight = _Height(root-&gt;_right);</span><br><span class="line">        return (leftHeight &gt; rightHeight ? leftHeight : rightHeight) + 1;</span><br><span class="line">    &#125;</span><br><span class="line">    //判断这是否是一颗平衡二叉树</span><br><span class="line">    bool IsBalance()</span><br><span class="line">    &#123;</span><br><span class="line">        return _IsBalance(_root);</span><br><span class="line">    &#125;</span><br><span class="line">    bool _IsBalance(Node* root)</span><br><span class="line">    &#123;</span><br><span class="line">        if(root == nullptr)</span><br><span class="line">        &#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">        int leftHeight = _Height(root-&gt;_left);</span><br><span class="line">        int rightHeight = _Height(root-&gt;_right);</span><br><span class="line">        //也有可能会出现平衡因子更新错误的情况，这里再做二次判断</span><br><span class="line">        if(rightHeight - leftHeight != root-&gt;_bf)</span><br><span class="line">        &#123;</span><br><span class="line">            std::cout &lt;&lt; root-&gt;_kv.first &lt;&lt; &quot; is error&quot; &lt;&lt; std::endl;</span><br><span class="line">        &#125;</span><br><span class="line">        return (abs(leftHeight - rightHeight) &lt; 2) &amp;&amp; _IsBalance(root-&gt;_left) &amp;&amp; _IsBalance(root-&gt;_right);</span><br><span class="line">    &#125;</span><br><span class="line">private:</span><br><span class="line">    void _InOrder(Node* parent)</span><br><span class="line">    &#123;</span><br><span class="line">        if(parent == nullptr)</span><br><span class="line">        &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        _InOrder(parent-&gt;_left);</span><br><span class="line">        std::cout &lt;&lt; parent-&gt;_kv.first &lt;&lt; &quot; &quot;;</span><br><span class="line">        _InOrder(parent-&gt;_right);</span><br><span class="line">    &#125;</span><br><span class="line">    Node* _root = nullptr;</span><br><span class="line">&#125;;</span><br><span class="line">void TestAVLTree()</span><br><span class="line">&#123;</span><br><span class="line">    AVLTree&lt;int, int&gt; t;</span><br><span class="line">    int a[] = &#123;16, 3, 7, 11, 9, 26, 18, 14, 15&#125;;</span><br><span class="line">    int b[] = &#123;4, 2, 6, 1, 3, 5, 15, 7, 16, 14&#125;;</span><br><span class="line">    for(auto e : b)</span><br><span class="line">    &#123;</span><br><span class="line">        t.Insert(std::make_pair(e, e));</span><br><span class="line">    &#125;</span><br><span class="line">    t.InOrder();</span><br><span class="line">    //验证是否平衡</span><br><span class="line">    std::cout &lt;&lt; t.IsBalance() &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">在主函数中调用TestAVLTree()</span><br><span class="line">1 2 3 4 5 6 7 14 15 16</span><br><span class="line">1</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;因为<code>AVLTree</code>总能通过旋转来调节自身的平衡，使自己变成一棵近完全二叉树以追求搜索二叉树的理想状态，因此它在搜索上的时间复杂度确实得到了极大的改进，可以一直维持在<code>OlogN</code>，但是这棵树它虽然近乎完美但是依然达不到要求，首先的原因就是它的调整，可以说调整虽然加快了它的搜索过程，但是也正是调整使它变得更为复杂。我们在根部插入新结点时，最坏情况下我们要从叶子调整到根，它的调整实在是太多了。其次，它的实现也因为调整变得十分复杂繁琐，虽然我们希望一棵<code>BSTree</code>搜索起来尽可能追求理想状态，但是这样的调整未免付出的代价也有点过大了。于是便有了接下来的<code>RBTree</code>的诞生。</p>
<h3 id="RBTree"><a href="#RBTree" class="headerlink" title="RBTree"></a>RBTree</h3><h4 id="什么是RBTRee"><a href="#什么是RBTRee" class="headerlink" title="什么是RBTRee"></a>什么是RBTRee</h4><p>&emsp;&emsp;<code>RBTree</code>即<strong>红黑树</strong>，它相比<code>AVLTree</code>更为简单，并且它大大减少了要调整的次数，在追求理想状态的过程中与调整次数达成了妥协，这也使得它成为<code>STL</code>中<code>map/set/multimap/multiset</code>的底层数据结构。<br>&emsp;&emsp;一棵树要是红黑树必须满足以下几条规则：<br>&emsp;&emsp;1、每个结点不是红色就是黑色的。<br>&emsp;&emsp;2、根节点是黑色的。<br>&emsp;&emsp;3、如果一个结点时红色的，则它两个孩子结点是黑色的。<br>&emsp;&emsp;4、对于每个结点，从该结点到其所有后代叶结点的简单路径上，均包含相同数目的黑结点。<br>&emsp;&emsp;5、每个叶子结点都是黑色的（此处的叶子结点指空结点）。</p>
<h4 id="RBTree的调整"><a href="#RBTree的调整" class="headerlink" title="RBTree的调整"></a>RBTree的调整</h4><p>&emsp;&emsp;我们在插入新节点的时候要考虑的就是新节点的颜色默认应该为什么颜色。我们首先分析如果新节点颜色如果为黑色，那么就意味着当前叶子的祖先路径上黑色必然会多出来一个，为了维持第4条规则，必然要对树进行调整，这就意味着如果新插入结点默认为黑色那么我们必然要进行调整，因为黑色结点对整棵树整体的影响是比较大的。那么如果新插入结点默认为红色呢？如果为红色只要它的父结点不为红色，那么此时我们是不需要进行调整的，因此调整的几率从必然要调整降低到了有可能不会需要调整，因此我们<strong>默认新插入的结点颜色为红色</strong>是最优的选择。<br>&emsp;&emsp;新插入结点默认为红色也有可能会遇到需要调整的情况，比如它的父结点也为红色那么此时该如何调整呢？这里的情况判断相比<code>AVLTree</code>更为复杂一些。<br>&emsp;&emsp;为了方便讨论，这里约定<code>cur</code>为当前节点，<code>p</code>为父节点，<code>g</code>为祖父节点，<code>u</code>为叔叔节点。 </p>
<h5 id="情况一"><a href="#情况一" class="headerlink" title="情况一"></a>情况一</h5><p>&emsp;&emsp;<code>cur</code>为红，<code>p</code>为红，<code>g</code>为黑，<code>u</code>存在且为红。<br><br><img src="/2019/10/21/【Cpp】第十六章-关联式容器/13.png" alt="AVLTree"><br><br>&emsp;&emsp;这种情况下肯定是要调整了，这种情况下要做的操作也很简单，变色即可。为了让红色不连续我们将<code>p</code>变为黑色，为了维持每条路径上黑色结点数量一致，我们将<code>u</code>也变为黑色，而<code>g</code>变为红色。如果<code>g</code>调整后和它的父结点再次出现了连续红色则再次根据情况进行调整。</p>
<h5 id="情况二"><a href="#情况二" class="headerlink" title="情况二"></a>情况二</h5><p>&emsp;&emsp;<code>cur</code>为红，<code>p</code>为红，<code>g</code>为黑，<code>u</code>不存在或为黑。<br><br><img src="/2019/10/21/【Cpp】第十六章-关联式容器/14.png" alt="AVLTree"><br><br>&emsp;&emsp;这种情况下调整方式为：如果<code>p</code>为<code>g</code>的左孩子，<code>cur</code>为p的左孩子，则进行右单旋转；相反， <code>p</code>为<code>g</code>的右孩子，<code>cur</code>为<code>p</code>的右孩子，则进行左单旋转。最后<code>p</code>变黑，<code>g</code>变红。这里的旋转方法和<code>AVLTree</code>的相同。<br></p>
<h5 id="情况三"><a href="#情况三" class="headerlink" title="情况三"></a>情况三</h5><p>&emsp;&emsp;<code>cur</code>为红，<code>p</code>为红，<code>g</code>为黑，<code>u</code>不存在或<code>u</code>为黑<br>。<br><img src="/2019/10/21/【Cpp】第十六章-关联式容器/15.png" alt="AVLTree"><br><br>&emsp;&emsp;<code>p</code>为<code>g</code>的左孩子，<code>cur</code>为<code>p</code>的右孩子，则针对<code>p</code>做左单旋转；相反， <code>p</code>为<code>g</code>的右孩子，<code>cur</code>为<code>p</code>的左孩子，则针对<code>p</code>做右单旋转 则转换成了情况2 。<br>&emsp;&emsp;这种情况与<code>AVLTree</code>中的双旋场景类似，<code>cur</code>在了内侧，因此我们必须旋转两次，好在这里旋转一次就可以变为情况二我们可以很方便的处理这种问题。要注意的是，旋转一次完毕后我们要交换<code>cur</code>和<code>parent</code>来让当前结点的情况和情况二完全一致。</p>
<h4 id="实现-2"><a href="#实现-2" class="headerlink" title="实现"></a>实现</h4><p>&emsp;&emsp;直接上代码，这里暂且没有实现删除。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br></pre></td><td class="code"><pre><span class="line">#pragma once</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;utility&gt;</span><br><span class="line">enum Color</span><br><span class="line">&#123;</span><br><span class="line">    RED,</span><br><span class="line">    BLACK</span><br><span class="line">&#125;;</span><br><span class="line">template&lt;class K, class V&gt;</span><br><span class="line">struct RBTNode</span><br><span class="line">&#123;</span><br><span class="line">    RBTNode(const std::pair&lt;K, V&gt;&amp; data = std::pair&lt;K, V&gt;())</span><br><span class="line">        :_data(data)</span><br><span class="line">        ,_left(nullptr)</span><br><span class="line">        ,_right(nullptr)</span><br><span class="line">        ,_parent(nullptr)</span><br><span class="line">        ,_color(RED)</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    std::pair&lt;K, V&gt; _data;</span><br><span class="line">    RBTNode&lt;K, V&gt;* _left;</span><br><span class="line">    RBTNode&lt;K, V&gt;* _right;</span><br><span class="line">    RBTNode&lt;K, V&gt;* _parent;</span><br><span class="line">    Color _color;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">template&lt;class K, class V&gt;</span><br><span class="line">class RBTree</span><br><span class="line">&#123;</span><br><span class="line">    typedef RBTNode&lt;K, V&gt; Node;</span><br><span class="line">public:</span><br><span class="line">    RBTree(const std::pair&lt;K, V&gt;&amp; data = std::pair&lt;K, V&gt;())</span><br><span class="line">        :_header(new Node(data))</span><br><span class="line">    &#123;</span><br><span class="line">        _header-&gt;_left = _header;</span><br><span class="line">        _header-&gt;_right = _header;</span><br><span class="line">        _header-&gt;_parent = nullptr;</span><br><span class="line">    &#125;</span><br><span class="line">    bool Insert(const std::pair&lt;K, V&gt;&amp; data)</span><br><span class="line">    &#123;</span><br><span class="line">        //空树，插入的为根结点</span><br><span class="line">        if(_header-&gt;_parent == nullptr)</span><br><span class="line">        &#123;</span><br><span class="line">            Node* root = new Node(data);</span><br><span class="line">            //根节点颜色必须为黑色</span><br><span class="line">            root-&gt;_color = BLACK;</span><br><span class="line">            _header-&gt;_parent = root;</span><br><span class="line">            root-&gt;_parent = _header;</span><br><span class="line">            _header-&gt;_left = root;</span><br><span class="line">            _header-&gt;_right = root;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">        Node* cur = _header-&gt;_parent;</span><br><span class="line">        Node* parent = _header;</span><br><span class="line">        while(cur)</span><br><span class="line">        &#123;</span><br><span class="line">            if(cur-&gt;_data.first &lt; data.first)</span><br><span class="line">            &#123;</span><br><span class="line">                parent = cur;</span><br><span class="line">                cur = cur-&gt;_right;</span><br><span class="line">            &#125;</span><br><span class="line">            else if(cur-&gt;_data.first &gt; data.first)</span><br><span class="line">            &#123;</span><br><span class="line">                parent = cur;</span><br><span class="line">                cur = cur-&gt;_left;</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">            &#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        cur = new Node(data);</span><br><span class="line">        if(parent-&gt;_data.first &lt; data.first)</span><br><span class="line">        &#123;</span><br><span class="line">            parent-&gt;_right = cur;</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            parent-&gt;_left = cur;</span><br><span class="line">        &#125;</span><br><span class="line">        cur-&gt;_parent = parent;</span><br><span class="line">        //_header-&gt;_left = cur;</span><br><span class="line">        //调整：修改颜色，旋转</span><br><span class="line">        while(cur != _header-&gt;_parent &amp;&amp; cur-&gt;_parent-&gt;_color == RED)</span><br><span class="line">        &#123;</span><br><span class="line">            Node* parent = cur-&gt;_parent;</span><br><span class="line">            Node* gParent = parent-&gt;_parent;</span><br><span class="line">            if(gParent-&gt;_left == parent)</span><br><span class="line">            &#123;</span><br><span class="line">                Node *uncle = gParent-&gt;_right;</span><br><span class="line">                //情况一</span><br><span class="line">                if(uncle &amp;&amp; uncle-&gt;_color == RED)</span><br><span class="line">                &#123;</span><br><span class="line">                    //更新颜色</span><br><span class="line">                    parent-&gt;_color = uncle-&gt;_color = BLACK;</span><br><span class="line">                    gParent-&gt;_color = RED;</span><br><span class="line">                    //向上继续更新</span><br><span class="line">                    cur = gParent;</span><br><span class="line">                &#125;</span><br><span class="line">                //情况二/三</span><br><span class="line">                else</span><br><span class="line">                &#123;</span><br><span class="line">                    //叔叔不存在或者叔叔为黑色</span><br><span class="line">                    //判断这里是否存在双旋的场景</span><br><span class="line">                    if(cur = parent-&gt;_right)</span><br><span class="line">                    &#123;</span><br><span class="line">                        //情况三</span><br><span class="line">                        //此时就是一个折现的形态就需要两次旋转了</span><br><span class="line">                        RotateL(parent);</span><br><span class="line">                        //左旋后，父亲变子，子变父亲，重回情况er</span><br><span class="line">                        std::swap(cur, parent);</span><br><span class="line">                    &#125;</span><br><span class="line">                    else</span><br><span class="line">                    &#123;</span><br><span class="line">                        //情况二</span><br><span class="line">                        RotateR(gParent);</span><br><span class="line">                        //更改颜色</span><br><span class="line">                        parent-&gt;_color = BLACK;</span><br><span class="line">                        gParent-&gt;_color = RED;</span><br><span class="line">                        //此时这课子树的根为黑色，所以不需要再继续向上调整</span><br><span class="line">                        break;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">            &#123;</span><br><span class="line">                Node* uncle = gParent-&gt;_left;</span><br><span class="line">                if(uncle &amp;&amp; uncle-&gt;_color == RED)</span><br><span class="line">                &#123;</span><br><span class="line">                    parent-&gt;_color = uncle-&gt;_color = BLACK;</span><br><span class="line">                    gParent-&gt;_color = RED;</span><br><span class="line">                    cur = gParent;</span><br><span class="line">                &#125;</span><br><span class="line">                else</span><br><span class="line">                &#123;</span><br><span class="line">                    if(cur == parent-&gt;_left)</span><br><span class="line">                    &#123;</span><br><span class="line">                        RotateR(parent);</span><br><span class="line">                        std::swap(cur, parent);</span><br><span class="line">                    &#125;</span><br><span class="line">                    else</span><br><span class="line">                    &#123;</span><br><span class="line">                        RotateL(gParent);</span><br><span class="line">                        parent-&gt;_color = BLACK;</span><br><span class="line">                        gParent-&gt;_color = RED;</span><br><span class="line">                        break;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        //根结点的颜色必须为黑色</span><br><span class="line">        _header-&gt;_parent-&gt;_color = BLACK;</span><br><span class="line">        //更新头节点</span><br><span class="line">        _header-&gt;_left = LeftMost();</span><br><span class="line">        _header-&gt;_right = RightMost();</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    //左旋</span><br><span class="line">    void RotateL(Node* parent)</span><br><span class="line">    &#123;</span><br><span class="line">        Node* subR = parent-&gt;_right;</span><br><span class="line">        Node* subRL = parent-&gt;_right-&gt;_left;</span><br><span class="line"></span><br><span class="line">        parent-&gt;_right = subRL;</span><br><span class="line">        if(subRL)</span><br><span class="line">        &#123;</span><br><span class="line">            subRL-&gt;_parent = parent;</span><br><span class="line">        &#125;</span><br><span class="line">        subR-&gt;_left = parent;</span><br><span class="line">        Node* ppNode = parent-&gt;_parent;</span><br><span class="line">        parent-&gt;_parent = subR;</span><br><span class="line">        //根</span><br><span class="line">        if(ppNode == _header)</span><br><span class="line">        &#123;</span><br><span class="line">            _header-&gt;_parent = subR;</span><br><span class="line">            subR-&gt;_parent = _header;</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            if(ppNode-&gt;_right == parent)</span><br><span class="line">            &#123;</span><br><span class="line">                ppNode-&gt;_right = subR;</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">            &#123;</span><br><span class="line">                ppNode-&gt;_left = subR;</span><br><span class="line">            &#125;</span><br><span class="line">            subR-&gt;_parent = ppNode;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    //右旋</span><br><span class="line">    void RotateR(Node* parent)</span><br><span class="line">    &#123;</span><br><span class="line">        Node* subL = parent-&gt;_left;</span><br><span class="line">        Node* subLR = parent-&gt;_left-&gt;_right;</span><br><span class="line"></span><br><span class="line">        parent-&gt;_left = subLR;</span><br><span class="line">        if(subLR)//subLR可能会为空，当h == 0时subLR为空</span><br><span class="line">        &#123;</span><br><span class="line">            subLR-&gt;_parent = parent;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        subL-&gt;_right = parent;//subL不可能为空</span><br><span class="line">        //记录下parent原来的父结点，为了方便parent移动可以找到这棵子树的父结点</span><br><span class="line">        Node* ppNode = parent-&gt;_parent;</span><br><span class="line">        parent-&gt;_parent = subL;</span><br><span class="line">        //更新这棵子树的新父结点subL与其父结点的连接</span><br><span class="line">        if(ppNode == _header)//如果子树的父结点为空则说明parent原本是整棵树的根节点</span><br><span class="line">        &#123;</span><br><span class="line">            _header-&gt;_parent= subL;</span><br><span class="line">            subL-&gt;_parent = _header;</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            if(ppNode-&gt;_right == parent)</span><br><span class="line">            &#123;</span><br><span class="line">                ppNode-&gt;_right = subL;</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">            &#123;</span><br><span class="line">                ppNode-&gt;_left = subL;</span><br><span class="line">            &#125;</span><br><span class="line">            subL-&gt;_parent = ppNode;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    //找到当前树的最左结点</span><br><span class="line">    Node* LeftMost()</span><br><span class="line">    &#123;</span><br><span class="line">        Node* cur = _header-&gt;_parent;</span><br><span class="line">        while(cur &amp;&amp; cur-&gt;_left)</span><br><span class="line">        &#123;</span><br><span class="line">            cur = cur-&gt;_left;</span><br><span class="line">        &#125;</span><br><span class="line">        return cur;</span><br><span class="line">    &#125;</span><br><span class="line">    //找到当前树的最有结点</span><br><span class="line">    Node* RightMost()</span><br><span class="line">    &#123;</span><br><span class="line">        Node* cur = _header-&gt;_parent;</span><br><span class="line">        while(cur &amp;&amp; cur-&gt;_right)</span><br><span class="line">        &#123;</span><br><span class="line">            cur = cur-&gt;_right;</span><br><span class="line">        &#125;</span><br><span class="line">        return cur;</span><br><span class="line">    &#125;</span><br><span class="line">    //中序遍历</span><br><span class="line">    void Inorder()</span><br><span class="line">    &#123;</span><br><span class="line">        _Inorder(_header-&gt;_parent);</span><br><span class="line">    &#125;</span><br><span class="line">    void _Inorder(Node* root)</span><br><span class="line">    &#123;</span><br><span class="line">        if(root == nullptr)</span><br><span class="line">        &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        _Inorder(root-&gt;_left);</span><br><span class="line">        std::cout &lt;&lt; root-&gt;_data.first &lt;&lt; &quot; &quot;;</span><br><span class="line">        _Inorder(root-&gt;_right);</span><br><span class="line">    &#125;</span><br><span class="line">    //判断是否是一个红黑树</span><br><span class="line">    bool IsRBTree()</span><br><span class="line">    &#123;</span><br><span class="line">        Node* root = _header-&gt;_parent;</span><br><span class="line">        if(root == nullptr)</span><br><span class="line">        &#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">        if(root-&gt;_color == RED)</span><br><span class="line">        &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        //统计一条路径黑结点的数量</span><br><span class="line">        int blackCount = 0;</span><br><span class="line">        Node* cur = root;</span><br><span class="line">        while(cur)</span><br><span class="line">        &#123;</span><br><span class="line">            if(cur-&gt;_color == BLACK)</span><br><span class="line">            &#123;</span><br><span class="line">                blackCount++;</span><br><span class="line">            &#125;</span><br><span class="line">            cur = cur-&gt;_left;</span><br><span class="line">        &#125;</span><br><span class="line">        //前序遍历</span><br><span class="line">        return _IsRBTree(root, blackCount, 0);</span><br><span class="line">    &#125;</span><br><span class="line">    bool _IsRBTree(Node* root, int blackCount, int curBlackCount)</span><br><span class="line">    &#123;</span><br><span class="line">        if(root == nullptr)</span><br><span class="line">        &#123;</span><br><span class="line">            if(curBlackCount != blackCount)</span><br><span class="line">            &#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">        //统计黑色结点的数量</span><br><span class="line">        if(root-&gt;_color == BLACK)</span><br><span class="line">        &#123;</span><br><span class="line">            curBlackCount++;</span><br><span class="line">        &#125;</span><br><span class="line">        //判断是否有红色连续</span><br><span class="line">        if(root-&gt;_parent-&gt;_color == RED &amp;&amp; root-&gt;_color == RED)</span><br><span class="line">        &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        return _IsRBTree(root-&gt;_left, blackCount, curBlackCount) </span><br><span class="line">        &amp;&amp; _IsRBTree(root-&gt;_right, blackCount, curBlackCount);</span><br><span class="line">    &#125;</span><br><span class="line">private:</span><br><span class="line">    //Node* _root;</span><br><span class="line">    //这里为了方便后续封装成map/set我们将其结构改造成一棵带头结点的环形树</span><br><span class="line">    //这里的头和环形类似于实现过的带头双向环形链表</span><br><span class="line">    //头节点的右孩子连接最右结点，左孩子连接最左结点，用头指向树真正的根结点</span><br><span class="line">    //相当于这个头结点是倒过来的，和真正的根结点头连着头，连个孩子和最左最右结点构成两个环</span><br><span class="line">    //封装成这种结构都是为了方便我们后续进一步封装，尽量和库中的保持一致</span><br><span class="line">    Node* _header;</span><br><span class="line">&#125;;</span><br><span class="line">void TestRBTree()</span><br><span class="line">&#123;</span><br><span class="line">    RBTree&lt;int, int&gt; rbt;</span><br><span class="line">    rbt.Insert(std::make_pair(1, 1));</span><br><span class="line">    rbt.Insert(std::make_pair(10, 1));</span><br><span class="line">    rbt.Insert(std::make_pair(2, 1));</span><br><span class="line">    rbt.Insert(std::make_pair(5, 1));</span><br><span class="line">    rbt.Insert(std::make_pair(3, 1));</span><br><span class="line">    rbt.Insert(std::make_pair(4, 1));</span><br><span class="line">    rbt.Insert(std::make_pair(7, 1));</span><br><span class="line">    rbt.Inorder();</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line">    //验证</span><br><span class="line">    std::cout &lt;&lt; (rbt.IsRBTree()) &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">执行TestRBTree:</span><br><span class="line">1 2 3 4 5 7 10 </span><br><span class="line">1</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;<code>RBTree</code>相比<code>AVLTree</code>性能更好，降低了需要旋转的次数，并且<code>RBTree</code>实现起来相比<code>AVLTree</code>较简单。</p>
<h3 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h3><p>&emsp;&emsp;STL库中的<code>map/set</code>的底层数据结构就是一棵红黑树，到了这一步我们从最基本的<code>BSTree</code>一路过关斩将最终实现了<code>RBTree</code>的基本功能，接下来我们要做的就是对<code>RBTree</code>进一步封装，使其完成<code>map/set</code>的基本功能。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br></pre></td><td class="code"><pre><span class="line">RBTreeMod.hpp:</span><br><span class="line">#pragma once</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;utility&gt;</span><br><span class="line">//为了方便封装进行的修改版本的红黑树</span><br><span class="line">enum Color</span><br><span class="line">&#123;</span><br><span class="line">    RED,</span><br><span class="line">    BLACK</span><br><span class="line">&#125;;</span><br><span class="line">template&lt;class V&gt;</span><br><span class="line">struct RBTNode</span><br><span class="line">&#123;</span><br><span class="line">    RBTNode(const V&amp; data = V())</span><br><span class="line">        :_data(data)</span><br><span class="line">        ,_left(nullptr)</span><br><span class="line">        ,_right(nullptr)</span><br><span class="line">        ,_parent(nullptr)</span><br><span class="line">        ,_color(RED)</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    V _data;</span><br><span class="line">    RBTNode&lt;V&gt;* _left;</span><br><span class="line">    RBTNode&lt;V&gt;* _right;</span><br><span class="line">    RBTNode&lt;V&gt;* _parent;</span><br><span class="line">    Color _color;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//每个容器都有自己的迭代器，我们的Map/Set也必须有！</span><br><span class="line">//在这里封装实现迭代器，Map/Set结构都是一致的，所以是现在RBTree的头文件中</span><br><span class="line">template&lt;class V&gt;</span><br><span class="line">class _RBTreeIterator</span><br><span class="line">&#123;</span><br><span class="line">    //封装红黑树的结点</span><br><span class="line">    typedef RBTNode&lt;V&gt; Node;</span><br><span class="line">    typedef _RBTreeIterator&lt;V&gt; Self;</span><br><span class="line">public:</span><br><span class="line">    _RBTreeIterator(Node* node)</span><br><span class="line">        :_node(node)</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    V&amp; operator*()</span><br><span class="line">    &#123;</span><br><span class="line">        return _node-&gt;_data;</span><br><span class="line">    &#125;</span><br><span class="line">    V* operator-&gt;()</span><br><span class="line">    &#123;</span><br><span class="line">        return &amp;_node-&gt;_data;</span><br><span class="line">    &#125;</span><br><span class="line">    bool operator!=(const Self&amp; it)</span><br><span class="line">    &#123;</span><br><span class="line">        return _node != it._node;</span><br><span class="line">    &#125;</span><br><span class="line">    bool operator==(const Self&amp; it)</span><br><span class="line">    &#123;</span><br><span class="line">        return _node == it._node;</span><br><span class="line">    &#125;</span><br><span class="line">    //我们之前更改红黑树的结构使其变成带头的就是为这里迭代器的遍历做铺垫</span><br><span class="line">    //1、_node-&gt;_right存在，走到右子树的最左结点</span><br><span class="line">    //2、_node-&gt;_right不存在，向上回溯，只要_node == parent-&gt;_right就继续向上回溯，不满足条件则停止回溯，更新_node的值为parent</span><br><span class="line">    Self&amp; operator++()</span><br><span class="line">    &#123;</span><br><span class="line">        if(_node-&gt;_right)</span><br><span class="line">        &#123;</span><br><span class="line">            //找到右子树最左结点</span><br><span class="line">            _node = _node-&gt;_right;</span><br><span class="line">            while(_node-&gt;_left)</span><br><span class="line">            &#123;</span><br><span class="line">                _node = _node-&gt;_left;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            Node* parent = _node-&gt;_parent;</span><br><span class="line">            while(_node == parent-&gt;_right)</span><br><span class="line">            &#123;</span><br><span class="line">                _node = parent;</span><br><span class="line">                parent = parent-&gt;_parent;</span><br><span class="line">            &#125;</span><br><span class="line">            //这个判断是为了避免树中没有右子树导致死循环的情况</span><br><span class="line">            if(_node-&gt;_right != parent)</span><br><span class="line">            &#123;</span><br><span class="line">                _node = parent;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return *this;</span><br><span class="line">    &#125;</span><br><span class="line">    //1、_node-&gt;_left存在，找左子树的最有结点</span><br><span class="line">    //2、_node-&gt;_left不存在，只要_node != parent-&gt;_right，向上回溯，条件不满足则更新_node为parent</span><br><span class="line">    Self&amp; operator--()</span><br><span class="line">    &#123;</span><br><span class="line">        if(_node-&gt;_left)</span><br><span class="line">        &#123;</span><br><span class="line">            _node = _node-&gt;_left;</span><br><span class="line">            while(_node-&gt;_right)</span><br><span class="line">            &#123;</span><br><span class="line">                _node = _node-&gt;_right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            Node* parent = _node-&gt;_parent;</span><br><span class="line">            while(_node != parent-&gt;_right)</span><br><span class="line">            &#123;</span><br><span class="line">                _node = parent;</span><br><span class="line">                parent = parent-&gt;_parent;</span><br><span class="line">            &#125;</span><br><span class="line">            _node = parent;</span><br><span class="line">        &#125;</span><br><span class="line">        return *this;</span><br><span class="line">    &#125;</span><br><span class="line">private:</span><br><span class="line">    Node* _node;</span><br><span class="line">&#125;;</span><br><span class="line">//此时的结构仿照STL中的内容，K依然代表Key，而V代表节点中data的类型</span><br><span class="line">//如果是map则V-&gt;std::pair&lt;K, V&gt;，如果是set则V-&gt;K</span><br><span class="line">//这样实现的原因是为了方便红黑树更为灵活的可以分别实现map和set</span><br><span class="line">template&lt;class K, class V, class KeyOfValue&gt;</span><br><span class="line">class RBTree</span><br><span class="line">&#123;</span><br><span class="line">    typedef RBTNode&lt;V&gt; Node;</span><br><span class="line">public:</span><br><span class="line">    typedef _RBTreeIterator&lt;V&gt; iterator;</span><br><span class="line">    //中序遍历的头即树中的最左结点</span><br><span class="line">    iterator begin()</span><br><span class="line">    &#123;</span><br><span class="line">        return iterator(_header-&gt;_left);</span><br><span class="line">    &#125;</span><br><span class="line">    //尾注意是它本身</span><br><span class="line">    iterator end()</span><br><span class="line">    &#123;</span><br><span class="line">        return iterator(_header);</span><br><span class="line">    &#125;</span><br><span class="line">    RBTree(const V&amp; data = V())</span><br><span class="line">        :_header(new Node(data))</span><br><span class="line">    &#123;</span><br><span class="line">        _header-&gt;_left = _header;</span><br><span class="line">        _header-&gt;_right = _header;</span><br><span class="line">        _header-&gt;_parent = nullptr;</span><br><span class="line">    &#125;</span><br><span class="line">    std::pair&lt;iterator, bool&gt; Insert(const V&amp; data)</span><br><span class="line">    &#123;</span><br><span class="line">        //空树，插入的为根结点</span><br><span class="line">        if(_header-&gt;_parent == nullptr)</span><br><span class="line">        &#123;</span><br><span class="line">            Node* root = new Node(data);</span><br><span class="line">            //根节点颜色必须为黑色</span><br><span class="line">            root-&gt;_color = BLACK;</span><br><span class="line">            _header-&gt;_parent = root;</span><br><span class="line">            root-&gt;_parent = _header;</span><br><span class="line">            _header-&gt;_left = root;</span><br><span class="line">            _header-&gt;_right = root;</span><br><span class="line">            return std::make_pair(iterator(root), true);</span><br><span class="line">        &#125;</span><br><span class="line">        Node* cur = _header-&gt;_parent;</span><br><span class="line">        Node* parent = _header;</span><br><span class="line">        KeyOfValue kov;</span><br><span class="line">        while(cur)</span><br><span class="line">        &#123;</span><br><span class="line">            //修改</span><br><span class="line">            if(kov(cur-&gt;_data) &lt; kov(data))</span><br><span class="line">            &#123;</span><br><span class="line">                parent = cur;</span><br><span class="line">                cur = cur-&gt;_right;</span><br><span class="line">            &#125;</span><br><span class="line">            else if(kov(cur-&gt;_data) &gt; kov(data))</span><br><span class="line">            &#123;</span><br><span class="line">                parent = cur;</span><br><span class="line">                cur = cur-&gt;_left;</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">            &#123;</span><br><span class="line">                //return false;</span><br><span class="line">                return std::make_pair(iterator(cur), false);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        cur = new Node(data);</span><br><span class="line">        if(kov(parent-&gt;_data) &lt; kov(data))</span><br><span class="line">        &#123;</span><br><span class="line">            parent-&gt;_right = cur;</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            parent-&gt;_left = cur;</span><br><span class="line">        &#125;</span><br><span class="line">        cur-&gt;_parent = parent;</span><br><span class="line">        Node* newNode = cur;</span><br><span class="line">        //_header-&gt;_left = cur;</span><br><span class="line">        //调整：修改颜色，旋转</span><br><span class="line">        while(cur != _header-&gt;_parent &amp;&amp; cur-&gt;_parent-&gt;_color == RED)</span><br><span class="line">        &#123;</span><br><span class="line">            Node* parent = cur-&gt;_parent;</span><br><span class="line">            Node* gParent = parent-&gt;_parent;</span><br><span class="line">            if(gParent-&gt;_left == parent)</span><br><span class="line">            &#123;</span><br><span class="line">                Node *uncle = gParent-&gt;_right;</span><br><span class="line">                //情况一</span><br><span class="line">                if(uncle &amp;&amp; uncle-&gt;_color == RED)</span><br><span class="line">                &#123;</span><br><span class="line">                    //更新颜色</span><br><span class="line">                    parent-&gt;_color = uncle-&gt;_color = BLACK;</span><br><span class="line">                    gParent-&gt;_color = RED;</span><br><span class="line">                    //向上继续更新</span><br><span class="line">                    cur = gParent;</span><br><span class="line">                &#125;</span><br><span class="line">                //情况二/三</span><br><span class="line">                else</span><br><span class="line">                &#123;</span><br><span class="line">                    //叔叔不存在或者叔叔为黑色</span><br><span class="line">                    //判断这里是否存在双旋的场景</span><br><span class="line">                    if(cur = parent-&gt;_right)</span><br><span class="line">                    &#123;</span><br><span class="line">                        //情况三</span><br><span class="line">                        //此时就是一个折现的形态就需要两次旋转了</span><br><span class="line">                        RotateL(parent);</span><br><span class="line">                        //左旋后，父亲变子，子变父亲，重回情况er</span><br><span class="line">                        std::swap(cur, parent);</span><br><span class="line">                    &#125;</span><br><span class="line">                    else</span><br><span class="line">                    &#123;</span><br><span class="line">                        //情况二</span><br><span class="line">                        RotateR(gParent);</span><br><span class="line">                        //更改颜色</span><br><span class="line">                        parent-&gt;_color = BLACK;</span><br><span class="line">                        gParent-&gt;_color = RED;</span><br><span class="line">                        //此时这课子树的根为黑色，所以不需要再继续向上调整</span><br><span class="line">                        break;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">            &#123;</span><br><span class="line">                Node* uncle = gParent-&gt;_left;</span><br><span class="line">                if(uncle &amp;&amp; uncle-&gt;_color == RED)</span><br><span class="line">                &#123;</span><br><span class="line">                    parent-&gt;_color = uncle-&gt;_color = BLACK;</span><br><span class="line">                    gParent-&gt;_color = RED;</span><br><span class="line">                    cur = gParent;</span><br><span class="line">                &#125;</span><br><span class="line">                else</span><br><span class="line">                &#123;</span><br><span class="line">                    if(cur == parent-&gt;_left)</span><br><span class="line">                    &#123;</span><br><span class="line">                        RotateR(parent);</span><br><span class="line">                        std::swap(cur, parent);</span><br><span class="line">                    &#125;</span><br><span class="line">                    else</span><br><span class="line">                    &#123;</span><br><span class="line">                        RotateL(gParent);</span><br><span class="line">                        parent-&gt;_color = BLACK;</span><br><span class="line">                        gParent-&gt;_color = RED;</span><br><span class="line">                        break;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        //根结点的颜色必须为黑色</span><br><span class="line">        _header-&gt;_parent-&gt;_color = BLACK;</span><br><span class="line">        //更新头节点</span><br><span class="line">        _header-&gt;_left = LeftMost();</span><br><span class="line">        _header-&gt;_right = RightMost();</span><br><span class="line">        //return true;</span><br><span class="line">        return std::make_pair(iterator(newNode), true);</span><br><span class="line">    &#125;</span><br><span class="line">    //左旋</span><br><span class="line">    void RotateL(Node* parent)</span><br><span class="line">    &#123;</span><br><span class="line">        Node* subR = parent-&gt;_right;</span><br><span class="line">        Node* subRL = parent-&gt;_right-&gt;_left;</span><br><span class="line"></span><br><span class="line">        parent-&gt;_right = subRL;</span><br><span class="line">        if(subRL)</span><br><span class="line">        &#123;</span><br><span class="line">            subRL-&gt;_parent = parent;</span><br><span class="line">        &#125;</span><br><span class="line">        subR-&gt;_left = parent;</span><br><span class="line">        Node* ppNode = parent-&gt;_parent;</span><br><span class="line">        parent-&gt;_parent = subR;</span><br><span class="line">        //根</span><br><span class="line">        if(ppNode == _header)</span><br><span class="line">        &#123;</span><br><span class="line">            _header-&gt;_parent = subR;</span><br><span class="line">            subR-&gt;_parent = _header;</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            if(ppNode-&gt;_right == parent)</span><br><span class="line">            &#123;</span><br><span class="line">                ppNode-&gt;_right = subR;</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">            &#123;</span><br><span class="line">                ppNode-&gt;_left = subR;</span><br><span class="line">            &#125;</span><br><span class="line">            subR-&gt;_parent = ppNode;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    //右旋</span><br><span class="line">    void RotateR(Node* parent)</span><br><span class="line">    &#123;</span><br><span class="line">        Node* subL = parent-&gt;_left;</span><br><span class="line">        Node* subLR = parent-&gt;_left-&gt;_right;</span><br><span class="line"></span><br><span class="line">        parent-&gt;_left = subLR;</span><br><span class="line">        if(subLR)//subLR可能会为空，当h == 0时subLR为空</span><br><span class="line">        &#123;</span><br><span class="line">            subLR-&gt;_parent = parent;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        subL-&gt;_right = parent;//subL不可能为空</span><br><span class="line">        //记录下parent原来的父结点，为了方便parent移动可以找到这棵子树的父结点</span><br><span class="line">        Node* ppNode = parent-&gt;_parent;</span><br><span class="line">        parent-&gt;_parent = subL;</span><br><span class="line">        //更新这棵子树的新父结点subL与其父结点的连接</span><br><span class="line">        if(ppNode == _header)//如果子树的父结点为空则说明parent原本是整棵树的根节点</span><br><span class="line">        &#123;</span><br><span class="line">            _header-&gt;_parent= subL;</span><br><span class="line">            subL-&gt;_parent = _header;</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            if(ppNode-&gt;_right == parent)</span><br><span class="line">            &#123;</span><br><span class="line">                ppNode-&gt;_right = subL;</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">            &#123;</span><br><span class="line">                ppNode-&gt;_left = subL;</span><br><span class="line">            &#125;</span><br><span class="line">            subL-&gt;_parent = ppNode;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    //找到当前树的最左结点</span><br><span class="line">    Node* LeftMost()</span><br><span class="line">    &#123;</span><br><span class="line">        Node* cur = _header-&gt;_parent;</span><br><span class="line">        while(cur &amp;&amp; cur-&gt;_left)</span><br><span class="line">        &#123;</span><br><span class="line">            cur = cur-&gt;_left;</span><br><span class="line">        &#125;</span><br><span class="line">        return cur;</span><br><span class="line">    &#125;</span><br><span class="line">    //找到当前树的最有结点</span><br><span class="line">    Node* RightMost()</span><br><span class="line">    &#123;</span><br><span class="line">        Node* cur = _header-&gt;_parent;</span><br><span class="line">        while(cur &amp;&amp; cur-&gt;_right)</span><br><span class="line">        &#123;</span><br><span class="line">            cur = cur-&gt;_right;</span><br><span class="line">        &#125;</span><br><span class="line">        return cur;</span><br><span class="line">    &#125;</span><br><span class="line">    //中序遍历</span><br><span class="line">    void Inorder()</span><br><span class="line">    &#123;</span><br><span class="line">        _Inorder(_header-&gt;_parent);</span><br><span class="line">    &#125;</span><br><span class="line">    void _Inorder(Node* root)</span><br><span class="line">    &#123;</span><br><span class="line">        if(root == nullptr)</span><br><span class="line">        &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        _Inorder(root-&gt;_left);</span><br><span class="line">        std::cout &lt;&lt; root-&gt;_data.first &lt;&lt; &quot; &quot;;</span><br><span class="line">        _Inorder(root-&gt;_right);</span><br><span class="line">    &#125;</span><br><span class="line">    //判断是否是一个红黑树</span><br><span class="line">    bool IsRBTree()</span><br><span class="line">    &#123;</span><br><span class="line">        Node* root = _header-&gt;_parent;</span><br><span class="line">        if(root == nullptr)</span><br><span class="line">        &#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">        if(root-&gt;_color == RED)</span><br><span class="line">        &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        //统计一条路径黑结点的数量</span><br><span class="line">        int blackCount = 0;</span><br><span class="line">        Node* cur = root;</span><br><span class="line">        while(cur)</span><br><span class="line">        &#123;</span><br><span class="line">            if(cur-&gt;_color == BLACK)</span><br><span class="line">            &#123;</span><br><span class="line">                blackCount++;</span><br><span class="line">            &#125;</span><br><span class="line">            cur = cur-&gt;_left;</span><br><span class="line">        &#125;</span><br><span class="line">        //前序遍历</span><br><span class="line">        return _IsRBTree(root, blackCount, 0);</span><br><span class="line">    &#125;</span><br><span class="line">    bool _IsRBTree(Node* root, int blackCount, int curBlackCount)</span><br><span class="line">    &#123;</span><br><span class="line">        if(root == nullptr)</span><br><span class="line">        &#123;</span><br><span class="line">            if(curBlackCount != blackCount)</span><br><span class="line">            &#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">        //统计黑色结点的数量</span><br><span class="line">        if(root-&gt;_color == BLACK)</span><br><span class="line">        &#123;</span><br><span class="line">            curBlackCount++;</span><br><span class="line">        &#125;</span><br><span class="line">        //判断是否有红色连续</span><br><span class="line">        if(root-&gt;_parent-&gt;_color == RED &amp;&amp; root-&gt;_color == RED)</span><br><span class="line">        &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        return _IsRBTree(root-&gt;_left, blackCount, curBlackCount) </span><br><span class="line">        &amp;&amp; _IsRBTree(root-&gt;_right, blackCount, curBlackCount);</span><br><span class="line">    &#125;</span><br><span class="line">private:</span><br><span class="line">    //Node* _root;</span><br><span class="line">    //这里为了方便后续封装成map/set我们将其结构改造成一棵带头结点的环形树</span><br><span class="line">    //这里的头和环形类似于实现过的带头双向环形链表</span><br><span class="line">    //头节点的右孩子连接最右结点，左孩子连接最左结点，用头指向树真正的根结点</span><br><span class="line">    //相当于这个头结点是倒过来的，和真正的根结点头连着头，连个孩子和最左最右结点构成两个环</span><br><span class="line">    //封装成这种结构都是为了方便我们后续进一步封装，尽量和库中的保持一致</span><br><span class="line">    Node* _header;</span><br><span class="line">&#125;;</span><br><span class="line">//void TestRBTree()</span><br><span class="line">//&#123;</span><br><span class="line">//    RBTree&lt;int, int&gt; rbt;</span><br><span class="line">//    rbt.Insert(std::make_pair(1, 1));</span><br><span class="line">//    rbt.Insert(std::make_pair(10, 1));</span><br><span class="line">//    rbt.Insert(std::make_pair(2, 1));</span><br><span class="line">//    rbt.Insert(std::make_pair(5, 1));</span><br><span class="line">//    rbt.Insert(std::make_pair(3, 1));</span><br><span class="line">//    rbt.Insert(std::make_pair(4, 1));</span><br><span class="line">//    rbt.Insert(std::make_pair(7, 1));</span><br><span class="line">//    rbt.Inorder();</span><br><span class="line">//    std::cout &lt;&lt; std::endl;</span><br><span class="line">//    //验证</span><br><span class="line">//    std::cout &lt;&lt; (rbt.IsRBTree()) &lt;&lt; std::endl;</span><br><span class="line">//&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">Map.hpp:</span><br><span class="line">#include &quot;RBTreeMod.hpp&quot;</span><br><span class="line">template&lt;class K, class V&gt;</span><br><span class="line">class Map</span><br><span class="line">&#123;</span><br><span class="line">    //为了让红黑树可以根据调用它的不同类型得以确定比较条件</span><br><span class="line">    //我们这里用内部类创建一个反函数用域返回当前结构下的Key值</span><br><span class="line">    struct MapKeyOfValue</span><br><span class="line">    &#123;</span><br><span class="line">        const K&amp; operator()(const std::pair&lt;K, V&gt;&amp; data)</span><br><span class="line">        &#123;</span><br><span class="line">            return data.first;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">public:</span><br><span class="line">    //这里为了能够动态识别这是一个类型要在前面加上typename关键字</span><br><span class="line">    typedef typename RBTree&lt;K, std::pair&lt;K, V&gt;, MapKeyOfValue&gt;::iterator iterator;</span><br><span class="line">    std::pair&lt;iterator, bool&gt; Insert(const std::pair&lt;K, V&gt;&amp; data)</span><br><span class="line">    &#123;</span><br><span class="line">       return  _rbt.Insert(data);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //实现迭代器</span><br><span class="line">    iterator begin()</span><br><span class="line">    &#123;</span><br><span class="line">        return _rbt.begin();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    iterator end()</span><br><span class="line">    &#123;</span><br><span class="line">        return _rbt.end();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    V&amp; operator[](const K&amp; key)</span><br><span class="line">    &#123;</span><br><span class="line">        std::pair&lt;iterator, bool&gt; ret = _rbt.Insert(std::make_pair(key, V()));</span><br><span class="line">        return ret.first-&gt;second;</span><br><span class="line">    &#125;</span><br><span class="line">private:</span><br><span class="line">    RBTree&lt;K, std::pair&lt;K, V&gt;, MapKeyOfValue&gt; _rbt;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">Set.hpp:</span><br><span class="line">#include &quot;RBTreeMod.hpp&quot;</span><br><span class="line">template&lt;class K&gt;</span><br><span class="line">class Set</span><br><span class="line">&#123;</span><br><span class="line">    struct SetKeyOfValue</span><br><span class="line">    &#123;</span><br><span class="line">        const K&amp; operator()(const K&amp; data)</span><br><span class="line">        &#123;</span><br><span class="line">            return data;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">public:</span><br><span class="line">    typedef typename RBTree&lt;K, K, SetKeyOfValue&gt;::iterator iterator;</span><br><span class="line">    std::pair&lt;iterator, bool&gt; Insert(const K&amp; data)</span><br><span class="line">    &#123;</span><br><span class="line">        return _rbt.Insert(data);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //实现迭代器</span><br><span class="line">    iterator begin()</span><br><span class="line">    &#123;</span><br><span class="line">        return _rbt.begin();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //实现迭代器</span><br><span class="line">    iterator end()</span><br><span class="line">    &#123;</span><br><span class="line">        return _rbt.end();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">    RBTree&lt;K, K, SetKeyOfValue&gt; _rbt;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">test.cpp:</span><br><span class="line">#include &quot;Map.hpp&quot;</span><br><span class="line">#include &quot;Set.hpp&quot;</span><br><span class="line">void TestMapSet()</span><br><span class="line">&#123;</span><br><span class="line">    Map&lt;int, int&gt; M;</span><br><span class="line">    M.Insert(std::make_pair(10, 1));</span><br><span class="line">    M.Insert(std::make_pair(3, 1));</span><br><span class="line">    M.Insert(std::make_pair(9, 1));</span><br><span class="line">    M.Insert(std::make_pair(2, 1));</span><br><span class="line">    M.Insert(std::make_pair(1, 1));</span><br><span class="line">    for(auto e : M)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; e.first &lt;&lt; &quot; &quot; &lt;&lt; e.second &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    M[1] = 100;</span><br><span class="line">    M[500] = 50;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line">    for(auto e : M)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; e.first &lt;&lt; &quot; &quot; &lt;&lt; e.second &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    Set&lt;int&gt; S;</span><br><span class="line">    S.Insert(1);</span><br><span class="line">    S.Insert(3);</span><br><span class="line">    S.Insert(5);</span><br><span class="line">    S.Insert(6);</span><br><span class="line">    S.Insert(2);</span><br><span class="line">    S.Insert(6);</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line">    for(auto e : S)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; e &lt;&lt; &quot; &quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    //TestBsTree1();</span><br><span class="line">    //TestAVLTree()m</span><br><span class="line">    //TestRBTree();</span><br><span class="line">    TestMapSet();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1 1 </span><br><span class="line">2 1 </span><br><span class="line">3 1</span><br><span class="line">9 1</span><br><span class="line">10 1</span><br><span class="line"></span><br><span class="line">1 100</span><br><span class="line">2 1</span><br><span class="line">3 1</span><br><span class="line">9 1</span><br><span class="line">10 1</span><br><span class="line">500 50</span><br><span class="line"></span><br><span class="line">1 2 3 5 6</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;<code>map/set</code>这种链式容器，也存在迭代器失效问题，但其的<strong>插入不会造成迭代器失效，删除会造成删除结点的迭代器失效</strong>。<br>&emsp;&emsp;由此一来，我们就完全实现了<code>map/set</code>两个容器，我们一路从<code>BSTree</code>到最终的<code>RBTree</code>，<del>中间充满了坎坷和艰辛</del>，不过这一趟学习下来，我们对<code>map/set</code>及其<code>multi</code>版本的底层实现有了进一步的理解，我们今后对其的使用也会变得更加得心应手。<br>&emsp;&emsp;但是至此我们的关联式容器部分还并没有完全结束，我们接下来会讨论<code>unordered</code>版本的关联式容器，他们的底层与普通版本的底层数据结构大相径庭，用到了哈希有关知识。</p>

      
    </div>
    
    
    

    

    <div>
    
    <div style="text-align:center;color: #ccc;font-size:14px;">-------------本文结束<i class="fa fa-paw"></i>感谢您的阅读!-------------</div>
    
    </div>

    
      <div>
        <div style="padding: 10px 0; margin: 20px auto; width: 90%; text-align: center;">
  <div>记录学习每一分，感谢您的赞助</div>
  <button id="rewardButton" disable="enable" onclick="var qr = document.getElementById('QR'); if (qr.style.display === 'none') {qr.style.display='block';} else {qr.style.display='none'}">
    <span>打赏</span>
  </button>
  <div id="QR" style="display: none;">

    
      <div id="wechat" style="display: inline-block">
        <img id="wechat_qr" src="/images/wechatpay.png" alt="MisakiFx 微信支付"/>
        <p>微信支付</p>
      </div>
    

    
      <div id="alipay" style="display: inline-block">
        <img id="alipay_qr" src="/images/alipay.jpg" alt="MisakiFx 支付宝"/>
        <p>支付宝</p>
      </div>
    

    

  </div>
</div>

      </div>
    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/Cpp/" rel="tag"># Cpp</a>
          
            <a href="/tags/关联式容器/" rel="tag"># 关联式容器</a>
          
            <a href="/tags/红黑树/" rel="tag"># 红黑树</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2019/10/20/【DS】第二章-顺序表和链表/" rel="next" title="【DS】第二章-顺序表和链表">
                <i class="fa fa-chevron-left"></i> 【DS】第二章-顺序表和链表
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2019/10/24/【Linux】请问下面的程序一共输出多少个“-”？/" rel="prev" title="【Linux】请问下面的程序一共输出多少个“-”？">
                【Linux】请问下面的程序一共输出多少个“-”？ <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/blog-logo.jpg"
                alt="MisakiFx" />
            
              <p class="site-author-name" itemprop="name">MisakiFx</p>
              <p class="site-description motion-element" itemprop="description">Hard working or giving up!!!</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">84</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">10</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">62</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/MisakiFx" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="mailto:1761607418@qq.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope-open"></i>E-Mail</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://music.163.com/#/user/home?id=432551242" target="_blank" title="网易云音乐">
                      
                        <i class="fa fa-fw fa-music"></i>网易云音乐</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://blog.csdn.net/qq_41669298" target="_blank" title="CSDN">
                      
                        <i class="fa fa-fw fa-crosshairs"></i>CSDN</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#关联式容器"><span class="nav-number">1.</span> <span class="nav-text">关联式容器</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#pair"><span class="nav-number">1.1.</span> <span class="nav-text">pair</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#map"><span class="nav-number">1.2.</span> <span class="nav-text">map</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#模板参数"><span class="nav-number">1.2.1.</span> <span class="nav-text">模板参数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#构造函数"><span class="nav-number">1.2.2.</span> <span class="nav-text">构造函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#迭代器相关"><span class="nav-number">1.2.3.</span> <span class="nav-text">迭代器相关</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#元素修改"><span class="nav-number">1.2.4.</span> <span class="nav-text">元素修改</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#容量及元素访问"><span class="nav-number">1.2.5.</span> <span class="nav-text">容量及元素访问</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#总结"><span class="nav-number">1.2.6.</span> <span class="nav-text">总结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#multimap"><span class="nav-number">1.3.</span> <span class="nav-text">multimap</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#set"><span class="nav-number">1.4.</span> <span class="nav-text">set</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#模板参数-1"><span class="nav-number">1.4.1.</span> <span class="nav-text">模板参数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#构造函数-1"><span class="nav-number">1.4.2.</span> <span class="nav-text">构造函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#迭代器相关-1"><span class="nav-number">1.4.3.</span> <span class="nav-text">迭代器相关</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#容量和修改"><span class="nav-number">1.4.4.</span> <span class="nav-text">容量和修改</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#总结-1"><span class="nav-number">1.4.5.</span> <span class="nav-text">总结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#multiset"><span class="nav-number">1.5.</span> <span class="nav-text">multiset</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#底层实现"><span class="nav-number">1.6.</span> <span class="nav-text">底层实现</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#BS-Tree"><span class="nav-number">1.6.1.</span> <span class="nav-text">BS Tree</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#什么是BS-Tree"><span class="nav-number">1.6.1.1.</span> <span class="nav-text">什么是BS Tree</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#实现"><span class="nav-number">1.6.1.2.</span> <span class="nav-text">实现</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#AVLTree"><span class="nav-number">1.6.2.</span> <span class="nav-text">AVLTree</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#什么是AVLTree"><span class="nav-number">1.6.2.1.</span> <span class="nav-text">什么是AVLTree</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#AVLTree平衡因子的更新"><span class="nav-number">1.6.2.2.</span> <span class="nav-text">AVLTree平衡因子的更新</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#AVLTree的旋转"><span class="nav-number">1.6.2.3.</span> <span class="nav-text">AVLTree的旋转</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#左单旋"><span class="nav-number">1.6.2.3.1.</span> <span class="nav-text">左单旋</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#右单旋"><span class="nav-number">1.6.2.3.2.</span> <span class="nav-text">右单旋</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#先右旋再左旋"><span class="nav-number">1.6.2.3.3.</span> <span class="nav-text">先右旋再左旋</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#先左旋再右旋"><span class="nav-number">1.6.2.3.4.</span> <span class="nav-text">先左旋再右旋</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#旋转场景"><span class="nav-number">1.6.2.4.</span> <span class="nav-text">旋转场景</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#实现-1"><span class="nav-number">1.6.2.5.</span> <span class="nav-text">实现</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#RBTree"><span class="nav-number">1.6.3.</span> <span class="nav-text">RBTree</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#什么是RBTRee"><span class="nav-number">1.6.3.1.</span> <span class="nav-text">什么是RBTRee</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#RBTree的调整"><span class="nav-number">1.6.3.2.</span> <span class="nav-text">RBTree的调整</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#情况一"><span class="nav-number">1.6.3.2.1.</span> <span class="nav-text">情况一</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#情况二"><span class="nav-number">1.6.3.2.2.</span> <span class="nav-text">情况二</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#情况三"><span class="nav-number">1.6.3.2.3.</span> <span class="nav-text">情况三</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#实现-2"><span class="nav-number">1.6.3.3.</span> <span class="nav-text">实现</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#封装"><span class="nav-number">1.6.4.</span> <span class="nav-text">封装</span></a></li></ol></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        ﻿<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js">
</script>
<div class="copyright">&copy; <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">MisakiFx</span>

  
</div>


<div class="powered-by">
  <i class="fa fa-user-md"></i>
  <span id="busuanzi_container_site_uv">
    我的网站的访客数:<span id="busuanzi_value_site_uv"></span>
  </span>
</div>



<span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.4</div>




<div class="theme-info">
  <div class="powered-by"></div>
  <span class="post-count">博客全站共256.1k字</span>
</div>

        ﻿







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  


  











  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  

  
  
    <script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

  <!-- 页面点击小红心 -->
        <script type="text/javascript" src="/js/src/love.js"></script>
<script src="/live2dw/lib/L2Dwidget.min.js?0c58a1486de42ac6cc1c59c7d98ae887"></script><script>L2Dwidget.init({"pluginModelPath":"assets/","model":{"jsonPath":"/live2dw/assets/z16.model.json"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":false},"log":false,"pluginJsPath":"lib/","pluginRootPath":"live2dw/","tagMode":false});</script></body>
</html>
